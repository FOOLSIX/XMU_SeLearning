1
00:00:13,333 --> 00:00:14,133
好

2
00:00:14,500 --> 00:00:18,500
呃上课前两个通知说一下啊

3
00:00:18,800 --> 00:00:20,066
第一个是

4
00:00:21,333 --> 00:00:23,166
呃那个

5
00:00:24,266 --> 00:00:28,166
嗯看华为的优惠券啊

6
00:00:28,166 --> 00:00:31,366
软工那边的华为优惠券又申请下来了

7
00:00:31,766 --> 00:00:32,566
然后

8
00:00:34,133 --> 00:00:37,599
我我们我之前给大家说过呃

9
00:00:38,166 --> 00:00:39,466
因为我们的个人设计

10
00:00:39,466 --> 00:00:40,999
其实不是一台服务器

11
00:00:41,000 --> 00:00:42,966
而是很多台服务器

12
00:00:43,300 --> 00:00:45,300
然后如果一个账号申请的话呢

13
00:00:45,300 --> 00:00:46,566
这些服务器资金的通讯

14
00:00:46,566 --> 00:00:48,199
是不收钱的啊

15
00:00:48,200 --> 00:00:52,400
一个账号在同一个地区申请的

16
00:00:52,400 --> 00:00:54,500
服务器通讯是不收钱的啊

17
00:00:54,500 --> 00:00:55,500
有个这个前提

18
00:00:55,700 --> 00:00:57,500
所以今年我们想把它改成

19
00:00:57,500 --> 00:01:00,066
以小组为单位来发放

20
00:01:00,766 --> 00:01:02,266
呃这个优惠券

21
00:01:02,500 --> 00:01:04,700
也就是你们小组或者是组长

22
00:01:04,766 --> 00:01:07,133
或者是你们哪一位同学

23
00:01:07,133 --> 00:01:09,733
都可以在这个文件里头啊

24
00:01:10,866 --> 00:01:12,366
这个标了一个3月2号

25
00:01:14,800 --> 00:01:16,666
我待会看一下啊

26
00:01:16,900 --> 00:01:18,333
在这个文件里头

27
00:01:18,333 --> 00:01:20,966
把你们的组号给写上去

28
00:01:20,966 --> 00:01:22,866
那每个组就写一位同学好了

29
00:01:23,200 --> 00:01:23,933
写了以后呢

30
00:01:23,933 --> 00:01:26,699
那我们优惠券就发给标了的

31
00:01:26,700 --> 00:01:28,000
就这个组的优惠券啊

32
00:01:28,000 --> 00:01:30,000
都发给这个组的人

33
00:01:30,266 --> 00:01:32,166
那我们发放的原则是这样的

34
00:01:32,166 --> 00:01:33,933
就是因为他有的组可能多

35
00:01:33,933 --> 00:01:34,933
有的组可能少

36
00:01:35,000 --> 00:01:36,500
我们大部分的组是5个人

37
00:01:36,500 --> 00:01:37,666
那有些组是4个人

38
00:01:37,666 --> 00:01:39,866
有些组可能是有卓越班那边

39
00:01:39,866 --> 00:01:40,733
有一个组是6个人

40
00:01:40,733 --> 00:01:43,733
因为他们不能跨班跨班分啊

41
00:01:43,800 --> 00:01:45,000
跟你作业班的话

42
00:01:45,000 --> 00:01:47,266
他他正好就有一个组16个人

43
00:01:47,400 --> 00:01:49,766
所以我们不是按人来发那个优惠券

44
00:01:49,766 --> 00:01:50,933
我们是把所有的优惠券

45
00:01:50,933 --> 00:01:53,333
按照多少个组评分的啊

46
00:01:53,333 --> 00:01:55,966
所以就是按照主为单位啊

47
00:01:55,966 --> 00:01:58,899
来发这个优惠券啊

48
00:01:58,900 --> 00:02:01,100
然后优惠券的这个用法

49
00:02:01,100 --> 00:02:03,733
建议大家合理的使用优惠券

50
00:02:03,733 --> 00:02:05,733
因为这个优惠券发放给大家

51
00:02:05,733 --> 00:02:08,133
是没必要一次性的使用的

52
00:02:08,166 --> 00:02:10,066
可以慢慢的用啊

53
00:02:10,400 --> 00:02:11,366
那用的期限是

54
00:02:11,366 --> 00:02:13,266
到今年年底截止

55
00:02:13,300 --> 00:02:14,900
就是1月1号之前

56
00:02:14,900 --> 00:02:16,133
必须要把它用掉

57
00:02:16,766 --> 00:02:18,166
呃我建议大家

58
00:02:18,166 --> 00:02:20,566
因为我我们跟华为申请这个

59
00:02:20,600 --> 00:02:22,266
这个优惠券也不容易啊

60
00:02:22,266 --> 00:02:23,366
一点点跟他抠

61
00:02:23,866 --> 00:02:25,366
呃所以我建议大家

62
00:02:25,733 --> 00:02:27,666
有效的来使用这些优惠券

63
00:02:27,766 --> 00:02:30,566
就是目前来说啊

64
00:02:30,566 --> 00:02:32,666
没必要一开始就跨几

65
00:02:32,666 --> 00:02:35,466
一下子把所有的服务器全部租到手

66
00:02:35,766 --> 00:02:37,399
你可以先租一台啊

67
00:02:37,400 --> 00:02:38,700
先去玩一下

68
00:02:38,866 --> 00:02:42,199
然后等到说你在大规模开发的时候

69
00:02:42,200 --> 00:02:43,566
需要多少台服务器

70
00:02:43,566 --> 00:02:45,266
再一台一台的加上去啊

71
00:02:45,266 --> 00:02:46,499
这个注意一下

72
00:02:46,500 --> 00:02:47,000
就是

73
00:02:47,000 --> 00:02:50,066
因为服务器租的时候是按月租的

74
00:02:50,166 --> 00:02:51,899
所以你越晚租

75
00:02:51,966 --> 00:02:55,466
你所你的服务器上的付出的钱就越少

76
00:02:55,700 --> 00:02:58,333
你就越可能租越多的服务器

77
00:02:58,366 --> 00:02:58,566
是吧

78
00:02:58,566 --> 00:03:01,299
因为总数给每个小组的总数是固定的

79
00:03:01,700 --> 00:03:04,100
所以你如果想租多的服务器的话呢

80
00:03:04,100 --> 00:03:05,533
你就要好好的去规划一下

81
00:03:05,533 --> 00:03:08,966
你在什么时候去租这些服务器啊

82
00:03:09,533 --> 00:03:12,299
这是第一个关于服务器的问题

83
00:03:12,300 --> 00:03:13,200
那服务器的话

84
00:03:13,200 --> 00:03:13,966
租的时候注意一下

85
00:03:13,966 --> 00:03:14,866
有两种服务器

86
00:03:14,866 --> 00:03:15,766
一种是云耀云的

87
00:03:15,766 --> 00:03:17,866
一种是ECS的服务器

88
00:03:18,166 --> 00:03:20,166
云耀云的服务器会比较便宜点

89
00:03:20,166 --> 00:03:22,566
所以尽量租云耀云的服务器

90
00:03:22,566 --> 00:03:22,733
因为

91
00:03:22,733 --> 00:03:24,899
我们并不需要那么高性能的服务器

92
00:03:25,133 --> 00:03:26,333
但是你知道

93
00:03:26,800 --> 00:03:28,500
其实我们更多的是希望说

94
00:03:28,500 --> 00:03:30,066
你能租更多的服务器

95
00:03:30,066 --> 00:03:31,666
然后你去控制一个

96
00:03:32,000 --> 00:03:33,600
数量更多的服务器集群

97
00:03:33,733 --> 00:03:35,499
这是我们这门课

98
00:03:35,733 --> 00:03:39,133
比较比较希望大家去掌握的技术

99
00:03:39,133 --> 00:03:41,966
而不是说你只控制一台或者两台

100
00:03:41,966 --> 00:03:43,199
这样的一个服务器

101
00:03:43,800 --> 00:03:45,300
这个是第一个事情

102
00:03:45,300 --> 00:03:47,400
就是我们的服务优惠券

103
00:03:47,400 --> 00:03:50,266
会以小组为单位来进行发放

104
00:03:50,266 --> 00:03:52,766
然后大家合理的使用这些优惠券

105
00:03:54,966 --> 00:03:56,133
第二个事情呢

106
00:03:56,166 --> 00:03:58,933
就是我们的第二轮作业出来了

107
00:04:00,266 --> 00:04:01,766
呃给大家看一下

108
00:04:10,166 --> 00:04:11,966
我们的第一轮讨论课刚完啊

109
00:04:11,966 --> 00:04:15,199
然后我们就开始规划第二轮的讨论课

110
00:04:15,300 --> 00:04:17,166
我们基本上的节奏是这样子

111
00:04:17,166 --> 00:04:20,266
就是呃一个月一次讨论课

112
00:04:26,400 --> 00:04:28,566
就是我们一个月一轮讨论课啊

113
00:04:31,400 --> 00:04:34,066
我们的第二轮讨论课的安排的时间

114
00:04:34,066 --> 00:04:34,866
是在

115
00:04:36,666 --> 00:04:40,466
十一月的六号到十二号这一周

116
00:04:41,100 --> 00:04:43,333
然后因为目前

117
00:04:43,333 --> 00:04:47,866
从第一轮讨论课的这个状况来看

118
00:04:47,866 --> 00:04:50,766
大家都挤在了售后和服务那一个模块

119
00:04:50,933 --> 00:04:53,599
然后那一个部分在讨论的时候

120
00:04:53,600 --> 00:04:56,100
会出现较多的跨班的问题

121
00:04:56,100 --> 00:04:58,666
就是你这个班的名额用完了

122
00:04:58,666 --> 00:05:00,133
然后你必须到别的班去讲

123
00:05:00,500 --> 00:05:02,366
所以我把这个顺序调了一下

124
00:05:02,366 --> 00:05:04,766
就是我们周一是售后服务

125
00:05:05,333 --> 00:05:06,533
周二呢大家注意下啊

126
00:05:06,533 --> 00:05:08,933
我们原来是物流和订单

127
00:05:08,933 --> 00:05:10,733
现在改成了顾客和订单

128
00:05:10,733 --> 00:05:13,999
因为把顾客从另外一个组拿过来了

129
00:05:14,100 --> 00:05:15,966
把物流改成了必做的

130
00:05:16,300 --> 00:05:17,400
必做的内容啊

131
00:05:17,400 --> 00:05:19,766
所以做了一下这样的一个调整

132
00:05:20,000 --> 00:05:21,566
所以我们第二轮的讨论课

133
00:05:21,566 --> 00:05:23,199
就是以售后服务

134
00:05:24,000 --> 00:05:26,500
顾客订单为单位来做

135
00:05:26,733 --> 00:05:28,099
那做的是什么呢

136
00:05:28,100 --> 00:05:29,933
做的就是我们的对象模型的设计

137
00:05:29,933 --> 00:05:32,333
API的设计和数据库的设计

138
00:05:32,333 --> 00:05:34,499
这就是我们今天要讲的内容

139
00:05:36,700 --> 00:05:37,533
面向对象

140
00:05:38,066 --> 00:05:39,899
这个OMO的对象模型

141
00:05:39,933 --> 00:05:43,766
我们主要是以b柱模块为内容

142
00:05:43,966 --> 00:05:45,333
去给大家讲说

143
00:05:45,400 --> 00:05:47,566
我们是如何设计对象模型的

144
00:05:47,766 --> 00:05:49,866
如何设计API的啊

145
00:05:49,866 --> 00:05:50,699
其实API的设计

146
00:05:50,700 --> 00:05:52,200
主要是跟着界面有关啊

147
00:05:52,200 --> 00:05:53,333
但是跟我们的领域

148
00:05:53,333 --> 00:05:54,599
模型是有一定的关系的

149
00:05:54,733 --> 00:05:57,733
以及如何去设计我们的数据库的啊

150
00:05:57,733 --> 00:05:58,966
数据库的存储的

151
00:06:01,666 --> 00:06:03,933
首先讲一下我们目前的这个模

152
00:06:03,933 --> 00:06:06,166
块的划分呃

153
00:06:06,166 --> 00:06:07,133
模块的划分

154
00:06:07,133 --> 00:06:08,266
我们之前给大家看到的

155
00:06:08,266 --> 00:06:10,066
是我们9大模块的划分

156
00:06:10,066 --> 00:06:10,699
那我今天

157
00:06:10,700 --> 00:06:13,566
把我们的另外两个模块也放上来

158
00:06:13,700 --> 00:06:15,166
就是我们的课程设计里头

159
00:06:15,166 --> 00:06:18,533
其实一共是11个模块啊

160
00:06:18,533 --> 00:06:20,866
除了大家熟悉的玖登2模块以外

161
00:06:20,866 --> 00:06:22,266
我们另外还有两个模块

162
00:06:22,266 --> 00:06:23,799
一个是我们的网关

163
00:06:24,133 --> 00:06:26,599
一个是我们的全线的系统

164
00:06:27,266 --> 00:06:28,899
啊网官和权限的系统

165
00:06:28,900 --> 00:06:30,466
都是属于必做的部分

166
00:06:30,466 --> 00:06:32,666
但是网官和权限的这两个模块

167
00:06:32,666 --> 00:06:34,899
我们已有三年没有动过了

168
00:06:34,966 --> 00:06:37,066
也就是四年前第一次的时候

169
00:06:37,066 --> 00:06:39,133
我们把这个模块做完了以后

170
00:06:39,333 --> 00:06:40,599
就再也没有改过了

171
00:06:40,600 --> 00:06:41,900
啊再也没有改过了

172
00:06:42,400 --> 00:06:44,066
呃原因有很多啊

173
00:06:44,066 --> 00:06:48,799
一个原因是我们在四年前做完了以后

174
00:06:48,800 --> 00:06:50,933
在前年做的时候

175
00:06:50,933 --> 00:06:53,999
其实我们更多的是在做这九大模块

176
00:06:54,000 --> 00:06:56,066
所以没有精力去管道这两个模块

177
00:06:56,066 --> 00:06:57,099
所以就没有动它

178
00:06:57,533 --> 00:06:59,133
去年呢因为没有检查

179
00:06:59,133 --> 00:07:01,999
所以说就没有去做额外的这两个模块

180
00:07:02,000 --> 00:07:02,533
b做模块

181
00:07:02,533 --> 00:07:03,666
做了一部分选中模块

182
00:07:03,666 --> 00:07:05,866
去年是完全没有做啊

183
00:07:05,866 --> 00:07:06,933
今年今年

184
00:07:06,933 --> 00:07:09,699
我们要看一下我们大家的能力如何

185
00:07:09,733 --> 00:07:10,699
局势怎么样

186
00:07:10,800 --> 00:07:12,366
如果大家做的比较快的话呢

187
00:07:12,366 --> 00:07:14,466
也许我们会去动到

188
00:07:14,466 --> 00:07:16,866
我们有三年没有动过的网关

189
00:07:16,866 --> 00:07:17,999
和全线的模块

190
00:07:18,166 --> 00:07:19,766
那如果说大家做的比较慢

191
00:07:19,766 --> 00:07:21,066
然后做的很不顺利的话呢

192
00:07:21,066 --> 00:07:22,599
可能我们还是关注于说

193
00:07:22,600 --> 00:07:26,066
把我们这个部分的9个模块来做完啊

194
00:07:26,066 --> 00:07:26,933
所以看一下吧

195
00:07:26,933 --> 00:07:28,299
啊如果今年不动的话呢

196
00:07:28,300 --> 00:07:29,400
明年估计就这样动了

197
00:07:29,400 --> 00:07:30,533
我们总的趋势来说

198
00:07:30,533 --> 00:07:31,499
大家会发现

199
00:07:32,000 --> 00:07:33,733
我们会不断的修改币种模块

200
00:07:33,733 --> 00:07:35,799
不断的缩减这个选入模块

201
00:07:35,800 --> 00:07:37,866
最后就把整个这个玩意全部给它

202
00:07:37,866 --> 00:07:38,666
做出来

203
00:07:42,766 --> 00:07:43,899
选做模块的部分来说

204
00:07:43,900 --> 00:07:45,400
大家可以看到做了下调整啊

205
00:07:45,400 --> 00:07:48,200
就是把原来的物流模块变成了b座

206
00:07:48,200 --> 00:07:50,766
今天我们打算加一个b座的部分

207
00:07:50,766 --> 00:07:52,199
把物流把它做出来

208
00:07:52,500 --> 00:07:54,533
然后选座部分就变成了两两啊

209
00:07:54,533 --> 00:07:57,299
我们变成了顾客和订单啊

210
00:07:57,300 --> 00:07:59,900
售后和售前售后服务啊

211
00:07:59,900 --> 00:08:02,466
变成了这两个选做的模块

212
00:08:03,466 --> 00:08:04,266
呃

213
00:08:05,933 --> 00:08:07,533
我们说那两个模块啊

214
00:08:07,533 --> 00:08:09,166
就是网关和权限模块

215
00:08:09,166 --> 00:08:10,966
跟这些模块之间的关系是什么

216
00:08:10,966 --> 00:08:12,366
没有划清它这根线

217
00:08:12,533 --> 00:08:13,766
所以大家会很好奇

218
00:08:13,766 --> 00:08:13,933
说

219
00:08:13,933 --> 00:08:16,199
网关和权限模块跟它们的关系是什么

220
00:08:16,600 --> 00:08:18,200
跟他们的关系是全部有关系

221
00:08:18,366 --> 00:08:19,399
所以就没划线

222
00:08:19,733 --> 00:08:21,133
为什么会全部有关系呢

223
00:08:21,133 --> 00:08:22,399
因为我们整个的网络结构

224
00:08:22,400 --> 00:08:23,200
中间

225
00:08:23,300 --> 00:08:27,500
所有的模块都是被包在网关里头的

226
00:08:27,600 --> 00:08:29,333
就是我们前端来访问的时候

227
00:08:29,333 --> 00:08:31,499
他其实访问不到我们所有的模块

228
00:08:31,500 --> 00:08:32,366
他访问的是什么

229
00:08:32,366 --> 00:08:33,299
访问的是这个模块

230
00:08:34,133 --> 00:08:35,366
访问的是网关模块

231
00:08:35,766 --> 00:08:36,899
通过网关模块

232
00:08:36,900 --> 00:08:39,666
才会访问到我们后面的这些模块

233
00:08:39,766 --> 00:08:41,966
然后网关模块做的两件事情

234
00:08:41,966 --> 00:08:44,699
第一件事情他会做限流和分发

235
00:08:44,900 --> 00:08:48,066
就是如果说后面会步数多个的话

236
00:08:48,066 --> 00:08:49,599
他会做动态自带平衡

237
00:08:49,966 --> 00:08:51,733
会限制前头的流量

238
00:08:52,266 --> 00:08:53,799
这是它本身所提供的功能

239
00:08:53,966 --> 00:08:54,666
那第二个功能

240
00:08:54,666 --> 00:08:54,799
就是

241
00:08:54,800 --> 00:08:56,900
我们在网官模块上头有做了一些开发

242
00:08:56,900 --> 00:08:57,566
这些开发

243
00:08:57,566 --> 00:09:00,733
使得网官模块能去做权限的教育

244
00:09:01,166 --> 00:09:02,133
就是一个用户上来

245
00:09:02,133 --> 00:09:04,466
他能不能去新建一个商品

246
00:09:04,466 --> 00:09:06,299
或者能不能去操作一个什么样的东西

247
00:09:06,300 --> 00:09:08,566
都是靠网关模块来完成的

248
00:09:08,666 --> 00:09:10,133
当然网关模块调用的

249
00:09:10,133 --> 00:09:12,699
就是我们在这里所看到这个权限模块

250
00:09:13,766 --> 00:09:15,266
前线模块其实不止在网关模

251
00:09:15,266 --> 00:09:17,466
块在掉其实所有的模块也会去掉

252
00:09:17,600 --> 00:09:19,166
那它是用AOP的方式

253
00:09:19,166 --> 00:09:20,799
编到了所有的模块上去

254
00:09:20,800 --> 00:09:21,600
就在括里头

255
00:09:21,600 --> 00:09:23,500
其实是有编进去了啊

256
00:09:23,500 --> 00:09:25,800
但是我们现在代码中间是把它切掉了

257
00:09:25,800 --> 00:09:26,800
这原因就是因为

258
00:09:26,800 --> 00:09:27,966
我们已有2年

259
00:09:28,400 --> 00:09:30,100
没有动过这个权限模块了

260
00:09:30,100 --> 00:09:30,766
所以我们现在

261
00:09:30,766 --> 00:09:33,066
目前我把权限模块标成是灰色的

262
00:09:33,166 --> 00:09:34,499
也就是我们现在代码中间

263
00:09:34,500 --> 00:09:36,133
权限模块是被隔离开的

264
00:09:36,133 --> 00:09:38,299
所有的调用都会直接过来

265
00:09:38,300 --> 00:09:40,000
而没有去管权限啊

266
00:09:40,000 --> 00:09:42,166
是现在目前这样的一个状况

267
00:09:42,300 --> 00:09:44,900
那今天我们暂时还是把主要的精力

268
00:09:44,900 --> 00:09:47,066
放在我们的这个九大模块里头

269
00:09:47,200 --> 00:09:50,500
然后如果说时间比较充裕啊

270
00:09:50,500 --> 00:09:51,766
大家能力比较强的话

271
00:09:51,766 --> 00:09:52,899
那我们可能会动手

272
00:09:52,900 --> 00:09:55,466
把权限模块来进行一些改造

273
00:09:55,466 --> 00:09:57,899
然后把它接入到我们的这个里面来

274
00:09:58,300 --> 00:10:00,666
这是整体的这样的一个结构啊

275
00:10:01,600 --> 00:10:03,300
那我们逐模块的来讲

276
00:10:03,300 --> 00:10:04,100
这个

277
00:10:04,300 --> 00:10:06,733
它的对象模型设计和数据库的设计

278
00:10:07,666 --> 00:10:08,999
啊我们前面已经讲过了

279
00:10:09,000 --> 00:10:10,933
他们的领域模型讲过一遍了

280
00:10:10,933 --> 00:10:13,099
但是其实经过了这一段时间

281
00:10:13,100 --> 00:10:16,733
包括大家的作业里头的讨论以后啊

282
00:10:16,733 --> 00:10:18,333
我们其实对于领域模型

283
00:10:18,333 --> 00:10:19,733
其实是有一些修改的

284
00:10:19,966 --> 00:10:21,299
因为大家知道

285
00:10:21,300 --> 00:10:23,733
设计过程就是一个不断的

286
00:10:23,733 --> 00:10:25,899
这个颠覆自己的过程啊

287
00:10:25,900 --> 00:10:29,000
你会把自己的认识不断的去刷新

288
00:10:29,300 --> 00:10:31,133
所以我会把啊

289
00:10:31,133 --> 00:10:31,999
我们在这一阶段

290
00:10:32,000 --> 00:10:33,466
修改出来的这个领域模型

291
00:10:33,466 --> 00:10:34,133
给大家讲一遍

292
00:10:34,133 --> 00:10:34,799
其实在之后

293
00:10:34,800 --> 00:10:37,400
我们还是可能会动到这个领域模型啊

294
00:10:37,466 --> 00:10:40,066
但是应该动的程度会越来越少

295
00:10:40,066 --> 00:10:42,799
就是它会越来越确定化啊

296
00:10:42,800 --> 00:10:44,000
是这样的一个过程

297
00:10:44,533 --> 00:10:47,066
我们目前的产品的指领域模型

298
00:10:47,066 --> 00:10:47,599
大家知道我

299
00:10:47,600 --> 00:10:48,700
们在这个指领域中间

300
00:10:48,700 --> 00:10:51,700
主要的目的就是要有基本的产品

301
00:10:51,700 --> 00:10:54,400
和产品怎么销售是两个事情

302
00:10:54,400 --> 00:10:56,066
是在这个指领中间去完成的

303
00:10:56,466 --> 00:10:59,333
所以它最核心的概念是我们的产品

304
00:10:59,366 --> 00:11:00,133
然后我们可以看到

305
00:11:00,133 --> 00:11:00,866
我们描述了

306
00:11:00,866 --> 00:11:03,566
这个产品是归属于某一个商铺的

307
00:11:03,800 --> 00:11:05,600
所以仓库和产品之间

308
00:11:05,600 --> 00:11:06,733
是一个一对多的关系

309
00:11:06,733 --> 00:11:07,999
而且是个聚合关系

310
00:11:08,200 --> 00:11:08,966
我们描述了

311
00:11:08,966 --> 00:11:10,733
这个产品是属于某一个分类的

312
00:11:10,733 --> 00:11:12,299
但是我们没有用一个聚合关系

313
00:11:12,300 --> 00:11:15,700
因为我们允许这个产品是没有分类的

314
00:11:15,800 --> 00:11:16,766
所以我们啊

315
00:11:16,766 --> 00:11:18,299
我们就没有用组合关系去描述

316
00:11:18,300 --> 00:11:19,733
而是一个聚合关系

317
00:11:20,266 --> 00:11:22,399
我们不仅仅描述了产品的分类

318
00:11:22,400 --> 00:11:23,933
和产品的商铺

319
00:11:23,933 --> 00:11:25,299
其实对于产品部分来说

320
00:11:25,300 --> 00:11:28,600
我们还描述了它是怎么计算运费的

321
00:11:28,800 --> 00:11:30,266
对于大部分产品来说

322
00:11:30,266 --> 00:11:32,599
其实它是会用默认的方式去计算运费

323
00:11:32,600 --> 00:11:35,766
但是如果小部分产品它的尺寸超标了

324
00:11:36,266 --> 00:11:37,899
或者它的重量超标了

325
00:11:37,900 --> 00:11:40,133
那它都会用特殊的模板

326
00:11:40,133 --> 00:11:41,466
去给它计算运费

327
00:11:41,666 --> 00:11:42,466
所以我们可以看到

328
00:11:42,466 --> 00:11:45,766
它跟运费模板之间是一个0到1的关系

329
00:11:45,766 --> 00:11:47,533
就是它大部分的产品

330
00:11:47,766 --> 00:11:49,933
90%的商品其实都是没有运费模板

331
00:11:50,500 --> 00:11:52,366
少部分的商品是有运费模板的

332
00:11:52,366 --> 00:11:53,766
那我们的定义是

333
00:11:53,866 --> 00:11:55,599
每一个商品它只能定义一个运费模板

334
00:11:55,600 --> 00:11:56,500
就它如果有的话

335
00:11:56,500 --> 00:11:57,900
给它定一个特殊的运费模板

336
00:11:58,100 --> 00:11:59,700
那怎么去算啊

337
00:11:59,700 --> 00:12:00,466
而从那边过来

338
00:12:00,466 --> 00:12:01,466
就是每个英文模板

339
00:12:01,466 --> 00:12:02,533
其实是可以重复用到

340
00:12:02,533 --> 00:12:03,599
不同的商品上去的

341
00:12:03,600 --> 00:12:07,366
所以是一个0到1到多的这样一个关系

342
00:12:07,866 --> 00:12:11,333
物流的原因跟这个因为模板类似啊

343
00:12:11,333 --> 00:12:12,333
因为大部分的商品

344
00:12:12,333 --> 00:12:14,666
就会按照正常的方式去做配送那

345
00:12:14,666 --> 00:12:16,166
如果少部分的商品

346
00:12:16,166 --> 00:12:18,366
是不能通过正常的物流去做配送的

347
00:12:18,366 --> 00:12:19,499
比如说需要德邦

348
00:12:19,500 --> 00:12:20,566
我卖家具的

349
00:12:20,666 --> 00:12:22,466
我需要通过德邦去做配送

350
00:12:22,933 --> 00:12:23,299
或者是

351
00:12:23,300 --> 00:12:25,566
通过当地的某些很特别的物流公司

352
00:12:25,566 --> 00:12:26,333
去做配送

353
00:12:26,333 --> 00:12:27,299
那我们就会给他定义

354
00:12:27,300 --> 00:12:29,300
一个特别的物流公司啊

355
00:12:29,300 --> 00:12:32,000
所以这也是一个0到1的

356
00:12:32,000 --> 00:12:32,933
就是大部分商品

357
00:12:32,933 --> 00:12:35,366
其实不需要定义他特别的物流配送

358
00:12:35,366 --> 00:12:37,099
而少部分是需要去定义

359
00:12:37,533 --> 00:12:38,666
这些东西

360
00:12:38,666 --> 00:12:40,366
都是关于商品本身的定义

361
00:12:41,266 --> 00:12:42,933
无关于商品怎么去卖

362
00:12:43,266 --> 00:12:44,899
是商品它是哪个商铺的

363
00:12:44,900 --> 00:12:45,800
它是哪个分类的

364
00:12:45,800 --> 00:12:46,866
它怎么算运费

365
00:12:46,866 --> 00:12:48,366
以及它怎么去配送

366
00:12:48,466 --> 00:12:50,533
这是商品本身的特性啊

367
00:12:50,533 --> 00:12:51,699
我们是这一部分

368
00:12:51,933 --> 00:12:52,699
而另外一部分呢

369
00:12:52,700 --> 00:12:53,700
这是商品怎么去卖

370
00:12:53,700 --> 00:12:54,733
这个我们之前讲过

371
00:12:54,733 --> 00:12:56,066
我们没有在上面做改动

372
00:12:56,066 --> 00:12:57,499
我们主要是两种销售方式

373
00:12:57,500 --> 00:12:59,166
普通销售和预售

374
00:13:00,266 --> 00:13:03,333
然后呢在普通销售的上面

375
00:13:03,333 --> 00:13:05,699
我们又可以加上两种活动

376
00:13:05,800 --> 00:13:08,500
一种活动是这个优惠活动

377
00:13:08,500 --> 00:13:10,266
一种活动是团购活动

378
00:13:10,266 --> 00:13:12,133
我们从这张图上看到的是

379
00:13:12,133 --> 00:13:13,866
貌似说在预售上面

380
00:13:13,866 --> 00:13:16,333
也能增加优惠活动和团购活动的

381
00:13:16,600 --> 00:13:18,133
但实际上我们在后面做的时候

382
00:13:18,133 --> 00:13:20,099
我们啊不支持这样做

383
00:13:20,266 --> 00:13:21,866
就是我们的团购和预售

384
00:13:21,866 --> 00:13:23,799
就只能加在于普通的销战斗啊

385
00:13:23,800 --> 00:13:26,900
不能加载于这个预售上面啊

386
00:13:26,900 --> 00:13:28,800
但是我们现在概念文明是这么画的

387
00:13:29,566 --> 00:13:31,166
呃后面在做对象模型的时候

388
00:13:31,166 --> 00:13:31,966
其实做不到

389
00:13:31,966 --> 00:13:32,999
做起来很困难啊

390
00:13:33,000 --> 00:13:34,800
所以我们是做了一些简化

391
00:13:35,166 --> 00:13:37,666
这是他的这个领域模型

392
00:13:38,600 --> 00:13:40,166
领域模型是后端工程师做的

393
00:13:40,166 --> 00:13:41,099
大家应该知道啊

394
00:13:41,100 --> 00:13:43,166
我们的这个啊

395
00:13:43,166 --> 00:13:45,366
其实如果严格来做分工的话

396
00:13:45,600 --> 00:13:47,800
我们的用力图是产品经理做

397
00:13:47,800 --> 00:13:50,200
的啊所以用用力的

398
00:13:50,333 --> 00:13:52,299
前面大家做的这个用力的描述啊

399
00:13:52,300 --> 00:13:53,500
是产品经理做的

400
00:13:54,200 --> 00:13:56,133
产品经理做完了用力描述以后呢

401
00:13:56,133 --> 00:13:58,566
那设计就是做工程师的人的

402
00:13:58,600 --> 00:14:01,566
后端工程师的切入点就是底蕴模型

403
00:14:02,066 --> 00:14:03,799
前端工程师的缺点是什么呢

404
00:14:03,800 --> 00:14:04,600
是界面

405
00:14:04,900 --> 00:14:07,166
所以当产品经理写了跟用户沟通

406
00:14:07,166 --> 00:14:07,966
写了一个用力以后

407
00:14:07,966 --> 00:14:09,799
后端工程师就开始去做领域模型

408
00:14:09,800 --> 00:14:11,200
前端工程师开始做界面

409
00:14:11,466 --> 00:14:13,766
然后两个东西做好了以后呢

410
00:14:13,766 --> 00:14:15,766
大家来敲一个什么呢

411
00:14:16,200 --> 00:14:19,333
就是我们说的API

412
00:14:21,000 --> 00:14:22,400
就是后端的API

413
00:14:22,733 --> 00:14:24,799
我们后端的API是用什么做的呢

414
00:14:24,800 --> 00:14:27,400
是用啊swaghub做的

415
00:14:27,466 --> 00:14:29,066
就这个东西啊

416
00:14:29,066 --> 00:14:31,466
这是一个放在网上面的东西啊

417
00:14:31,466 --> 00:14:33,533
不是在本地来做的

418
00:14:33,800 --> 00:14:36,133
那这个东西的主要的目的就是

419
00:14:36,133 --> 00:14:37,066
我们要描述说

420
00:14:37,066 --> 00:14:39,066
我们后端到底要开发多少API

421
00:14:39,400 --> 00:14:39,933
大家知道

422
00:14:39,933 --> 00:14:42,499
对于对于后端工程师来说

423
00:14:42,500 --> 00:14:45,700
你的所有的工作就是去实现这些API

424
00:14:46,400 --> 00:14:47,900
那这些API从哪来的

425
00:14:47,966 --> 00:14:50,166
这些API首先来自于界面

426
00:14:50,466 --> 00:14:52,199
也来自于领域模型

427
00:14:52,300 --> 00:14:53,766
也就是当界面工程师

428
00:14:53,766 --> 00:14:55,866
把界面模型设计出来以后

429
00:14:55,866 --> 00:14:58,333
他会看到每个界面长什么样子

430
00:14:58,333 --> 00:15:00,266
每个界面需要输入什么东西

431
00:15:00,266 --> 00:15:03,099
每个界面需要展现什么样东西

432
00:15:03,533 --> 00:15:04,733
然后呢后端工作师

433
00:15:04,733 --> 00:15:06,299
他就跟后端工作师去商量

434
00:15:06,300 --> 00:15:08,566
这其实是要跟后端工作师商量说

435
00:15:08,566 --> 00:15:09,799
我需要一个什么样东西

436
00:15:09,800 --> 00:15:11,133
你给我设计一个APR

437
00:15:11,600 --> 00:15:13,466
那后端工程师怎么来设计API

438
00:15:13,766 --> 00:15:14,533
后端工程师

439
00:15:14,533 --> 00:15:16,866
我们知道这个API是Restor风格的API

440
00:15:17,200 --> 00:15:18,366
Restor风格的API

441
00:15:18,366 --> 00:15:20,933
最明显的一个特征就是什么呢

442
00:15:20,933 --> 00:15:23,999
就是它是针对资源的操作

443
00:15:24,500 --> 00:15:24,733
所以

444
00:15:24,733 --> 00:15:27,199
后端工程师在设计这个API的时候

445
00:15:27,666 --> 00:15:30,166
他会想说我怎样来做这些API

446
00:15:30,300 --> 00:15:32,866
那首先看系统都有什么样的资源

447
00:15:33,166 --> 00:15:35,799
然后把所有前端公司界定

448
00:15:35,800 --> 00:15:37,700
API上头所要的这些操作

449
00:15:38,133 --> 00:15:41,533
把它转化成为对这些资源的操作啊

450
00:15:41,533 --> 00:15:43,133
我们在那个焦瓦伊

451
00:15:43,133 --> 00:15:43,966
克里斯讲过

452
00:15:43,966 --> 00:15:45,499
那个research API的

453
00:15:45,500 --> 00:15:47,100
那样的一个设计的原则

454
00:15:47,266 --> 00:15:48,733
所以我们可以看一下

455
00:15:48,733 --> 00:15:51,933
我们目前手上有的这些API啊

456
00:15:51,933 --> 00:15:53,266
我们分模块来看

457
00:15:53,566 --> 00:15:54,566
比如说产品

458
00:15:57,333 --> 00:15:58,533
产品的这些API

459
00:15:59,900 --> 00:16:01,333
好我们看这边的这个目录

460
00:16:02,000 --> 00:16:03,800
大家能发现一个什么样的特征

461
00:16:08,966 --> 00:16:10,266
能发现一个什么样的特征

462
00:16:10,466 --> 00:16:12,933
所有的这些API所操作的资源

463
00:16:13,333 --> 00:16:16,799
就是我们在领域模型中间所描述的

464
00:16:16,800 --> 00:16:24,866
商品商铺分类销售团购预售

465
00:16:25,600 --> 00:16:27,333
还有优惠活动

466
00:16:27,966 --> 00:16:31,299
就是我们在领域模型中间所描述的

467
00:16:31,300 --> 00:16:32,200
这些资源

468
00:16:32,466 --> 00:16:35,966
就是我们在research API中间所设计的

469
00:16:35,966 --> 00:16:36,766
那些东西

470
00:16:37,100 --> 00:16:39,733
我们会把前端工程师所描述的界面

471
00:16:39,733 --> 00:16:41,266
以及他要做的操作

472
00:16:41,566 --> 00:16:45,733
转化成为对这些资源的操作

473
00:16:45,866 --> 00:16:48,499
按照race的风格的这种要求啊

474
00:16:48,500 --> 00:16:50,266
转化成为这个操作

475
00:16:50,500 --> 00:16:53,200
所以就变成了我们的API的设计

476
00:16:54,200 --> 00:16:55,300
那大家的下一轮的作业

477
00:16:55,300 --> 00:16:56,900
中间的一个任务啊

478
00:16:56,900 --> 00:16:58,300
就是要做API的设计

479
00:16:58,300 --> 00:17:00,000
我们不需要大家从0开始做起

480
00:17:00,000 --> 00:17:01,333
因为大家没有做界面

481
00:17:01,666 --> 00:17:04,533
所以你不知道说那个界面长成什么样

482
00:17:04,533 --> 00:17:06,566
所以你其实是没有一个驱动力的

483
00:17:06,566 --> 00:17:08,699
就说我们应该设计什么样的API来做

484
00:17:09,566 --> 00:17:11,166
啊我们的API

485
00:17:11,333 --> 00:17:13,599
其实往年同学们都有设计过了

486
00:17:13,700 --> 00:17:15,900
这是所有的9个模块啊

487
00:17:15,900 --> 00:17:17,900
10个10个模块的API

488
00:17:17,900 --> 00:17:19,400
我们一共是11个模块

489
00:17:19,400 --> 00:17:21,533
那个开头位是没有API的

490
00:17:21,533 --> 00:17:23,333
因为它就是一个转发的作用

491
00:17:23,466 --> 00:17:24,799
所以剩下的9个模块

492
00:17:24,800 --> 00:17:26,300
10个模块的API都在这

493
00:17:27,100 --> 00:17:29,966
那大家选择你自己要做的那个模块

494
00:17:30,333 --> 00:17:33,166
去看看说你觉得这些API里头

495
00:17:33,166 --> 00:17:35,499
你觉得设计的不合理的地方

496
00:17:35,866 --> 00:17:38,499
或者你觉得需要增加的东西

497
00:17:38,500 --> 00:17:39,900
因为注意一下

498
00:17:39,966 --> 00:17:41,266
因为待会大家会看到

499
00:17:41,266 --> 00:17:42,599
我们今年的领域模型

500
00:17:42,600 --> 00:17:44,533
其实跟往年是不太一样

501
00:17:45,133 --> 00:17:46,699
因为领域模型不一样

502
00:17:46,700 --> 00:17:47,600
特别是领域模型

503
00:17:47,600 --> 00:17:49,200
中间描述的资源不一样

504
00:17:49,400 --> 00:17:50,733
就会造成什么呢

505
00:17:50,733 --> 00:17:52,199
就会造成API不一样

506
00:17:52,366 --> 00:17:55,399
所以大家需要根据我们今年所讲的

507
00:17:55,400 --> 00:17:56,266
领域模型

508
00:17:56,666 --> 00:17:58,933
去重新修改和设计

509
00:17:59,133 --> 00:18:00,333
往年的这些API

510
00:18:00,600 --> 00:18:03,400
改成跟今年的领域模型是一致的

511
00:18:03,533 --> 00:18:06,266
所以我们在下一轮的讨论课的

512
00:18:06,366 --> 00:18:07,799
下一轮作业的第一个任务

513
00:18:07,900 --> 00:18:09,000
API的设计

514
00:18:09,133 --> 00:18:10,766
不是从零开始做起

515
00:18:10,766 --> 00:18:13,466
而是从现有的API

516
00:18:14,100 --> 00:18:17,666
改成当前的领域模型的API啊

517
00:18:17,666 --> 00:18:19,099
这个明确了吧

518
00:18:19,133 --> 00:18:20,099
然后做法怎么样

519
00:18:20,100 --> 00:18:22,100
做法大家就还是在这个swag Hop上去做

520
00:18:22,100 --> 00:18:24,200
你们去开个账号啊

521
00:18:24,266 --> 00:18:26,899
去在上面去把我的这个

522
00:18:26,933 --> 00:18:28,866
大家可以看到我们这个原文件啊

523
00:18:30,100 --> 00:18:31,733
原文件其实是可以拷贝出来的

524
00:18:31,733 --> 00:18:32,533
在这

525
00:18:32,866 --> 00:18:33,966
这个原文件很大

526
00:18:36,366 --> 00:18:38,866
一共有14,378行

527
00:18:39,466 --> 00:18:39,999
大家知道

528
00:18:40,000 --> 00:18:42,300
这可不是一年两年能写出来的啊

529
00:18:42,300 --> 00:18:44,900
这是若干年的同学努力啊

530
00:18:45,066 --> 00:18:47,099
啪啪啪写出来的

531
00:18:47,166 --> 00:18:47,399
所以

532
00:18:47,400 --> 00:18:49,533
你把你们自己的那个要做的那个部分

533
00:18:49,533 --> 00:18:50,733
把它考出去啊

534
00:18:50,966 --> 00:18:52,899
考出去以后注意除了考前面以外

535
00:18:52,900 --> 00:18:54,933
你还把后面的这个model也要考出去

536
00:18:55,333 --> 00:18:57,466
因为整个模型是分为两块的

537
00:18:57,466 --> 00:18:58,266
一块是API

538
00:18:58,266 --> 00:18:58,866
一块是后面

539
00:18:58,866 --> 00:18:59,666
的这个model

540
00:18:59,966 --> 00:19:02,066
model嘛你就不加区分的全部考过去

541
00:19:02,066 --> 00:19:02,933
然后前面的模块

542
00:19:02,933 --> 00:19:04,999
你就只考你自己要做那个模块

543
00:19:05,266 --> 00:19:07,966
然后用你的账号去做一个API

544
00:19:08,366 --> 00:19:12,999
教的时候把这个链接交上来就好

545
00:19:13,000 --> 00:19:14,866
不用交别的东西

546
00:19:15,000 --> 00:19:15,866
但注意下啊

547
00:19:15,866 --> 00:19:17,866
要把你这个发布成为public

548
00:19:18,133 --> 00:19:20,199
因为你在做的时候是个private的

549
00:19:20,266 --> 00:19:21,199
别人是看不到的啊

550
00:19:21,200 --> 00:19:22,900
你把它发布成为public的

551
00:19:23,100 --> 00:19:24,166
别人才能看得到

552
00:19:24,366 --> 00:19:26,133
然后你把URL加上来

553
00:19:26,133 --> 00:19:27,699
然后啊

554
00:19:28,066 --> 00:19:30,099
讨论个时候我先看看你的这个设计

555
00:19:30,400 --> 00:19:31,166
那作业的时候

556
00:19:31,166 --> 00:19:33,133
助教也是直接去通过这个URL

557
00:19:33,133 --> 00:19:35,799
去看你们的API的设计啊

558
00:19:36,533 --> 00:19:38,333
这是用12个Hop来做

559
00:19:38,666 --> 00:19:40,066
但其实我们知道

560
00:19:40,066 --> 00:19:41,766
今天的技术其实在不断的进步啊

561
00:19:41,766 --> 00:19:43,666
12个Hop其实已经存在了十多年了

562
00:19:43,700 --> 00:19:44,066
今天

563
00:19:44,066 --> 00:19:45,966
其实他有在用一种新的方式来做

564
00:19:45,966 --> 00:19:50,466
这个API叫做open API的方式来做啊

565
00:19:50,466 --> 00:19:51,366
其实我也想尝试

566
00:19:51,366 --> 00:19:53,199
因为我还是对新的东西

567
00:19:53,200 --> 00:19:54,100
还是很有兴趣的

568
00:19:54,100 --> 00:19:56,600
所以我也想今年改成新的方式去做

569
00:19:56,966 --> 00:19:58,866
那要做成新的方式呢

570
00:19:58,966 --> 00:20:02,866
我不想重写这14,000多行的这个代码

571
00:20:03,000 --> 00:20:05,933
所以我想把它迁移到新的上去

572
00:20:06,466 --> 00:20:09,466
但是迁移的时候他说你写的太多了

573
00:20:09,566 --> 00:20:11,166
太长他迁移不过去

574
00:20:12,533 --> 00:20:13,733
一点点钱

575
00:20:13,733 --> 00:20:14,299
这个没办法

576
00:20:14,300 --> 00:20:15,933
他是有相互的关系的

577
00:20:15,933 --> 00:20:16,966
他没办法一点点迁

578
00:20:16,966 --> 00:20:18,599
因为你把它切开了以后啊

579
00:20:18,900 --> 00:20:21,066
他的逻辑就会报错啊

580
00:20:21,966 --> 00:20:23,766
那就我们现在这个旧的方式

581
00:20:23,766 --> 00:20:24,599
让他待着吧啊

582
00:20:24,600 --> 00:20:26,266
所以大家如果有兴趣的话呢

583
00:20:26,266 --> 00:20:27,766
想做新的方式

584
00:20:27,766 --> 00:20:29,466
你们可以看看新的方式怎么做啊

585
00:20:29,466 --> 00:20:32,099
这叫做open API的方式

586
00:20:33,200 --> 00:20:35,100
呃OPPO f s是一个规范

587
00:20:35,133 --> 00:20:35,699
呃swag

588
00:20:35,700 --> 00:20:38,900
Hop是这个公司本身所提供的一种格式

589
00:20:38,900 --> 00:20:40,866
当然这个其实大家用的最多的啊

590
00:20:40,866 --> 00:20:43,066
就是在有规范出现之前

591
00:20:43,266 --> 00:20:45,533
这个其实就是事实上的工业标准

592
00:20:45,533 --> 00:20:47,133
大家都是用这个swag

593
00:20:47,300 --> 00:20:49,600
来写我们的API的定义的

594
00:20:51,100 --> 00:20:53,500
呃这是关于API的设计

595
00:20:53,500 --> 00:20:55,333
所以API设计我们不再说太多

596
00:20:55,466 --> 00:20:56,466
API的设计里头

597
00:20:56,466 --> 00:20:57,599
其实我们有看到说

598
00:20:57,600 --> 00:21:00,200
它是来自于前端的界面设计

599
00:21:00,200 --> 00:21:04,200
和后端的领域模型共同造成的结果

600
00:21:04,400 --> 00:21:06,600
那有了这个API设计以后

601
00:21:07,366 --> 00:21:08,599
我们就会有下一步

602
00:21:08,600 --> 00:21:09,500
对象模型

603
00:21:09,933 --> 00:21:10,366
大家知道

604
00:21:10,366 --> 00:21:10,933
对象模型

605
00:21:10,933 --> 00:21:13,366
是我们在周一的课里头讲到过的

606
00:21:13,666 --> 00:21:16,399
在我们的层次体系结构中间

607
00:21:16,400 --> 00:21:18,766
充血模型中间最重要的部分

608
00:21:18,766 --> 00:21:20,566
也就是我们中间的do对象

609
00:21:20,566 --> 00:21:22,599
或者do对象长啥样

610
00:21:23,100 --> 00:21:25,000
就是我们所说的这个对象模型

611
00:21:25,366 --> 00:21:26,933
对象模型怎么设计来的

612
00:21:27,000 --> 00:21:29,766
对象模型的来源来自于两个方面

613
00:21:30,000 --> 00:21:31,466
一个是API

614
00:21:31,566 --> 00:21:33,133
一个是领域模型

615
00:21:33,300 --> 00:21:35,600
就是API和领域模型

616
00:21:35,600 --> 00:21:37,566
决定着我们的对象模型怎么来

617
00:21:37,700 --> 00:21:39,333
我们在这个对象模型中间啊

618
00:21:39,333 --> 00:21:40,499
我们可以看到说

619
00:21:40,500 --> 00:21:42,366
它其实跟我们的领域模型

620
00:21:42,366 --> 00:21:44,066
是有一定的相似性

621
00:21:44,200 --> 00:21:46,133
我们看上面这个白色的部分

622
00:21:46,866 --> 00:21:52,299
白色的部分在商品和这个呃

623
00:21:54,700 --> 00:21:57,366
在商品和这个分类啊

624
00:21:57,366 --> 00:21:59,466
这两个对象模型上头

625
00:21:59,466 --> 00:22:02,899
基本上是跟我们的领域模型

626
00:22:02,900 --> 00:22:04,766
是完全一样啊

627
00:22:04,900 --> 00:22:05,933
就是商品

628
00:22:07,500 --> 00:22:09,666
分类商品模板

629
00:22:10,133 --> 00:22:13,799
商品和这个呃配送

630
00:22:18,000 --> 00:22:18,966
基本上是一模一样

631
00:22:18,966 --> 00:22:19,699
就这一边

632
00:22:19,700 --> 00:22:20,300
大家看下

633
00:22:20,300 --> 00:22:21,700
基本上是一模一样

634
00:22:22,066 --> 00:22:23,466
差别在于哪

635
00:22:23,666 --> 00:22:27,299
差别在于说相对于领域模型

636
00:22:27,300 --> 00:22:29,866
我们说它的关系是双向的

637
00:22:29,866 --> 00:22:31,699
它就描述说它们两个之间的

638
00:22:31,700 --> 00:22:32,166
一个本质

639
00:22:32,166 --> 00:22:32,966
比如说

640
00:22:33,133 --> 00:22:37,133
它描述的是商铺所关注的所有的商品

641
00:22:37,800 --> 00:22:38,566
啊

642
00:22:38,566 --> 00:22:40,799
他描述的是商铺所关注的所有商品

643
00:22:40,800 --> 00:22:43,366
他描述的是分类底下所有的商品

644
00:22:43,566 --> 00:22:45,066
那这个是个双向

645
00:22:45,300 --> 00:22:47,400
但是在对向模型上头

646
00:22:47,400 --> 00:22:50,666
我们把双向的变成了单向

647
00:22:51,566 --> 00:22:52,266
大家可以看到

648
00:22:52,266 --> 00:22:55,299
我们一般不会选择用双向啊

649
00:22:55,300 --> 00:22:56,333
但有一地方会

650
00:22:56,400 --> 00:22:57,700
但是在这一个部分来说

651
00:22:57,700 --> 00:23:01,466
我们的选择就全部是由双向的

652
00:23:01,533 --> 00:23:03,266
变成单向

653
00:23:03,600 --> 00:23:06,200
那变成单向的原因是什么

654
00:23:07,333 --> 00:23:08,533
变成单项的原因

655
00:23:08,566 --> 00:23:11,933
首要的原因是因为效率的问题

656
00:23:12,133 --> 00:23:12,799
比如说

657
00:23:12,800 --> 00:23:15,933
我们从分类和商品这个例子来看

658
00:23:16,200 --> 00:23:17,666
我们在领域目中间看到

659
00:23:17,666 --> 00:23:20,366
分类和商品是一个一对多的关系

660
00:23:20,366 --> 00:23:22,899
一个分类底下有多个商品

661
00:23:23,100 --> 00:23:23,900
对吧

662
00:23:24,466 --> 00:23:27,733
但是我们在这个对象名之间会发现说

663
00:23:27,733 --> 00:23:28,766
我们把这个关系

664
00:23:28,766 --> 00:23:30,666
变成一个一对一的关系

665
00:23:31,500 --> 00:23:33,366
就是这个话的描述

666
00:23:33,366 --> 00:23:33,899
表示说

667
00:23:33,900 --> 00:23:37,000
商品中间有一个属性叫做category

668
00:23:37,700 --> 00:23:38,933
category是它的分类

669
00:23:38,933 --> 00:23:43,199
是这个对象原本的描述是

670
00:23:44,566 --> 00:23:45,966
一对多的关系

671
00:23:45,966 --> 00:23:48,766
我们现在把一对多的这个方向

672
00:23:48,766 --> 00:23:50,066
给他舍弃了

673
00:23:50,333 --> 00:23:51,799
只留下了他

674
00:23:51,800 --> 00:23:53,466
从多对一的方向

675
00:23:53,466 --> 00:23:54,866
多对一其实就是一对一

676
00:23:55,000 --> 00:23:56,000
这个应该理解吧

677
00:23:56,000 --> 00:23:57,466
多对一就是一对一

678
00:23:57,900 --> 00:23:58,966
多对一表示说

679
00:23:58,966 --> 00:24:01,166
多个商品会在一个分类里头

680
00:24:01,166 --> 00:24:03,199
每一个商品只能在一个分类中间

681
00:24:03,200 --> 00:24:05,566
所以说一个商品就只有一个分类

682
00:24:05,966 --> 00:24:07,733
所以多对一就是一对一

683
00:24:07,800 --> 00:24:08,666
我们在领域中间

684
00:24:08,666 --> 00:24:09,966
描述的是一个双向关系

685
00:24:09,966 --> 00:24:11,899
但是在对象模型中间

686
00:24:11,900 --> 00:24:12,533
在这个例中间

687
00:24:12,533 --> 00:24:14,666
只描述了一个单项的关系

688
00:24:15,566 --> 00:24:16,733
那为什么会这么做

689
00:24:17,466 --> 00:24:18,733
双向关系怎么办

690
00:24:18,866 --> 00:24:19,766
双向关系

691
00:24:20,200 --> 00:24:21,700
双向的那个一对多的关系

692
00:24:21,700 --> 00:24:23,500
就是一个分类底下的所有

693
00:24:23,500 --> 00:24:25,566
的商品这个关系需不需要

694
00:24:26,266 --> 00:24:27,599
这就是我们在做对象模型期间

695
00:24:27,600 --> 00:24:28,766
所考虑的因素

696
00:24:28,800 --> 00:24:29,700
需不需要呢

697
00:24:29,800 --> 00:24:32,866
这个需不需要完全是由API来决定

698
00:24:33,166 --> 00:24:36,133
所以我们去看一下固执的API这个

699
00:24:37,966 --> 00:24:39,066
我们会发现

700
00:24:39,066 --> 00:24:40,766
在固执的API里头

701
00:24:41,866 --> 00:24:43,466
在商品的API里头啊

702
00:24:44,566 --> 00:24:46,899
我们其实是有一个API的

703
00:24:49,333 --> 00:24:51,999
这个API应该是获得分类底下的

704
00:24:52,000 --> 00:24:53,866
就是获得某一个分类底下的

705
00:24:53,866 --> 00:24:54,733
所有的商品啊

706
00:24:54,733 --> 00:24:56,133
我们这个好像是把漏掉

707
00:24:56,366 --> 00:24:57,533
应该是有一个这样的API

708
00:24:57,533 --> 00:24:58,299
因为前端界面上

709
00:24:58,300 --> 00:25:00,533
都是要从分类一直看下来

710
00:25:00,600 --> 00:25:02,933
最后会看到分类底下的所有的商品

711
00:25:02,933 --> 00:25:04,333
是有一个这样的API的

712
00:25:04,733 --> 00:25:06,466
那如果说有这样的一个API

713
00:25:06,766 --> 00:25:08,499
你在对象模型上头

714
00:25:08,500 --> 00:25:11,800
为什么不把分类和对象之间的

715
00:25:11,800 --> 00:25:12,933
一对多的关系

716
00:25:12,933 --> 00:25:13,966
去把它建立起来

717
00:25:16,666 --> 00:25:17,333
那当然有必要

718
00:25:17,333 --> 00:25:18,666
你API要做出来啊

719
00:25:19,300 --> 00:25:20,133
你API不做出来

720
00:25:20,133 --> 00:25:21,066
对象模型上面没有你

721
00:25:21,066 --> 00:25:21,933
就意味着这个对象模型

722
00:25:21,933 --> 00:25:23,599
其实是没办法去描述

723
00:25:23,966 --> 00:25:25,899
一个分类底下的所有商品的

724
00:25:26,400 --> 00:25:27,966
对吧因为你没建这个关系

725
00:25:28,166 --> 00:25:29,533
你只描述了是什么

726
00:25:29,533 --> 00:25:33,166
只描述了说这个分类他关联的啊

727
00:25:33,166 --> 00:25:34,533
这个商品他关联的分类

728
00:25:34,533 --> 00:25:35,733
所以你拿到一个商品啊

729
00:25:35,733 --> 00:25:37,299
你会知道这个商品的分类是什么

730
00:25:37,300 --> 00:25:38,166
这个是需要的啊

731
00:25:38,166 --> 00:25:38,599
因为我们看到

732
00:25:38,600 --> 00:25:40,866
一个商品的具体的信息的时候

733
00:25:40,866 --> 00:25:41,299
肯定要看到

734
00:25:41,300 --> 00:25:42,866
这个商品所属的分类是什么

735
00:25:42,866 --> 00:25:44,133
这个是肯定会需要的

736
00:25:44,500 --> 00:25:46,200
但是你其实这样的一个对象模型

737
00:25:46,200 --> 00:25:47,733
是没有能力去描述说

738
00:25:47,733 --> 00:25:49,766
一个分类底下到底有哪些商品

739
00:25:50,133 --> 00:25:51,266
它没有这个内容

740
00:25:52,266 --> 00:25:53,466
那怎么办

741
00:25:53,800 --> 00:25:54,866
为什么会这么做

742
00:25:55,533 --> 00:25:56,466
这个就是效率的

743
00:25:56,466 --> 00:25:59,366
问题我们知道一个分类底下的商品

744
00:25:59,800 --> 00:26:00,766
少则几十

745
00:26:00,766 --> 00:26:02,666
多则几百对吧

746
00:26:02,933 --> 00:26:05,133
那如果说把它变成对象模型的话

747
00:26:05,133 --> 00:26:08,266
意味着一个分类底下的所有的商品

748
00:26:08,266 --> 00:26:09,966
都需要从数据库里查出来

749
00:26:09,966 --> 00:26:12,133
放到我们的对象模型里中间

750
00:26:12,166 --> 00:26:15,333
因为对象模型是在内存中间的模型

751
00:26:15,333 --> 00:26:17,066
而不是在存储里头的模型

752
00:26:17,066 --> 00:26:18,766
我们后面会讲数据库的模型

753
00:26:18,766 --> 00:26:20,266
那是存储里头的模型

754
00:26:20,700 --> 00:26:21,333
这是讲说

755
00:26:21,333 --> 00:26:23,266
我们把数据从存储里头拿出来

756
00:26:23,266 --> 00:26:25,899
放到内存中间的模型

757
00:26:25,966 --> 00:26:26,933
因为对象模型

758
00:26:26,933 --> 00:26:29,399
是我们的业务的依附之地

759
00:26:29,800 --> 00:26:32,066
业务是依附在对象模型上面的

760
00:26:32,166 --> 00:26:34,933
但是对象模型必须在内存里头

761
00:26:35,300 --> 00:26:37,600
所以如果说我们要上面做业务的话

762
00:26:37,933 --> 00:26:38,966
这个业务需要知道

763
00:26:38,966 --> 00:26:40,666
一个分离下的所有商品的话

764
00:26:40,866 --> 00:26:43,299
那这个对象模型就需要把它建出来

765
00:26:43,766 --> 00:26:45,766
建出来以后就会产生一个问题

766
00:26:45,900 --> 00:26:46,366
大家知道

767
00:26:46,366 --> 00:26:48,166
如果说我们只能对象模型的

768
00:26:48,166 --> 00:26:50,199
去描述一个分类题上的所有商品

769
00:26:50,400 --> 00:26:51,966
这个对象模型是很笨重

770
00:26:51,966 --> 00:26:53,133
而且是很低效的

771
00:26:55,100 --> 00:26:56,666
因为这个商品太多了

772
00:26:56,933 --> 00:26:58,666
所以我们现在的选择就是

773
00:26:58,666 --> 00:26:59,666
我们在对象文件上找

774
00:26:59,666 --> 00:27:02,099
我们选择忽视这部分的需求

775
00:27:02,666 --> 00:27:03,966
就不描述说

776
00:27:03,966 --> 00:27:05,966
一个分类底下的多少商品是什么

777
00:27:06,100 --> 00:27:07,133
那这就带来一个问题

778
00:27:07,133 --> 00:27:08,133
API怎么做出来

779
00:27:08,666 --> 00:27:09,366
API上呢

780
00:27:09,366 --> 00:27:11,966
是有去描述一个分类底下的所有商品

781
00:27:12,266 --> 00:27:14,133
所以答案就是

782
00:27:14,266 --> 00:27:15,199
结论就是

783
00:27:15,366 --> 00:27:15,999
这个API

784
00:27:16,000 --> 00:27:19,133
是没办法用面向对象的方式去实现

785
00:27:20,066 --> 00:27:20,699
这个API

786
00:27:20,700 --> 00:27:24,766
就能纯粹使用面向功能的方式去做

787
00:27:25,300 --> 00:27:25,566
所以

788
00:27:25,566 --> 00:27:28,299
我们在具体做一个系统的设计的时候

789
00:27:28,300 --> 00:27:31,533
不是孤立地使用某一种设计方式

790
00:27:32,200 --> 00:27:34,666
所有的设计方法都会综

791
00:27:34,666 --> 00:27:35,399
合的用到

792
00:27:35,400 --> 00:27:37,000
就是我们在设计一个系统的时候

793
00:27:37,000 --> 00:27:38,366
我们说他这个面向对象的设计

794
00:27:38,366 --> 00:27:42,066
我们不是说他100%都是面向对象的设计

795
00:27:42,366 --> 00:27:46,133
只是说我们会在一个选择的时候

796
00:27:46,366 --> 00:27:49,266
如果他可以用面向对象设计去做出来

797
00:27:49,800 --> 00:27:52,466
那我们优先会采用面向对象的设计

798
00:27:52,466 --> 00:27:53,266
去做

799
00:27:53,466 --> 00:27:55,266
那如果说用面向对象的设计去做

800
00:27:55,266 --> 00:27:55,999
这个问题

801
00:27:56,000 --> 00:27:57,166
是一个低效的

802
00:27:58,133 --> 00:27:59,766
我们就会选择其他的方式去做

803
00:27:59,766 --> 00:28:01,799
比如说在这个地方我们的对象没中

804
00:28:01,800 --> 00:28:03,566
也没有建立分类

805
00:28:03,566 --> 00:28:05,566
和商品的一对多的关系

806
00:28:05,566 --> 00:28:06,966
那意味着在API上头

807
00:28:06,966 --> 00:28:08,899
你要看一个分类上面的所有商品

808
00:28:08,900 --> 00:28:09,966
的时候是看不到的

809
00:28:10,200 --> 00:28:11,666
在对象没中也是做不到的

810
00:28:11,900 --> 00:28:14,166
就只能用面向功能的方式去做

811
00:28:14,266 --> 00:28:15,199
面向功能方怎么做呢

812
00:28:15,200 --> 00:28:18,066
就是在SOS上做一个方法

813
00:28:18,066 --> 00:28:20,133
SOS的方法去叫稻城的方法

814
00:28:20,166 --> 00:28:21,733
然后去把这个东西捞出来

815
00:28:22,400 --> 00:28:23,900
拿回去给他看就好了

816
00:28:24,066 --> 00:28:25,266
在对象模型中间

817
00:28:25,266 --> 00:28:29,566
是没有一行跟这个API有关的代码

818
00:28:29,900 --> 00:28:32,566
这就是我们在读对象模型时候

819
00:28:32,566 --> 00:28:33,399
的一个抉择

820
00:28:34,100 --> 00:28:35,400
所以要明确一点啊

821
00:28:35,400 --> 00:28:36,866
做对象模型的时候

822
00:28:36,866 --> 00:28:38,866
你要考虑到效率问题

823
00:28:39,266 --> 00:28:42,866
你要考虑到说你不是想用对象模型

824
00:28:42,966 --> 00:28:44,899
就是想用面向对象的方法

825
00:28:44,900 --> 00:28:48,666
把所有的API都去把它实现

826
00:28:48,666 --> 00:28:50,133
这样实际上是做不到的

827
00:28:50,200 --> 00:28:51,933
我们其实是有一些选择

828
00:28:51,933 --> 00:28:54,799
我们要在这个API上头调用对象模型

829
00:28:54,800 --> 00:28:55,933
去做哪些API

830
00:28:56,500 --> 00:28:59,566
做的前提就是它的效率是可以接受的

831
00:28:59,766 --> 00:29:01,499
如果它的效率是不可以接受的

832
00:29:01,500 --> 00:29:04,500
那你就不要选用面向对象的方式

833
00:29:04,733 --> 00:29:06,266
去做这样一个设计

834
00:29:06,533 --> 00:29:07,999
这个就是我举了个例子啊

835
00:29:08,000 --> 00:29:09,900
从category到product

836
00:29:09,966 --> 00:29:10,899
我们舍弃

837
00:29:10,900 --> 00:29:13,466
了它本需要的

838
00:29:13,466 --> 00:29:16,599
category和product的一对多的关系

839
00:29:16,700 --> 00:29:18,266
那这里还有另外一个一对多的关系

840
00:29:18,266 --> 00:29:19,099
大家可以看到

841
00:29:19,466 --> 00:29:21,766
product和other product就是一个商品

842
00:29:21,766 --> 00:29:23,099
和它关联的商品

843
00:29:23,466 --> 00:29:24,599
这个一对多的关系

844
00:29:24,600 --> 00:29:26,000
我们把它保留下来了

845
00:29:26,666 --> 00:29:27,766
为什么把它保留下来

846
00:29:28,333 --> 00:29:30,166
原因就是因为它的数目是很有限

847
00:29:30,466 --> 00:29:32,299
大家可以在商品的网页上呢看到

848
00:29:32,300 --> 00:29:33,966
当你买一个商品的时候

849
00:29:34,000 --> 00:29:35,666
你下面还可以点的商品

850
00:29:35,733 --> 00:29:37,299
其实就是很有限的

851
00:29:37,600 --> 00:29:41,000
其实也就是大概少则五六个

852
00:29:41,100 --> 00:29:43,466
多则十几二十多个

853
00:29:43,566 --> 00:29:46,199
所以我们一般认为比如说少则五六个

854
00:29:46,200 --> 00:29:48,600
多则十几二345780

855
00:29:48,600 --> 00:29:51,666
也不认为100个以内都是可以接受的啊

856
00:29:51,666 --> 00:29:52,799
那我们效率都可以接受

857
00:29:52,800 --> 00:29:54,600
当然这个越多你的效率越慢

858
00:29:55,066 --> 00:29:55,599
这个越少

859
00:29:55,600 --> 00:29:56,866
你的效率也越快

860
00:29:56,933 --> 00:29:58,333
所以在这部分设计来说

861
00:29:58,333 --> 00:29:59,299
因为我们知道

862
00:29:59,933 --> 00:30:02,333
所有的这个商品所关联的其他商品

863
00:30:02,333 --> 00:30:03,366
其实是有线

864
00:30:03,700 --> 00:30:06,400
这个线通常在十几个左右

865
00:30:07,300 --> 00:30:08,933
所以我们把这个关系

866
00:30:08,933 --> 00:30:10,133
就做到对象平台上

867
00:30:10,200 --> 00:30:12,000
因为他对于我们的效率影响

868
00:30:12,266 --> 00:30:13,366
不是那么大啊

869
00:30:13,366 --> 00:30:15,199
不是那么大这是

870
00:30:19,966 --> 00:30:21,366
这是这个关系啊

871
00:30:22,166 --> 00:30:24,199
这是这边这个产品的这个关系

872
00:30:24,900 --> 00:30:27,333
呃然后大家会看到

873
00:30:27,333 --> 00:30:29,966
我们在这个里头

874
00:30:30,966 --> 00:30:32,966
同样有一个一对多的关系

875
00:30:33,366 --> 00:30:34,133
这个一对关系呢

876
00:30:34,133 --> 00:30:36,333
是一个商品和销售

877
00:30:36,600 --> 00:30:39,366
我们知道这个商品在不同的时间

878
00:30:39,366 --> 00:30:40,899
他的on sale是不一样的

879
00:30:40,900 --> 00:30:42,733
因为他在不同时间会卖不同的价格

880
00:30:42,733 --> 00:30:44,366
以不同的数量卖不同的价格

881
00:30:44,600 --> 00:30:47,066
所以这是一个一对多的关系

882
00:30:48,000 --> 00:30:49,333
那这时候你就会发现

883
00:30:49,333 --> 00:30:50,599
这个一对多的关系

884
00:30:50,600 --> 00:30:53,533
我们跟category的的做法不一样

885
00:30:53,933 --> 00:30:55,866
category的做法是这个

886
00:30:55,866 --> 00:30:58,199
一对就是category和它的一对多的关系

887
00:30:58,200 --> 00:30:59,700
我们完全舍弃了

888
00:30:59,800 --> 00:31:03,466
我们只保留了从category到从product

889
00:31:03,466 --> 00:31:04,533
category的这个多

890
00:31:04,533 --> 00:31:05,766
到1的这个方向

891
00:31:05,933 --> 00:31:08,366
记录了这个但是在

892
00:31:09,966 --> 00:31:11,733
这个product这里哈

893
00:31:12,166 --> 00:31:14,199
我们采用的方式是

894
00:31:14,200 --> 00:31:16,333
其实我们记了一个单项

895
00:31:16,333 --> 00:31:18,666
记了一个呃

896
00:31:18,666 --> 00:31:19,166
怎么说呢

897
00:31:19,166 --> 00:31:20,166
记了一个

898
00:31:20,900 --> 00:31:24,800
从product到Excel的一对一的关系

899
00:31:25,700 --> 00:31:26,933
那你为什么会想说

900
00:31:26,933 --> 00:31:29,266
它本身是一个一对多的关系

901
00:31:29,700 --> 00:31:31,366
为什么我们在对象模型中间

902
00:31:31,366 --> 00:31:34,266
采用了一个一对一的关系去描述它

903
00:31:35,700 --> 00:31:37,400
首先大家应该知道啊

904
00:31:37,600 --> 00:31:39,400
这个原因还是效率问题

905
00:31:39,700 --> 00:31:42,533
因为一个商品的历史的销售的记录

906
00:31:42,666 --> 00:31:44,133
可能会有大几十

907
00:31:44,300 --> 00:31:46,000
而且这个很频繁

908
00:31:46,333 --> 00:31:48,166
就是这个还不像那个category

909
00:31:48,700 --> 00:31:49,966
他是非常平凡

910
00:31:50,466 --> 00:31:52,366
所以每拿到一个商品

911
00:31:52,366 --> 00:31:55,199
如果要把他大几十个历史的销售记录

912
00:31:55,200 --> 00:31:56,466
全带出来的话

913
00:31:56,766 --> 00:31:58,133
肯定是一个低效的

914
00:31:58,600 --> 00:31:59,700
但是他又需要

915
00:32:00,066 --> 00:32:01,933
因为我们去看这个API

916
00:32:01,933 --> 00:32:03,733
就是我们所有的设计的冲动啊

917
00:32:03,733 --> 00:32:05,099
都是来自于这个API

918
00:32:05,466 --> 00:32:06,933
比如说我们最常我们知道

919
00:32:06,933 --> 00:32:11,133
这个API其实是一个高频会调用的API

920
00:32:13,266 --> 00:32:14,066
有这个API

921
00:32:14,900 --> 00:32:17,000
顾客去看到一个商品的详细信息

922
00:32:17,000 --> 00:32:19,100
这是一个高频会调用的API

923
00:32:19,400 --> 00:32:21,100
这个API的的里头

924
00:32:21,100 --> 00:32:22,400
大家会注意到说

925
00:32:22,566 --> 00:32:23,499
他所描述的

926
00:32:23,500 --> 00:32:25,466
就是顾客想看到的一个商品信息

927
00:32:25,566 --> 00:32:26,866
顾客看到一个商品

928
00:32:26,966 --> 00:32:28,999
想看到商品的基自己的信息以外

929
00:32:29,166 --> 00:32:30,899
当然想看到商品的价格

930
00:32:31,500 --> 00:32:33,000
还有就是他虽然看不到

931
00:32:33,000 --> 00:32:33,800
但是他既然知道

932
00:32:33,800 --> 00:32:35,733
这上面还能还有多少数据在卖

933
00:32:35,933 --> 00:32:37,866
因为大家知道如果他到0的话

934
00:32:37,866 --> 00:32:39,133
他就会说有售罄

935
00:32:39,500 --> 00:32:40,333
如果他到还剩

936
00:32:40,333 --> 00:32:41,199
那么几件的话嘛

937
00:32:41,200 --> 00:32:42,866
通常界面上会显示一个

938
00:32:43,000 --> 00:32:44,900
这个商品还剩几件是吧

939
00:32:44,966 --> 00:32:46,133
如果他很多的话嘛

940
00:32:46,133 --> 00:32:47,266
基本上就什么都不显示

941
00:32:47,266 --> 00:32:49,066
那是界面工程师的问题啊

942
00:32:49,066 --> 00:32:50,666
界面工程界面设计会说

943
00:32:51,333 --> 00:32:55,166
我想知道说这个商品到底啊能不能买

944
00:32:55,166 --> 00:32:55,999
如果他到0的话

945
00:32:56,000 --> 00:32:57,466
其实就会显示个售罄

946
00:32:57,566 --> 00:32:59,299
如果剩个5件或者剩个6件

947
00:32:59,300 --> 00:33:00,266
就会显示出来

948
00:33:00,333 --> 00:33:01,366
如果还剩很多的话

949
00:33:01,366 --> 00:33:02,766
其实他就什么都不会显示

950
00:33:03,066 --> 00:33:04,666
所以他需要知道这个数量

951
00:33:05,400 --> 00:33:06,933
你要去买这个商品的时候

952
00:33:06,933 --> 00:33:07,933
就是界面工程师会说

953
00:33:07,933 --> 00:33:09,199
我要去买这个商品时候

954
00:33:09,300 --> 00:33:10,166
我其实要知道说

955
00:33:10,166 --> 00:33:12,566
这个商品我一次一个订单能买多少个

956
00:33:12,866 --> 00:33:14,666
所以那个Max quality

957
00:33:14,666 --> 00:33:16,466
就是他一次能买多少个

958
00:33:16,700 --> 00:33:19,166
也需要在送到前端

959
00:33:19,166 --> 00:33:20,666
虽然界面上不需要显示

960
00:33:20,666 --> 00:33:22,766
但是前端工程师在做界面时候

961
00:33:22,766 --> 00:33:24,399
他要根据这个值去决定

962
00:33:24,566 --> 00:33:25,799
你能一次买多少

963
00:33:25,933 --> 00:33:27,799
对吧这些值都需要

964
00:33:28,066 --> 00:33:28,866
所以我们可以看到

965
00:33:28,866 --> 00:33:30,166
我们在做这个API时候

966
00:33:30,166 --> 00:33:32,899
就把这个商品的这一把值全丢给他了

967
00:33:32,900 --> 00:33:34,100
所以前端工程师就很简单

968
00:33:34,100 --> 00:33:36,133
拿到这个东西时候就直接就用就好了

969
00:33:36,533 --> 00:33:38,733
也不要去管我们后面的结构是什么

970
00:33:38,966 --> 00:33:40,566
所以大家应该能看到说

971
00:33:40,666 --> 00:33:42,733
这是由什么东西产生的呢

972
00:33:42,966 --> 00:33:43,766
这个数据就是

973
00:33:43,766 --> 00:33:44,166
我们看到

974
00:33:44,166 --> 00:33:45,566
这个数据是由什么东西产生的

975
00:33:45,900 --> 00:33:47,200
是由DTO产生的

976
00:33:47,566 --> 00:33:48,566
就是我们在后端

977
00:33:48,566 --> 00:33:51,466
工程师是把要传给前面的这些东西

978
00:33:51,466 --> 00:33:52,399
变成一个DTO

979
00:33:52,733 --> 00:33:54,966
然后把它丢给前端的工程师的

980
00:33:55,133 --> 00:33:56,266
这个DTO

981
00:33:56,566 --> 00:33:59,333
跟我们的领域模型可是不一样的

982
00:33:59,900 --> 00:34:02,000
跟我们的对象模型也是不一样

983
00:34:02,333 --> 00:34:04,066
我们在领域模型和对象模型中间

984
00:34:04,066 --> 00:34:05,766
会发现说我

985
00:34:05,766 --> 00:34:07,366
们的产品的基本信息在这

986
00:34:07,900 --> 00:34:11,366
我们的那些它的价格数量

987
00:34:11,366 --> 00:34:12,899
一次可以买多少个的信息

988
00:34:12,900 --> 00:34:13,866
是在这个地方

989
00:34:15,100 --> 00:34:16,733
它是在两个地方

990
00:34:16,866 --> 00:34:18,366
我们在概念里头

991
00:34:18,366 --> 00:34:20,766
在领域某年的对某人都是分开的

992
00:34:21,266 --> 00:34:23,733
所以当我们在使用那个API的时候

993
00:34:23,733 --> 00:34:25,666
你知道它应该是拿到一个商品

994
00:34:25,666 --> 00:34:28,399
和拿到它所关联的当前有效的这个

995
00:34:28,400 --> 00:34:31,500
销售把两个信息合起来变成那个DTO

996
00:34:31,500 --> 00:34:33,600
丢给前端的

997
00:34:34,366 --> 00:34:37,966
所以从商品到销售的这个关系

998
00:34:38,266 --> 00:34:40,899
是一个高频会被使用的消息

999
00:34:41,066 --> 00:34:43,466
但是他其实并不会用到什么呢

1000
00:34:43,666 --> 00:34:45,199
并不会用到他的所有

1001
00:34:45,333 --> 00:34:46,399
只是想知道

1002
00:34:46,400 --> 00:34:48,966
他当前有效的那个是什么

1003
00:34:49,066 --> 00:34:50,066
所以我们可以看到

1004
00:34:50,066 --> 00:34:54,299
我们在这里做关系的时候不是简单的

1005
00:34:54,300 --> 00:34:55,600
就是我们在做领域模型的时候

1006
00:34:55,600 --> 00:34:56,866
我们去认识它的本质

1007
00:34:56,866 --> 00:34:58,199
它是理论中的关系

1008
00:34:58,300 --> 00:34:59,800
但是我们在做对象模型的时候

1009
00:34:59,800 --> 00:35:01,733
我们会做权衡

1010
00:35:01,900 --> 00:35:03,766
说本质是那样

1011
00:35:03,933 --> 00:35:07,499
但是我们到底要建个什么样的东西

1012
00:35:07,500 --> 00:35:10,500
我们现在建的是一个一对一的关系

1013
00:35:10,866 --> 00:35:12,666
这个一对关系是是双向的啊

1014
00:35:13,333 --> 00:35:14,566
其实是双向的

1015
00:35:14,600 --> 00:35:16,566
就是我这里要补全一下

1016
00:35:16,566 --> 00:35:18,499
这边从product到这个Excel

1017
00:35:18,800 --> 00:35:21,166
每一个Excel是可以知道它的product

1018
00:35:21,166 --> 00:35:22,333
因为它是个一对多的关系

1019
00:35:22,333 --> 00:35:24,799
所以从Excel到product是没什么关系

1020
00:35:25,100 --> 00:35:27,866
但是从product到Excel是说了简化

1021
00:35:28,000 --> 00:35:30,100
把原本的一对多的关系

1022
00:35:30,100 --> 00:35:32,333
变成了一个一对一的关系

1023
00:35:32,733 --> 00:35:34,199
这里头会有很复杂的问题

1024
00:35:34,200 --> 00:35:35,566
因为有些时候

1025
00:35:35,566 --> 00:35:38,399
我们需要当前有效的商品的价格

1026
00:35:38,733 --> 00:35:40,599
从订单中间看过去的时候

1027
00:35:40,600 --> 00:35:41,966
就是看的历史价

1028
00:35:42,133 --> 00:35:42,499
大家知道

1029
00:35:42,500 --> 00:35:43,300
订单上看的时候

1030
00:35:43,300 --> 00:35:45,533
可不是看当前有效的

1031
00:35:45,533 --> 00:35:47,566
价格而是看的历史价格

1032
00:35:47,733 --> 00:35:47,999
所以

1033
00:35:48,000 --> 00:35:50,200
这个一对一的关系是会发生改变的

1034
00:35:50,566 --> 00:35:52,366
但这个改变在什么时候

1035
00:35:52,366 --> 00:35:54,099
会看到哪一个Excel

1036
00:35:54,166 --> 00:35:55,766
我们在后面的设计中心去讲

1037
00:35:55,766 --> 00:35:56,866
但是我们现在可以看到

1038
00:35:56,866 --> 00:35:58,166
我们做了一个简化

1039
00:35:58,466 --> 00:36:00,333
做了简化以后就会带来另外一个问题

1040
00:36:00,333 --> 00:36:01,999
原本是一对多的关系

1041
00:36:02,700 --> 00:36:04,133
一对多的关系需不需要呢

1042
00:36:05,966 --> 00:36:08,066
我们看API需不需要啊

1043
00:36:08,066 --> 00:36:10,733
以API为准我们在

1044
00:36:18,133 --> 00:36:20,299
我们在API里头可以看到

1045
00:36:20,300 --> 00:36:24,100
对于设普通用户其实是不需要这个的

1046
00:36:24,300 --> 00:36:26,700
但是对于我们的管理员来说

1047
00:36:26,700 --> 00:36:28,900
他会有一个这样的get的请求

1048
00:36:38,300 --> 00:36:39,133
就是这个

1049
00:36:40,500 --> 00:36:42,500
这个请求是管理员想看到某个商品

1050
00:36:42,500 --> 00:36:45,266
他所有的销售的情况

1051
00:36:46,133 --> 00:36:47,733
对吧所以他一个get请求

1052
00:36:47,733 --> 00:36:49,899
想拿到一个商品底下的所有的销售

1053
00:36:50,733 --> 00:36:52,566
啊所以这个就意味着

1054
00:36:52,566 --> 00:36:54,499
他返回的是一个销售的列表

1055
00:36:55,200 --> 00:36:56,700
这就需要一对多的关系

1056
00:36:57,866 --> 00:36:59,166
那这一对关系怎么办

1057
00:37:02,200 --> 00:37:03,000
怎么办

1058
00:37:03,600 --> 00:37:04,400
同样的道理

1059
00:37:04,400 --> 00:37:05,166
对象模型上

1060
00:37:05,166 --> 00:37:08,099
没有用面向功能的方式去解决他

1061
00:37:09,600 --> 00:37:10,666
用面相功能的方式

1062
00:37:10,666 --> 00:37:11,999
就是在收费时中间做一个方法

1063
00:37:12,000 --> 00:37:12,866
这样稻成的方法

1064
00:37:12,866 --> 00:37:14,133
然后把结果返回去

1065
00:37:14,200 --> 00:37:15,700
跟我们的面相

1066
00:37:15,700 --> 00:37:17,466
对象的模型是完全没有关系的

1067
00:37:18,000 --> 00:37:20,533
所以我们这里的API的设计

1068
00:37:20,533 --> 00:37:22,466
是根据用户的需求和界面来

1069
00:37:22,533 --> 00:37:23,366
但大家要知道

1070
00:37:23,366 --> 00:37:24,966
我们在构建对象模型的时候

1071
00:37:24,966 --> 00:37:26,266
其实不是万能的

1072
00:37:26,733 --> 00:37:28,466
我们会考虑它的效率问题

1073
00:37:28,466 --> 00:37:31,499
决定哪些问题在对象模型中间解决

1074
00:37:31,766 --> 00:37:34,166
哪些问题不在对象模型中解决

1075
00:37:34,366 --> 00:37:36,133
如果大家去仔细去研读的话

1076
00:37:36,133 --> 00:37:38,933
你会发现有个很有特点的现象

1077
00:37:39,100 --> 00:37:41,900
就是如果简单的针三改查的话

1078
00:37:41,900 --> 00:37:44,133
基本上是不靠对象模型去完成

1079
00:37:44,566 --> 00:37:46,799
就是我们通常来说简单的CRUD

1080
00:37:47,066 --> 00:37:50,133
特别是那种批量查询的CRUD

1081
00:37:50,600 --> 00:37:53,133
就是不会靠对象培训去完成

1082
00:37:53,133 --> 00:37:55,133
都是靠面向功能的方式去完成

1083
00:37:55,400 --> 00:37:57,166
但是针对这些东西

1084
00:37:57,166 --> 00:37:58,333
如果是有业务

1085
00:37:58,533 --> 00:38:01,466
比如说他的增三改增删改

1086
00:38:01,466 --> 00:38:02,799
是有业务的增删改

1087
00:38:02,900 --> 00:38:05,066
而不是简单的你叫增一个东西就能增

1088
00:38:05,333 --> 00:38:06,533
你要改个东西就能改

1089
00:38:06,866 --> 00:38:08,266
你要删一个东西就能删

1090
00:38:08,600 --> 00:38:09,466
是由业务决定

1091
00:38:09,466 --> 00:38:11,099
说这个东西增出来是什么样子

1092
00:38:11,100 --> 00:38:12,700
他是改能不能改

1093
00:38:12,733 --> 00:38:13,899
改出来是什么样子

1094
00:38:13,900 --> 00:38:15,333
以及他删能不能删

1095
00:38:15,600 --> 00:38:17,933
有业务的这些增删改的话

1096
00:38:18,000 --> 00:38:20,566
就会交由对象模型去完成

1097
00:38:20,666 --> 00:38:21,999
如果没有业务的

1098
00:38:22,000 --> 00:38:26,133
这个增删改和CI就是CIUD的话

1099
00:38:26,266 --> 00:38:28,199
那基本就不需要用到对项模型

1100
00:38:28,200 --> 00:38:29,800
就直接这么写啊

1101
00:38:29,800 --> 00:38:31,700
直接这么写就好了啊

1102
00:38:31,700 --> 00:38:32,566
大家知道啊

1103
00:38:32,566 --> 00:38:33,766
你要做一个系统

1104
00:38:33,766 --> 00:38:36,099
这个系统要有魅力

1105
00:38:36,300 --> 00:38:37,100
要有

1106
00:38:37,666 --> 00:38:39,066
要有这个价值

1107
00:38:39,333 --> 00:38:40,399
价值在于哪

1108
00:38:40,766 --> 00:38:42,133
价值在于业务

1109
00:38:42,266 --> 00:38:42,933
而不在于说

1110
00:38:42,933 --> 00:38:43,566
你做个系统

1111
00:38:43,566 --> 00:38:44,499
能把信息存进去

1112
00:38:44,500 --> 00:38:45,333
能把系统读出来

1113
00:38:45,333 --> 00:38:46,133
能把系统改

1114
00:38:46,200 --> 00:38:47,000
能把信息改了

1115
00:38:47,000 --> 00:38:47,966
能把信息删了

1116
00:38:48,600 --> 00:38:50,666
这样的系统是没有任何意义的

1117
00:38:50,666 --> 00:38:52,866
如果你去了解需求

1118
00:38:52,900 --> 00:38:53,800
然后需求得出来

1119
00:38:53,800 --> 00:38:55,200
就是一个正常改查的系统

1120
00:38:55,666 --> 00:38:56,966
你知道这个需求肯定是有问题

1121
00:38:57,100 --> 00:38:57,700
做出来以后

1122
00:38:57,700 --> 00:38:59,200
这个用户时间是没什么意义的

1123
00:38:59,200 --> 00:39:00,766
他穿用你一个系统去

1124
00:39:00,900 --> 00:39:02,500
还不如拿个Excel文件

1125
00:39:02,866 --> 00:39:04,499
一样的一样的道理

1126
00:39:04,500 --> 00:39:06,300
是吧所以你要做一个系统

1127
00:39:06,300 --> 00:39:07,933
肯定是要去做Excel文件

1128
00:39:07,933 --> 00:39:09,133
中间做不了的事情

1129
00:39:09,166 --> 00:39:10,866
不是简单的增长改查

1130
00:39:10,866 --> 00:39:12,766
而是有业务的东西啊

1131
00:39:12,766 --> 00:39:14,999
才是它的价值所在啊

1132
00:39:16,566 --> 00:39:19,299
这是这个on sale那这边

1133
00:39:19,300 --> 00:39:20,133
我们会看到

1134
00:39:20,133 --> 00:39:21,933
我们还会有个更复杂的

1135
00:39:21,966 --> 00:39:23,199
对象模型的关系

1136
00:39:23,200 --> 00:39:24,133
建立在这儿

1137
00:39:24,800 --> 00:39:25,766
多对多的

1138
00:39:27,166 --> 00:39:28,599
这个就是硬杠的

1139
00:39:28,600 --> 00:39:30,766
不对多的就直接进到对项门中间去了

1140
00:39:30,866 --> 00:39:32,733
为什么因为这个很重要

1141
00:39:33,100 --> 00:39:35,166
我们在这个里头会发现说

1142
00:39:35,166 --> 00:39:35,933
我们需要知道

1143
00:39:35,933 --> 00:39:38,066
一个销售到底参与了什么样的活动

1144
00:39:38,266 --> 00:39:39,599
他可以参与多个活动

1145
00:39:40,066 --> 00:39:41,099
我们其实需要知道

1146
00:39:41,100 --> 00:39:43,600
一个活动到底会有多少个销售参与

1147
00:39:43,600 --> 00:39:45,266
比如说团购活动就很重要

1148
00:39:45,266 --> 00:39:47,066
因为团购活动他要记总数

1149
00:39:47,400 --> 00:39:49,133
所有的销售卖出来的数

1150
00:39:49,133 --> 00:39:50,866
才是那个团购活动的总数

1151
00:39:51,133 --> 00:39:52,999
所以这个多对多的关系

1152
00:39:53,000 --> 00:39:54,466
我们采取硬杠的方式

1153
00:39:54,466 --> 00:39:55,999
写到了对象朋友中间

1154
00:39:56,200 --> 00:39:57,266
这里头你就会考虑到

1155
00:39:57,266 --> 00:39:58,533
他是不是有效率问题

1156
00:39:59,566 --> 00:40:01,066
他会不会有效率问题

1157
00:40:01,300 --> 00:40:04,200
一个商品所参与的活动

1158
00:40:04,400 --> 00:40:05,733
这个数目大家应该知道

1159
00:40:05,733 --> 00:40:08,266
从理论上来说是有限

1160
00:40:08,533 --> 00:40:09,799
因为我们同时代

1161
00:40:09,800 --> 00:40:11,566
也就是几十上百个活动

1162
00:40:11,766 --> 00:40:13,499
所以一个商品会参加的活动吗

1163
00:40:13,500 --> 00:40:14,733
太多了也没有什么意义

1164
00:40:14,733 --> 00:40:16,866
通常就是两个3个4个5个6个7个啊

1165
00:40:16,866 --> 00:40:17,666
都堆到10个

1166
00:40:17,666 --> 00:40:18,733
你会觉得很多了

1167
00:40:19,000 --> 00:40:20,300
也会有点手足无措

1168
00:40:20,666 --> 00:40:24,266
所以商品到活动的一对这个多的关系

1169
00:40:24,266 --> 00:40:25,699
是没有什么太大问题的

1170
00:40:25,966 --> 00:40:28,499
但是活动到销售的多的关系

1171
00:40:28,500 --> 00:40:30,066
是会有一定的问题的

1172
00:40:30,733 --> 00:40:32,966
就是他会有活动

1173
00:40:32,966 --> 00:40:34,866
会做全场活动

1174
00:40:35,533 --> 00:40:38,699
就是所有的商品都参加活动

1175
00:40:39,266 --> 00:40:41,066
那这个时候怎么办啊

1176
00:40:41,066 --> 00:40:42,866
所以全场活动

1177
00:40:42,900 --> 00:40:45,866
我们是有做了一些特定的限制

1178
00:40:46,300 --> 00:40:47,466
就是全场活动啊

1179
00:40:47,466 --> 00:40:49,699
并不是用一对多的关系去做的

1180
00:40:49,766 --> 00:40:51,399
但如果不是全场活动

1181
00:40:51,400 --> 00:40:53,866
就是简单的选进来的活动的话

1182
00:40:54,066 --> 00:40:55,999
因为我们的所有的活动

1183
00:40:56,000 --> 00:40:57,166
都有一个限定啊

1184
00:40:57,166 --> 00:40:57,366
这一

1185
00:40:57,366 --> 00:41:00,533
个前提就是我们不会做跨商铺的活动

1186
00:41:01,200 --> 00:41:02,466
所有的活动

1187
00:41:02,466 --> 00:41:05,799
全是限定在一个商铺里头去完成的

1188
00:41:05,933 --> 00:41:07,166
没有跨商铺的活动

1189
00:41:07,166 --> 00:41:08,499
就没有平台级的活动

1190
00:41:08,900 --> 00:41:10,466
只有商铺自己的活动

1191
00:41:10,600 --> 00:41:13,300
那因为每一个商铺的商品

1192
00:41:13,300 --> 00:41:14,800
是数量比较少的

1193
00:41:15,100 --> 00:41:18,700
所以说活动里头的商品的销售

1194
00:41:18,866 --> 00:41:20,299
也会是比较有限的

1195
00:41:20,300 --> 00:41:21,166
所以这里啊

1196
00:41:21,166 --> 00:41:23,666
这个这是基于这样的一系列的前提

1197
00:41:24,133 --> 00:41:26,899
这里建了一个多对多的关系啊

1198
00:41:26,900 --> 00:41:28,133
这是在对象朋友中间

1199
00:41:28,133 --> 00:41:28,999
大家应该知道

1200
00:41:29,400 --> 00:41:30,200
之所以这么做

1201
00:41:30,200 --> 00:41:32,600
是有很多的限制限制了

1202
00:41:32,600 --> 00:41:33,966
说一个活动中间的

1203
00:41:34,133 --> 00:41:35,799
一个销售中间的活动是有限的

1204
00:41:35,800 --> 00:41:40,400
一个活动中间的销售东西是有限的

1205
00:41:40,700 --> 00:41:42,133
有了这么多前提限制啊

1206
00:41:42,133 --> 00:41:43,999
你才能这么做这一个决定

1207
00:41:44,300 --> 00:41:46,133
当然如果对于一个大商铺来说

1208
00:41:46,133 --> 00:41:46,699
大家会知道

1209
00:41:46,700 --> 00:41:47,733
这样的一个设计

1210
00:41:48,500 --> 00:41:50,366
是会存在的一定的风险

1211
00:41:50,366 --> 00:41:52,599
特别是在活动和销售的这个多的

1212
00:41:52,600 --> 00:41:53,500
这个部分中

1213
00:41:53,500 --> 00:41:54,533
存在一定的风险

1214
00:41:54,900 --> 00:41:57,133
所以如果有风险的话

1215
00:41:57,133 --> 00:41:58,799
那再说我们怎么去改

1216
00:41:58,800 --> 00:42:00,100
我们现在这样的一个设计

1217
00:42:00,100 --> 00:42:01,300
就是这个样子

1218
00:42:02,266 --> 00:42:04,299
那这是白色的四个东西啊

1219
00:42:04,300 --> 00:42:05,266
这四个东西呢

1220
00:42:05,266 --> 00:42:08,399
基本上是跟领域模型是一致的

1221
00:42:08,733 --> 00:42:10,666
唯一的差别就是大家会发现

1222
00:42:10,666 --> 00:42:13,466
我们把预售的这个概念

1223
00:42:13,500 --> 00:42:16,000
在对向模型中间看不到

1224
00:42:16,900 --> 00:42:18,766
为啥预售看不到了

1225
00:42:19,333 --> 00:42:22,266
是因为我们在对这个领域模型

1226
00:42:22,266 --> 00:42:23,766
虽然是分开了两个概念

1227
00:42:24,133 --> 00:42:25,299
但是这两个概念

1228
00:42:25,300 --> 00:42:26,533
我们在做对象模型的时候

1229
00:42:26,533 --> 00:42:28,166
我们觉得它可以合二为一

1230
00:42:28,666 --> 00:42:29,733
怎么合二为一法呢

1231
00:42:29,733 --> 00:42:33,966
就是我们重新修改了一个销售的内涵

1232
00:42:34,366 --> 00:42:37,699
我们说销售的内涵和外延啊

1233
00:42:37,866 --> 00:42:39,999
任何一个概念的内涵和外延

1234
00:42:40,100 --> 00:42:40,766
我们认为

1235
00:42:40,766 --> 00:42:42,466
销售是一个什么呢

1236
00:42:42,733 --> 00:42:44,999
销售是一个预售

1237
00:42:45,866 --> 00:42:48,066
这个预售的定金是0

1238
00:42:48,200 --> 00:42:52,266
他的尾款支付时间等于开始时间

1239
00:42:52,733 --> 00:42:54,266
所以你可以认为

1240
00:42:54,266 --> 00:42:56,499
销售是一个特别的预售

1241
00:42:56,700 --> 00:42:59,000
而基本上所有的东西都是可以预售

1242
00:42:59,266 --> 00:43:00,566
之所以他这个正常的销售

1243
00:43:00,566 --> 00:43:01,866
是因为他不用付定金

1244
00:43:02,000 --> 00:43:03,133
而且他付尾款的时间

1245
00:43:03,133 --> 00:43:05,466
就是他的开始时间

1246
00:43:05,800 --> 00:43:06,566
两个相同

1247
00:43:06,566 --> 00:43:08,366
那就预售变成了普通销售

1248
00:43:08,500 --> 00:43:09,600
如果两个不相同

1249
00:43:09,600 --> 00:43:10,700
定金不为零

1250
00:43:11,000 --> 00:43:12,466
那就是预售

1251
00:43:12,666 --> 00:43:15,599
对吧所以你如果这么来认识的话

1252
00:43:15,600 --> 00:43:16,266
你就会发现

1253
00:43:16,266 --> 00:43:19,166
这两个概念如果把内涵改一下

1254
00:43:19,566 --> 00:43:20,766
就变成同一个概念

1255
00:43:20,866 --> 00:43:22,933
我没有去改领域模型是故意的啊

1256
00:43:22,933 --> 00:43:23,866
就是给大家看一下

1257
00:43:23,866 --> 00:43:24,966
因为我们在读对象模型时候

1258
00:43:24,966 --> 00:43:26,599
觉得没必要把它分成两个概念

1259
00:43:27,133 --> 00:43:27,966
所以大家可以看到

1260
00:43:27,966 --> 00:43:28,933
我们在这里头

1261
00:43:29,200 --> 00:43:30,700
直接把它写在了一个里头

1262
00:43:30,700 --> 00:43:33,133
然后里头用了一个属性type去表示

1263
00:43:33,133 --> 00:43:36,366
说它是预售还是团购还是什么

1264
00:43:36,366 --> 00:43:36,733
但其实

1265
00:43:36,733 --> 00:43:38,933
这个其实也不需要你能够判断出来

1266
00:43:38,933 --> 00:43:41,599
但是我们还是把它显性的

1267
00:43:41,600 --> 00:43:42,700
把它写了出来

1268
00:43:42,900 --> 00:43:44,000
这是第一个变化

1269
00:43:44,333 --> 00:43:47,399
第二个变化是我们的活动是有两个

1270
00:43:47,400 --> 00:43:49,300
团购和预售两个活动

1271
00:43:49,500 --> 00:43:50,866
但是我们在这里我们可以看到

1272
00:43:50,866 --> 00:43:54,399
我们这里增加了一个附类叫做活动

1273
00:43:54,600 --> 00:43:57,533
然后把团购和预售呢变成它的子类

1274
00:43:58,166 --> 00:44:00,499
你会想说为什么要增加一个负类

1275
00:44:00,800 --> 00:44:03,400
对于团购和预售有什么共同的点

1276
00:44:04,800 --> 00:44:06,266
有就是它的名称

1277
00:44:06,266 --> 00:44:07,699
大家都有一个名字

1278
00:44:07,933 --> 00:44:09,799
除了名字以外就没有共同点

1279
00:44:10,133 --> 00:44:12,566
那两个活动就除了名称

1280
00:44:12,566 --> 00:44:14,366
有一个名称是个共同点以外

1281
00:44:15,000 --> 00:44:16,300
没有任何共同点的东西

1282
00:44:16,300 --> 00:44:18,800
有没有必要把它变成一个负累呢

1283
00:44:19,100 --> 00:44:21,466
其实从理论上来说是没有必要的

1284
00:44:21,666 --> 00:44:22,999
但是我们就是把它变了

1285
00:44:23,466 --> 00:44:24,699
变了的原因在于说

1286
00:44:24,700 --> 00:44:25,266
大家可以看到

1287
00:44:25,266 --> 00:44:28,666
我们这些对象模型用了不同的颜色

1288
00:44:28,933 --> 00:44:30,933
这个颜色是有含义的

1289
00:44:31,066 --> 00:44:33,533
因为我们这里所看到的是对象模型

1290
00:44:34,333 --> 00:44:37,533
每一个对象其实是有大量的实力的

1291
00:44:38,200 --> 00:44:40,900
无论是category product on sale和活动

1292
00:44:40,900 --> 00:44:42,500
都是有大量的实力的

1293
00:44:42,600 --> 00:44:43,133
大家知道

1294
00:44:43,133 --> 00:44:44,399
有大量实力

1295
00:44:44,400 --> 00:44:45,100
这些对象

1296
00:44:45,100 --> 00:44:47,733
是肯定不可能一直待在内存里的

1297
00:44:48,066 --> 00:44:50,866
它是一定要存到一个存储机制里去的

1298
00:44:51,066 --> 00:44:51,866
它存到哪

1299
00:44:52,466 --> 00:44:54,199
我们在这里看到的这种颜色

1300
00:44:54,200 --> 00:44:55,700
其实就是表述说

1301
00:44:55,700 --> 00:44:57,766
这个对象存在什么地方

1302
00:44:57,900 --> 00:44:59,500
我们白色的这些对象

1303
00:44:59,500 --> 00:45:01,366
是存在关系数据库里的

1304
00:45:01,366 --> 00:45:02,966
那买水果的数据库里的

1305
00:45:03,300 --> 00:45:05,900
蓝色的这些对象是来自于其他模块

1306
00:45:05,933 --> 00:45:07,799
我们这个里头没有它的存储

1307
00:45:08,200 --> 00:45:11,966
我们要获得一个呃这个运费模板

1308
00:45:12,166 --> 00:45:15,199
要获得一个这个快递的方式

1309
00:45:15,200 --> 00:45:15,933
物流的方式

1310
00:45:15,933 --> 00:45:17,999
都要调其他模块去得到

1311
00:45:18,133 --> 00:45:19,333
至于其他模块存哪

1312
00:45:19,333 --> 00:45:20,333
我们不知道啊

1313
00:45:20,333 --> 00:45:22,666
反正我们是调他的API达到这个对象

1314
00:45:22,766 --> 00:45:24,933
所以蓝色部分是存在其他模块的

1315
00:45:24,933 --> 00:45:26,533
我们调其他模块去获得

1316
00:45:26,866 --> 00:45:28,166
黄色部分存在哪呢

1317
00:45:28,500 --> 00:45:30,400
黄色部分是存在Mango里头的

1318
00:45:30,533 --> 00:45:33,466
就是我们其实是有两种存储的机制

1319
00:45:33,666 --> 00:45:34,366
一种啊

1320
00:45:34,366 --> 00:45:36,199
因为这样是有三种存储机制啊

1321
00:45:36,200 --> 00:45:38,700
我们现在只看到了存的这个

1322
00:45:38,966 --> 00:45:41,866
MYCO的关节数据库和非关节数据库的

1323
00:45:41,866 --> 00:45:44,999
Mango为什么会使用芒果数据库来存

1324
00:45:45,366 --> 00:45:46,699
这一堆黄色的

1325
00:45:47,100 --> 00:45:48,000
原因很简单

1326
00:45:48,000 --> 00:45:48,533
大家有没有觉得

1327
00:45:48,533 --> 00:45:50,366
这堆黄色的看起来特别复杂

1328
00:45:51,000 --> 00:45:54,400
它有特别复杂的类面向对象的结构

1329
00:45:54,700 --> 00:45:56,466
所以当我们如果试图把这么

1330
00:45:56,466 --> 00:45:58,399
复杂的继承关系和关联关系

1331
00:45:58,400 --> 00:46:00,566
存到关系数据库里去的时候

1332
00:46:00,566 --> 00:46:01,733
我们非常的辛苦

1333
00:46:02,133 --> 00:46:04,133
所以我们大概从前年开始

1334
00:46:04,333 --> 00:46:07,099
我们引入了一种非关系的数据库

1335
00:46:07,100 --> 00:46:09,100
专门用来存储我们这样的

1336
00:46:09,100 --> 00:46:11,566
具有很明显的面向对象特征的

1337
00:46:11,700 --> 00:46:12,300
这些对象

1338
00:46:12,300 --> 00:46:13,166
给他丢进去

1339
00:46:13,200 --> 00:46:15,600
好处在于说对象进对象出

1340
00:46:15,600 --> 00:46:17,266
完全不需要做映射

1341
00:46:17,500 --> 00:46:20,133
他的对象存到那个数据库里去

1342
00:46:20,466 --> 00:46:21,066
他的关系

1343
00:46:21,066 --> 00:46:21,666
他的关联

1344
00:46:21,666 --> 00:46:23,299
他的这层关系全部都会进去

1345
00:46:23,300 --> 00:46:24,266
然后把它拿出来

1346
00:46:24,266 --> 00:46:25,599
他就照样复回来

1347
00:46:25,600 --> 00:46:27,766
我们的代码变得非常的简洁啊

1348
00:46:28,400 --> 00:46:29,333
早先的时候

1349
00:46:29,333 --> 00:46:31,366
我们其实费了牛鼻子的劲

1350
00:46:31,366 --> 00:46:33,599
把这个关系存到关系数据库里去

1351
00:46:33,800 --> 00:46:36,133
很复杂把关系数据库做的很复杂

1352
00:46:36,400 --> 00:46:39,266
所以大概从2021年开始

1353
00:46:39,266 --> 00:46:42,199
我们果断的把这一部分的数据

1354
00:46:42,500 --> 00:46:44,500
改成了no secret数据库

1355
00:46:44,500 --> 00:46:45,966
所以我们最后的对象

1356
00:46:45,966 --> 00:46:48,466
其实会来自于三个地方

1357
00:46:48,466 --> 00:46:52,266
关系数据库其他模块和非关系数据库

1358
00:46:52,266 --> 00:46:54,266
哈那我们用不同的颜色标出来

1359
00:46:54,366 --> 00:46:56,366
那正是因为我们的这个对象

1360
00:46:56,366 --> 00:46:58,699
被切成了两种存储机制

1361
00:46:59,100 --> 00:47:01,866
所以我们的来源是从主

1362
00:47:02,066 --> 00:47:04,366
主力的数据库是关节数据库

1363
00:47:04,533 --> 00:47:06,299
所以我们需要弄一个activity

1364
00:47:06,733 --> 00:47:07,466
知道说

1365
00:47:07,466 --> 00:47:10,733
这个数据是存在了其他的地方

1366
00:47:11,066 --> 00:47:12,533
然后其他地方的那个地方

1367
00:47:12,533 --> 00:47:13,933
它的组件叫什么

1368
00:47:14,100 --> 00:47:15,800
被存在了这个activity里头

1369
00:47:16,366 --> 00:47:18,699
所以我们从这条线拿到这个activity

1370
00:47:18,700 --> 00:47:21,766
然后从activity中间再去到其他的中间

1371
00:47:21,933 --> 00:47:23,333
去拿其他的东西

1372
00:47:23,566 --> 00:47:24,299
把它拿出来

1373
00:47:24,300 --> 00:47:25,100
变成这个样子

1374
00:47:25,166 --> 00:47:26,499
所以这个对象模型

1375
00:47:26,500 --> 00:47:27,933
为什么会加了一个activity

1376
00:47:28,166 --> 00:47:30,133
就是因为我们存储的原因

1377
00:47:30,733 --> 00:47:32,099
所以啊通过这个例子

1378
00:47:32,100 --> 00:47:33,400
这是我们目前看到一个

1379
00:47:33,400 --> 00:47:35,400
比较复杂的对象模型的例子

1380
00:47:35,500 --> 00:47:36,333
大家应该知道

1381
00:47:36,333 --> 00:47:37,466
对象模型的设计

1382
00:47:37,466 --> 00:47:39,066
不是简单的

1383
00:47:39,666 --> 00:47:41,466
把领域模型超过来就完了

1384
00:47:41,466 --> 00:47:42,933
它来源于领域模型

1385
00:47:42,933 --> 00:47:45,333
但更多的驱动是我们的API

1386
00:47:45,666 --> 00:47:47,333
我们要看我们的每个API

1387
00:47:47,333 --> 00:47:48,899
对于我们的这个对象模型

1388
00:47:48,900 --> 00:47:50,166
有些什么样的要求

1389
00:47:50,333 --> 00:47:51,666
然后要去考虑说

1390
00:47:51,666 --> 00:47:54,466
这些API能不能在对象模型上实现

1391
00:47:54,800 --> 00:47:57,066
如果这些API不能在对象模型上实现

1392
00:47:57,066 --> 00:47:59,499
我们就会改用面向功能的方式去做

1393
00:47:59,666 --> 00:48:00,566
如果能实现

1394
00:48:00,566 --> 00:48:02,599
我们就需要把要实现这些API

1395
00:48:02,600 --> 00:48:03,733
所需要的关联

1396
00:48:03,933 --> 00:48:04,766
给它建出来

1397
00:48:05,100 --> 00:48:06,200
除了这个部分以外

1398
00:48:06,200 --> 00:48:07,266
我们还是要考虑出

1399
00:48:07,266 --> 00:48:07,966
这些对象模型

1400
00:48:07,966 --> 00:48:10,299
是要存在什么样的介质里头

1401
00:48:10,733 --> 00:48:11,999
它存在什么样的戒指里头

1402
00:48:12,000 --> 00:48:14,266
就需要用什么样的方式

1403
00:48:14,366 --> 00:48:17,333
去把不同戒指的捞出来的对象

1404
00:48:17,366 --> 00:48:18,199
拼接起来

1405
00:48:18,300 --> 00:48:20,300
所以我们会引入中间那个activity的

1406
00:48:20,300 --> 00:48:21,100
这个对象

1407
00:48:21,666 --> 00:48:22,566
听起来很复杂啊

1408
00:48:22,566 --> 00:48:23,599
但是大家应该知道

1409
00:48:23,600 --> 00:48:24,900
罗马不是一天建成的

1410
00:48:24,900 --> 00:48:26,400
我们今天能看到这么复杂的

1411
00:48:26,400 --> 00:48:27,400
这样一个模型

1412
00:48:27,500 --> 00:48:28,866
包括后面还能看到更复杂

1413
00:48:28,866 --> 00:48:31,999
这项模型其实是我们的若干界的同学

1414
00:48:32,000 --> 00:48:34,366
一年一年在上面不断的修改啊

1415
00:48:34,366 --> 00:48:35,333
变成了这个样子

1416
00:48:35,666 --> 00:48:37,099
我们如果OMO这个东西

1417
00:48:37,100 --> 00:48:37,933
一直讲下去的话

1418
00:48:37,933 --> 00:48:39,899
大家应该会知道它会变得越来越复杂

1419
00:48:40,166 --> 00:48:41,199
变得越来越丰富啊

1420
00:48:41,200 --> 00:48:42,333
所以我们每届同学

1421
00:48:42,333 --> 00:48:44,499
理解前面的同学做的这些东西

1422
00:48:44,666 --> 00:48:47,133
然后在上面去加上我们自己的东西啊

1423
00:48:47,133 --> 00:48:48,166
是这样一个过程

1424
00:54:57,700 --> 00:54:58,500
好

1425
00:54:59,133 --> 00:55:00,666
然后后面这些黄色喷雾

1426
00:55:00,666 --> 00:55:01,899
为什么会这么复杂

1427
00:55:01,900 --> 00:55:03,066
因为我们的特别

1428
00:55:03,066 --> 00:55:04,466
在优惠活动这一块来说

1429
00:55:04,466 --> 00:55:05,699
是非常复杂

1430
00:55:05,800 --> 00:55:08,366
我们的这个结构是试图做到

1431
00:55:08,466 --> 00:55:11,399
目前大家已知的所有的优惠活动

1432
00:55:11,866 --> 00:55:12,933
都能够做出来

1433
00:55:13,166 --> 00:55:14,599
什么满减啊

1434
00:55:14,666 --> 00:55:17,366
满折啊第三件多少钱啊

1435
00:55:17,366 --> 00:55:18,899
第二件多少钱啊

1436
00:55:19,733 --> 00:55:22,399
啊比如说跨类多少多少啊

1437
00:55:22,766 --> 00:55:23,599
跨铺没有啊

1438
00:55:23,600 --> 00:55:25,200
因为我没有跨铺的活动

1439
00:55:25,200 --> 00:55:27,366
但是跨类多少啊

1440
00:55:27,366 --> 00:55:29,333
等等等等都可以做出来啊

1441
00:55:29,533 --> 00:55:30,666
所以做的很复杂

1442
00:55:30,666 --> 00:55:34,099
那我具体这个底头怎么做出来的

1443
00:55:34,100 --> 00:55:35,766
我们到可能到最后了

1444
00:55:35,766 --> 00:55:37,533
还要把整个面这样的设计讲完

1445
00:55:37,566 --> 00:55:39,999
才会知道说这个到底是怎么做的

1446
00:55:40,000 --> 00:55:41,800
因为用了设计模式啊

1447
00:55:41,800 --> 00:55:43,666
用了调节器的设计模式

1448
00:55:47,066 --> 00:55:50,933
状态图我们这里所描述的这些对象

1449
00:55:51,133 --> 00:55:53,299
其实是有状态

1450
00:55:53,566 --> 00:55:54,333
这个状态图

1451
00:55:54,333 --> 00:55:56,399
我们在之前的建模中间已经讲到

1452
00:55:56,533 --> 00:55:58,299
这里所讲的这个状态

1453
00:55:58,300 --> 00:56:01,300
主要是指这个产品的状态

1454
00:56:01,466 --> 00:56:03,666
还有这个活动的状态

1455
00:56:04,166 --> 00:56:05,533
主要是这两个对象啊

1456
00:56:05,533 --> 00:56:06,499
是有状态

1457
00:56:06,733 --> 00:56:09,333
所以他的状态是怎样迁移的

1458
00:56:09,666 --> 00:56:11,799
是需要用状态图来描述出来

1459
00:56:12,200 --> 00:56:15,300
之前我们在讲这个状态图的时候

1460
00:56:15,300 --> 00:56:16,333
我们知道啊

1461
00:56:16,966 --> 00:56:20,166
状态的迁移是靠事件去描述的

1462
00:56:20,200 --> 00:56:22,966
事件我们在这里头写的是什么呢

1463
00:56:22,966 --> 00:56:24,166
写的是中文

1464
00:56:24,566 --> 00:56:25,399
审核

1465
00:56:26,266 --> 00:56:28,133
那如果说到这个阶段

1466
00:56:28,133 --> 00:56:31,566
就是所有的API都有做出来的阶段

1467
00:56:32,666 --> 00:56:33,566
这个事件

1468
00:56:33,800 --> 00:56:35,300
审核这个事件

1469
00:56:35,666 --> 00:56:37,499
就需要明确到说

1470
00:56:37,500 --> 00:56:42,300
它是我们在API上面的哪一个API呢

1471
00:56:42,666 --> 00:56:45,466
所以对于审核这个事件来说啊

1472
00:56:45,466 --> 00:56:47,366
它的API其实就是这个API

1473
00:56:49,200 --> 00:56:51,566
就是这个a撇

1474
00:56:57,200 --> 00:57:00,133
就是货品的发布啊

1475
00:57:00,266 --> 00:57:04,466
所以我们在状态截图上头

1476
00:57:06,166 --> 00:57:08,499
单画一张图是不够的

1477
00:57:08,900 --> 00:57:11,000
在写作业的时候啊

1478
00:57:11,333 --> 00:57:13,666
这个状态图要补上去啊

1479
00:57:13,666 --> 00:57:14,566
状态图

1480
00:57:15,000 --> 00:57:17,566
也需要在第二轮的作业中间去写

1481
00:57:17,900 --> 00:57:19,400
状态图画完了以后

1482
00:57:19,400 --> 00:57:22,366
在后面要加上文字去描述

1483
00:57:22,366 --> 00:57:24,999
说这个事件到底是API

1484
00:57:25,000 --> 00:57:27,000
上面的哪一个API

1485
00:57:27,466 --> 00:57:29,699
会造成它的状态迁移

1486
00:57:30,166 --> 00:57:30,499
所以说

1487
00:57:30,500 --> 00:57:32,666
如果说这个事件是由API造成的

1488
00:57:32,666 --> 00:57:33,733
那就需要写API

1489
00:57:34,133 --> 00:57:37,499
像这些事件上是因为是时间造成

1490
00:57:37,500 --> 00:57:38,900
不是API造成的

1491
00:57:39,133 --> 00:57:41,499
那就不需要去写API

1492
00:57:43,866 --> 00:57:45,299
对禁售解聘也是API

1493
00:57:45,566 --> 00:57:46,899
所以说你到这个API上

1494
00:57:46,900 --> 00:57:50,000
也能找到说禁售和解聘的API

1495
00:57:51,500 --> 00:57:54,066
那下面这个对

1496
00:57:54,100 --> 00:57:56,766
就是因为API的调用

1497
00:57:57,133 --> 00:58:00,266
造成了我们的状态的迁移

1498
00:58:00,600 --> 00:58:02,733
所以在状态上头写的那个事件

1499
00:58:02,966 --> 00:58:05,599
对应到API上是哪个API

1500
00:58:05,733 --> 00:58:07,099
需要把它明确下来

1501
00:58:07,133 --> 00:58:09,866
就是在这个这一阶段啊

1502
00:58:10,166 --> 00:58:11,999
需要补充这个工作

1503
00:58:12,700 --> 00:58:13,100
状态基图

1504
00:58:13,100 --> 00:58:13,900
我待会写一下

1505
00:58:13,900 --> 00:58:16,600
就是我们在第二个阶段要做的

1506
00:58:16,700 --> 00:58:18,866
这个讨论课和作业里头的任务

1507
00:58:19,100 --> 00:58:20,766
是我们的对象模型

1508
00:58:21,133 --> 00:58:22,733
API的改动啊

1509
00:58:22,733 --> 00:58:23,766
不是API的设计

1510
00:58:23,766 --> 00:58:25,066
API的改动

1511
00:58:25,500 --> 00:58:27,266
然后状态基图

1512
00:58:27,333 --> 00:58:30,766
还有最后一个数据库的设计

1513
00:58:31,566 --> 00:58:33,666
数据库的设计其实我们全部的都有

1514
00:58:33,666 --> 00:58:35,566
给大家一个去年的版本

1515
00:58:36,100 --> 00:58:37,666
呃大家所要做的事情

1516
00:58:37,666 --> 00:58:40,499
只要是因为你前面的领域模型

1517
00:58:40,500 --> 00:58:41,933
对象模型动了

1518
00:58:42,266 --> 00:58:43,599
数据库设计就要动

1519
00:58:43,600 --> 00:58:44,866
我们这里讲的数据库设计

1520
00:58:44,866 --> 00:58:46,333
是指关节数据库设计

1521
00:58:46,333 --> 00:58:48,499
因为对象的存储是不用管

1522
00:58:49,000 --> 00:58:50,300
对象模型长啥样

1523
00:58:50,300 --> 00:58:51,800
照原样丢进去就好了

1524
00:58:51,933 --> 00:58:54,066
但是关系数据库

1525
00:58:54,700 --> 00:58:55,333
我们知道

1526
00:58:55,333 --> 00:58:58,299
它是跟对象模型不是一一一色

1527
00:58:58,500 --> 00:58:59,533
那我们看一下

1528
00:58:59,533 --> 00:59:00,766
我们在这里所看到的

1529
00:59:00,766 --> 00:59:02,733
这个关系数据库

1530
00:59:02,733 --> 00:59:04,866
就是产品的部分的关系数据库

1531
00:59:04,966 --> 00:59:08,066
它里头一共有123456啊

1532
00:59:08,066 --> 00:59:09,933
一共有6张表

1533
00:59:10,533 --> 00:59:12,266
那我们这里描述的

1534
00:59:12,700 --> 00:59:13,966
其实描述的是什么呢

1535
00:59:13,966 --> 00:59:15,566
描述的是我们的PO对象

1536
00:59:16,166 --> 00:59:18,333
就是因为我们这里在用类图来画

1537
00:59:18,333 --> 00:59:20,266
其实描述的是PO对象

1538
00:59:20,600 --> 00:59:21,600
因为我们知道

1539
00:59:21,600 --> 00:59:24,300
在那个存储的那个层次结构上头

1540
00:59:24,300 --> 00:59:26,766
PO对象每一个PO对象

1541
00:59:27,333 --> 00:59:29,066
就是对应的是一个什么呢

1542
00:59:29,200 --> 00:59:30,533
对应的是一张表

1543
00:59:30,600 --> 00:59:32,500
每一个Po对象的属性

1544
00:59:32,766 --> 00:59:35,166
对应的就是那张表的字段啊

1545
00:59:35,166 --> 00:59:37,966
所以我们这里其实描述的是Po对象

1546
00:59:38,533 --> 00:59:39,333
呃

1547
00:59:40,933 --> 00:59:42,066
在这个里头啊

1548
00:59:42,066 --> 00:59:43,066
大家会发现

1549
00:59:43,066 --> 00:59:46,266
基本上跟我们的就是前面的这一部分

1550
00:59:46,600 --> 00:59:50,400
这一部分跟他是基本上是一样的

1551
00:59:50,700 --> 00:59:52,266
然后呢我们的对象模型中间

1552
00:59:52,266 --> 00:59:53,666
其实少画了一类对象

1553
00:59:53,666 --> 00:59:55,099
其实还有这个草稿对象

1554
00:59:55,800 --> 00:59:57,766
就是为什么会把商品

1555
00:59:57,766 --> 01:00:00,199
把它变出一类草稿对象出来

1556
01:00:00,666 --> 01:00:04,566
这个原因是因为商品在新增的时候

1557
01:00:04,866 --> 01:00:07,499
我们并没有把新增的商品

1558
01:00:07,566 --> 01:00:09,466
放到了这张表里

1559
01:00:09,500 --> 01:00:11,866
而把它放在了这张表里

1560
01:00:13,766 --> 01:00:15,999
然后通过了审核以后

1561
01:00:16,000 --> 01:00:19,600
才把它从这张表变到了这张表

1562
01:00:20,600 --> 01:00:21,600
这个倒清真

1563
01:00:21,600 --> 01:00:25,266
倒是不是特别需要说他需要这样变

1564
01:00:25,466 --> 01:00:27,766
这么做的主要原因是因为修改

1565
01:00:28,566 --> 01:00:29,466
因为我们知道

1566
01:00:29,466 --> 01:00:31,666
从API上头我们可以看到

1567
01:00:31,666 --> 01:00:32,599
从需求上头啊

1568
01:00:32,600 --> 01:00:33,766
另一东西已经写了

1569
01:00:33,766 --> 01:00:36,299
我们在修改商品属性的时候

1570
01:00:36,300 --> 01:00:37,966
是有一部分属性

1571
01:00:38,400 --> 01:00:41,366
是需要经过审核的啊

1572
01:00:41,366 --> 01:00:43,466
这部分经过审核的属性

1573
01:00:43,466 --> 01:00:44,733
其实就跟新增的

1574
01:00:44,733 --> 01:00:47,466
时候所要填的那部分属性是一致的

1575
01:00:47,533 --> 01:00:49,366
就是我们这产品中间的所有的属性

1576
01:00:49,366 --> 01:00:50,933
并不是所有属性都需要审核

1577
01:00:51,500 --> 01:00:53,100
但是有一小部分属性

1578
01:00:53,100 --> 01:00:54,300
比如说它的名字

1579
01:00:54,300 --> 01:00:56,533
它的源地产地

1580
01:00:56,533 --> 01:00:58,533
它的分类等等

1581
01:00:58,533 --> 01:01:00,199
这些东西是需要审核的

1582
01:01:00,200 --> 01:01:02,566
那这些东西就会放到了这张表里

1583
01:01:02,933 --> 01:01:05,499
所以如果我们修改这个商品的时候

1584
01:01:05,500 --> 01:01:08,200
原来的商品是没有动的

1585
01:01:08,600 --> 01:01:11,566
而是在这边去增加了一个新的记录

1586
01:01:12,266 --> 01:01:13,066
填在了这里

1587
01:01:13,066 --> 01:01:15,199
等待管理员去审核

1588
01:01:15,700 --> 01:01:17,400
如果管理员没有审核过

1589
01:01:17,566 --> 01:01:19,299
那就根本就不会动

1590
01:01:19,700 --> 01:01:21,366
如果管理员审核过了

1591
01:01:21,366 --> 01:01:23,599
才会用它去修改它

1592
01:01:24,366 --> 01:01:26,499
所以这是这张数据表的设计啊

1593
01:01:26,533 --> 01:01:26,733
所以

1594
01:01:26,733 --> 01:01:28,699
我们对象模型中间其实也应该改一下

1595
01:01:28,733 --> 01:01:30,866
我待会课后我再把它改一下

1596
01:01:30,966 --> 01:01:31,599
大家会发现

1597
01:01:31,600 --> 01:01:33,566
我其实每堂课我把笔记本夹在

1598
01:01:33,566 --> 01:01:34,266
那就干嘛呢

1599
01:01:34,266 --> 01:01:36,533
每讲一次就去改一下

1600
01:01:36,533 --> 01:01:38,099
每讲一次就去改一下

1601
01:01:38,100 --> 01:01:38,966
所以讲到下午的话

1602
01:01:38,966 --> 01:01:40,733
这个对象模型会变得更复杂啊

1603
01:01:41,000 --> 01:01:42,566
这其实已经讲过很多遍了

1604
01:01:42,566 --> 01:01:45,799
但是你会发现每讲一次都需要去改

1605
01:01:46,200 --> 01:01:47,400
设计就是这个样子

1606
01:01:47,566 --> 01:01:48,933
它不是一个固定的

1607
01:01:48,933 --> 01:01:50,733
一横一成不变的东西

1608
01:01:50,966 --> 01:01:52,899
其实你们在讨论的过程中间

1609
01:01:52,900 --> 01:01:53,766
在讲的过程中间

1610
01:01:53,766 --> 01:01:57,566
每讲一次都会对它有更深入的认识

1611
01:01:58,066 --> 01:01:59,566
所以设计一定要什么呢

1612
01:01:59,566 --> 01:02:00,599
一定要讲出来

1613
01:02:00,600 --> 01:02:02,000
一定要讨论出来

1614
01:02:02,333 --> 01:02:03,533
不讲不讨论

1615
01:02:03,533 --> 01:02:06,399
闷着头去做是不会发现任何问题的

1616
01:02:06,566 --> 01:02:07,399
你多讲一遍

1617
01:02:07,400 --> 01:02:08,900
你就会发现他的问题多一点

1618
01:02:08,900 --> 01:02:11,066
再讲一遍发现他还会有问题

1619
01:02:11,366 --> 01:02:12,566
多讲多讨论

1620
01:02:12,566 --> 01:02:14,133
才能在写代码之前

1621
01:02:14,133 --> 01:02:16,666
把很多问题给他滴露出来

1622
01:02:16,900 --> 01:02:18,866
如果说等到你去写代码时候

1623
01:02:18,866 --> 01:02:19,799
才判断这些问题

1624
01:02:19,800 --> 01:02:21,533
你要知道写代

1625
01:02:21,533 --> 01:02:23,599
码的那个工作量就浪费了

1626
01:02:24,066 --> 01:02:24,533
为什么

1627
01:02:24,533 --> 01:02:27,766
有些的这个程序员的小组的工作效率

1628
01:02:27,766 --> 01:02:29,699
会比另外一些人要高出很多

1629
01:02:29,766 --> 01:02:31,866
他以更少的时间能把它做出来

1630
01:02:32,000 --> 01:02:34,333
原因是因为他可能在做之前

1631
01:02:34,333 --> 01:02:37,399
已经经过了充分的讨论和考虑了

1632
01:02:37,400 --> 01:02:38,800
然后再去动手去做

1633
01:02:39,333 --> 01:02:41,533
讨论和考虑的时间

1634
01:02:41,533 --> 01:02:42,399
其实会占到

1635
01:02:42,400 --> 01:02:45,566
整个动手去做的一半的时间

1636
01:02:45,566 --> 01:02:46,799
所以且程序有点像什么

1637
01:02:46,800 --> 01:02:48,266
有点像高手过招

1638
01:02:48,600 --> 01:02:49,200
大家知道

1639
01:02:49,200 --> 01:02:50,700
如果说武林高手过招

1640
01:02:50,700 --> 01:02:52,566
其实双方战略

1641
01:02:52,566 --> 01:02:56,066
你先要先要比划很久是吧

1642
01:02:56,100 --> 01:02:59,266
先要去大量的在做口头的工作

1643
01:02:59,533 --> 01:03:01,333
然后动手的时候

1644
01:03:01,333 --> 01:03:04,299
可能就是一两招就是致命的

1645
01:03:04,300 --> 01:03:05,300
就是解决问题的

1646
01:03:05,300 --> 01:03:07,100
而不是说两个人要打上半个小时

1647
01:03:07,100 --> 01:03:08,066
才能决一个

1648
01:03:08,333 --> 01:03:09,466
决一个高低啊

1649
01:03:09,466 --> 01:03:11,333
其实写代码一样的道理

1650
01:03:11,866 --> 01:03:15,099
你在动手之前去充分的讨论和考虑

1651
01:03:15,600 --> 01:03:18,200
虽然你觉得这个时间可能会花的很长

1652
01:03:18,200 --> 01:03:21,333
但是他绝对是节省你写代码的时间

1653
01:03:21,666 --> 01:03:22,466
如果这件事情

1654
01:03:22,466 --> 01:03:24,733
在你前面的设计中间没有考虑清楚

1655
01:03:24,733 --> 01:03:26,533
动手做手才发现问题

1656
01:03:26,866 --> 01:03:28,599
那你意味着你在发现问题

1657
01:03:28,600 --> 01:03:30,333
中间做的那些代码就浪费了

1658
01:03:30,700 --> 01:03:32,300
而那些代码做的浪费代码

1659
01:03:32,300 --> 01:03:33,733
你就意味着要重新去改

1660
01:03:33,900 --> 01:03:35,733
重新去把它再割出来

1661
01:03:35,933 --> 01:03:37,066
再去把它抛弃掉

1662
01:03:37,066 --> 01:03:38,899
这都需要消耗时间啊

1663
01:03:39,900 --> 01:03:41,500
所以多讲多讨论

1664
01:03:41,600 --> 01:03:43,533
小组内部多讲多去讨论

1665
01:03:43,533 --> 01:03:45,299
其实也会帮助你们

1666
01:03:45,300 --> 01:03:47,566
把这个东西做得更好

1667
01:03:47,566 --> 01:03:48,199
这就是为什么

1668
01:03:48,200 --> 01:03:50,800
我们在作业的这个部分来说

1669
01:03:50,800 --> 01:03:51,933
我们一直在强调

1670
01:03:51,933 --> 01:03:53,766
不是简单的交一个作业

1671
01:03:54,066 --> 01:03:55,599
为什么要先有讨论课

1672
01:03:55,600 --> 01:03:57,066
要先有同学来教

1673
01:03:57,066 --> 01:03:58,699
然后会有必做的部分

1674
01:03:58,700 --> 01:04:00,866
就是因为要多次的讨论

1675
01:04:00,866 --> 01:04:01,933
多次的分析啊

1676
01:04:01,933 --> 01:04:03,099
才会有一个结果

1677
01:04:04,333 --> 01:04:06,799
这个就是我们的修改

1678
01:04:06,800 --> 01:04:08,066
实际上是先放到那边的

1679
01:04:08,066 --> 01:04:09,299
审核完了以后啊

1680
01:04:09,300 --> 01:04:09,866
才会过来

1681
01:04:09,866 --> 01:04:10,599
所以数据表上呢

1682
01:04:10,600 --> 01:04:11,733
是两张表

1683
01:04:12,333 --> 01:04:14,799
要审核的那些属性其实放在那个草稿

1684
01:04:14,800 --> 01:04:15,800
商品中间的

1685
01:04:16,100 --> 01:04:17,266
新增的就先放到那边

1686
01:04:17,266 --> 01:04:18,866
修改措施首先放到那边

1687
01:04:18,866 --> 01:04:20,599
然后核核准了以后

1688
01:04:20,766 --> 01:04:23,966
才会过来去修改这个产品这张表

1689
01:04:25,066 --> 01:04:27,099
呃然后大家注意一下

1690
01:04:27,100 --> 01:04:32,333
在这个呃表的这个部分来说

1691
01:04:32,900 --> 01:04:35,533
我们知道在对象关系上面

1692
01:04:35,533 --> 01:04:37,533
我们舍弃了category

1693
01:04:37,533 --> 01:04:40,533
和商品的一对多的关系

1694
01:04:40,900 --> 01:04:43,600
建立的是一个从商品指向

1695
01:04:44,566 --> 01:04:48,266
从商品指向分类的一个一对一的关系

1696
01:04:48,700 --> 01:04:49,733
啊但是我们知道

1697
01:04:49,733 --> 01:04:51,899
API是需要这个一对多关系的

1698
01:04:52,500 --> 01:04:53,366
数据表示呢

1699
01:04:53,366 --> 01:04:56,166
你发现他依然没有建立

1700
01:04:56,166 --> 01:04:57,299
这个一对多的关系

1701
01:04:57,500 --> 01:04:59,200
还是个一对一的关系

1702
01:05:00,300 --> 01:05:01,933
那一对多关系能做的出来吗

1703
01:05:03,000 --> 01:05:05,500
如果说对象模型当中你可以省略他

1704
01:05:05,500 --> 01:05:07,266
说我对象模型不管

1705
01:05:07,566 --> 01:05:09,466
交由面向功能的方式去做

1706
01:05:10,133 --> 01:05:12,899
数据表上头是不能省略的

1707
01:05:13,566 --> 01:05:15,099
数据表上头省略的话

1708
01:05:15,100 --> 01:05:16,500
那就肯定就做不出来了

1709
01:05:16,500 --> 01:05:18,366
对吧那数据表上头

1710
01:05:18,366 --> 01:05:20,133
为什么也没有一对多的关系呢

1711
01:05:21,333 --> 01:05:22,333
这个就是因为

1712
01:05:23,666 --> 01:05:24,899
在数据表上头

1713
01:05:25,600 --> 01:05:30,166
我们说关系一对多的反向是多对一

1714
01:05:30,266 --> 01:05:31,999
多对一其实就是一对一

1715
01:05:32,266 --> 01:05:32,933
在数据表上头

1716
01:05:32,933 --> 01:05:34,399
我们在Mybit值里面讲到

1717
01:05:34,400 --> 01:05:35,933
所有一对多的关系

1718
01:05:35,933 --> 01:05:39,699
我们都被采用多对一这边去记

1719
01:05:39,966 --> 01:05:45,133
所以这个分类和商品的一对多的关系

1720
01:05:45,266 --> 01:05:47,399
其实记在商品里头的

1721
01:05:48,266 --> 01:05:49,566
看这个人ID过来的

1722
01:05:49,800 --> 01:05:51,733
所以你如果说在功能上头

1723
01:05:51,733 --> 01:05:53,799
要去查到一个商品中

1724
01:05:53,800 --> 01:05:55,766
一个分类下面的所有的商品

1725
01:05:55,766 --> 01:05:56,666
怎么去做呢

1726
01:05:57,700 --> 01:05:59,566
对查商品表用category

1727
01:05:59,566 --> 01:06:03,566
ID作为查询值去查商品表就能查出来

1728
01:06:03,666 --> 01:06:04,366
所以这个部分

1729
01:06:04,366 --> 01:06:07,066
是完全不需要用面向对象的方式

1730
01:06:07,066 --> 01:06:07,766
去做的

1731
01:06:07,766 --> 01:06:10,666
就是用面向功能的方式进来去写代码

1732
01:06:10,666 --> 01:06:11,866
然后去查数据库

1733
01:06:11,933 --> 01:06:13,933
查出来就会比较好了啊

1734
01:06:13,933 --> 01:06:15,166
就是我们这部分

1735
01:06:15,166 --> 01:06:17,299
是完全没在对象名字之间去描述的

1736
01:06:18,466 --> 01:06:19,799
然后这一边

1737
01:06:19,866 --> 01:06:23,199
同样的商品和销售一对多的关系

1738
01:06:23,366 --> 01:06:24,166
这个一的东西

1739
01:06:24,166 --> 01:06:25,733
对他们内是没有去描述的

1740
01:06:25,800 --> 01:06:27,400
数据库可不能不描述啊

1741
01:06:27,400 --> 01:06:28,800
他其实是要描述的

1742
01:06:28,800 --> 01:06:32,300
他这个描述其实也是用多到1的方式

1743
01:06:32,300 --> 01:06:34,066
就是这边写了一个product ID

1744
01:06:34,100 --> 01:06:35,933
去描述它的商品

1745
01:06:36,333 --> 01:06:37,466
这个一对多的

1746
01:06:38,466 --> 01:06:39,599
这个是个多对多的

1747
01:06:39,600 --> 01:06:41,266
就是我们在对讲明中间看到

1748
01:06:41,266 --> 01:06:42,566
它是一个多对多的

1749
01:06:44,500 --> 01:06:45,600
多对多的关系

1750
01:06:46,000 --> 01:06:47,300
那在数据表里头

1751
01:06:47,300 --> 01:06:49,466
大家就可以看到多对多的关系

1752
01:06:49,533 --> 01:06:51,066
如果要在数据表里

1753
01:06:51,200 --> 01:06:52,666
关系表里去描述的话

1754
01:06:53,100 --> 01:06:54,300
就是加第三张表

1755
01:06:54,566 --> 01:06:55,866
加了一张中间表

1756
01:06:57,000 --> 01:06:59,900
这样的中间表变成了两个一对多的

1757
01:06:59,900 --> 01:07:00,700
弯起

1758
01:07:00,700 --> 01:07:03,500
这个我想大家在er图里头的做法

1759
01:07:03,500 --> 01:07:04,566
是一模一样

1760
01:07:05,166 --> 01:07:07,366
对吧易拉图里的做法是一模一样

1761
01:07:07,500 --> 01:07:10,200
这就典型的是加了一张表啊

1762
01:07:10,200 --> 01:07:11,600
典型的是加了一张表

1763
01:07:11,800 --> 01:07:15,200
这张表里头没有任何其他的属性

1764
01:07:15,300 --> 01:07:16,600
并没有任何关

1765
01:07:16,766 --> 01:07:20,466
属性是依赖于销售和活动的

1766
01:07:20,466 --> 01:07:23,599
没有就单纯的就是为了建立

1767
01:07:23,600 --> 01:07:25,733
他的多对多的关系

1768
01:07:26,000 --> 01:07:27,100
去描述的

1769
01:07:27,300 --> 01:07:27,933
这里头啊

1770
01:07:27,933 --> 01:07:28,599
大家可以看到

1771
01:07:28,600 --> 01:07:32,866
我们刚才说的这个全场有效的问题

1772
01:07:32,966 --> 01:07:35,099
我们其实是用了一个方案

1773
01:07:35,100 --> 01:07:39,366
这个方案就是属于这叫做cheek

1774
01:07:39,500 --> 01:07:40,266
什么叫cheek呢

1775
01:07:40,266 --> 01:07:40,933
就是

1776
01:07:40,933 --> 01:07:43,333
我们如果说一个活动对全场有效的话

1777
01:07:43,333 --> 01:07:45,166
其实它没必要去建立一个一

1778
01:07:45,166 --> 01:07:46,166
对多的关系

1779
01:07:46,300 --> 01:07:47,800
而是把这个商品

1780
01:07:47,800 --> 01:07:48,600
把这个活动

1781
01:07:48,600 --> 01:07:51,866
和一个昂塞尔ID为0的去标记起来

1782
01:07:52,166 --> 01:07:54,099
这就表示说

1783
01:07:54,100 --> 01:07:57,866
它跟这个商铺里头的所有的销售

1784
01:07:58,400 --> 01:07:59,400
都是有效

1785
01:08:00,100 --> 01:08:01,500
就这么来啊

1786
01:08:01,500 --> 01:08:02,933
就是这么来啊

1787
01:08:03,366 --> 01:08:06,499
这是相当于用去壳来去解决它啊

1788
01:08:06,500 --> 01:08:08,666
这是数据表的设计

1789
01:08:09,266 --> 01:08:10,666
所以啊

1790
01:08:11,533 --> 01:08:13,399
我们下一轮的这个讨论课和作业

1791
01:08:13,400 --> 01:08:14,933
就是这样的一个过程

1792
01:08:14,966 --> 01:08:17,299
我们会给大家我们的领域模型

1793
01:08:17,300 --> 01:08:18,000
就领域模型

1794
01:08:18,000 --> 01:08:20,066
我们在今天和星期一

1795
01:08:20,066 --> 01:08:22,066
会逐步的把每个模块都讲完

1796
01:08:22,566 --> 01:08:22,999
然后当然

1797
01:08:23,000 --> 01:08:26,200
这个脸模型不见得是100%完美无瑕的啊

1798
01:08:26,200 --> 01:08:27,366
如果你们觉得有问题

1799
01:08:27,366 --> 01:08:30,266
你们就说你们脸模型想怎么去改

1800
01:08:30,800 --> 01:08:33,900
领域模型决定了这个对象模型

1801
01:08:34,066 --> 01:08:36,666
同样API也决定了对象模型

1802
01:08:36,666 --> 01:08:39,199
但API的驱动是前端界面

1803
01:08:39,200 --> 01:08:40,533
我们没有做前端界面

1804
01:08:40,600 --> 01:08:42,466
所以你们API的驱动是什么呢

1805
01:08:42,466 --> 01:08:44,366
API的驱动就是我们已经做好了的

1806
01:08:44,366 --> 01:08:45,166
这个API

1807
01:08:45,166 --> 01:08:47,666
你看看跟现在这个领域模型配不配

1808
01:08:48,133 --> 01:08:49,399
如果跟这个领域模型不配

1809
01:08:49,533 --> 01:08:50,533
那你就这些API

1810
01:08:50,533 --> 01:08:51,999
要做的这些API你都要改

1811
01:08:52,333 --> 01:08:53,199
如果配的话嘛

1812
01:08:53,200 --> 01:08:54,566
你就不需要改啊

1813
01:08:54,566 --> 01:08:55,066
不需要改

1814
01:08:55,066 --> 01:08:57,066
所以你们把这个文件拷出去

1815
01:08:57,466 --> 01:08:59,533
在每个小组自己去做

1816
01:08:59,566 --> 01:09:00,299
做一个

1817
01:09:00,300 --> 01:09:02,700
开个账号自己做一份放进去啊

1818
01:09:02,700 --> 01:09:04,800
然后把URL提交上来

1819
01:09:05,533 --> 01:09:08,499
这是API的设计和对象模型的设计

1820
01:09:08,500 --> 01:09:09,333
来驱动对象模型

1821
01:09:09,333 --> 01:09:09,966
设计

1822
01:09:09,966 --> 01:09:13,799
对象模型中间如果有对象是有状态的

1823
01:09:13,900 --> 01:09:16,000
用状态基图画出来

1824
01:09:16,366 --> 01:09:19,466
然后状态基图的事件注意下

1825
01:09:19,666 --> 01:09:22,699
如果它是由界面的API来确定的

1826
01:09:22,700 --> 01:09:24,866
写一个复录去描述

1827
01:09:24,866 --> 01:09:27,133
说它是由哪一个API来设计的

1828
01:09:27,400 --> 01:09:29,566
最后是关系

1829
01:09:29,566 --> 01:09:30,466
数据库的设计

1830
01:09:31,400 --> 01:09:32,333
我们的芒果数据库

1831
01:09:32,333 --> 01:09:33,866
不需要你设计那个对象模型

1832
01:09:33,866 --> 01:09:34,599
直接丢就好了

1833
01:09:34,600 --> 01:09:35,200
关系数据库

1834
01:09:35,200 --> 01:09:36,200
就涉及到了

1835
01:09:36,400 --> 01:09:39,333
我们的对象模型和关系数据库的映射

1836
01:09:39,466 --> 01:09:40,933
或者说我们在领域模型

1837
01:09:40,933 --> 01:09:42,466
或者API中间有描述的东西

1838
01:09:42,466 --> 01:09:44,333
在对象模型里面没有去描述

1839
01:09:44,533 --> 01:09:46,466
那关系数据库是肯定要去描述的

1840
01:09:46,466 --> 01:09:47,599
他不描述的话

1841
01:09:48,200 --> 01:09:49,566
功能就没办法实现了啊

1842
01:09:49,566 --> 01:09:51,966
所以说这个数据库的设计

1843
01:09:52,166 --> 01:09:56,333
这就是我们一个模块的这个内容

1844
01:09:56,333 --> 01:09:59,733
那每个小组是要做两个模块的啊

1845
01:09:59,733 --> 01:10:01,733
所以做两个这个内容

1846
01:10:01,866 --> 01:10:02,866
我最后啊

1847
01:10:02,866 --> 01:10:03,999
我最后会

1848
01:10:04,200 --> 01:10:05,766
就是我们现在在viki上呢

1849
01:10:05,766 --> 01:10:07,666
是有一个文档是需求分析的文档

1850
01:10:08,133 --> 01:10:09,199
然后这一周放开始

1851
01:10:09,200 --> 01:10:10,966
我就会开始开另外一个文档

1852
01:10:10,966 --> 01:10:12,766
就是我们的详细设计文档

1853
01:10:13,066 --> 01:10:15,299
所以我们的详细设计的内容

1854
01:10:15,300 --> 01:10:17,866
其实是被分成两次讨论课

1855
01:10:17,866 --> 01:10:20,333
两轮讨论课两次作业去完成的

1856
01:10:20,566 --> 01:10:23,599
前半段就是我们在这个11月份要做的

1857
01:10:24,200 --> 01:10:25,100
那后半段呢

1858
01:10:25,100 --> 01:10:26,700
就是我们在12月份要做的

1859
01:10:26,700 --> 01:10:29,200
就是针对里头的每一个API的

1860
01:10:29,200 --> 01:10:30,000
详细的设计

1861
01:10:30,000 --> 01:10:31,866
那就是后半段来做的

1862
01:10:31,933 --> 01:10:34,333
所以我们把详细设计的这个文档

1863
01:10:34,333 --> 01:10:37,133
把它分成了两次两轮的

1864
01:10:37,133 --> 01:10:38,533
这个讨论课和作业啊

1865
01:10:38,533 --> 01:10:39,733
来完成那同样呢

1866
01:10:39,733 --> 01:10:42,799
我会在Viki上放一个标准的文档

1867
01:10:42,800 --> 01:10:44,100
然后我们把b座部分

1868
01:10:44,100 --> 01:10:45,100
就我讲过的这部分

1869
01:10:45,100 --> 01:10:46,300
我把它全部写好

1870
01:10:46,400 --> 01:10:47,333
把它放进去

1871
01:10:47,700 --> 01:10:48,066
然后

1872
01:10:48,066 --> 01:10:50,899
大家就按照我放的那个文档的格式

1873
01:10:50,933 --> 01:10:52,899
去做这个

1874
01:10:52,900 --> 01:10:54,900
我们的讨论课和作业啊

1875
01:10:54,900 --> 01:10:56,500
按照这个过程来做

1876
01:10:57,766 --> 01:10:58,499
那今天的话

1877
01:10:58,500 --> 01:10:59,900
我们除了讲完产品以外

1878
01:10:59,900 --> 01:11:01,400
我们还打算把我们的必做部分

1879
01:11:01,400 --> 01:11:02,400
都讲完啊

1880
01:11:02,766 --> 01:11:03,533
能讲多少讲多

1881
01:11:03,533 --> 01:11:04,899
少然后剩下没讲完的

1882
01:11:04,900 --> 01:11:06,066
我们放到下周一去讲

1883
01:11:08,600 --> 01:11:11,400
第二个必做的部分是商铺

1884
01:11:11,933 --> 01:11:13,766
商铺的部分来说

1885
01:11:13,766 --> 01:11:15,666
我们可以看到领域模型有了一些变化

1886
01:11:15,666 --> 01:11:18,099
啊这个就是啊

1887
01:11:18,100 --> 01:11:20,066
我们第一把一部分内容给割掉了

1888
01:11:20,066 --> 01:11:21,766
我们其实在之前讲

1889
01:11:21,766 --> 01:11:22,799
商铺的领域模型时候

1890
01:11:22,800 --> 01:11:26,133
已经感觉到说这个里头有有有

1891
01:11:26,133 --> 01:11:27,366
有一堆东西

1892
01:11:27,366 --> 01:11:29,933
好像跟现在这个东西是两块是吧

1893
01:11:29,933 --> 01:11:31,466
有一块是他的服务的

1894
01:11:31,466 --> 01:11:33,333
就是这个商铺的商品

1895
01:11:33,333 --> 01:11:35,333
怎么做售前售后服务的

1896
01:11:35,500 --> 01:11:36,933
有一块是来算运费的

1897
01:11:37,000 --> 01:11:38,166
这两块概念之间

1898
01:11:38,166 --> 01:11:40,466
好像是没有一个必然关系

1899
01:11:40,966 --> 01:11:43,499
所以我们就毅然的把那一块的概念

1900
01:11:43,500 --> 01:11:46,066
全部切到了服务的部分

1901
01:11:46,466 --> 01:11:49,899
而留下了他的运费的部分

1902
01:11:50,166 --> 01:11:53,666
所以我们在商铺子女中间的领域模型

1903
01:11:53,900 --> 01:11:55,400
子女模型核心的东西

1904
01:11:55,400 --> 01:11:57,133
其实就是两个商铺

1905
01:11:57,733 --> 01:11:59,999
商铺的运费怎么去算

1906
01:12:00,300 --> 01:12:01,933
所以商铺的部分来说啊

1907
01:12:01,933 --> 01:12:03,599
这个概念和属性

1908
01:12:03,600 --> 01:12:04,333
这个没什么好说的

1909
01:12:04,333 --> 01:12:05,733
跟跟之前是一样

1910
01:12:06,166 --> 01:12:08,166
我们着重把它细化了

1911
01:12:08,166 --> 01:12:10,466
在运费部分的概念

1912
01:12:10,666 --> 01:12:13,066
我们认为运费的模板

1913
01:12:13,066 --> 01:12:14,499
是我们一个最核心的概念

1914
01:12:14,500 --> 01:12:15,800
就是比如说这个商铺说

1915
01:12:15,800 --> 01:12:17,733
他要有一种计费方式

1916
01:12:18,266 --> 01:12:19,899
这个模板的内涵的定义

1917
01:12:19,900 --> 01:12:21,566
就是它这种计费方式

1918
01:12:21,866 --> 01:12:22,199
当然

1919
01:12:22,200 --> 01:12:24,400
一个商铺可以定义很多种计费方式

1920
01:12:24,400 --> 01:12:26,200
所以是一个一对多的关系啊

1921
01:12:26,200 --> 01:12:29,600
就这个这个概念是个一对多的关系

1922
01:12:29,600 --> 01:12:30,933
这个应该没什么问题

1923
01:12:31,166 --> 01:12:32,466
每一个计费方式

1924
01:12:32,466 --> 01:12:36,266
是会因为地区不同而不同的

1925
01:12:36,266 --> 01:12:38,599
因为大家知道配送到不同地区

1926
01:12:39,100 --> 01:12:41,000
这个运费是不同计算的

1927
01:12:41,133 --> 01:12:43,399
所以针对不同的地区

1928
01:12:43,466 --> 01:12:45,333
每一个运费模板中间

1929
01:12:45,333 --> 01:12:48,699
都会定义一个对应的地区模板

1930
01:12:49,133 --> 01:12:49,533
这个地区

1931
01:12:49,533 --> 01:12:51,333
模板呢我们其实并没有限制说

1932
01:12:51,333 --> 01:12:53,299
一个地区模板只能对应一个地区

1933
01:12:53,533 --> 01:12:55,699
我们其实可以把一个运费模板定义

1934
01:12:55,700 --> 01:12:56,866
对应很多个地区啊

1935
01:12:56,866 --> 01:12:58,899
其实在真正定义这里是这么定义的

1936
01:12:58,900 --> 01:13:00,300
比如说华南地区5省

1937
01:13:00,566 --> 01:13:03,366
就会用同样的方式来计算运费

1938
01:13:03,533 --> 01:13:04,999
比如说以福建为中心

1939
01:13:05,066 --> 01:13:08,899
那我们通常来说福建江西广东

1940
01:13:08,900 --> 01:13:10,166
还有上面的浙江

1941
01:13:10,166 --> 01:13:12,699
这四个省的运费是完全一样

1942
01:13:12,966 --> 01:13:14,399
就是你只要在这四个省里头

1943
01:13:14,400 --> 01:13:15,300
去配送的话

1944
01:13:15,300 --> 01:13:16,466
就是完全一样的

1945
01:13:16,566 --> 01:13:18,266
然后再往远一点的话

1946
01:13:18,266 --> 01:13:19,599
比如说湖南湖北

1947
01:13:20,333 --> 01:13:22,899
这个配送又是完全的湖南湖北广西

1948
01:13:22,900 --> 01:13:24,866
通常来说我们是以咱这里的仓库

1949
01:13:24,866 --> 01:13:26,266
是以在福建的话

1950
01:13:26,533 --> 01:13:27,999
那就是以福建为中心

1951
01:13:28,000 --> 01:13:30,566
画的这个圆心过去啊

1952
01:13:30,566 --> 01:13:33,666
所以湖南湖北河南安徽

1953
01:13:33,933 --> 01:13:35,399
然后下面的这个广西

1954
01:13:35,400 --> 01:13:36,700
这又是一圈

1955
01:13:36,800 --> 01:13:38,800
又是一个相同的运费

1956
01:13:38,966 --> 01:13:40,333
然后再往远的话

1957
01:13:40,333 --> 01:13:41,566
云南云贵川

1958
01:13:42,466 --> 01:13:44,599
然后包括上面的陕西

1959
01:13:44,600 --> 01:13:46,466
这又是一圈的运费

1960
01:13:46,666 --> 01:13:48,733
然后再往那边就是西藏新疆

1961
01:13:49,300 --> 01:13:50,400
然后东北

1962
01:13:50,666 --> 01:13:51,799
这又是一圈的运费

1963
01:13:51,800 --> 01:13:53,933
就基本上就是以你仓库所在地

1964
01:13:54,666 --> 01:13:56,099
画一个圆圈啊

1965
01:13:56,100 --> 01:13:57,466
画一个圆圈过来

1966
01:13:57,733 --> 01:13:58,933
这个部分来说

1967
01:13:58,933 --> 01:14:00,366
我们会稍微复杂

1968
01:14:00,366 --> 01:14:01,533
就是真正的需求

1969
01:14:01,533 --> 01:14:04,766
其实他是会定义不同的运费模板的

1970
01:14:04,766 --> 01:14:05,933
就是同样一个商品

1971
01:14:05,933 --> 01:14:07,799
他如果从不同的仓库配出去的话

1972
01:14:07,800 --> 01:14:09,133
他是不同的运费模板

1973
01:14:09,200 --> 01:14:10,766
但我们现在没有做的这么复杂

1974
01:14:10,766 --> 01:14:12,533
我们就只定义了一套运费模板

1975
01:14:12,700 --> 01:14:14,066
就是啊

1976
01:14:14,066 --> 01:14:16,299
这个都不管他从哪个仓库发出去的

1977
01:14:16,300 --> 01:14:18,766
都是按照相同的方式来计算啊

1978
01:14:19,066 --> 01:14:20,866
所以我们这里看到

1979
01:14:20,866 --> 01:14:22,799
运费模板中间针对不同地区

1980
01:14:23,000 --> 01:14:24,566
其实是有不同定义的

1981
01:14:24,566 --> 01:14:26,366
然后每一个地区

1982
01:14:26,366 --> 01:14:26,899
的运费

1983
01:14:26,900 --> 01:14:28,733
模板其实是可以关联多个地区的

1984
01:14:28,733 --> 01:14:29,699
比如说我们刚刚说了

1985
01:14:29,700 --> 01:14:31,000
从福建来说

1986
01:14:31,200 --> 01:14:33,133
就是福建这一圈啊

1987
01:14:33,133 --> 01:14:35,166
这五个省都是一个地区的

1988
01:14:35,666 --> 01:14:37,299
都都都是在一个模板里头

1989
01:14:37,666 --> 01:14:39,333
然后具体计算的时候

1990
01:14:39,333 --> 01:14:40,466
我们之前已经讨论过了

1991
01:14:40,466 --> 01:14:43,166
我们分为重量模板和计数模板啊

1992
01:14:43,166 --> 01:14:46,399
就是因为建筑模板是因为它超尺寸了

1993
01:14:46,533 --> 01:14:48,766
所以我们都按键去做计算啊

1994
01:14:48,766 --> 01:14:51,133
这是我们对于前面的领域模型

1995
01:14:51,133 --> 01:14:51,933
其实可以看见

1996
01:14:51,933 --> 01:14:52,599
我们在这一次

1997
01:14:52,600 --> 01:14:54,866
又对人做了一些这个细化

1998
01:14:54,933 --> 01:14:56,666
特别是在模板这一块

1999
01:14:56,733 --> 01:15:00,066
然后把整个服务那一块把它丢弃了

2000
01:15:00,133 --> 01:15:02,599
放到了服务的模块里去

2001
01:15:03,966 --> 01:15:06,566
他的这个对象图也没觉得

2002
01:15:06,566 --> 01:15:08,466
好像比刚才那个更复杂了啊

2003
01:15:10,100 --> 01:15:11,866
对吧还出现那种新的颜色

2004
01:15:12,066 --> 01:15:13,466
那我们先从大家熟悉的

2005
01:15:13,466 --> 01:15:14,966
白色的开始说起啊

2006
01:15:15,300 --> 01:15:17,300
商铺就是从这个商铺概念来

2007
01:15:17,366 --> 01:15:20,099
这个没什么好说的啊啊

2008
01:15:20,266 --> 01:15:22,299
然后商铺和模板之间的关系

2009
01:15:22,300 --> 01:15:22,900
大家可以看到

2010
01:15:22,900 --> 01:15:25,500
在领域目前是一个一对多的关系

2011
01:15:26,133 --> 01:15:28,199
对吧然后我们在对象朋友中间呢

2012
01:15:28,200 --> 01:15:29,266
就把它舍弃了

2013
01:15:29,266 --> 01:15:30,199
我不要一对多了

2014
01:15:30,200 --> 01:15:31,000
变成一对一了

2015
01:15:31,000 --> 01:15:31,900
这个道理一样

2016
01:15:31,900 --> 01:15:32,900
一对多了怎么办

2017
01:15:33,066 --> 01:15:35,066
有多多就面向功能的方式去实现

2018
01:15:35,100 --> 01:15:36,366
我们这里在对象里面

2019
01:15:36,366 --> 01:15:38,666
只记了一个商铺的默认模板

2020
01:15:38,933 --> 01:15:40,399
这个原因就是因为大家知道

2021
01:15:40,400 --> 01:15:42,966
默认模板使用的频率

2022
01:15:43,500 --> 01:15:45,900
是比他的其他类型的模板

2023
01:15:46,133 --> 01:15:47,533
要大非常多的

2024
01:15:47,733 --> 01:15:49,399
因为实际在用的时候

2025
01:15:49,400 --> 01:15:52,066
大量的商品都是使用默认模板

2026
01:15:52,466 --> 01:15:53,899
而不会用那些特定的模板

2027
01:15:53,900 --> 01:15:55,066
可能只有10%

2028
01:15:55,066 --> 01:15:58,699
甚至5%六的商品是用的一些特殊模板

2029
01:15:58,866 --> 01:16:01,333
所以我们在对象模型中间采用了它

2030
01:16:01,333 --> 01:16:03,266
高频会使用到的

2031
01:16:03,266 --> 01:16:04,166
部分我们前面讲过

2032
01:16:04,166 --> 01:16:05,566
需求是有高频的吗

2033
01:16:05,966 --> 01:16:07,199
其实你在做对向模型设计时候

2034
01:16:07,200 --> 01:16:09,100
也是去处理那些高频的部分

2035
01:16:09,366 --> 01:16:09,999
所以这部分

2036
01:16:10,000 --> 01:16:12,466
我们用了一个一对一的关系

2037
01:16:12,466 --> 01:16:13,533
一对一的关系怎么办

2038
01:16:13,766 --> 01:16:15,133
API中间依然是有

2039
01:16:15,133 --> 01:16:16,766
大家去看那个API的设计啊

2040
01:16:16,766 --> 01:16:17,566
依然是有说

2041
01:16:17,566 --> 01:16:19,333
要看到一个商铺底下所有模板

2042
01:16:19,566 --> 01:16:20,166
那个API

2043
01:16:20,166 --> 01:16:22,866
就要靠面向功能的方式去实现了

2044
01:16:23,200 --> 01:16:24,133
变向对象的方式里头

2045
01:16:24,133 --> 01:16:26,766
只做了商铺的默认模板

2046
01:16:27,166 --> 01:16:29,699
然后商铺的默认模板

2047
01:16:29,733 --> 01:16:32,666
商铺的模板和地区模板之间的关系

2048
01:16:32,666 --> 01:16:34,499
是一个一对多的关系

2049
01:16:34,766 --> 01:16:36,333
同样我们也把它舍弃了

2050
01:16:36,533 --> 01:16:38,099
我们只描述了一个

2051
01:16:38,100 --> 01:16:42,533
从地区模板到商铺的这个方向的

2052
01:16:42,533 --> 01:16:43,766
一个一对一的关系

2053
01:16:43,900 --> 01:16:45,800
那那个如果要显示的话怎么办

2054
01:16:45,866 --> 01:16:48,133
同样用面向功能的方式去做啊

2055
01:16:48,200 --> 01:16:49,100
所以对象模型

2056
01:16:49,100 --> 01:16:51,500
是对于我们在领域模型里面

2057
01:16:51,500 --> 01:16:52,933
所描述的那些本质

2058
01:16:52,966 --> 01:16:54,666
我们会做一些取舍

2059
01:16:54,666 --> 01:16:56,333
基于效率做些取舍

2060
01:16:56,700 --> 01:16:59,000
去基于它的频率去做些取舍

2061
01:16:59,066 --> 01:17:01,566
我们选择我们所要描述的东西

2062
01:17:01,800 --> 01:17:04,900
然后大家也看到运费模板和建筑模板

2063
01:17:04,900 --> 01:17:07,733
我们采用了芒果数据库集醇

2064
01:17:07,733 --> 01:17:09,699
因为它这个格式很复杂

2065
01:17:09,800 --> 01:17:11,466
所以采用了芒果数据库集醇

2066
01:17:11,666 --> 01:17:12,299
这三个东西

2067
01:17:12,300 --> 01:17:13,900
采用了my simple数据库集醇

2068
01:17:13,900 --> 01:17:15,533
reading是来自于地区模块的

2069
01:17:15,533 --> 01:17:16,566
所以它是蓝色

2070
01:17:16,766 --> 01:17:18,799
然后大家可以看到出现了绿色的部分

2071
01:17:19,166 --> 01:17:20,066
预售部分是什么呢

2072
01:17:20,066 --> 01:17:21,899
预售部分是不需要存的对象

2073
01:17:22,266 --> 01:17:22,666
为什么

2074
01:17:22,666 --> 01:17:25,166
我们会有这么多不需要存的对象

2075
01:17:25,200 --> 01:17:27,900
就是因为我们的订单要分包裹

2076
01:17:28,400 --> 01:17:29,966
这个是件很讨厌的事情

2077
01:17:30,133 --> 01:17:33,099
就是有些顾客他会买很多的东西

2078
01:17:33,933 --> 01:17:35,199
最可怕的就是

2079
01:17:35,200 --> 01:17:38,500
这些用户买了杂七杂八的东西

2080
01:17:38,700 --> 01:17:41,366
就是各种各样的东西都买了一些

2081
01:17:41,733 --> 01:17:42,933
然后买的很多

2082
01:17:42,933 --> 01:17:45,333
多到说一个包裹寄不出去了

2083
01:17:45,800 --> 01:17:46,600
怎么办呢

2084
01:17:46,700 --> 01:17:49,200
你就需要把用户买的这些商品

2085
01:17:49,200 --> 01:17:51,266
分到多个包裹里头

2086
01:17:51,266 --> 01:17:52,299
把它寄出去

2087
01:17:52,400 --> 01:17:53,666
所以我们的运费模板

2088
01:17:53,666 --> 01:17:55,133
除了在做运费以外

2089
01:17:55,133 --> 01:17:56,366
其实他做了另外一件事情

2090
01:17:56,366 --> 01:17:58,699
就是根据这个运费模板的定义

2091
01:17:58,700 --> 01:18:00,466
我这个模板最多

2092
01:18:00,466 --> 01:18:03,299
其实每一个模板都有定义的

2093
01:18:03,300 --> 01:18:06,200
说他最多能够在一个包裹里头

2094
01:18:06,266 --> 01:18:07,133
放多少东西

2095
01:18:07,133 --> 01:18:09,566
比如说重量或者件数都有

2096
01:18:09,866 --> 01:18:11,266
你不可能说我100件

2097
01:18:11,266 --> 01:18:12,666
放到一个包裹里头寄出去

2098
01:18:13,200 --> 01:18:14,400
我的重量比如说我

2099
01:18:14,400 --> 01:18:17,666
我是100公斤放到一个包裹里去

2100
01:18:17,666 --> 01:18:18,666
这是不可能的

2101
01:18:18,766 --> 01:18:21,366
所以它其实定义了说它的上限是多少

2102
01:18:21,533 --> 01:18:22,933
一旦超过它的上限

2103
01:18:22,933 --> 01:18:24,666
就涉及到一个很复杂的问题

2104
01:18:24,800 --> 01:18:26,933
你得要把这些商品分到两个包裹

2105
01:18:26,933 --> 01:18:28,566
或者分到三个包裹里寄出去

2106
01:18:29,133 --> 01:18:30,166
那怎么分法

2107
01:18:31,066 --> 01:18:32,299
这就有个算法问题

2108
01:18:32,400 --> 01:18:33,800
这个算法很复杂啊

2109
01:18:33,800 --> 01:18:37,133
因为它其实不是一个NP的问题啊

2110
01:18:37,133 --> 01:18:39,399
算法课应该这学大家也是学的是吧

2111
01:18:39,566 --> 01:18:41,733
我们去年有一帮很优秀的同学

2112
01:18:41,733 --> 01:18:44,399
在这个算法上都做了很多很多的尝试

2113
01:18:44,666 --> 01:18:47,899
所以实际上做了非常多的算法来计算

2114
01:18:47,900 --> 01:18:51,866
说到底怎么把这个订单里的商品

2115
01:18:51,866 --> 01:18:53,533
分成多个包裹

2116
01:18:53,700 --> 01:18:57,366
它的原则就是快递费用最少

2117
01:18:58,166 --> 01:19:00,066
就是我可能分成两个包裹

2118
01:19:00,066 --> 01:19:01,299
还不如分三个包裹

2119
01:19:01,300 --> 01:19:02,966
因为我三个包裹的重量嘛

2120
01:19:03,166 --> 01:19:05,966
可能每个重量的这个价钱是最少的

2121
01:19:06,400 --> 01:19:09,000
所以以费用最优的方式

2122
01:19:09,000 --> 01:19:11,400
去把它分成不同的包裹去做

2123
01:19:11,733 --> 01:19:12,966
这个大家应该知道

2124
01:19:12,966 --> 01:19:14,566
我们去年其实有个大神啊

2125
01:19:14,566 --> 01:19:15,399
叫周和

2126
01:19:16,166 --> 01:19:16,999
这他做的

2127
01:19:17,500 --> 01:19:20,466
他做了里头最复杂的这个费用的计算

2128
01:19:20,466 --> 01:19:21,366
的这个算法

2129
01:19:21,400 --> 01:19:23,733
他应该是拿到了那个ACM的金牌是吧

2130
01:19:24,300 --> 01:19:24,766
对啊

2131
01:19:24,766 --> 01:19:27,299
这个一般我们不是每届都有同学呢

2132
01:19:27,300 --> 01:19:28,900
拿到ACM金牌了

2133
01:19:29,933 --> 01:19:32,799
通常来说是两三年才会出现一个

2134
01:19:32,800 --> 01:19:35,300
这样的出现这么一次啊

2135
01:19:35,300 --> 01:19:36,066
这样的人

2136
01:19:36,066 --> 01:19:38,099
而且出现一个ACM拿金牌的人

2137
01:19:38,100 --> 01:19:39,600
他其实并不是他单个

2138
01:19:39,700 --> 01:19:41,933
因为大家知道ACM比赛都是团队比赛

2139
01:19:42,100 --> 01:19:45,366
所以他会带起一帮人去去去做

2140
01:19:45,366 --> 01:19:47,466
所以去年的那一届里

2141
01:19:47,466 --> 01:19:49,533
他就有好几个善于做算法

2142
01:19:49,800 --> 01:19:50,766
于他们就在算法上的

2143
01:19:50,766 --> 01:19:52,566
玩命的去不断的尝试

2144
01:19:52,566 --> 01:19:53,599
做不同的算法

2145
01:19:53,933 --> 01:19:55,399
都做这个代码里头了啊

2146
01:19:55,966 --> 01:19:56,966
这就是绿色部分

2147
01:19:57,100 --> 01:19:58,133
因为这些算法的部分

2148
01:19:58,133 --> 01:19:59,566
是不需要传到数据库里的

2149
01:19:59,733 --> 01:20:01,499
也不需要传到芒果里头的

2150
01:20:01,733 --> 01:20:04,533
他就是我们的这个对象

2151
01:20:05,066 --> 01:20:07,366
所以我们可以看到了我们的第四种啊

2152
01:20:07,366 --> 01:20:08,199
预测的部分

2153
01:20:08,200 --> 01:20:09,766
这个同样也告诉大家一个道理

2154
01:20:09,766 --> 01:20:10,799
我们现在这个代码中间

2155
01:20:10,800 --> 01:20:14,766
其实是累积了若干界同学大神的代码

2156
01:20:14,766 --> 01:20:16,499
啊在这里头

2157
01:20:16,533 --> 01:20:18,599
所以大家每一次都是能看到前人

2158
01:20:18,733 --> 01:20:21,266
前面的学长们做的东西啊

2159
01:20:21,266 --> 01:20:22,499
然后一件件的往上的

2160
01:20:22,500 --> 01:20:24,333
去理解他们做的东西

2161
01:20:24,333 --> 01:20:25,399
去修改他们的东西

2162
01:20:25,400 --> 01:20:27,100
把它变得越来越好

2163
01:20:27,466 --> 01:20:29,199
这就是我们为什么在若干年来

2164
01:20:29,200 --> 01:20:31,500
都持续的在用同样一个

2165
01:20:31,500 --> 01:20:33,300
大家觉得老掉牙的话题

2166
01:20:33,733 --> 01:20:35,266
来做这个课程设计

2167
01:20:35,266 --> 01:20:37,499
就是不在于说我们做什么东西啊

2168
01:20:37,500 --> 01:20:40,100
在于说我们是怎么怎么去做啊

2169
01:20:40,200 --> 01:20:41,700
这个才更加有意义

2170
01:20:44,300 --> 01:20:45,066
数据库的设计

2171
01:20:45,066 --> 01:20:46,499
这个没什么好说的啊

2172
01:20:46,500 --> 01:20:47,466
这个跟前面的

2173
01:20:47,466 --> 01:20:48,533
因为他的对象啊

2174
01:20:48,533 --> 01:20:49,599
相对比较简单

2175
01:20:49,600 --> 01:20:51,400
就是麻烦在算法部分

2176
01:20:51,766 --> 01:20:54,066
所以基本上就是跟我们的产品

2177
01:20:54,066 --> 01:20:56,699
那边的数据库的设计是一致的

2178
01:20:56,733 --> 01:20:58,699
这里我其实还缺了一个状态

2179
01:20:58,700 --> 01:21:00,466
因为那个商铺是有状态的

2180
01:21:00,466 --> 01:21:02,399
那我之后把它补上去啊

2181
01:21:02,500 --> 01:21:04,766
我我不会补到这个PPT上了啊

2182
01:21:04,766 --> 01:21:05,766
我补到这个PPT上吧

2183
01:21:05,766 --> 01:21:06,933
因为下午还要再讲一次

2184
01:21:06,933 --> 01:21:08,366
中午我再把它补上去

2185
01:21:08,700 --> 01:21:09,933
商铺是有状态啊

2186
01:21:09,933 --> 01:21:11,299
把状态补再补上去

2187
01:21:11,666 --> 01:21:14,399
最后我们讲一下支付模块啊

2188
01:21:14,400 --> 01:21:16,466
支付模块的领域模型

2189
01:21:16,466 --> 01:21:17,933
我们没有多大的变化啊

2190
01:21:17,933 --> 01:21:19,399
因为这个部分来说

2191
01:21:19,400 --> 01:21:21,566
其实它的业务很简单

2192
01:21:21,566 --> 01:21:22,699
就是要记住

2193
01:21:23,000 --> 01:21:24,000
我们在第三方支付

2194
01:21:24,000 --> 01:21:25,466
那边的相关的信息

2195
01:21:25,466 --> 01:21:26,533
然后去做比对

2196
01:21:26,900 --> 01:21:28,733
所以我们知道我们会有支付

2197
01:21:28,733 --> 01:21:29,499
会有退款

2198
01:21:29,500 --> 01:21:30,600
然后因为做分账的

2199
01:21:30,600 --> 01:21:32,866
会有支付的分账和支付的退款

2200
01:21:32,900 --> 01:21:33,966
然后因为会有差

2201
01:21:33,966 --> 01:21:35,666
所以做了这个对账

2202
01:21:36,100 --> 01:21:37,166
然后每一个商铺呢

2203
01:21:37,166 --> 01:21:39,499
会在不同的支付渠道上去开那个账号

2204
01:21:39,666 --> 01:21:41,499
平台也会去开这个账号啊

2205
01:21:41,500 --> 01:21:42,766
所以就会有这么多概率

2206
01:21:42,766 --> 01:21:43,799
这个之前讲过了

2207
01:21:43,800 --> 01:21:44,566
也没有改变

2208
01:21:44,566 --> 01:21:46,333
所以我就不怎么仔细去讲

2209
01:21:46,700 --> 01:21:49,366
我们来看一下他的对象模型

2210
01:21:49,866 --> 01:21:51,666
对象模型在这部分来说

2211
01:21:51,666 --> 01:21:53,999
它最大的变化在于在于说

2212
01:21:54,000 --> 01:21:55,900
我们从概念中间觉得说

2213
01:21:55,900 --> 01:21:58,300
有必要做一个抽象的概念

2214
01:21:58,300 --> 01:21:59,300
叫做交易

2215
01:21:59,533 --> 01:22:03,599
我们认为支付交易退款交易啊

2216
01:22:03,700 --> 01:22:07,100
分账交易和这个返款的分账交易

2217
01:22:07,100 --> 01:22:08,300
其实都有共性

2218
01:22:08,366 --> 01:22:10,933
所以把它所有的共性的部分

2219
01:22:10,933 --> 01:22:13,499
做成了一个抽象的附类

2220
01:22:13,500 --> 01:22:14,933
叫做transaction啊

2221
01:22:14,933 --> 01:22:17,199
这个就是做了一个继承

2222
01:22:17,200 --> 01:22:18,600
这样的一个设计

2223
01:22:18,766 --> 01:22:19,999
所有的关系

2224
01:22:20,000 --> 01:22:21,300
这跟前面不一样

2225
01:22:21,400 --> 01:22:24,733
我们没有做任何的省略

2226
01:22:26,100 --> 01:22:27,133
领域模型中间

2227
01:22:27,133 --> 01:22:28,199
所有的关系

2228
01:22:28,200 --> 01:22:31,533
全部照原样搬到了对象模型中间

2229
01:22:33,066 --> 01:22:34,199
为什么会这样做

2230
01:22:35,166 --> 01:22:36,199
这叫做理由

2231
01:22:36,200 --> 01:22:37,366
为什么会这么做

2232
01:22:37,500 --> 01:22:39,766
为什么前面都在讲说我们会有抉择

2233
01:22:39,766 --> 01:22:40,366
会有省略

2234
01:22:40,366 --> 01:22:44,366
就这个模块啥都没省就绝样搬进来

2235
01:22:44,866 --> 01:22:46,799
因为这个模块的特征在于说

2236
01:22:48,400 --> 01:22:50,366
不是因为他的个数都很少

2237
01:22:50,766 --> 01:22:52,566
就除了这个部分呢

2238
01:22:52,566 --> 01:22:54,599
一个账户下面所有的交易

2239
01:22:54,866 --> 01:22:57,733
这个部分好像我们是没有去记录

2240
01:22:57,733 --> 01:23:01,366
他啊把这个部分做了省略以外

2241
01:23:01,400 --> 01:23:03,100
这个一对多的不管他了

2242
01:23:03,566 --> 01:23:05,966
这个一对多的只做了一个一对一的

2243
01:23:05,966 --> 01:23:08,266
因为那个会很多其他部分

2244
01:23:08,266 --> 01:23:09,799
所有的一对多的关系

2245
01:23:09,800 --> 01:23:10,100
比如说

2246
01:23:10,100 --> 01:23:12,166
我们可以看到支付和支付的分账

2247
01:23:12,200 --> 01:23:14,566
我们现在一笔支付只有两笔分账啊

2248
01:23:14,566 --> 01:23:15,933
一笔支付只有一笔分账

2249
01:23:15,933 --> 01:23:17,899
这笔支付是啊

2250
01:23:18,000 --> 01:23:19,166
这笔支付啊

2251
01:23:19,466 --> 01:23:21,299
这笔支付是退给

2252
01:23:21,300 --> 01:23:22,266
是分给平台的

2253
01:23:22,266 --> 01:23:23,366
所以这一笔分账

2254
01:23:23,666 --> 01:23:25,466
所以这是一个一对一的关系

2255
01:23:26,166 --> 01:23:27,999
那退款的部分来说

2256
01:23:28,000 --> 01:23:29,166
其实也只有一笔退款

2257
01:23:29,166 --> 01:23:29,766
这个也写错了

2258
01:23:29,766 --> 01:23:30,733
只有一笔退款

2259
01:23:30,866 --> 01:23:32,666
因为是从平台退给商户

2260
01:23:32,666 --> 01:23:34,466
商户再退给那个

2261
01:23:34,466 --> 01:23:35,699
所以只有一笔退款

2262
01:23:35,866 --> 01:23:37,699
所以这里头很多的

2263
01:23:38,000 --> 01:23:39,200
唯一的这个一对多的关系

2264
01:23:39,200 --> 01:23:41,666
就是一个支付是有多笔退款

2265
01:23:41,666 --> 01:23:43,133
因为支付是一个订单

2266
01:23:43,133 --> 01:23:44,133
订单里有很多商品

2267
01:23:44,133 --> 01:23:45,566
每个商品会单独退货

2268
01:23:45,733 --> 01:23:48,066
所以一笔支付会有多个退款

2269
01:23:48,066 --> 01:23:49,599
这个是一个一对多的

2270
01:23:49,966 --> 01:23:50,666
这个一对多的

2271
01:23:50,666 --> 01:23:52,733
原样保留在对象门口中间了

2272
01:23:52,733 --> 01:23:53,566
原因是什么

2273
01:23:53,566 --> 01:23:54,533
原因在于两个

2274
01:23:54,533 --> 01:23:55,766
第一它不会特别多

2275
01:23:56,333 --> 01:23:57,999
你一个商户

2276
01:23:58,000 --> 01:23:59,466
一个订单都能买多少商品呢

2277
01:23:59,466 --> 01:24:00,666
买100件200件

2278
01:24:00,666 --> 01:24:01,766
顶天了是吧

2279
01:24:02,066 --> 01:24:02,999
100件200件

2280
01:24:03,000 --> 01:24:04,133
一件件的把它退回去

2281
01:24:04,133 --> 01:24:05,333
也就是100-200条

2282
01:24:05,333 --> 01:24:06,999
但是我们这里说极端情况

2283
01:24:07,166 --> 01:24:08,199
大部分情况

2284
01:24:08,400 --> 01:24:11,000
通常来说就是一个支付这

2285
01:24:11,000 --> 01:24:13,066
个最多两三笔这个退款

2286
01:24:13,266 --> 01:24:16,166
所以对象模型把它完整的构建出来

2287
01:24:16,166 --> 01:24:17,999
效率上不会有太大的损失

2288
01:24:18,366 --> 01:24:18,966
这是第一啊

2289
01:24:18,966 --> 01:24:19,966
基于效率的考虑

2290
01:24:20,200 --> 01:24:21,966
第二是我们在这里头

2291
01:24:21,966 --> 01:24:23,999
其实是有一个很关键的业务

2292
01:24:24,133 --> 01:24:27,866
就是退款的总额不能超过支付的总额

2293
01:24:28,066 --> 01:24:30,199
这是我们做支付模块的底线

2294
01:24:30,733 --> 01:24:31,466
大家会想说

2295
01:24:31,466 --> 01:24:33,999
为什么退款总额会超过支付总额

2296
01:24:35,166 --> 01:24:36,966
因为会有黑客黑进的

2297
01:24:37,566 --> 01:24:39,366
所以如果用黑客黑进呢

2298
01:24:39,366 --> 01:24:42,133
我们在整个系统的业务逻辑的每一层

2299
01:24:42,133 --> 01:24:43,666
都其实要做这样的一个判断

2300
01:24:44,000 --> 01:24:44,733
按道理做

2301
01:24:44,733 --> 01:24:45,966
如果前端正常操作时候

2302
01:24:45,966 --> 01:24:47,733
是不可能出现这样一个情况的

2303
01:24:47,866 --> 01:24:48,733
但是你要知道

2304
01:24:48,733 --> 01:24:50,499
当有黑客黑你的系统的时候

2305
01:24:51,066 --> 01:24:54,366
调用你的我们的API是被公布在怪网

2306
01:24:54,866 --> 01:24:57,066
调用你的API不见得是你的前端

2307
01:24:57,366 --> 01:24:59,133
所以他可能有各种办法黑进来

2308
01:24:59,133 --> 01:25:01,166
最后让你来退出

2309
01:25:01,366 --> 01:25:02,399
超过你的

2310
01:25:02,466 --> 01:25:04,366
首先我们的所有的退款都要有支付

2311
01:25:04,366 --> 01:25:05,499
这是个前提啊

2312
01:25:05,600 --> 01:25:07,533
不能没有支付来退款

2313
01:25:07,600 --> 01:25:09,500
然后所有的退款

2314
01:25:09,700 --> 01:25:12,766
都只能不超过他的支付金额

2315
01:25:13,100 --> 01:25:14,566
所以这就是在业务逻辑上呢

2316
01:25:14,566 --> 01:25:15,866
要去做做判断

2317
01:25:15,900 --> 01:25:18,000
而这个判断会频繁的使用到

2318
01:25:18,000 --> 01:25:20,500
一个支付到目前为止有多少退款

2319
01:25:21,000 --> 01:25:22,933
所以这个我们建立到对象模型里去

2320
01:25:23,266 --> 01:25:24,499
这就是效率

2321
01:25:24,500 --> 01:25:25,400
不会有损失

2322
01:25:25,400 --> 01:25:26,800
业务上的非常关键

2323
01:25:27,000 --> 01:25:28,600
所以我们在这个部分来说

2324
01:25:28,600 --> 01:25:29,800
把一对多的关系

2325
01:25:29,800 --> 01:25:31,700
完整的搬到对象模型里头

2326
01:25:32,100 --> 01:25:33,333
其他的没啥啊

2327
01:25:34,100 --> 01:25:35,400
这部分其实比较简单

2328
01:25:35,400 --> 01:25:36,466
看起来很多

2329
01:25:36,600 --> 01:25:38,666
为啥对象模型看起来没有别的颜色

2330
01:25:38,666 --> 01:25:41,699
是吧全纯的关系数据会了啊

2331
01:25:41,700 --> 01:25:42,966
全程的关键是就会了

2332
01:25:43,166 --> 01:25:43,866
去年做的时候

2333
01:25:43,866 --> 01:25:45,599
这个是第一个做的必做模块

2334
01:25:46,166 --> 01:25:48,866
那当然我们今年这一块要做修改啊

2335
01:25:48,866 --> 01:25:50,366
做修改呃

2336
01:25:50,366 --> 01:25:52,566
但是我们打算把它放到稍厚一点

2337
01:25:52,900 --> 01:25:53,800
放到稍厚一点

2338
01:25:54,133 --> 01:25:57,366
我们今年从产品这个模块开始着手

2339
01:25:58,000 --> 01:25:59,333
他的状态图啊

2340
01:25:59,333 --> 01:26:01,166
每一个东西都是有状态

2341
01:26:01,466 --> 01:26:02,599
就是四个交易

2342
01:26:02,600 --> 01:26:04,533
每个交易都是有状态的

2343
01:26:04,766 --> 01:26:07,866
我们略微讲一下他这个状态的迁移啊

2344
01:26:07,866 --> 01:26:11,133
这里头每一个动作要么都要对API

2345
01:26:11,800 --> 01:26:14,166
要么就要对应说啊

2346
01:26:14,166 --> 01:26:15,099
你去做描述

2347
01:26:15,100 --> 01:26:16,300
说他怎么完成的

2348
01:26:16,566 --> 01:26:18,466
我们首先看这个支付交易

2349
01:26:18,866 --> 01:26:19,766
支付交易啊

2350
01:26:19,766 --> 01:26:21,966
我们都知道我们在做这个

2351
01:26:22,666 --> 01:26:23,399
这个部分来说

2352
01:26:23,400 --> 01:26:24,733
我们是要记住

2353
01:26:24,733 --> 01:26:28,566
我们和支付渠道的差异在哪

2354
01:26:29,066 --> 01:26:31,999
所以当我们去完成支付的时候

2355
01:26:32,000 --> 01:26:33,533
我们所有做支付的时候

2356
01:26:33,533 --> 01:26:34,899
我们自己先要记一笔

2357
01:26:35,500 --> 01:26:36,566
就是我们在支付之前

2358
01:26:36,566 --> 01:26:37,366
我们记一笔

2359
01:26:37,600 --> 01:26:38,733
产生一个支付交易

2360
01:26:38,733 --> 01:26:40,166
这时候他的状态是6

2361
01:26:40,600 --> 01:26:43,466
就是待支付的状态啊

2362
01:26:43,466 --> 01:26:44,533
待支付的状态

2363
01:26:44,933 --> 01:26:47,366
那然后就去支付平台支付了

2364
01:26:47,366 --> 01:26:49,066
支付平台支付时候我们是不知道的

2365
01:26:49,300 --> 01:26:51,200
它支付成功以后会回掉我们

2366
01:26:51,200 --> 01:26:52,500
或者我们主动去查

2367
01:26:52,766 --> 01:26:54,499
所以这里我们写的是

2368
01:26:54,500 --> 01:26:56,600
支付后去查询渠道

2369
01:26:56,766 --> 01:26:59,099
但其实被回掉也会

2370
01:26:59,566 --> 01:27:00,866
如果说被回调成功了

2371
01:27:00,866 --> 01:27:02,799
我们其实就把当前这个支付交易

2372
01:27:02,800 --> 01:27:04,600
改成成功支付

2373
01:27:04,866 --> 01:27:06,933
如果没有被回调的话

2374
01:27:06,933 --> 01:27:08,666
其实我们要主动去查询

2375
01:27:08,666 --> 01:27:10,099
那个支付渠道的

2376
01:27:10,100 --> 01:27:10,700
政府交易

2377
01:27:10,700 --> 01:27:12,566
看看他是不是有支付成功了

2378
01:27:12,866 --> 01:27:14,999
所以如果成功了就到成功

2379
01:27:15,200 --> 01:27:17,500
如果说查询或者被毁掉

2380
01:27:17,500 --> 01:27:18,366
告诉你失败了

2381
01:27:18,366 --> 01:27:22,333
就到这个是这个支付的失败啊

2382
01:27:22,333 --> 01:27:23,166
那还有一种可能性

2383
01:27:23,166 --> 01:27:26,466
就是支付的过程中间被用户取消了

2384
01:27:26,700 --> 01:27:28,166
用户他他就没支付了

2385
01:27:28,166 --> 01:27:29,566
然后把订单取消了

2386
01:27:29,666 --> 01:27:31,299
所以说会到这个5啊

2387
01:27:31,300 --> 01:27:33,100
这个是取消的这个状态

2388
01:27:33,533 --> 01:27:35,733
那如果到了这个成功这个状态的话

2389
01:27:35,866 --> 01:27:37,933
我们后面要做的事情是要对账

2390
01:27:38,000 --> 01:27:39,166
就是我们的支付平台

2391
01:27:39,166 --> 01:27:40,099
其实要保证说

2392
01:27:40,100 --> 01:27:41,066
我们的支付交易

2393
01:27:41,066 --> 01:27:44,066
和支付渠道的支付交易是完全一致的

2394
01:27:44,300 --> 01:27:45,533
所以我们要去做对账

2395
01:27:46,566 --> 01:27:47,366
这个对账

2396
01:27:48,600 --> 01:27:50,666
如果说跟支付平台是完全一样

2397
01:27:50,866 --> 01:27:52,366
那就是到2

2398
01:27:52,500 --> 01:27:53,133
表示他赢

2399
01:27:53,133 --> 01:27:53,799
对账

2400
01:27:53,800 --> 01:27:56,133
如果跟支付平台的那边交易是不一样

2401
01:27:56,266 --> 01:27:57,299
他就到了这边

2402
01:27:57,700 --> 01:27:58,466
到了这边以后

2403
01:27:58,466 --> 01:28:00,166
其实他并不能去做任何动作

2404
01:28:00,166 --> 01:28:01,199
这靠手工来做

2405
01:28:01,200 --> 01:28:02,333
就手工去排查

2406
01:28:02,333 --> 01:28:04,299
说为什么跟支付平台那个不一样

2407
01:28:04,733 --> 01:28:08,399
那如果排查最后的结论是OK啊

2408
01:28:08,400 --> 01:28:10,066
反正错了就我们也认了

2409
01:28:10,333 --> 01:28:11,699
所以说他要去调战

2410
01:28:11,700 --> 01:28:13,200
调到这个以对战

2411
01:28:13,733 --> 01:28:15,099
调到以对战以后啊

2412
01:28:15,100 --> 01:28:16,333
然后才能去分战

2413
01:28:17,400 --> 01:28:18,100
才能去分账

2414
01:28:18,100 --> 01:28:20,666
因为这笔钱目前是在商户的账户里头

2415
01:28:20,666 --> 01:28:22,366
并不在平台里

2416
01:28:22,466 --> 01:28:26,066
所以当这个已经兑完账了以后啊

2417
01:28:26,066 --> 01:28:27,266
才能去分账

2418
01:28:27,533 --> 01:28:28,999
那这里其实要描述出

2419
01:28:29,000 --> 01:28:31,300
他如果是调的怎么去做啊

2420
01:28:31,300 --> 01:28:32,933
这个我们今年再去考虑一下

2421
01:28:32,933 --> 01:28:35,333
如果说正常的话啊

2422
01:28:36,900 --> 01:28:37,733
没有挂账啊

2423
01:28:37,733 --> 01:28:38,599
就是就是

2424
01:28:38,600 --> 01:28:39,533
我们从交易来说

2425
01:28:39,533 --> 01:28:40,599
我们要标示出

2426
01:28:40,600 --> 01:28:41,500
如果对账成功了

2427
01:28:41,500 --> 01:28:41,933
就是这样

2428
01:28:41,933 --> 01:28:42,766
如果没对账成功了

2429
01:28:42,766 --> 01:28:44,099
就要去记录下来

2430
01:28:44,166 --> 01:28:46,199
然后这里如果手工处理成功了

2431
01:28:46,200 --> 01:28:47,333
其实是不能分账

2432
01:28:47,566 --> 01:28:49,999
他他肯定是不对啊

2433
01:28:50,000 --> 01:28:51,533
这个看怎么怎么去处理啊

2434
01:28:51,533 --> 01:28:52,766
这个我们还没去管他

2435
01:28:52,900 --> 01:28:54,266
所以对账成功以后

2436
01:28:54,266 --> 01:28:55,733
然后才能去做分账

2437
01:28:56,066 --> 01:28:57,166
分账完成了以后

2438
01:28:57,166 --> 01:28:59,266
然后到了这个东西的终结态

2439
01:28:59,766 --> 01:29:02,399
所以任何一个支付交易的最终的状态

2440
01:29:02,400 --> 01:29:04,133
就是要么他支付失败了

2441
01:29:04,333 --> 01:29:06,366
要么他被顾客取消了被

2442
01:29:06,366 --> 01:29:08,466
支付着被被顾客取消了

2443
01:29:08,533 --> 01:29:09,733
要么就是他支付成功

2444
01:29:09,733 --> 01:29:12,699
然后把这笔钱一部分留给了商户

2445
01:29:12,700 --> 01:29:14,800
一部分分给了平台

2446
01:29:15,066 --> 01:29:16,533
那商户被留下的部分

2447
01:29:16,533 --> 01:29:18,799
他才可以从他的支付宝或者微信账号

2448
01:29:18,800 --> 01:29:19,966
转到他的银行卡上

2449
01:29:20,100 --> 01:29:22,300
没有分账之前他是转不了的

2450
01:29:22,300 --> 01:29:23,800
但这个不是我们来控制的啊

2451
01:29:23,800 --> 01:29:25,800
这个就是支付宝和微信来控制的

2452
01:29:25,800 --> 01:29:27,666
如果不做这个分账的话

2453
01:29:27,900 --> 01:29:29,466
这个钱就一直都在支付宝微信上

2454
01:29:29,466 --> 01:29:31,066
他是转不到那个商户的

2455
01:29:31,066 --> 01:29:32,099
自己的银行卡上

2456
01:29:33,600 --> 01:29:35,666
退款退款就相对麻烦一点

2457
01:29:35,666 --> 01:29:37,166
因为有分有了分账啊

2458
01:29:37,166 --> 01:29:38,733
所以同样当用当

2459
01:29:38,733 --> 01:29:40,066
这个不是顾客退款

2460
01:29:40,066 --> 01:29:42,533
这是我们的平台审核说他可以退款

2461
01:29:43,300 --> 01:29:44,400
那比如说售后

2462
01:29:45,066 --> 01:29:46,599
或者说用户取消了

2463
01:29:46,600 --> 01:29:49,000
我们平台自动的就来进行退款

2464
01:29:49,100 --> 01:29:51,700
我们会首先记一笔说这个待退款

2465
01:29:51,766 --> 01:29:53,566
这就是因为我们要知道

2466
01:29:53,566 --> 01:29:55,266
平台里面退款没有完成啊

2467
01:29:55,266 --> 01:29:56,766
支付渠道里面也没有完成

2468
01:29:57,133 --> 01:29:58,333
然后他会被回掉

2469
01:29:58,333 --> 01:29:59,533
或者是主动查询

2470
01:29:59,533 --> 01:30:01,766
这个结果就是失败的话叫做失败

2471
01:30:02,133 --> 01:30:03,899
然后如果说是成功的话呢

2472
01:30:03,900 --> 01:30:07,266
就到这个分账以退款

2473
01:30:07,333 --> 01:30:08,866
这个退款会比较麻烦一点

2474
01:30:08,866 --> 01:30:12,066
因为他要要看说它是不是已经分账

2475
01:30:12,533 --> 01:30:14,066
如果它已经分账的话呢

2476
01:30:14,066 --> 01:30:15,699
那它就会中间有个状态

2477
01:30:15,900 --> 01:30:18,166
说要先从分账退款

2478
01:30:18,166 --> 01:30:19,566
然后再到成功

2479
01:30:19,733 --> 01:30:21,199
如果说没有分账的话呢

2480
01:30:21,200 --> 01:30:22,100
其实就会直接过来

2481
01:30:22,100 --> 01:30:23,600
这个要要再改一下啊

2482
01:30:23,600 --> 01:30:26,266
如果没有的话就会直接过来啊

2483
01:30:26,266 --> 01:30:27,599
到这个已退款

2484
01:30:28,533 --> 01:30:30,366
呃然后如果在推广中间

2485
01:30:30,366 --> 01:30:32,133
被用户被平台取消了

2486
01:30:32,133 --> 01:30:33,999
这就会直接到了这个取消的状态

2487
01:30:34,200 --> 01:30:37,366
那如果这个退款已经成功了

2488
01:30:37,466 --> 01:30:38,766
后面的过程一样的一样的

2489
01:30:38,766 --> 01:30:40,466
要对账对账成

2490
01:30:40,466 --> 01:30:41,799
功了他才是最后的状态

2491
01:30:41,800 --> 01:30:42,733
对账不成功啊

2492
01:30:42,733 --> 01:30:43,566
直接变成错账

2493
01:30:43,566 --> 01:30:44,699
然后要去挑战

2494
01:30:45,066 --> 01:30:47,366
这是这个退款的交易

2495
01:30:47,366 --> 01:30:49,333
这里多的就是他会有一个分账

2496
01:30:49,333 --> 01:30:50,333
退款的状态

2497
01:30:52,100 --> 01:30:54,600
分账的这个支付支付分账

2498
01:30:54,600 --> 01:30:56,700
交易支付分账也是一笔交易

2499
01:30:56,700 --> 01:30:57,566
要记下来的

2500
01:30:57,700 --> 01:30:59,466
因为这个在平台那边支付

2501
01:30:59,466 --> 01:31:02,066
平台那边会有一个呃那个

2502
01:31:02,166 --> 01:31:03,699
所以在分账之前

2503
01:31:03,700 --> 01:31:05,733
我们这里要建一个交易所

2504
01:31:05,733 --> 01:31:06,666
我们要分账

2505
01:31:07,500 --> 01:31:09,666
然后去调那个平台去分账

2506
01:31:09,800 --> 01:31:12,533
所以调平台分账完成以后

2507
01:31:12,533 --> 01:31:14,999
去查平台那边是不是已经完成了分账

2508
01:31:15,366 --> 01:31:18,499
如果说平台那边已经完成分账啊

2509
01:31:18,500 --> 01:31:20,166
那就变成这个已成功

2510
01:31:20,400 --> 01:31:22,600
这个成功以后再还要再去对账

2511
01:31:22,866 --> 01:31:24,066
就是对说

2512
01:31:25,066 --> 01:31:27,099
商户那边说这个分担已经成功了

2513
01:31:27,500 --> 01:31:29,066
平台这边这笔钱

2514
01:31:29,066 --> 01:31:31,999
是不是已经打到这个平台里头来了

2515
01:31:32,066 --> 01:31:33,533
所以平台那边会查到

2516
01:31:33,533 --> 01:31:35,999
说有笔钱从商户那边分到我这边来

2517
01:31:36,366 --> 01:31:37,399
所以要去对账

2518
01:31:37,500 --> 01:31:38,566
如果对失败了

2519
01:31:38,566 --> 01:31:39,366
就变成错账

2520
01:31:39,366 --> 01:31:40,099
如果对成功了

2521
01:31:40,100 --> 01:31:42,000
就变成这个已经那个

2522
01:31:42,166 --> 01:31:43,133
那错账的话

2523
01:31:43,133 --> 01:31:44,166
就靠手工调

2524
01:31:44,166 --> 01:31:47,066
把它调到这个已对账的这个范围内了

2525
01:31:47,066 --> 01:31:48,366
所以最终的状态就是

2526
01:31:48,366 --> 01:31:50,099
要么就是分账失败了

2527
01:31:50,266 --> 01:31:51,466
要么分账成功

2528
01:31:51,666 --> 01:31:53,666
变成已完成对账

2529
01:31:54,200 --> 01:31:56,733
退款类似退款类似

2530
01:31:56,733 --> 01:31:58,933
退款比分账有一个差别

2531
01:31:58,933 --> 01:32:00,566
分账是不可以被取消的

2532
01:32:01,166 --> 01:32:02,799
分账一调就是直接去做

2533
01:32:02,966 --> 01:32:03,766
那退款的话

2534
01:32:03,766 --> 01:32:04,399
有可能说

2535
01:32:04,400 --> 01:32:06,066
比如说平台说要退款

2536
01:32:06,300 --> 01:32:07,966
那退款首先就要来退

2537
01:32:07,966 --> 01:32:10,333
分账所以这边分账也会记一笔数

2538
01:32:10,333 --> 01:32:11,699
他会有一个分账

2539
01:32:11,866 --> 01:32:13,466
那如果退款被取消了

2540
01:32:13,466 --> 01:32:15,133
分账的退款也会被取消

2541
01:32:15,133 --> 01:32:17,533
所以这里会到这里来啊

2542
01:32:17,533 --> 01:32:20,966
然后如果说他去做这个分账的话啊

2543
01:32:20,966 --> 01:32:22,099
他去做这个分账的

2544
01:32:22,100 --> 01:32:23,700
话那分账的话

2545
01:32:23,700 --> 01:32:26,666
他就会去调这个退款分账的API

2546
01:32:26,666 --> 01:32:28,766
然后这边会完成

2547
01:32:28,766 --> 01:32:29,933
后面这个是一样的

2548
01:32:30,000 --> 01:32:31,800
这边如果说是失败的话

2549
01:32:31,800 --> 01:32:33,333
他就会到这个退回失败

2550
01:32:33,500 --> 01:32:35,133
这样的一个分账交易

2551
01:32:35,533 --> 01:32:37,733
最后是这个调账的部分

2552
01:32:38,000 --> 01:32:39,300
如果对账出错了

2553
01:32:39,300 --> 01:32:40,500
会记到这个内集里头

2554
01:32:40,500 --> 01:32:41,400
对象里头啊

2555
01:32:41,400 --> 01:32:43,266
所以他都会记成未处理

2556
01:32:43,266 --> 01:32:45,399
然后我们就不管他怎么调了

2557
01:32:45,500 --> 01:32:46,733
最后如果他调完了以后

2558
01:32:46,733 --> 01:32:48,199
把标成已调账

2559
01:32:48,533 --> 01:32:50,733
这就是支付状态的

2560
01:32:50,733 --> 01:32:53,099
这个他的数据库设计

2561
01:32:53,100 --> 01:32:55,500
基本上跟领域模型的设计是一致的

2562
01:32:55,500 --> 01:32:57,066
这个我们就不多讲

2563
01:32:57,066 --> 01:32:58,599
因为这个相对比较简单啊

2564
01:32:58,600 --> 01:32:59,933
虽然看起来东西很多

2565
01:33:00,300 --> 01:33:01,700
相对比较简单

2566
01:33:03,066 --> 01:33:03,999
物流模块

2567
01:33:04,000 --> 01:33:07,200
物流模块是今年的这个b座了

2568
01:33:07,300 --> 01:33:09,466
我们把它调成了b座的部分

2569
01:33:09,466 --> 01:33:13,733
那它主要的目的就是为了描述说

2570
01:33:14,766 --> 01:33:16,733
商铺的物流是怎么发出去的

2571
01:33:16,766 --> 01:33:18,866
以及它怎么通过第三方的平台

2572
01:33:18,866 --> 01:33:20,566
来完成这样一个物流的

2573
01:33:21,266 --> 01:33:21,333
啊

2574
01:33:21,333 --> 01:33:23,933
这个我综合了几位同学的几个小组的

2575
01:33:23,933 --> 01:33:25,466
这个呃

2576
01:33:25,466 --> 01:33:27,566
领域模型和去年的领域模型啊

2577
01:33:29,566 --> 01:33:30,766
这个我们之前没讲过啊

2578
01:33:30,766 --> 01:33:31,866
之前是选做的呀

2579
01:33:32,700 --> 01:33:34,400
这个是之前是选做的嘛

2580
01:33:34,400 --> 01:33:36,133
我们之前只讲过b做的

2581
01:33:37,100 --> 01:33:38,166
之前其实也有

2582
01:33:38,200 --> 01:33:40,066
就是去年也有啊

2583
01:33:40,066 --> 01:33:42,899
但是去年的这个基础上头

2584
01:33:42,900 --> 01:33:44,066
做了一点点改动

2585
01:33:46,566 --> 01:33:47,699
所以选做部分题

2586
01:33:47,700 --> 01:33:51,333
会根据这个API来做

2587
01:33:51,333 --> 01:33:52,066
它的对应的

2588
01:33:52,066 --> 01:33:54,733
这个对象模型和数据库的设计

2589
01:33:54,733 --> 01:33:55,766
那这个部分来说呢

2590
01:33:55,766 --> 01:33:57,466
我们就不放到作业里头去做了

2591
01:33:57,733 --> 01:33:58,199
这个部分呢

2592
01:33:58,200 --> 01:34:00,566
我们就在b座任务里头去做啊

2593
01:34:00,566 --> 01:34:01,166
就是这个部分

2594
01:34:01,166 --> 01:34:02,766
是在b座任务中间去做的

2595
01:34:03,800 --> 01:34:06,400
呃他的这个领域模型我们只做

2596
01:34:06,400 --> 01:34:08,266
了他的领域模型没有做他对象模型

2597
01:34:08,266 --> 01:34:10,499
这个交给后面的b座任务去做

2598
01:34:10,900 --> 01:34:12,333
那他的领域里头

2599
01:34:12,333 --> 01:34:15,766
主要描述的是商物流平台

2600
01:34:17,066 --> 01:34:17,866
运单

2601
01:34:18,366 --> 01:34:21,299
但是物流和运单不是直接有关系的

2602
01:34:21,400 --> 01:34:24,866
因为这个物流的内涵

2603
01:34:24,866 --> 01:34:26,333
这个概念的内涵是什么

2604
01:34:26,333 --> 01:34:29,733
是我们平台所支持的物流

2605
01:34:29,966 --> 01:34:30,599
因为我们知道

2606
01:34:30,600 --> 01:34:32,333
我们平台每要支持一个物流

2607
01:34:32,333 --> 01:34:33,933
都需要去开发对应的代码

2608
01:34:34,466 --> 01:34:37,566
都需要在这个物流公司去登记

2609
01:34:37,566 --> 01:34:39,199
说他的我们的用户名

2610
01:34:39,200 --> 01:34:40,000
我们的ID

2611
01:34:40,300 --> 01:34:42,866
因为我们要用我们这个登记的

2612
01:34:42,866 --> 01:34:44,533
这个平台的应用ID

2613
01:34:44,533 --> 01:34:45,733
去调查的API

2614
01:34:46,133 --> 01:34:49,666
才能查到这个平台上面的所有的物流

2615
01:34:49,966 --> 01:34:52,299
所以技术上头

2616
01:34:52,300 --> 01:34:53,733
我们要开发这部分代码

2617
01:34:54,366 --> 01:34:54,899
业务上头

2618
01:34:54,900 --> 01:34:57,500
我们要去那个物流公司去登记这个API

2619
01:34:57,566 --> 01:34:58,533
两个事情做到以后

2620
01:34:58,533 --> 01:35:00,333
我们才能在我们的平台中间

2621
01:35:00,333 --> 01:35:02,866
让所有的商户来使用这个

2622
01:35:02,933 --> 01:35:04,466
我们平台的物流功能

2623
01:35:04,733 --> 01:35:08,066
所以这个其实描述的是我们的平台

2624
01:35:08,066 --> 01:35:11,099
技术上头支持的物流公司

2625
01:35:11,800 --> 01:35:14,100
那对于每一个商铺来说

2626
01:35:14,100 --> 01:35:15,333
我们的这个概念

2627
01:35:15,333 --> 01:35:17,666
商铺物流这个概念描述的是什么呢

2628
01:35:17,800 --> 01:35:19,500
描述的是这个商铺

2629
01:35:19,666 --> 01:35:22,066
他所选择的物流公司

2630
01:35:22,266 --> 01:35:23,999
也许我们的平台做的很强大

2631
01:35:24,000 --> 01:35:25,400
描述了二三十家物流公司

2632
01:35:25,400 --> 01:35:26,900
都能从技术上支持

2633
01:35:27,200 --> 01:35:28,733
但对于每一个商铺来说

2634
01:35:28,733 --> 01:35:31,399
他不会去跟所有的物流公司去签约

2635
01:35:31,400 --> 01:35:33,766
因为他也没办法去跟所有的物流公司

2636
01:35:33,766 --> 01:35:35,599
去签那个月结的约

2637
01:35:35,600 --> 01:35:36,666
那个太贵了

2638
01:35:36,900 --> 01:35:38,566
所以他通常会选择一家

2639
01:35:38,566 --> 01:35:40,466
或者两家物流公司去签约

2640
01:35:40,800 --> 01:35:42,266
所以这一个概念

2641
01:35:42,266 --> 01:35:46,099
描述的就是商铺签约的物流公司

2642
01:35:46,100 --> 01:35:48,800
当然这些签约的物流公司应该是我们

2643
01:35:48,800 --> 01:35:50,266
平台所支持的物流公司

2644
01:35:50,266 --> 01:35:51,266
你跟我们的平台

2645
01:35:51,266 --> 01:35:53,333
不支持那些物流公司去签约的话

2646
01:35:53,700 --> 01:35:55,466
我们的平台肯定没办法帮你发快递

2647
01:35:55,466 --> 01:35:56,133
是吧所以说

2648
01:35:56,133 --> 01:35:57,933
他在我们的平台

2649
01:35:57,933 --> 01:35:59,199
支持物流公司的范围内

2650
01:35:59,200 --> 01:36:01,400
去选择一些物流公司去签约

2651
01:36:01,600 --> 01:36:03,666
所以这个概念里头所描述的属性

2652
01:36:03,666 --> 01:36:05,499
就是他签约了以后

2653
01:36:06,100 --> 01:36:09,000
他的用户名和ID是多少

2654
01:36:09,166 --> 01:36:12,266
因为在这个里头去发快递的时候

2655
01:36:12,266 --> 01:36:15,199
是用他的用户名和ID去发的快递

2656
01:36:15,266 --> 01:36:18,099
而不是用的平台的用户名和ID去查

2657
01:36:18,100 --> 01:36:18,900
发的快递

2658
01:36:19,200 --> 01:36:21,566
我们查的时候是可以用平台去查

2659
01:36:21,700 --> 01:36:24,666
但是涉及到费用的结算的时候

2660
01:36:24,900 --> 01:36:26,366
发快递的时候

2661
01:36:26,366 --> 01:36:28,766
就必须要用商户的这个用户名和ID

2662
01:36:28,766 --> 01:36:33,866
去去发这个是这个部分啊

2663
01:36:33,866 --> 01:36:34,999
就是这个概念

2664
01:36:35,333 --> 01:36:37,133
所以我们所有的运单

2665
01:36:37,133 --> 01:36:40,866
都是用用户的这个概念发出去的运单

2666
01:36:41,100 --> 01:36:42,866
而不是平台发出去的运单

2667
01:36:42,866 --> 01:36:44,199
平台其实不发运单

2668
01:36:44,366 --> 01:36:46,533
是商户在发运单啊

2669
01:36:46,533 --> 01:36:49,366
所以所有的运单

2670
01:36:49,366 --> 01:36:52,299
这就是所有的真正发出去的运单

2671
01:36:52,300 --> 01:36:54,333
也就是我们真正的包啊

2672
01:36:54,333 --> 01:36:55,733
这其实就是同一个概念

2673
01:36:55,733 --> 01:36:56,899
因为运单就是包裹

2674
01:36:56,900 --> 01:36:57,966
包裹就是运单啊

2675
01:36:57,966 --> 01:36:59,199
就是同一个东西

2676
01:36:59,533 --> 01:37:00,966
所有的这些运单

2677
01:37:00,966 --> 01:37:05,599
都是属于商铺的某一个账号

2678
01:37:05,600 --> 01:37:08,300
他从这个账号啊发出去的这个运单

2679
01:37:08,300 --> 01:37:10,966
这是下面的这三个概念

2680
01:37:11,466 --> 01:37:12,799
这个是商铺的仓库

2681
01:37:12,800 --> 01:37:13,466
一个商铺呢

2682
01:37:13,466 --> 01:37:14,799
可以定义多个仓库

2683
01:37:15,133 --> 01:37:19,166
那每一个仓库他会负责发一地街地区

2684
01:37:19,166 --> 01:37:20,599
所以这是个一对多的关

2685
01:37:20,600 --> 01:37:22,200
多对多的关系啊

2686
01:37:22,200 --> 01:37:24,200
因为一个商铺可以负责发很多地区

2687
01:37:24,200 --> 01:37:27,933
一个地区可以由不同商户的很多商铺

2688
01:37:28,100 --> 01:37:30,466
所以地区这个概念就会带很多的

2689
01:37:30,466 --> 01:37:34,099
是个多又多的关系这个部分来说啊

2690
01:37:34,566 --> 01:37:35,499
这个部分来说

2691
01:37:35,500 --> 01:37:36,500
我们可以看到

2692
01:37:36,533 --> 01:37:38,666
我们这里会要去描述说

2693
01:37:38,800 --> 01:37:42,700
用户的仓库到底要用哪些物流

2694
01:37:43,400 --> 01:37:44,566
这个他可以去描述

2695
01:37:44,566 --> 01:37:46,799
所以一个仓库会描述多个物流

2696
01:37:46,933 --> 01:37:47,599
但多个物流

2697
01:37:47,600 --> 01:37:49,500
可以用在商户的不同仓库上

2698
01:37:49,900 --> 01:37:51,566
所以这变成一个多对多的啊

2699
01:37:51,566 --> 01:37:52,566
所以这里会比较麻烦

2700
01:37:52,566 --> 01:37:53,866
大家会发现这是多对多的

2701
01:37:53,866 --> 01:37:54,866
这是多对多的

2702
01:37:55,366 --> 01:37:56,366
这也是多对多的

2703
01:37:56,366 --> 01:37:57,466
这个描述什么呢

2704
01:37:57,466 --> 01:38:00,666
这个描述说我的商户的这个物流

2705
01:38:00,666 --> 01:38:04,366
到底哪些区域当前是不能发货的

2706
01:38:04,800 --> 01:38:05,866
就是我们说的

2707
01:38:06,200 --> 01:38:08,000
我不能发货的地区是什么

2708
01:38:08,066 --> 01:38:10,799
这个完全就是因为自然灾害的原因

2709
01:38:10,800 --> 01:38:13,300
造成说某一段短时间之内

2710
01:38:13,500 --> 01:38:15,400
这一地区是不能发货的

2711
01:38:15,400 --> 01:38:18,066
那这个设定就会直接影响到我们

2712
01:38:18,066 --> 01:38:18,933
在界面上的

2713
01:38:18,933 --> 01:38:20,899
去买这个商品的时候

2714
01:38:21,133 --> 01:38:24,133
你进去发现该地区无法配送

2715
01:38:24,600 --> 01:38:25,466
就伸过来了

2716
01:38:25,800 --> 01:38:27,600
因为商户有设定了

2717
01:38:27,600 --> 01:38:28,933
说我在某些地区

2718
01:38:28,933 --> 01:38:30,699
短时间之内是不能发货的

2719
01:38:30,800 --> 01:38:32,300
所以最后就会影响到说

2720
01:38:32,300 --> 01:38:33,933
你在商品界面上的看到

2721
01:38:34,333 --> 01:38:37,866
因为你的顾客的配送地址的那个原因

2722
01:38:37,866 --> 01:38:41,333
造成该地区是无法配送的啊

2723
01:38:41,366 --> 01:38:42,799
这是这么来的

2724
01:38:48,933 --> 01:38:49,999
仓库第三个属性

2725
01:38:50,000 --> 01:38:50,566
这个是啊

2726
01:38:50,566 --> 01:38:51,366
优先级啊

2727
01:38:51,866 --> 01:38:53,299
啊这个是有效无效

2728
01:38:54,766 --> 01:38:56,766
这个是仓库要有联系人啊

2729
01:38:57,400 --> 01:38:58,500
你的仓库要发货

2730
01:38:58,500 --> 01:39:00,300
他的出货的地址

2731
01:39:00,300 --> 01:39:02,333
出货的发件人就这个地方

2732
01:39:02,400 --> 01:39:04,800
这是联系人啊

2733
01:39:04,800 --> 01:39:07,133
CASANE联系人啊

2734
01:39:09,533 --> 01:39:12,066
这是我们的这个物流指令啊

2735
01:39:12,066 --> 01:39:12,866
因为快下课了

2736
01:39:12,866 --> 01:39:15,933
我们就地区就不讲了啊

2737
01:39:15,933 --> 01:39:17,499
那地区其实很简单

2738
01:39:17,500 --> 01:39:18,700
大家一看就知道

2739
01:39:19,600 --> 01:39:20,700
我把地区讲完吧

2740
01:39:21,933 --> 01:39:22,399
地区很简单

2741
01:39:22,400 --> 01:39:22,966
地区一个概念

2742
01:39:22,966 --> 01:39:26,466
就地区这个地区是用了国家标准的

2743
01:39:26,466 --> 01:39:27,366
地理数据

2744
01:39:27,666 --> 01:39:29,666
所以每一个东西都有它的名字

2745
01:39:29,666 --> 01:39:31,299
拼音经纬度啊

2746
01:39:31,466 --> 01:39:33,099
然后就一个对象

2747
01:39:33,733 --> 01:39:35,799
然后他有一个状态

2748
01:39:35,800 --> 01:39:36,766
这个是一看就知道

2749
01:39:36,766 --> 01:39:38,399
我们会把某些地区暂时废弃

2750
01:39:38,400 --> 01:39:40,333
因为国家的地区会什么呢

2751
01:39:40,333 --> 01:39:42,499
会调整就是某些区啊

2752
01:39:42,500 --> 01:39:43,133
会合并啊

2753
01:39:43,133 --> 01:39:43,866
会新增啊

2754
01:39:43,866 --> 01:39:46,133
所以说这个就是会做下这个东西

2755
01:39:47,366 --> 01:39:48,299
然后其他的没啥

2756
01:39:48,300 --> 01:39:49,000
这就是地区

2757
01:39:49,000 --> 01:39:50,533
这张这个就是我们独立一个模块

2758
01:39:50,533 --> 01:39:51,466
这模块只有一张表

2759
01:39:51,466 --> 01:39:52,333
只有一个对象

2760
01:39:52,466 --> 01:39:54,533
因为他会被所有的模块公用

2761
01:39:54,566 --> 01:39:56,566
所以我们就给他独立成了一个模块

2762
01:39:56,933 --> 01:39:58,333
好我们今天就到这里

