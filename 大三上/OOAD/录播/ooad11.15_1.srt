1
00:02:16,666 --> 00:02:17,466
好

2
00:02:17,933 --> 00:02:19,366
呃星期一

3
00:02:19,366 --> 00:02:23,866
我们讲完了支付模块的一部分内容

4
00:02:24,200 --> 00:02:26,100
然后上完课以后

5
00:02:26,466 --> 00:02:27,766
那个同学们

6
00:02:27,800 --> 00:02:30,566
有同学跟我反映说这部分太难了

7
00:02:30,566 --> 00:02:32,699
完全跟不上啊

8
00:02:32,700 --> 00:02:34,933
听不懂这在讲什么

9
00:02:35,933 --> 00:02:36,799
确实是啊

10
00:02:36,800 --> 00:02:38,366
就是呃

11
00:02:38,366 --> 00:02:41,299
我们进入到这个详细设计阶段以后

12
00:02:41,300 --> 00:02:43,400
其实大家知道要做设计

13
00:02:43,400 --> 00:02:45,000
要做出一个设计来

14
00:02:45,000 --> 00:02:48,000
其实是由多方面的因素所决定的

15
00:02:48,500 --> 00:02:51,000
第一你要首先最基本的

16
00:02:51,000 --> 00:02:56,000
你要首先会用UML去描述你的设计啊

17
00:02:56,000 --> 00:03:00,000
所以你如果对UML的这些图都不会用

18
00:03:00,000 --> 00:03:01,266
或者看不懂的话

19
00:03:01,266 --> 00:03:02,333
你就是个哑巴

20
00:03:02,933 --> 00:03:05,666
你什么就算是你有再好的设计啊

21
00:03:05,666 --> 00:03:07,133
你也说不出来

22
00:03:07,366 --> 00:03:08,666
也描述不出来

23
00:03:08,900 --> 00:03:10,466
这是第一啊

24
00:03:10,566 --> 00:03:14,566
第二是你要有这个掌握了设计方法

25
00:03:14,866 --> 00:03:17,466
因为你会了UML

26
00:03:17,500 --> 00:03:19,100
知道UML怎么去描述

27
00:03:19,100 --> 00:03:22,933
但是你如果不知道怎么去设计

28
00:03:23,333 --> 00:03:25,799
你实际上是说不出来任何东西的

29
00:03:25,800 --> 00:03:26,600
也就是说

30
00:03:26,666 --> 00:03:27,466
你不会知道

31
00:03:27,466 --> 00:03:28,799
说一个设计是一个好的设计

32
00:03:28,800 --> 00:03:30,933
或者是一个设计是个坏的设计啊

33
00:03:30,933 --> 00:03:33,699
所以你要掌握基本的设计方法

34
00:03:33,866 --> 00:03:34,799
那第三是

35
00:03:34,800 --> 00:03:37,333
设计其实是依赖于特定的技术架构的

36
00:03:37,500 --> 00:03:40,066
他不可能脱离特定的技术架构

37
00:03:40,066 --> 00:03:42,366
去谈说这个设计是个什么样的

38
00:03:42,966 --> 00:03:43,866
所以你需要了解

39
00:03:43,866 --> 00:03:46,199
你设计所依赖的这个技术架构

40
00:03:46,466 --> 00:03:47,533
那在这个学习中间

41
00:03:47,533 --> 00:03:48,566
我们的整个设计

42
00:03:48,566 --> 00:03:52,066
都是基于这个Supreme的架构的

43
00:03:52,300 --> 00:03:54,933
所以你如果对Supreme的架构不熟悉

44
00:03:55,566 --> 00:03:56,366
不要说

45
00:03:56,366 --> 00:03:59,266
你去做出在这个架构上面的一个设计

46
00:03:59,400 --> 00:04:01,333
你去理解这个上面的这个设计

47
00:04:01,333 --> 00:04:02,699
为什么这么去设计

48
00:04:02,900 --> 00:04:03,933
都会很困难

49
00:04:04,166 --> 00:04:06,133
所以为什么大家进入到

50
00:04:06,333 --> 00:04:07,866
就是进入到这个星期

51
00:04:07,866 --> 00:04:09,533
陡然觉得这个问题

52
00:04:09,533 --> 00:04:12,533
变得比较听起来会比较难了

53
00:04:12,566 --> 00:04:13,866
原因就是因为

54
00:04:13,866 --> 00:04:16,666
要么是前面的这个UML的这个图

55
00:04:16,766 --> 00:04:17,999
没有掌握好

56
00:04:18,000 --> 00:04:19,266
所以你不了解说

57
00:04:19,266 --> 00:04:21,299
在这个图上画的东西是什么

58
00:04:21,533 --> 00:04:22,599
再一个就是

59
00:04:22,966 --> 00:04:23,799
大部分同学

60
00:04:23,800 --> 00:04:26,866
目前对于设计和对于技术架构来说

61
00:04:26,866 --> 00:04:28,199
都是不熟悉的

62
00:04:28,500 --> 00:04:31,200
所以会觉得看到这样的一个设计

63
00:04:31,200 --> 00:04:31,900
因为这些设计

64
00:04:31,900 --> 00:04:34,933
都是若干年的同学累积下来的啊

65
00:04:34,933 --> 00:04:37,499
这都是做到最后做到12月份的时候

66
00:04:37,733 --> 00:04:39,466
做的最好的那些同学

67
00:04:39,600 --> 00:04:42,000
累积下来的这些设计和实现

68
00:04:42,566 --> 00:04:43,366
那当然

69
00:04:43,400 --> 00:04:47,266
在大家目前这个阶段去看两个月以后

70
00:04:47,466 --> 00:04:49,333
整个年纪段最好的一批同学

71
00:04:49,333 --> 00:04:50,399
做出来的东西

72
00:04:50,666 --> 00:04:52,133
肯定是有差距的啊

73
00:04:52,133 --> 00:04:55,566
这个是肯定是是是客观存在的

74
00:04:55,566 --> 00:04:57,466
但是没关系啊

75
00:04:57,466 --> 00:04:58,333
慢慢的来

76
00:04:58,533 --> 00:05:00,566
所以呃

77
00:05:00,566 --> 00:05:01,966
努力去理解

78
00:05:01,966 --> 00:05:04,799
说我每就是从至少从这一周开始

79
00:05:05,200 --> 00:05:06,733
在面向对象这门课中间

80
00:05:06,733 --> 00:05:09,666
努力去理解我在每一堂课里讲的内容

81
00:05:09,666 --> 00:05:12,299
我为什么这门课我会去录课

82
00:05:12,800 --> 00:05:16,100
前面的部分录客的意义不太重要

83
00:05:16,100 --> 00:05:18,200
但是后面的部分的这个录客

84
00:05:18,200 --> 00:05:19,400
就变得很重要了

85
00:05:19,466 --> 00:05:22,699
因为其实对于大家目前的水平来说

86
00:05:22,700 --> 00:05:24,966
你很难在这个阶段

87
00:05:25,266 --> 00:05:27,866
能够完全听懂这个课程里的内容

88
00:05:28,333 --> 00:05:31,199
就是你从这个设计的能力上头

89
00:05:31,400 --> 00:05:32,766
从技术架构的手续上头

90
00:05:32,766 --> 00:05:35,333
其实都还没有达到说这个

91
00:05:35,333 --> 00:05:37,066
我现在讲的这个内容

92
00:05:37,066 --> 00:05:38,499
所以你很难百分之

93
00:05:38,500 --> 00:05:39,466
不说100%吧

94
00:05:39,466 --> 00:05:43,533
60%或者70%能抓到我所讲的这个内容

95
00:05:43,533 --> 00:05:44,533
都是挺困难的

96
00:05:44,866 --> 00:05:46,733
所以在之后啊

97
00:05:47,266 --> 00:05:48,466
大家去看录课

98
00:05:48,766 --> 00:05:50,733
然后去慢慢的理解

99
00:05:50,933 --> 00:05:52,766
这是第一个层面上

100
00:05:52,766 --> 00:05:56,533
就是你首先要能够理解说我在讲什么

101
00:05:56,800 --> 00:05:58,766
我为什么会要这样去做

102
00:05:58,766 --> 00:05:59,599
就是这个设计为

103
00:05:59,600 --> 00:06:01,533
什么会要这样去做这个设计

104
00:06:02,266 --> 00:06:03,899
那这只是理解层面的

105
00:06:03,933 --> 00:06:06,199
但是大家知道设计是要去动手的

106
00:06:06,666 --> 00:06:08,299
如果说你光说不练

107
00:06:08,300 --> 00:06:09,066
不去动手

108
00:06:09,066 --> 00:06:11,399
你是根本就没有办法去掌握

109
00:06:11,400 --> 00:06:12,400
设计的方法的

110
00:06:12,600 --> 00:06:14,000
这也是为什么我们这门课

111
00:06:14,000 --> 00:06:16,566
会要在前面做这么多必做的任务

112
00:06:17,100 --> 00:06:18,933
做b做的任务的过程

113
00:06:18,933 --> 00:06:20,666
其实就是我手把手的教你

114
00:06:21,000 --> 00:06:22,366
这个东西怎么做设计

115
00:06:22,400 --> 00:06:23,933
因为b做任务的部分

116
00:06:23,933 --> 00:06:24,533
大家可以看到

117
00:06:24,533 --> 00:06:25,466
在支付模块中间

118
00:06:25,466 --> 00:06:27,599
其实大的价值全部都搭出来了

119
00:06:27,866 --> 00:06:31,066
这里头设计里头是有问题的

120
00:06:31,066 --> 00:06:31,933
这些问题

121
00:06:32,333 --> 00:06:34,333
任何一个设计者在设计之初

122
00:06:34,666 --> 00:06:36,899
都不会100%的意识到

123
00:06:37,133 --> 00:06:40,166
你只有去把这个设计最后全部测试

124
00:06:40,166 --> 00:06:42,133
全部的代码都跑过去以后

125
00:06:42,733 --> 00:06:43,999
才会知道他的问题在哪

126
00:06:44,000 --> 00:06:45,066
才会去改进

127
00:06:45,066 --> 00:06:46,166
这样的一个测试

128
00:06:46,366 --> 00:06:48,533
所以如果大家

129
00:06:48,533 --> 00:06:51,566
想真正的去掌握设计的方法

130
00:06:51,866 --> 00:06:56,333
掌握用spin的框架去开发代码的技术

131
00:06:56,800 --> 00:06:57,700
需要动手

132
00:06:58,266 --> 00:07:00,666
无论是设计还是编码都需要去动手

133
00:07:00,900 --> 00:07:03,066
所以11月份的这个阶段

134
00:07:03,066 --> 00:07:05,999
我希望大家努力的去参与b座任务

135
00:07:06,200 --> 00:07:07,400
虽然有可能说

136
00:07:07,700 --> 00:07:10,133
因为b座任务的数目是有限的

137
00:07:10,266 --> 00:07:12,599
也有可能可能忙活了一个月下来

138
00:07:12,600 --> 00:07:15,300
可能很多必斗任务你交了

139
00:07:15,300 --> 00:07:16,600
但是没有被选中

140
00:07:16,966 --> 00:07:18,333
但是这个过程啊

141
00:07:18,333 --> 00:07:19,599
你其实你在做的过程中

142
00:07:19,600 --> 00:07:21,500
你自己会意识到自己很多问题

143
00:07:21,600 --> 00:07:22,466
然后你会看到

144
00:07:22,466 --> 00:07:24,366
选中的同学的必斗作业是什么样子

145
00:07:24,366 --> 00:07:25,666
他做出来是什么样子

146
00:07:25,733 --> 00:07:27,666
和我做的这个差别是什么

147
00:07:27,666 --> 00:07:28,599
然后去理解说

148
00:07:28,600 --> 00:07:31,933
为什么我会选这位同学的设计

149
00:07:31,933 --> 00:07:33,533
或者不选你的设计

150
00:07:33,600 --> 00:07:34,900
然后你如果有疑问

151
00:07:34,900 --> 00:07:38,400
你可以再这个来找我来讨论

152
00:07:38,666 --> 00:07:39,766
这个过程

153
00:07:39,766 --> 00:07:41,366
才能锻炼你的设计能力

154
00:07:41,366 --> 00:07:43,466
和动手编程的能力

155
00:07:43,600 --> 00:07:46,400
如果不去参与必做任务

156
00:07:46,733 --> 00:07:47,666
大家应该知道

157
00:07:47,666 --> 00:07:49,966
到12月份你去做选做任务的时候

158
00:07:50,400 --> 00:07:52,900
你基本上是动不了手的

159
00:07:53,700 --> 00:07:55,200
到11月份开始

160
00:07:55,200 --> 00:07:55,866
课程会

161
00:07:55,866 --> 00:07:57,733
就是我们设计的内容会陡然变难

162
00:07:57,733 --> 00:07:59,333
就是因为这个因素造成的

163
00:07:59,466 --> 00:08:00,933
这个难度的削米

164
00:08:00,933 --> 00:08:03,133
就要靠大家动手去做

165
00:08:03,133 --> 00:08:05,066
去理会去体会

166
00:08:05,100 --> 00:08:06,933
才能慢慢的这个解决

167
00:08:07,066 --> 00:08:07,866
那当然

168
00:08:08,333 --> 00:08:10,566
我也会尽量的把课程的内容

169
00:08:10,566 --> 00:08:12,299
给减慢一些啊

170
00:08:12,300 --> 00:08:13,266
星期一的课

171
00:08:13,266 --> 00:08:14,333
因为是第一次开始

172
00:08:14,333 --> 00:08:16,133
大规模的讲这个设计

173
00:08:16,366 --> 00:08:19,733
所以呃大部分同学跟我反映的都是

174
00:08:20,500 --> 00:08:21,366
跟不上了啊

175
00:08:21,366 --> 00:08:23,733
听不懂这在这在讲什么啊

176
00:08:23,733 --> 00:08:28,533
所以我把周一的课的后半部分

177
00:08:28,533 --> 00:08:31,499
就是特别涉及到设计模式的部分

178
00:08:31,600 --> 00:08:32,733
我再讲一遍

179
00:08:32,733 --> 00:08:33,866
因为我们在周一

180
00:08:33,866 --> 00:08:34,799
我在周一课时候

181
00:08:34,800 --> 00:08:37,900
其实没有特别去强调

182
00:08:37,900 --> 00:08:40,000
里头其实用到了多个设计模式

183
00:08:40,000 --> 00:08:40,866
因为设计模式

184
00:08:40,866 --> 00:08:43,699
是我们下学期的软件体系结构

185
00:08:43,700 --> 00:08:44,400
那门课里头

186
00:08:44,400 --> 00:08:45,400
会要讲到

187
00:08:45,800 --> 00:08:46,600
我们这门课里头

188
00:08:46,600 --> 00:08:48,300
因为这个设计做出来以后

189
00:08:48,600 --> 00:08:50,666
其实我们已经用了很多的设计模式

190
00:08:50,866 --> 00:08:52,166
但是我们在讲课时候

191
00:08:52,166 --> 00:08:54,399
我们不可能把这些设计模式全部剔掉

192
00:08:54,666 --> 00:08:56,533
然后去给大家讲简单的东西

193
00:08:56,533 --> 00:08:57,666
这个是一体的

194
00:08:57,866 --> 00:09:00,099
所以设计到这些设计模式的部分

195
00:09:00,100 --> 00:09:01,933
可能大家就更难以去理解了

196
00:09:01,933 --> 00:09:03,366
因为设计模式是成熟的

197
00:09:03,366 --> 00:09:04,799
更加复杂的设计

198
00:09:05,166 --> 00:09:06,066
不是简单的

199
00:09:06,066 --> 00:09:08,366
用创建者和信息专家

200
00:09:08,733 --> 00:09:10,333
就能解决的问题啊

201
00:09:10,333 --> 00:09:13,366
所以我把设计模式的内容

202
00:09:13,366 --> 00:09:14,699
虽然是在下期讲的

203
00:09:14,700 --> 00:09:15,800
但是我把这些内容

204
00:09:15,800 --> 00:09:18,366
就在我们这门课里头所用到的

205
00:09:18,366 --> 00:09:19,766
就是我们这个目前这个设计

206
00:09:19,766 --> 00:09:20,599
中间所用到的

207
00:09:20,600 --> 00:09:21,966
所有的设计模式

208
00:09:22,000 --> 00:09:23,733
我都给大家仔细的讲一遍

209
00:09:24,166 --> 00:09:26,266
然后让大家去理解

210
00:09:26,266 --> 00:09:27,199
说这个设计中间

211
00:09:27,200 --> 00:09:28,900
为什么会在这个地方

212
00:09:28,966 --> 00:09:31,066
要用这样的一个设计模式啊

213
00:09:32,066 --> 00:09:34,133
啊所以周一的课的前半部分

214
00:09:34,166 --> 00:09:35,299
就是这个创建者

215
00:09:35,300 --> 00:09:36,666
信息专家的这个部分来说

216
00:09:36,666 --> 00:09:38,166
应该是相对比较简单的啊

217
00:09:38,166 --> 00:09:40,699
大家知道这两个方法关锁的方法

218
00:09:40,700 --> 00:09:43,566
其实主要解决的是谁创建谁

219
00:09:43,566 --> 00:09:47,399
我们通常是用组合关系啊

220
00:09:47,400 --> 00:09:49,400
基本上是基于组合关系

221
00:09:50,000 --> 00:09:51,900
去看整体和局部的关系

222
00:09:51,900 --> 00:09:53,000
去决定说一些东西

223
00:09:53,000 --> 00:09:54,933
去创建另外一个东西

224
00:09:54,933 --> 00:09:56,966
所以我们在前面的这个设计中间

225
00:09:56,966 --> 00:09:58,899
我们用啊

226
00:09:58,900 --> 00:10:03,766
支付渠道去创建我们商铺的支付渠道

227
00:10:03,900 --> 00:10:06,500
那信息专家就是更广泛的应用了

228
00:10:07,300 --> 00:10:09,200
他其实所说的中心的问题

229
00:10:09,533 --> 00:10:11,399
就是面向对象的封装性

230
00:10:11,933 --> 00:10:13,899
就是我们在这些对象中间

231
00:10:13,900 --> 00:10:14,800
是要有方法的

232
00:10:14,800 --> 00:10:17,700
这些方法是去访问自己的属性的

233
00:10:17,800 --> 00:10:19,300
因为我们前面在领域模型中间

234
00:10:19,300 --> 00:10:22,600
给这些给这些对象设定了他的属性

235
00:10:23,066 --> 00:10:25,499
所以当我们去做代码的时候

236
00:10:25,500 --> 00:10:27,700
我们要把这些跟这些属性有关的代码

237
00:10:27,700 --> 00:10:31,366
封装在这个对象的方法里头啊

238
00:10:31,366 --> 00:10:33,566
说是面向对象最基本的特性

239
00:10:33,800 --> 00:10:36,200
所以信息专家的这个这个方法

240
00:10:36,200 --> 00:10:37,333
其实就是在做出来

241
00:10:37,333 --> 00:10:39,799
面向对象最基本的这个封装性啊

242
00:10:39,800 --> 00:10:42,000
如果一个面向对象是没有封装性的

243
00:10:42,333 --> 00:10:42,999
那这个对象

244
00:10:43,000 --> 00:10:43,533
这个设计

245
00:10:43,533 --> 00:10:46,299
肯定就不是一个面向对象的设计了

246
00:10:46,300 --> 00:10:48,600
啊这是面向对象设计的最基本特征

247
00:10:48,600 --> 00:10:50,533
就是靠封装信

248
00:10:50,533 --> 00:10:53,399
靠信息专家这个方法来完成的

249
00:10:53,400 --> 00:10:56,333
所以这两个来说相对比较简单一点

250
00:10:57,066 --> 00:10:59,899
那我从后面相对比较难的

251
00:11:00,166 --> 00:11:01,499
这几个方法啊

252
00:11:01,500 --> 00:11:02,300
再把

253
00:11:02,400 --> 00:11:04,600
里头的一些内容给它补充了一下

254
00:11:04,766 --> 00:11:08,266
然后把我们在周一时候讲的一些错误

255
00:11:08,266 --> 00:11:09,499
给它纠正了一下

256
00:11:09,700 --> 00:11:11,400
然后我们再把它重讲一遍

257
00:11:12,100 --> 00:11:15,200
第一个是这个多肽的方法

258
00:11:15,566 --> 00:11:17,999
多肽的方法其实要解决的问题

259
00:11:18,000 --> 00:11:19,400
在我们这个设计中间

260
00:11:19,400 --> 00:11:22,100
就是我们支付退款支付分账

261
00:11:22,166 --> 00:11:25,299
退款分账这四个交易中间是有共性的

262
00:11:25,500 --> 00:11:26,300
我们可以看到

263
00:11:26,300 --> 00:11:27,100
从对象模型中间

264
00:11:27,100 --> 00:11:29,400
他看到他有共同的属性

265
00:11:29,933 --> 00:11:32,399
对吧那其实基于共同的属性

266
00:11:32,400 --> 00:11:33,800
就会有共同的行为

267
00:11:33,933 --> 00:11:34,666
因为我们刚才说了

268
00:11:34,666 --> 00:11:35,699
我们是有封装性的

269
00:11:35,700 --> 00:11:36,466
我们要把代码

270
00:11:36,466 --> 00:11:39,699
封装到这些对象的方法里头

271
00:11:39,900 --> 00:11:41,733
那这些代码是访问他的属性的

272
00:11:41,733 --> 00:11:44,566
既然这4个交易是有共性的属性的

273
00:11:44,600 --> 00:11:47,066
那他肯定基于这些共性的属性

274
00:11:47,533 --> 00:11:49,166
是有共同的行为的

275
00:11:49,166 --> 00:11:50,366
是有共同的方法的

276
00:11:50,366 --> 00:11:52,733
我们把这些共性的行为

277
00:11:53,333 --> 00:11:56,099
把它放到他的附类里头

278
00:11:56,333 --> 00:11:59,733
而把他不同的行为放到他的子类里头

279
00:11:59,800 --> 00:12:01,300
这个是我们在面向对象中间

280
00:12:01,300 --> 00:12:03,200
一个最基本的操作

281
00:12:03,400 --> 00:12:05,566
就是用多态的方式

282
00:12:05,566 --> 00:12:06,799
用继承的方式

283
00:12:06,966 --> 00:12:10,099
去实现不同的类型的行为

284
00:12:10,400 --> 00:12:12,566
所以在这个对象模型中间啊

285
00:12:12,566 --> 00:12:13,699
大家可以看到

286
00:12:14,466 --> 00:12:18,266
我们在transaction下面是有4个子类的

287
00:12:18,400 --> 00:12:19,300
这个主要的原因

288
00:12:19,300 --> 00:12:20,366
就是因为我们在对象中

289
00:12:20,366 --> 00:12:21,466
它是有相同的属性

290
00:12:21,466 --> 00:12:22,799
而因为这些相同的属性

291
00:12:22,800 --> 00:12:24,600
就我们看到了这些相同的属性

292
00:12:24,900 --> 00:12:27,666
它其实是有蛮多的相同的行为的

293
00:12:28,200 --> 00:12:29,966
那在代码中间啊

294
00:12:29,966 --> 00:12:34,366
我们所看到的在trashocking中间的行为

295
00:12:34,533 --> 00:12:35,999
是些什么样的行为呢

296
00:12:36,666 --> 00:12:38,566
我们切到代码中间来看一下

297
00:12:43,800 --> 00:12:44,866
这是我们的

298
00:12:49,500 --> 00:12:51,700
这是我们的transaction的这个类

299
00:12:51,733 --> 00:12:53,766
那共性的属性是写在这个里面

300
00:12:53,766 --> 00:12:54,399
了

301
00:12:54,400 --> 00:12:56,733
然后因为有这些共性区属性的存在

302
00:12:56,733 --> 00:12:59,699
我们就会写很多共性的方法

303
00:12:59,800 --> 00:13:01,000
不多不太多啊

304
00:13:01,000 --> 00:13:04,000
但是基本上是基于这些共性的属性啊

305
00:13:04,000 --> 00:13:05,500
所形成的方法

306
00:13:05,500 --> 00:13:07,500
我们重要的主要讲

307
00:13:07,500 --> 00:13:09,866
其中的一个比较有业务的方法

308
00:13:10,000 --> 00:13:11,000
是一个什么方法呢

309
00:13:11,000 --> 00:13:11,333
就是

310
00:13:11,333 --> 00:13:14,166
我们其实在所有有状态的对象上头

311
00:13:14,666 --> 00:13:16,333
都有这样的一个方法

312
00:13:16,333 --> 00:13:20,766
叫做是否允允许状态迁移

313
00:13:21,100 --> 00:13:22,166
这样的一个方法

314
00:13:22,400 --> 00:13:25,700
这个方法其实不仅仅是在这里

315
00:13:25,866 --> 00:13:28,899
基本上我们所有有状态的对象里头

316
00:13:29,100 --> 00:13:30,600
都有写了这个方法

317
00:13:30,933 --> 00:13:32,133
那因为面向对象

318
00:13:32,133 --> 00:13:33,733
就是交往的面向对象来说

319
00:13:33,733 --> 00:13:35,399
他是不允许多继承的

320
00:13:35,533 --> 00:13:36,899
因为我们并不是所有对象

321
00:13:36,900 --> 00:13:39,266
都是有状态的

322
00:13:39,333 --> 00:13:42,899
所以我们没有办法把这一个方法

323
00:13:42,933 --> 00:13:45,499
写到它的积累上去

324
00:13:45,500 --> 00:13:46,733
它这个上面其实还有个积累

325
00:13:46,733 --> 00:13:48,099
叫做or more object

326
00:13:48,333 --> 00:13:49,666
因为or more object里头

327
00:13:49,666 --> 00:13:51,266
并不是所有的对象都是有状态的

328
00:13:51,266 --> 00:13:53,799
只有一少部分对象是有状态的

329
00:13:53,800 --> 00:13:56,166
那恰巧在我们的4个交易

330
00:13:56,166 --> 00:13:57,466
这4对象中间

331
00:13:57,933 --> 00:14:00,066
四个交易都是有状态的

332
00:14:00,066 --> 00:14:01,766
我们的状态基图啊

333
00:14:02,966 --> 00:14:03,899
大家看一下

334
00:14:09,066 --> 00:14:10,299
我们的状态截图

335
00:14:11,066 --> 00:14:13,099
是有放到了这个设计文档中间

336
00:14:13,100 --> 00:14:13,666
顺便说一下

337
00:14:13,666 --> 00:14:15,966
这个设计文档昨晚上我把它更新到了

338
00:14:16,266 --> 00:14:18,799
就是大家在这个模块里面

339
00:14:18,800 --> 00:14:22,266
最后要教的文档的状况啊

340
00:14:22,266 --> 00:14:24,199
大家在这个这个题作业中间

341
00:14:24,200 --> 00:14:25,733
其实做到了前半段

342
00:14:26,533 --> 00:14:27,899
就是做完他的状态图

343
00:14:27,900 --> 00:14:29,466
数据库设计对象模型设计

344
00:14:29,766 --> 00:14:33,166
第五部分其实是在上个月没有做的

345
00:14:33,166 --> 00:14:34,799
那下一轮的作业

346
00:14:34,866 --> 00:14:36,933
就是大家的两个选作模块

347
00:14:36,933 --> 00:14:40,099
需要交两份这样的文档

348
00:14:40,200 --> 00:14:43,100
那每一份文档就是在这一次作业的基

349
00:14:43,100 --> 00:14:43,533
础上头

350
00:14:43,533 --> 00:14:46,366
因为之前大家做的这个对象模型

351
00:14:46,366 --> 00:14:47,299
数据库设计

352
00:14:47,300 --> 00:14:48,566
包括状态

353
00:14:49,400 --> 00:14:51,700
会在下一次做的过程中间发生改变

354
00:14:51,700 --> 00:14:53,100
所以改变了要去更新

355
00:14:53,266 --> 00:14:54,399
我们在这一次

356
00:14:54,400 --> 00:14:55,300
其实跟我在上一层

357
00:14:55,300 --> 00:14:56,166
大家说他的状态时候

358
00:14:56,166 --> 00:14:57,366
我是有做了改变的啊

359
00:14:57,366 --> 00:14:58,399
所以待会仔细说

360
00:14:58,566 --> 00:15:01,866
然后再会加上他的设计逻辑

361
00:15:04,533 --> 00:15:05,266
这个部分啊

362
00:15:05,266 --> 00:15:05,766
大家可以看到

363
00:15:05,766 --> 00:15:09,366
大量的是在用我们的静态模型的类图

364
00:15:09,366 --> 00:15:10,799
动态模型的顺序图

365
00:15:10,900 --> 00:15:12,566
去描述我们的逻辑的

366
00:15:12,733 --> 00:15:16,133
这一部分在整个课程成绩中间

367
00:15:16,133 --> 00:15:19,266
大概会占到70%以上的成绩

368
00:15:19,666 --> 00:15:22,399
也就是我们前面花了半个学期

369
00:15:22,400 --> 00:15:24,533
所讲的所有的内容

370
00:15:24,700 --> 00:15:26,900
在整体的这个课程的成绩

371
00:15:26,900 --> 00:15:28,300
无论是在课程设计里头

372
00:15:28,533 --> 00:15:31,566
还是在我们的期末考试里头

373
00:15:31,566 --> 00:15:34,499
都只占到了30%以下的内容

374
00:15:34,866 --> 00:15:38,533
70%以上的内容其实都是从这一周开始

375
00:15:39,166 --> 00:15:40,999
我们所讲的内容

376
00:15:41,000 --> 00:15:43,800
其实都在剩下的70%里头

377
00:15:43,866 --> 00:15:45,133
那这个文档中间

378
00:15:45,133 --> 00:15:45,799
大家可以看到

379
00:15:45,800 --> 00:15:46,933
后面部分所提交的

380
00:15:46,933 --> 00:15:51,366
就是我们关于各个问题的设计是什么

381
00:15:51,866 --> 00:15:52,566
而这些设计

382
00:15:52,566 --> 00:15:56,066
就是用我们的静态模型和动态模型

383
00:15:56,066 --> 00:15:57,366
静态模型就是类图

384
00:15:57,566 --> 00:16:01,399
动态模型就是我们的顺序图去描述的

385
00:16:01,400 --> 00:16:03,733
当然因为我在这里我没有写文字

386
00:16:03,800 --> 00:16:04,700
如果说

387
00:16:04,933 --> 00:16:08,066
如果大家觉得这种图不足以描述的话

388
00:16:08,166 --> 00:16:09,366
你们去写文字

389
00:16:09,900 --> 00:16:10,733
我在这里

390
00:16:10,733 --> 00:16:11,899
基本上是用图

391
00:16:11,900 --> 00:16:13,933
就能够替代所有的文字了

392
00:16:13,933 --> 00:16:14,566
就这张图

393
00:16:14,566 --> 00:16:15,599
基本上就能看清楚出

394
00:16:15,600 --> 00:16:18,200
这个设计是做什么的

395
00:16:18,200 --> 00:16:19,366
是怎么做的啊

396
00:16:19,366 --> 00:16:20,899
基本就能看清楚这个问题

397
00:16:22,466 --> 00:16:24,566
啊那我们回来看这个状态图

398
00:16:24,566 --> 00:16:27,733
我们可以看到这4个对象是有状态

399
00:16:28,200 --> 00:16:30,166
这些状态是有迁移的

400
00:16:31,100 --> 00:16:33,133
那这个迁移关系其实

401
00:16:33,133 --> 00:16:36,666
在整个的程序逻辑中间都有去判断

402
00:16:36,900 --> 00:16:37,600
去判断什么呢

403
00:16:37,600 --> 00:16:38,666
比如说我做一个动作

404
00:16:38,666 --> 00:16:39,166
我这个动作

405
00:16:39,166 --> 00:16:41,733
要把这个状态从a状态迁移到b状态

406
00:16:42,200 --> 00:16:44,500
那我们之前设计的这个状态图

407
00:16:44,733 --> 00:16:47,699
是否允许这样的一个状态的迁移

408
00:16:47,933 --> 00:16:49,566
比如说我从6状态

409
00:16:49,566 --> 00:16:51,299
是不是能直接跳到分叉状态

410
00:16:52,300 --> 00:16:54,133
这个状态基础里头就已经限制了

411
00:16:54,133 --> 00:16:56,466
说你其实是不可以从一个6状态

412
00:16:56,466 --> 00:16:57,899
变成一个分散状态的

413
00:16:57,966 --> 00:17:00,466
你从一个6状态只能变成这4个状态

414
00:17:00,933 --> 00:17:05,099
对吧那我们在所有的状态

415
00:17:05,366 --> 00:17:07,333
有状态对象之间其实都有这个问题

416
00:17:07,333 --> 00:17:08,899
就是当我们去做状态迁移时

417
00:17:08,900 --> 00:17:10,966
都要判断说当前的状态

418
00:17:11,266 --> 00:17:12,733
在这个状态截图上头

419
00:17:12,733 --> 00:17:15,099
是不是能做这样的一个迁移

420
00:17:15,333 --> 00:17:16,566
那我们怎么做的呢

421
00:17:17,900 --> 00:17:19,133
我们在这个代码中间

422
00:17:19,133 --> 00:17:22,766
因为四个对象都是有状态的

423
00:17:34,300 --> 00:17:35,933
所以我们写了一个什么呢

424
00:17:35,933 --> 00:17:37,466
写了一个allow status

425
00:17:37,700 --> 00:17:39,600
这个allow status会调一个方法

426
00:17:39,600 --> 00:17:41,400
这个方法叫做get transaction

427
00:17:41,600 --> 00:17:42,200
大家可以看到

428
00:17:42,200 --> 00:17:44,200
这个get transaction也是一个abstract的方法

429
00:17:44,200 --> 00:17:44,966
这个意味着什么

430
00:17:44,966 --> 00:17:48,699
意味着这个方法没有在负类中间实现

431
00:17:49,266 --> 00:17:51,799
他是会放到纸类中间去实现的

432
00:17:51,966 --> 00:17:53,933
所以如果我们去看他的任何一个纸类

433
00:17:53,933 --> 00:17:55,599
比如说看这个paytracks

434
00:17:55,600 --> 00:17:56,400
这个纸类

435
00:18:01,966 --> 00:18:03,933
我们在这里头就可以看到它实现了

436
00:18:03,933 --> 00:18:05,533
我们在附类中间所定义的

437
00:18:05,533 --> 00:18:06,699
那个abstract的方法

438
00:18:06,700 --> 00:18:08,533
叫做gate transcation

439
00:18:08,766 --> 00:18:10,133
这个里头只有一行代码

440
00:18:10,133 --> 00:18:11,066
这行代码是干嘛呢

441
00:18:11,066 --> 00:18:13,133
这行代码是要返回我们的

442
00:18:13,133 --> 00:18:16,099
一个静态的属性

443
00:18:16,600 --> 00:18:17,266
就是这个

444
00:18:17,266 --> 00:18:18,133
这是个map

445
00:18:18,766 --> 00:18:21,099
这个静态的属性是定义在什么

446
00:18:21,100 --> 00:18:22,866
定义在我们

447
00:18:22,866 --> 00:18:24,133
的子类里头的

448
00:18:24,666 --> 00:18:26,533
因为这个静态属性在子类中间

449
00:18:26,533 --> 00:18:28,999
负类是没有办法去访问的

450
00:18:29,100 --> 00:18:29,333
所以

451
00:18:29,333 --> 00:18:32,166
我们这里其实是做了一个子类的继承

452
00:18:32,166 --> 00:18:33,699
的方法

453
00:18:33,700 --> 00:18:37,166
就是从负类中间继承下来的这个方法

454
00:18:37,400 --> 00:18:38,200
然后

455
00:18:39,533 --> 00:18:41,799
去返回了他在子类中间

456
00:18:41,800 --> 00:18:43,866
所定义的一个静态变量

457
00:18:43,966 --> 00:18:46,366
这个静态变量是一个map

458
00:18:46,366 --> 00:18:48,166
这个map所描述的

459
00:18:48,466 --> 00:18:52,199
就是我们在那张状态基图所看到的

460
00:18:52,200 --> 00:18:54,933
状态和状态之间的迁移关系

461
00:18:55,366 --> 00:18:56,799
它的key是什么呢

462
00:18:56,800 --> 00:18:58,900
key是我们的当前状态

463
00:18:59,166 --> 00:19:00,499
比如说当前状态是6的话

464
00:19:00,500 --> 00:19:00,933
如果说

465
00:19:00,933 --> 00:19:04,899
这个支付的交易的当前状态是6的话

466
00:19:04,933 --> 00:19:08,999
那它可以迁移到的是fail concel concel

467
00:19:09,000 --> 00:19:11,466
success和run这四个状态

468
00:19:11,533 --> 00:19:13,299
这也就是我们在状态基图上的

469
00:19:13,300 --> 00:19:13,866
所看到的

470
00:19:13,866 --> 00:19:14,666
这个样子

471
00:19:18,866 --> 00:19:20,266
看6状态

472
00:19:20,533 --> 00:19:23,533
那它如果说是啊

473
00:19:23,533 --> 00:19:25,299
这是这是这个全塞形啊

474
00:19:25,666 --> 00:19:27,533
这是胚全塞形是6状态

475
00:19:27,533 --> 00:19:28,699
如果它是6状态的话

476
00:19:28,700 --> 00:19:29,533
状态基图上头

477
00:19:29,533 --> 00:19:31,299
它可以因为各种动作

478
00:19:31,600 --> 00:19:33,666
迁移到这四个状态上去

479
00:19:33,800 --> 00:19:34,133
所以

480
00:19:34,133 --> 00:19:37,933
我们在pay transaction的这个代码中间

481
00:19:37,933 --> 00:19:40,933
我们写了一个这个哈西map

482
00:19:40,933 --> 00:19:42,333
这个哈西map则记得是

483
00:19:42,333 --> 00:19:43,566
当我们的transaction

484
00:19:43,566 --> 00:19:45,499
这个状态是什么状态的时候

485
00:19:45,533 --> 00:19:49,666
它可以迁移到的状态是哪些状态

486
00:19:49,900 --> 00:19:53,400
所以success可能只能迁到可以分账

487
00:19:53,400 --> 00:19:56,266
run可以去通过对账啊签到success

488
00:19:56,266 --> 00:19:57,866
所以做了这样的一个结构

489
00:19:58,000 --> 00:19:59,200
每一个子类

490
00:19:59,200 --> 00:20:00,866
都做了一个这样的一个结构

491
00:20:00,933 --> 00:20:04,266
比如说我们可以看到refund transaction

492
00:20:04,466 --> 00:20:05,799
同样也有这个结构

493
00:20:07,700 --> 00:20:09,100
当然因为他状态基础不一样

494
00:20:09,100 --> 00:20:11,900
所以说他的这个map里头

495
00:20:11,900 --> 00:20:13,533
所写的内容就不一样

496
00:20:13,533 --> 00:20:14,766
但是他也实现了

497
00:20:14,766 --> 00:20:17,066
我们在free中间定义的那个get全才行

498
00:20:17,866 --> 00:20:20,299
所以当我们在负累中间

499
00:20:20,300 --> 00:20:22,800
去调这个get transaction的时候

500
00:20:22,800 --> 00:20:24,533
大家知道会发生什么

501
00:20:24,900 --> 00:20:27,366
因为这个负累是一个upstrack的负累

502
00:20:28,200 --> 00:20:30,766
是一个抽象的负累对吧

503
00:20:30,766 --> 00:20:31,266
大家知道

504
00:20:31,266 --> 00:20:32,099
抽象的负累

505
00:20:32,100 --> 00:20:34,133
是没办法实力画出一个对象的

506
00:20:34,133 --> 00:20:35,866
我们在定义上就限制了

507
00:20:35,933 --> 00:20:36,699
这个全三个形

508
00:20:36,700 --> 00:20:37,266
是不可能

509
00:20:37,266 --> 00:20:40,133
实力画出一个transaction的对象

510
00:20:40,333 --> 00:20:43,766
他只能实力画出他子类的对象

511
00:20:44,066 --> 00:20:44,566
对吧

512
00:20:44,566 --> 00:20:47,766
那因为只能实力画出他子类的对象

513
00:20:47,933 --> 00:20:51,799
当我们去调任何一个子类实例的

514
00:20:51,800 --> 00:20:53,733
allow status的方法的时候

515
00:20:53,900 --> 00:20:54,600
大家可以看到

516
00:20:54,600 --> 00:20:56,100
在子类实例中间

517
00:20:56,100 --> 00:20:58,133
是没有定义allow status的方法的

518
00:20:58,333 --> 00:21:00,599
所以他会继承从复类

519
00:21:02,100 --> 00:21:04,000
下来的这个allowstance方法

520
00:21:04,100 --> 00:21:06,366
那继承复类的allowstance方法

521
00:21:06,366 --> 00:21:08,266
就会就会去运行这段代码

522
00:21:08,533 --> 00:21:09,899
在运行这段代码的时候啊

523
00:21:09,900 --> 00:21:10,366
大家可以看到

524
00:21:10,366 --> 00:21:11,699
它其实会去得到

525
00:21:11,700 --> 00:21:17,500
说我的状态迁移的这个集合是什么

526
00:21:17,500 --> 00:21:19,400
我知道我的当前状态是什么啊

527
00:21:19,400 --> 00:21:20,866
知道因为我无论是4个交易的

528
00:21:20,866 --> 00:21:21,799
当前状态都是什么

529
00:21:21,900 --> 00:21:23,500
所以我用我的当前状态

530
00:21:23,666 --> 00:21:25,533
在这个集合里去取

531
00:21:25,533 --> 00:21:28,966
说我可以迁移到的状态是什么

532
00:21:29,066 --> 00:21:31,199
在调这个get全申请的时候

533
00:21:31,300 --> 00:21:36,000
因为实力化的指对象的类型不同

534
00:21:36,800 --> 00:21:41,266
他就会去调他只对象对应的那个全sex

535
00:21:41,266 --> 00:21:42,299
get全车型

536
00:21:42,366 --> 00:21:43,299
因为我们在复类中间

537
00:21:43,300 --> 00:21:44,666
没有定义get全车型

538
00:21:44,766 --> 00:21:46,733
而且复类也不能实际化出对象

539
00:21:46,766 --> 00:21:47,066
所以

540
00:21:47,066 --> 00:21:49,866
真正在运行allow status这个方法的时候

541
00:21:49,866 --> 00:21:53,066
都是他的四个交易在运行的

542
00:21:53,066 --> 00:21:55,599
就他的子类对象

543
00:21:56,166 --> 00:21:58,199
他的子类对象在运行的

544
00:21:58,266 --> 00:21:58,733
所以这时

545
00:21:58,733 --> 00:22:00,199
候他调他的get权申请之后

546
00:22:00,200 --> 00:22:03,733
全是他的子类对象的get权申请方法

547
00:22:03,800 --> 00:22:04,066
这样

548
00:22:04,066 --> 00:22:06,399
就得到了自己子类对象的那个状态

549
00:22:07,000 --> 00:22:07,800
迁移图

550
00:22:07,800 --> 00:22:09,966
所以你这时候去拿当前状态去看时候

551
00:22:09,966 --> 00:22:11,099
在那个迁移图上头

552
00:22:11,100 --> 00:22:12,300
下一个状态是什么

553
00:22:12,466 --> 00:22:13,333
得出来的集合

554
00:22:13,333 --> 00:22:15,066
就是这个指类对象的

555
00:22:15,066 --> 00:22:16,799
可以迁移到的这个集合

556
00:22:17,266 --> 00:22:18,566
所以我们做了一个集合

557
00:22:18,566 --> 00:22:19,566
然后判断说

558
00:22:19,566 --> 00:22:23,333
你要迁移去的那个状态是不是允许在

559
00:22:23,333 --> 00:22:24,399
是不是在这个集合里

560
00:22:24,400 --> 00:22:25,266
如果在这个集合里

561
00:22:25,266 --> 00:22:26,166
说明你从这个状态

562
00:22:26,166 --> 00:22:27,333
是可以迁到那个状态的

563
00:22:27,400 --> 00:22:29,000
如果不在

564
00:22:29,200 --> 00:22:30,133
不允许

565
00:22:31,133 --> 00:22:31,866
不在这个集合里

566
00:22:31,866 --> 00:22:33,866
就不允许你做这样的一个迁移啊

567
00:22:33,866 --> 00:22:37,566
所以这个不只就是做的

568
00:22:37,566 --> 00:22:40,699
是允不允许你迁移的这样的一个判断

569
00:22:41,466 --> 00:22:43,466
这个就是我们最基本的

570
00:22:43,466 --> 00:22:45,899
使用多肽的方式

571
00:22:46,100 --> 00:22:47,500
在上面去做的东西

572
00:22:47,500 --> 00:22:48,966
多肽体现在哪呢

573
00:22:49,000 --> 00:22:51,700
多肽体现在这个方法上

574
00:22:53,166 --> 00:22:53,966
就这个方法上

575
00:22:53,966 --> 00:22:55,966
在复类中间它是定义了

576
00:22:56,166 --> 00:22:58,533
但是没有去实现

577
00:22:58,966 --> 00:23:01,799
在子类的方法中间去实现了

578
00:23:01,800 --> 00:23:05,066
所以因为它是不同的子类对象

579
00:23:05,566 --> 00:23:09,133
它就会体现出不同的逻辑出来

580
00:23:09,133 --> 00:23:12,533
所以这就是我们在这个代码中间啊

581
00:23:12,533 --> 00:23:13,066
可以看到

582
00:23:13,066 --> 00:23:15,533
多态的使用其实是停在这里的

583
00:23:15,800 --> 00:23:16,966
对大概是这个前提是

584
00:23:16,966 --> 00:23:18,866
大家应该对面向对象的继承啊

585
00:23:18,866 --> 00:23:19,999
多态应该很熟悉

586
00:23:20,000 --> 00:23:20,566
是吧

587
00:23:20,566 --> 00:23:22,966
才会知道这个逻辑是这样的一个逻辑

588
00:23:24,000 --> 00:23:26,166
这是我们的这个设计

589
00:23:26,166 --> 00:23:28,466
就在多肽上头做的这个设计啊

590
00:23:28,466 --> 00:23:30,566
因为近期时候讲的时候

591
00:23:30,566 --> 00:23:31,499
没有讲这么清楚

592
00:23:31,500 --> 00:23:33,700
可能同学们对于这个多肽的设计

593
00:23:33,700 --> 00:23:34,566
不是这么理解

594
00:23:34,566 --> 00:23:37,366
所以我今天把它更仔细的讲一下

595
00:23:37,566 --> 00:23:38,966
那这个东西大家看起来

596
00:23:38,966 --> 00:23:40,333
这么完美是吧

597
00:23:40,533 --> 00:23:41,933
就是看起来

598
00:23:41,933 --> 00:23:44,499
这个设计好像很巧妙的样子啊

599
00:23:44,566 --> 00:23:45,266
为什么

600
00:23:45,266 --> 00:23:48,533
因为这是一个标准的设计模式

601
00:23:48,766 --> 00:23:51,533
这个设计模式叫做template method

602
00:23:52,333 --> 00:23:53,799
就是我们实际上大家知道

603
00:23:53,800 --> 00:23:54,766
大家都不是聪明人

604
00:23:54,766 --> 00:23:55,866
特别是做工程

605
00:23:55,866 --> 00:23:58,099
就是我们去解决工程问题的时候

606
00:23:58,500 --> 00:23:59,266
大部分的人

607
00:23:59,266 --> 00:24:00,266
其实是没有能力

608
00:24:00,266 --> 00:24:02,299
去创建一个新的设计方法

609
00:24:02,400 --> 00:24:05,266
或者一个新的东西的

610
00:24:05,300 --> 00:24:07,333
那作为工程角度来说

611
00:24:07,333 --> 00:24:10,866
你更多的是用成熟的解决方案

612
00:24:11,133 --> 00:24:13,533
成熟的方法设计模式

613
00:24:13,533 --> 00:24:16,866
就是一整套成熟的解决方案

614
00:24:17,333 --> 00:24:18,499
那比如说这个地方

615
00:24:18,500 --> 00:24:22,200
我们用到的就是一个称之为template method

616
00:24:22,200 --> 00:24:24,533
模板方法的设计模式

617
00:24:24,800 --> 00:24:26,100
模板方法是什么呢

618
00:24:26,100 --> 00:24:29,400
模板方法其实它把它分成了两个部分

619
00:24:29,400 --> 00:24:31,200
一个叫做模板方法

620
00:24:31,200 --> 00:24:33,000
一个叫做基本方法

621
00:24:33,066 --> 00:24:35,333
我们在这个代码中间

622
00:24:36,866 --> 00:24:37,666
啊

623
00:24:38,100 --> 00:24:39,700
模板方法是哪一个呢

624
00:24:42,500 --> 00:24:43,333
是这个

625
00:24:52,466 --> 00:24:53,733
我们在这个代码中间

626
00:24:54,466 --> 00:24:56,733
模板方法是这个Allowstatus

627
00:24:56,866 --> 00:24:57,899
写在负累中间的

628
00:24:57,900 --> 00:25:00,366
你就可以看到它像是一个填空题

629
00:25:01,200 --> 00:25:02,533
基本方法是哪个呢

630
00:25:02,533 --> 00:25:03,699
基本方法是这个

631
00:25:05,100 --> 00:25:06,266
get transaction

632
00:25:07,100 --> 00:25:09,733
所以模板方法是写在负类中间的

633
00:25:09,733 --> 00:25:10,766
一个填空题

634
00:25:10,766 --> 00:25:11,799
这个空在哪

635
00:25:11,800 --> 00:25:12,966
空在这个地方

636
00:25:13,866 --> 00:25:14,666
这是他的空

637
00:25:15,066 --> 00:25:17,666
因为只类对象的不同

638
00:25:17,666 --> 00:25:20,766
所以这个空就会填上不同的内容

639
00:25:20,866 --> 00:25:23,666
最后造成这个模板方法这个老stage

640
00:25:23,666 --> 00:25:26,566
表现出不同的效果出来啊

641
00:25:26,566 --> 00:25:30,799
所以模板方法又被称之为钩子方法

642
00:25:31,400 --> 00:25:33,733
就是你可以想象他是在腹类中间

643
00:25:33,733 --> 00:25:35,366
在这个地方竖了一个勾子

644
00:25:35,800 --> 00:25:36,666
勾下去了

645
00:25:37,100 --> 00:25:38,066
然后这个勾子呢

646
00:25:38,066 --> 00:25:39,366
会因为你是不同的子类

647
00:25:39,366 --> 00:25:41,399
这个勾的方法是不同的

648
00:25:41,400 --> 00:25:43,666
所以使得这个模板方法表现的方

649
00:25:43,666 --> 00:25:45,333
式啊是不同的

650
00:25:45,933 --> 00:25:48,099
这个就是我们在设计模式中间的

651
00:25:48,100 --> 00:25:49,466
最简单的

652
00:25:49,466 --> 00:25:51,699
也是最经典的一个

653
00:25:51,700 --> 00:25:53,600
基于多态的设计方法

654
00:25:53,600 --> 00:25:56,566
叫做模板方法啊

655
00:25:56,566 --> 00:25:58,733
叫做模板方法的设计模式啊

656
00:25:58,733 --> 00:25:59,666
这个写错了

657
00:25:59,966 --> 00:26:00,866
模板方法

658
00:26:11,466 --> 00:26:11,699
这个

659
00:26:11,700 --> 00:26:14,366
就跟下学期的那个软硬体育结构课的

660
00:26:14,366 --> 00:26:14,933
那种思维

661
00:26:14,933 --> 00:26:16,299
有一点重复的

662
00:26:16,333 --> 00:26:19,166
因为他会完整的讲所有的设计模式

663
00:26:19,266 --> 00:26:20,366
但是我们这门课中间

664
00:26:20,366 --> 00:26:22,866
只讲我们用到的设计模式啊

665
00:26:23,100 --> 00:26:23,266
所以

666
00:26:23,266 --> 00:26:25,599
这是我们第一个大家碰到的设计模式

667
00:26:25,600 --> 00:26:27,166
叫做模板方法

668
00:26:27,266 --> 00:26:28,566
它经典的类图

669
00:26:28,566 --> 00:26:31,133
就是在设计模式那本书里头

670
00:26:31,133 --> 00:26:33,399
包括在软件提结构那本课

671
00:26:33,400 --> 00:26:34,966
中间所讲到的

672
00:26:34,966 --> 00:26:36,466
这个类图的结构

673
00:26:36,466 --> 00:26:37,933
就是我们这里看到这个结构

674
00:26:38,400 --> 00:26:39,466
这个是负类

675
00:26:39,700 --> 00:26:40,900
这个是子类

676
00:26:40,900 --> 00:26:42,733
负类是一个抽象的负类

677
00:26:42,933 --> 00:26:45,166
然后负类中间有定义了模板方法

678
00:26:45,166 --> 00:26:45,933
他可能会有弱感

679
00:26:45,933 --> 00:26:47,066
和模板方法不一定啊

680
00:26:47,066 --> 00:26:49,199
这里我们看到的只有一个

681
00:26:49,500 --> 00:26:50,866
我们用的时候也只有一个

682
00:26:50,866 --> 00:26:52,399
但其实是可以定义很多个的

683
00:26:52,600 --> 00:26:53,666
在这个模板方法中间

684
00:26:53,666 --> 00:26:56,133
他会调用他的若干个基本方法

685
00:26:56,133 --> 00:26:56,799
但我们这个例子中间

686
00:26:56,800 --> 00:26:58,100
我们只调了一个基本方法

687
00:26:58,100 --> 00:26:59,466
就是他的get全c型

688
00:26:59,600 --> 00:27:01,566
但其实是可以调多个基本方法的

689
00:27:01,566 --> 00:27:04,366
而这些基本方法是在子类中间实现

690
00:27:05,300 --> 00:27:07,100
附类对象不能实力化

691
00:27:07,100 --> 00:27:08,766
子类对象才能实力化

692
00:27:08,866 --> 00:27:11,066
所以当我们实力化出子类对象

693
00:27:11,066 --> 00:27:13,266
去调他的模板方法的时候

694
00:27:13,400 --> 00:27:15,066
他会因为这个子类对象

695
00:27:15,066 --> 00:27:17,133
所实现的基本方法的不同

696
00:27:17,266 --> 00:27:21,199
让模板方法体现出来不同的行为出来

697
00:27:21,466 --> 00:27:24,466
这就是我们称之为模板方法的

698
00:27:24,466 --> 00:27:25,366
设计模式

699
00:27:25,733 --> 00:27:26,733
这一块有问题吗

700
00:27:26,733 --> 00:27:28,733
这是个最简单的设计模

701
00:27:28,733 --> 00:27:30,933
式啊我一个个的设计模式慢慢讲

702
00:27:32,733 --> 00:27:33,533
没有问题是吧

703
00:27:33,533 --> 00:27:35,999
好那我们继续往下面讲

704
00:27:36,400 --> 00:27:38,400
那多肽这个部分来说啊

705
00:27:38,400 --> 00:27:40,766
其实是我们在面向对象中间

706
00:27:40,766 --> 00:27:43,133
一个最基本的特性啊

707
00:27:43,133 --> 00:27:45,566
但是我们其实在后面会讲

708
00:27:45,566 --> 00:27:47,999
我们并不是非常赞同

709
00:27:48,000 --> 00:27:51,200
大家普遍的使用这个多肽

710
00:27:51,400 --> 00:27:53,866
就是多肽不是用来表现你

711
00:27:53,866 --> 00:27:56,366
是面向对象设计的一个特征

712
00:27:56,733 --> 00:27:59,733
是因为你在需要用到多肽的时候

713
00:27:59,733 --> 00:28:00,733
才会去用多肽

714
00:28:00,733 --> 00:28:02,366
比如说我们这里地主

715
00:28:02,366 --> 00:28:03,999
你看到我们为什么会用多态

716
00:28:04,000 --> 00:28:06,133
是因为我们不想重复写那些代码

717
00:28:06,366 --> 00:28:07,966
大家知道在写代码

718
00:28:07,966 --> 00:28:10,333
不管是用哪种设计方式去写代码

719
00:28:10,400 --> 00:28:11,766
一个最基本的原则

720
00:28:11,766 --> 00:28:13,366
就是不要重复写代码

721
00:28:13,566 --> 00:28:15,466
所以因为我们不想重复写代码

722
00:28:15,566 --> 00:28:17,399
所以我们这里用了一个多态啊

723
00:28:17,400 --> 00:28:18,266
来解决它

724
00:28:19,333 --> 00:28:22,366
那第二个我们要讲的是间接的方式

725
00:28:22,600 --> 00:28:23,600
在支付模块中间

726
00:28:23,600 --> 00:28:25,966
大家知道比较麻烦的问题在于说

727
00:28:25,966 --> 00:28:28,099
它要支持多个支付渠道

728
00:28:28,366 --> 00:28:29,799
而这个多个支付渠道呢

729
00:28:29,800 --> 00:28:31,066
会不断的增加的

730
00:28:31,066 --> 00:28:32,699
而且每一个支付渠道呢

731
00:28:32,700 --> 00:28:34,400
它的API也会发生改变的

732
00:28:34,733 --> 00:28:36,699
所以我们希望说

733
00:28:36,700 --> 00:28:41,400
我们的代码跟这些支付渠道的东西

734
00:28:41,400 --> 00:28:42,866
保持一定的距离

735
00:28:42,966 --> 00:28:44,666
因为他会不断的增加

736
00:28:44,800 --> 00:28:47,333
我们现在是微信和支付宝以后会增加

737
00:28:47,333 --> 00:28:48,699
云闪付会增加

738
00:28:48,900 --> 00:28:50,200
比如说京东支付等等

739
00:28:50,200 --> 00:28:51,500
凡是有支付牌照的

740
00:28:51,500 --> 00:28:54,166
这些支付渠道都会逐步的增加上来

741
00:28:54,966 --> 00:28:57,766
那如果说在增加这些支付渠道

742
00:28:57,800 --> 00:28:59,466
或者说这些支付渠道的API

743
00:28:59,466 --> 00:29:00,899
在发生改变的时候

744
00:29:02,000 --> 00:29:03,566
我们的代码是要调用他的

745
00:29:03,700 --> 00:29:05,333
如果不保持距离的话

746
00:29:05,333 --> 00:29:07,099
我们的代码就会受到影响

747
00:29:07,500 --> 00:29:09,700
所以我们在这个部分来说采

748
00:29:09,700 --> 00:29:11,400
用了一种间接的方式

749
00:29:11,400 --> 00:29:14,400
就是避免我们的这些代码

750
00:29:14,733 --> 00:29:15,899
支付模块的代码

751
00:29:15,900 --> 00:29:18,800
和所有他所支持的支付渠道的代码

752
00:29:18,800 --> 00:29:19,900
来直接偶合

753
00:29:20,533 --> 00:29:21,533
使得他在增加

754
00:29:21,533 --> 00:29:23,933
或者说他在去发生改变的时候

755
00:29:23,933 --> 00:29:25,199
有可能啊

756
00:29:25,200 --> 00:29:26,366
不是说100%的

757
00:29:26,466 --> 00:29:27,599
是说有可能

758
00:29:27,600 --> 00:29:29,900
不会影响到我们的支付模块里头的

759
00:29:29,900 --> 00:29:32,066
这个大部分的代码

760
00:29:32,566 --> 00:29:34,166
这个方案就是间接的方案

761
00:29:34,166 --> 00:29:35,333
就是我不直接用你啊

762
00:29:35,333 --> 00:29:37,599
我通过其他对象来用你

763
00:29:38,566 --> 00:29:39,699
我们看到的

764
00:29:39,700 --> 00:29:42,666
我们在做这个签约

765
00:29:43,366 --> 00:29:44,933
支付渠道的这个动作

766
00:29:44,933 --> 00:29:47,399
中间它其实包含了第一

767
00:29:47,400 --> 00:29:51,000
把用户所提交上来的信息

768
00:29:51,500 --> 00:29:53,100
保存到我们的系统中间

769
00:29:53,100 --> 00:29:54,733
因为用户需要到微信

770
00:29:54,733 --> 00:29:56,933
支付宝各个支付渠道上去开一个账号

771
00:29:57,166 --> 00:29:58,966
他要把这个账号记在我们这里

772
00:29:59,766 --> 00:30:00,566
第二个呢

773
00:30:00,600 --> 00:30:02,933
其实我们要通过支付渠道

774
00:30:02,933 --> 00:30:06,899
把我们平台的账号和商户的账号

775
00:30:06,900 --> 00:30:08,933
做一个分账关系的绑定

776
00:30:09,066 --> 00:30:11,533
为啥因为我们后面要去做他分账

777
00:30:11,533 --> 00:30:12,266
要把他的钱

778
00:30:12,266 --> 00:30:13,899
从他的账上转到我们账上来

779
00:30:14,266 --> 00:30:15,399
如果在支付渠道中间

780
00:30:15,400 --> 00:30:16,733
不做这样的一个绑定的话

781
00:30:16,733 --> 00:30:20,066
你其实是没办法去操作商户的账号的

782
00:30:20,066 --> 00:30:21,666
虽然他把这些信息都给你了

783
00:30:21,733 --> 00:30:24,999
你也没办法去让钱从他的账号上头

784
00:30:25,533 --> 00:30:26,999
转到我们的账号上头

785
00:30:27,000 --> 00:30:28,400
是没办法去做这个动作的

786
00:30:28,700 --> 00:30:30,733
所以这里头就涉及到了两个行为

787
00:30:30,733 --> 00:30:31,499
一个行为是

788
00:30:31,500 --> 00:30:32,266
我们把

789
00:30:32,266 --> 00:30:35,699
商户在各个支付渠道上的注册信息

790
00:30:35,766 --> 00:30:37,199
他拿到的商户号啊

791
00:30:37,200 --> 00:30:38,300
密钥啊等等

792
00:30:38,300 --> 00:30:40,300
这些信息寄到我们的系统中间

793
00:30:40,300 --> 00:30:42,366
因为我们要用这个信息去读

794
00:30:42,366 --> 00:30:45,099
他的账户的相关的信息啊

795
00:30:45,100 --> 00:30:45,933
因为他账户相关的信息

796
00:30:45,933 --> 00:30:46,966
我们是要去读的

797
00:30:47,200 --> 00:30:48,366
那第二个是什么

798
00:30:48,366 --> 00:30:48,866
第二个就是我

799
00:30:48,866 --> 00:30:49,999
们要分账的话

800
00:30:50,066 --> 00:30:52,566
是需要去用这个信息

801
00:30:52,566 --> 00:30:54,299
去在支付平台中间

802
00:30:54,300 --> 00:30:56,100
去建立一个分账关系的

803
00:30:56,166 --> 00:30:57,699
所以这是他的两个行为

804
00:30:58,133 --> 00:30:59,199
我们在设计这个API时候

805
00:30:59,200 --> 00:31:00,333
其实做了简化啊

806
00:31:00,333 --> 00:31:02,533
就是我们其实并没有把一个商户

807
00:31:02,533 --> 00:31:03,466
在支付渠道中间

808
00:31:03,466 --> 00:31:06,733
所有需要的信息全部记录下来

809
00:31:06,733 --> 00:31:09,466
没有去做这样的一个完整的实现

810
00:31:09,600 --> 00:31:11,566
那取了一个最简单的属性

811
00:31:11,566 --> 00:31:13,533
就是无论是在哪个支付渠道上头

812
00:31:13,533 --> 00:31:14,699
他都需要一个最基本的

813
00:31:14,700 --> 00:31:15,800
就他有一个商户号

814
00:31:16,366 --> 00:31:18,133
在微信平台上

815
00:31:18,133 --> 00:31:18,733
在支付平台上

816
00:31:18,733 --> 00:31:19,899
他在注册了账号以后

817
00:31:19,900 --> 00:31:21,933
都会给你一个唯一的这个商户号

818
00:31:21,933 --> 00:31:23,366
我们只记了这个东西啊

819
00:31:23,600 --> 00:31:24,366
所以大家可以看到

820
00:31:24,366 --> 00:31:26,999
这个API设计所就很设计的就很简单

821
00:31:27,000 --> 00:31:30,066
就是要求商户把他的商户号

822
00:31:30,666 --> 00:31:32,599
给登记到我们的平台里头

823
00:31:32,700 --> 00:31:34,000
然后我们用这个商户号

824
00:31:34,000 --> 00:31:36,466
去建立分账关系啊

825
00:31:36,700 --> 00:31:41,300
这是呃我们的这个API

826
00:31:42,366 --> 00:31:44,133
那这个API里头的设计

827
00:31:44,133 --> 00:31:46,766
就是我们说的去做这两个事情

828
00:31:46,933 --> 00:31:47,966
这个过程中间啊

829
00:31:47,966 --> 00:31:48,799
大家可以看到

830
00:31:48,800 --> 00:31:52,700
我们用到了我们的创建者的模式

831
00:31:52,733 --> 00:31:56,066
因为大家知道在签约一个商户的时候

832
00:31:56,066 --> 00:31:58,599
涉及到了一个新的商户

833
00:31:58,600 --> 00:32:00,866
支付渠道对象的产生

834
00:32:01,366 --> 00:32:03,366
而在我们的类图

835
00:32:03,366 --> 00:32:04,566
在对象模型中间

836
00:32:04,600 --> 00:32:05,766
我们可以看到

837
00:32:06,066 --> 00:32:09,966
商户的这个支付渠道对象

838
00:32:10,300 --> 00:32:14,266
和我们平台的支持的渠道对象

839
00:32:14,566 --> 00:32:15,699
之间的关系

840
00:32:15,733 --> 00:32:17,566
是一个组合关系

841
00:32:17,900 --> 00:32:19,666
我们知道创建者模式

842
00:32:19,666 --> 00:32:22,099
当我们划了一个组合关系的时候

843
00:32:22,366 --> 00:32:25,766
你高概率会用创建者的模式

844
00:32:25,866 --> 00:32:28,566
来创建这个channel对象

845
00:32:28,800 --> 00:32:31,133
所以这个API所做的事情就是

846
00:32:31,133 --> 00:32:33,599
首先你要把shop channel

847
00:32:33,600 --> 00:32:34,800
把商户的信息登记

848
00:32:34,800 --> 00:32:35,800
到我们的系统里头来

849
00:32:35,800 --> 00:32:36,666
要登记进来

850
00:32:36,666 --> 00:32:38,866
你首先要创建对象才能登记上来

851
00:32:38,966 --> 00:32:41,299
所以我们在这里啊可以看到

852
00:32:41,300 --> 00:32:42,400
进入到surface层以后

853
00:32:42,400 --> 00:32:44,266
第一步是由ID到对象

854
00:32:44,266 --> 00:32:45,099
这个没什么好说的

855
00:32:45,100 --> 00:32:46,333
跟前面是完全一样的

856
00:32:46,500 --> 00:32:49,600
那第二步则是把整个的职责

857
00:32:49,600 --> 00:32:51,133
认为他是创建者

858
00:32:51,133 --> 00:32:54,266
模式给他付给了渠道对象

859
00:32:55,000 --> 00:32:57,466
所以在渠道对象中间就有一个方法

860
00:32:57,466 --> 00:32:58,999
叫做create shop channel

861
00:32:59,000 --> 00:33:02,100
这就是我们前面说的创建者的模式

862
00:33:02,200 --> 00:33:04,166
那这个部分他做什么

863
00:33:04,166 --> 00:33:05,166
就做我们的两件事情

864
00:33:05,166 --> 00:33:05,466
第一

865
00:33:05,466 --> 00:33:08,599
是把商户的信息登记到数据库里去

866
00:33:09,100 --> 00:33:11,100
第二就是去调支付渠道

867
00:33:11,266 --> 00:33:12,533
所以我们在这里可以看到

868
00:33:12,533 --> 00:33:14,499
我们把调支付渠道

869
00:33:14,500 --> 00:33:17,666
去做登记分账关系

870
00:33:17,666 --> 00:33:19,133
这个事情做在了前面

871
00:33:19,300 --> 00:33:20,600
然后把差数据

872
00:33:20,600 --> 00:33:22,166
或者这件事情做到了后面

873
00:33:22,333 --> 00:33:23,733
为什么要这样来做

874
00:33:24,400 --> 00:33:25,200
大家觉得

875
00:33:26,700 --> 00:33:28,133
这样是避免说啊

876
00:33:28,133 --> 00:33:29,766
因为这个东西失败了

877
00:33:30,000 --> 00:33:31,266
要让这个东西回滚

878
00:33:31,266 --> 00:33:32,766
我们是有能力做到这一点的

879
00:33:32,766 --> 00:33:35,533
就是有能力做到说这个东西登记了

880
00:33:35,533 --> 00:33:36,933
然后这个东西失败了

881
00:33:36,933 --> 00:33:39,499
他会去把它回滚过来

882
00:33:39,566 --> 00:33:42,199
那现在我们这样的一个做法

883
00:33:42,866 --> 00:33:44,899
就是避免说因为他失败了

884
00:33:44,966 --> 00:33:46,066
要把他回滚

885
00:33:46,200 --> 00:33:47,900
效率上会更高一点

886
00:33:48,066 --> 00:33:49,099
但大家在做的时候

887
00:33:49,100 --> 00:33:50,366
会考虑到另外一个问题

888
00:33:50,366 --> 00:33:51,466
这么做是合理的吗

889
00:33:51,466 --> 00:33:52,266
你们觉得

890
00:33:54,300 --> 00:33:55,000
这么做是合理吗

891
00:33:55,000 --> 00:33:55,800
这个顺序做

892
00:33:55,800 --> 00:33:56,933
这么做是合理的吗

893
00:33:56,933 --> 00:33:57,733
你们觉得

894
00:34:02,933 --> 00:34:03,599
合理的吗

895
00:34:03,600 --> 00:34:05,266
你们觉得这个做是合理的吗

896
00:34:12,933 --> 00:34:13,733
大家注意下啊

897
00:34:13,733 --> 00:34:15,299
看我们的这个代码里头

898
00:34:16,133 --> 00:34:17,699
我们的事物边界

899
00:34:17,700 --> 00:34:20,533
是全部切在了service层

900
00:34:38,333 --> 00:34:39,866
这是channel式设为史

901
00:34:39,866 --> 00:34:42,333
我们的事务边界默认上面

902
00:34:42,333 --> 00:34:44,299
我们全部切到了设为史层

903
00:34:44,566 --> 00:34:45,533
切到这个位置上头

904
00:34:45,533 --> 00:34:47,166
基本上所有的设为史的方法

905
00:34:47,166 --> 00:34:50,066
在前面都切了一个art transaction

906
00:34:50,133 --> 00:34:50,899
这就是事物

907
00:34:50,900 --> 00:34:53,000
从设为史的方法开始

908
00:34:53,266 --> 00:34:56,599
所以在这个设计中间

909
00:35:04,300 --> 00:35:05,333
所以在这个设计中间

910
00:35:05,333 --> 00:35:06,399
我们的事物在哪呢

911
00:35:06,400 --> 00:35:07,500
我们的事物在这

912
00:35:08,200 --> 00:35:10,800
从这开始的这个事物

913
00:35:11,166 --> 00:35:12,899
那从这开始的事物

914
00:35:12,900 --> 00:35:14,966
大家会觉得这样的一个设计

915
00:35:14,966 --> 00:35:15,733
是合理的设计

916
00:35:15,733 --> 00:35:16,666
还是不合理设计

917
00:35:19,766 --> 00:35:21,366
你们觉得合理还是不合理

918
00:35:21,700 --> 00:35:24,733
先去掉支付渠道去做签约

919
00:35:25,133 --> 00:35:27,166
然后再去查数据库

920
00:35:30,300 --> 00:35:31,533
好像没有感觉是吧

921
00:35:31,533 --> 00:35:33,166
不知道他合理还是不合理

922
00:35:33,366 --> 00:35:34,066
那我跟他说

923
00:35:34,066 --> 00:35:35,999
他跟大家说不合理的地方啊

924
00:35:36,600 --> 00:35:39,600
调这个支付渠道去完成签约

925
00:35:39,866 --> 00:35:40,999
这个是没有问题的

926
00:35:41,000 --> 00:35:41,800
对吧

927
00:35:42,300 --> 00:35:43,566
那签完约以后

928
00:35:43,566 --> 00:35:44,666
如果他成功了

929
00:35:44,666 --> 00:35:45,733
插数据库的时候

930
00:35:45,733 --> 00:35:47,166
发现插数据库失败了

931
00:35:47,166 --> 00:35:48,499
这时候数据库崩溃了

932
00:35:48,600 --> 00:35:50,000
或者数据库不是崩溃了

933
00:35:50,000 --> 00:35:51,600
因为数据库太繁忙

934
00:35:51,733 --> 00:35:54,299
他有可能是造成那个时候阻塞了

935
00:35:54,300 --> 00:35:55,800
然后数据库没办法插进去

936
00:35:56,500 --> 00:35:57,300
会怎么样

937
00:35:58,200 --> 00:35:58,733
会怎么样

938
00:35:58,733 --> 00:35:59,533
你们觉得

939
00:36:01,100 --> 00:36:01,900
会怎么样

940
00:36:03,366 --> 00:36:05,966
会造成事物的回滚

941
00:36:06,466 --> 00:36:09,566
就是整个事物就全部失败掉

942
00:36:09,700 --> 00:36:11,733
所以造成这个签约是没签成功的

943
00:36:12,066 --> 00:36:14,133
但是这个API

944
00:36:15,166 --> 00:36:18,066
这个API是没有办法回滚的

945
00:36:18,066 --> 00:36:20,533
因为这是调的第三方渠道的API

946
00:36:20,800 --> 00:36:23,733
所以如果说先做这个签约

947
00:36:23,933 --> 00:36:25,599
再去插数据库的话

948
00:36:25,600 --> 00:36:28,666
会造成在第二步插数据库失败的时候

949
00:36:29,066 --> 00:36:30,133
签约签成功了

950
00:36:30,666 --> 00:36:32,099
但是数据库没插进去

951
00:36:32,300 --> 00:36:34,266
所以最后表现出来是你没有签约成功

952
00:36:34,266 --> 00:36:35,533
但实际上调支付渠道

953
00:36:35,533 --> 00:36:37,333
是有完整的这个签约过程

954
00:36:37,966 --> 00:36:39,599
所以这个设计是有问题的

955
00:36:39,933 --> 00:36:41,799
我们周一一讲的这个设计

956
00:36:41,933 --> 00:36:44,933
这个设计其实应该把第4和第5反过来

957
00:36:45,266 --> 00:36:47,266
就是先插数据库

958
00:36:47,700 --> 00:36:50,166
再去调支付渠道

959
00:36:51,500 --> 00:36:52,133
这样的话

960
00:36:52,133 --> 00:36:55,799
如果说调支付渠道没有成功会怎么样

961
00:36:57,200 --> 00:36:58,800
会回滚数据库

962
00:36:59,066 --> 00:37:00,899
就是他的全商品的边界

963
00:37:01,133 --> 00:37:02,299
是在这个位置上的

964
00:37:03,366 --> 00:37:04,899
全三引文件是在这个位上的

965
00:37:04,966 --> 00:37:06,999
所以他会去回滚数据库啊

966
00:37:07,000 --> 00:37:07,800
造成说

967
00:37:07,800 --> 00:37:11,366
这个插进去的数据会回滚回来啊

968
00:37:12,900 --> 00:37:14,600
反格顺序才是对的啊

969
00:37:14,600 --> 00:37:15,500
所以设计里头

970
00:37:15,500 --> 00:37:18,400
其实有很多细节部分的东西

971
00:37:18,400 --> 00:37:19,700
要去考量的

972
00:37:20,266 --> 00:37:21,666
这个地方我们说考量的

973
00:37:21,666 --> 00:37:24,066
其实就大家要熟悉说在spin会员

974
00:37:24,066 --> 00:37:25,366
他的事物是怎么做的

975
00:37:25,566 --> 00:37:26,933
他事物切在那里

976
00:37:27,166 --> 00:37:29,099
有些东西是有事物的

977
00:37:29,100 --> 00:37:31,166
有些东西是没有事物的

978
00:37:31,333 --> 00:37:34,199
所以总体的设计原则是

979
00:37:34,200 --> 00:37:38,066
把没有事物的东西怎么办

980
00:37:38,866 --> 00:37:41,799
靠后靠到尾巴上去做

981
00:37:42,266 --> 00:37:42,799
这样的话

982
00:37:42,800 --> 00:37:45,900
就会使得说前面有失误的东西

983
00:37:45,900 --> 00:37:47,800
会因为最后一个没有失误的东西

984
00:37:47,800 --> 00:37:50,066
失败了把它回滚回去

985
00:37:50,166 --> 00:37:51,999
但是如果你把没有失误的东西

986
00:37:52,000 --> 00:37:53,133
靠到前面去做

987
00:37:53,466 --> 00:37:55,099
后面的东西失败了

988
00:37:55,100 --> 00:37:57,500
前面做完的事情是没办法回滚的

989
00:37:57,666 --> 00:37:58,766
所以就会出问题

990
00:37:59,133 --> 00:38:00,966
对吧所以这个设计是有问题的啊

991
00:38:00,966 --> 00:38:03,866
待会我课后把这个顺序改一下

992
00:38:04,100 --> 00:38:06,733
这样才可以做到正确的逻辑啊

993
00:38:07,166 --> 00:38:08,299
所有的这些设计

994
00:38:08,300 --> 00:38:09,333
我之前说了

995
00:38:10,000 --> 00:38:11,200
看懂原面图

996
00:38:11,333 --> 00:38:13,266
绘画原面图是个最基本的

997
00:38:13,500 --> 00:38:14,733
会用设计方法

998
00:38:14,800 --> 00:38:17,300
会去做出这个设计是第二步的

999
00:38:17,366 --> 00:38:18,133
但所有的设计

1000
00:38:18,133 --> 00:38:19,766
都是基于特定技术架构的

1001
00:38:19,966 --> 00:38:21,499
你如果没有技术架构的基础

1002
00:38:21,500 --> 00:38:22,333
你其实根本就不知道

1003
00:38:22,333 --> 00:38:23,566
这个设计有什么问题

1004
00:38:23,766 --> 00:38:26,366
你如果有这个技术架构的基础知识啊

1005
00:38:26,366 --> 00:38:27,333
你才会知道

1006
00:38:27,900 --> 00:38:30,200
这个设计是有什么样的问题的

1007
00:38:30,666 --> 00:38:32,199
所有的人都不是圣人啊

1008
00:38:32,200 --> 00:38:32,566
大家知道

1009
00:38:32,566 --> 00:38:35,499
没有人是能把设计一次性的做好

1010
00:38:35,700 --> 00:38:38,266
所以大家可以看到我们在做这个过程

1011
00:38:38,266 --> 00:38:39,133
我在做这个过程中间

1012
00:38:39,133 --> 00:38:40,766
其实是在不断的修正

1013
00:38:41,133 --> 00:38:42,333
自己的这个设计的

1014
00:38:42,400 --> 00:38:44,133
那其实大家会发现

1015
00:38:44,133 --> 00:38:47,066
经过这个事前的思考

1016
00:38:47,100 --> 00:38:49,500
用代码去做事后的讲述

1017
00:38:49,500 --> 00:38:50,800
经过了三轮修正以后

1018
00:38:50,800 --> 00:38:54,700
大家如果再去做里头的这些测试的话

1019
00:38:55,133 --> 00:38:56,399
虽然还能会发现问题

1020
00:38:56,400 --> 00:38:59,900
但是这些问题就会减少非常多啊

1021
00:38:59,900 --> 00:39:05,933
所以我们说设计一定要做思考和讲

1022
00:39:06,066 --> 00:39:08,333
这三个过程一定要结合起来

1023
00:39:08,600 --> 00:39:09,966
你如果缺了任何过程

1024
00:39:09,966 --> 00:39:12,566
只能把错误留到最后才去发现啊

1025
00:39:12,566 --> 00:39:14,933
那个代价其实是最高的啊

1026
00:39:14,966 --> 00:39:16,466
所以这个顺序要挑过来

1027
00:39:16,566 --> 00:39:17,899
要不然会有问题的

1028
00:39:18,466 --> 00:39:20,466
待会课间时候我把它换一下

1029
00:39:21,766 --> 00:39:24,199
这是我们的这个地方

1030
00:39:24,266 --> 00:39:24,933
那大家知道

1031
00:39:24,933 --> 00:39:26,266
我们在这一个设计中间

1032
00:39:26,266 --> 00:39:27,799
其实是没有看到

1033
00:39:27,800 --> 00:39:31,566
任何跟微信和支付宝有关的因素

1034
00:39:31,566 --> 00:39:32,566
我们看到的是

1035
00:39:32,566 --> 00:39:34,966
我们就调了一个pay Adapter

1036
00:39:35,300 --> 00:39:37,900
去创建了这样的一个支付渠道

1037
00:39:37,933 --> 00:39:39,466
就只做了这么一个事情

1038
00:39:39,866 --> 00:39:41,899
那微信和支付宝在哪呢

1039
00:39:42,166 --> 00:39:43,866
我们在类图上头

1040
00:39:43,866 --> 00:39:45,999
可以看到我们的pay Adtrapter

1041
00:39:46,000 --> 00:39:50,133
这是我完整化了这个部分的类图啊

1042
00:39:50,133 --> 00:39:53,566
因为整个模块的类图是极其复杂的

1043
00:39:53,566 --> 00:39:55,766
你是没有办法把它在一张图上的

1044
00:39:55,766 --> 00:39:56,899
去描述出来

1045
00:39:57,366 --> 00:39:58,999
那我实际上做法就是

1046
00:39:59,000 --> 00:40:00,500
我按照这个内容

1047
00:40:00,500 --> 00:40:04,800
去分块的来画了他的局部的类图

1048
00:40:05,066 --> 00:40:06,133
这一个局部类图

1049
00:40:06,133 --> 00:40:10,566
是跟支付渠道有关的的局部类图啊

1050
00:40:10,566 --> 00:40:11,933
所以在对象模型上

1051
00:40:11,933 --> 00:40:12,766
大家可以看到

1052
00:40:12,966 --> 00:40:14,999
支付渠道里头最核心的两个对象

1053
00:40:15,000 --> 00:40:16,066
一个是channel对象

1054
00:40:16,066 --> 00:40:16,599
一个是shop

1055
00:40:16,600 --> 00:40:17,400
channel对象

1056
00:40:17,533 --> 00:40:18,499
这张类图上的

1057
00:40:18,500 --> 00:40:21,666
表述了chain的对象和shop chain对象

1058
00:40:21,800 --> 00:40:23,300
跟我们的service对象

1059
00:40:23,300 --> 00:40:24,700
盗对象之间的关系

1060
00:40:24,700 --> 00:40:26,166
Mapper都没有画

1061
00:40:26,166 --> 00:40:27,166
除了这两个map啊

1062
00:40:27,166 --> 00:40:29,399
我们为了示意我们画了以外

1063
00:40:29,400 --> 00:40:31,300
其他的map啊都没有画

1064
00:40:31,400 --> 00:40:34,000
所以这是一张局部的类图

1065
00:40:34,300 --> 00:40:35,866
那在这张局部的类图上头

1066
00:40:35,866 --> 00:40:36,466
大家可以看到

1067
00:40:36,466 --> 00:40:39,366
这个pay Adapter其实定义的是一个接口

1068
00:40:39,966 --> 00:40:40,899
这里头定义的是什么呢

1069
00:40:40,900 --> 00:40:44,933
定义的是一系列调支付渠道的方法

1070
00:40:45,200 --> 00:40:46,133
但大家知道

1071
00:40:46,466 --> 00:40:48,566
微信和支付宝的支付渠道的方法

1072
00:40:48,566 --> 00:40:49,533
是完全不一样

1073
00:40:49,966 --> 00:40:52,899
不但他的参数不一样

1074
00:40:52,900 --> 00:40:53,900
返回值不一样

1075
00:40:54,166 --> 00:40:57,499
方法名就是它的URL都不一样

1076
00:40:57,733 --> 00:40:59,999
那这些不一样的东西写在哪呢

1077
00:41:00,000 --> 00:41:03,000
我们写在了这个微配Mapper

1078
00:41:03,000 --> 00:41:05,166
和阿里配的这个map里头

1079
00:41:05,266 --> 00:41:07,133
大家可以看一下这个代码啊

1080
00:41:14,500 --> 00:41:16,966
我们写在了map层的这两个map里头

1081
00:41:17,933 --> 00:41:19,966
呃这两个map里头

1082
00:41:19,966 --> 00:41:22,766
我们是用open FIN的这种方式

1083
00:41:22,933 --> 00:41:26,999
把像这些支付渠道所调用的

1084
00:41:27,200 --> 00:41:28,700
HTTP的request

1085
00:41:28,700 --> 00:41:30,133
就是它是restroof风格的

1086
00:41:30,133 --> 00:41:32,766
HTTP的request的和它的返回指针

1087
00:41:32,766 --> 00:41:35,599
GT response用open friend的技术去写

1088
00:41:35,666 --> 00:41:37,199
这里又涉及到了一个

1089
00:41:37,266 --> 00:41:39,266
我们在教育中心还没有讲的技术

1090
00:41:39,266 --> 00:41:42,099
就是怎样去向另外一个模块

1091
00:41:42,700 --> 00:41:46,466
去调用它的restful API的方法啊

1092
00:41:46,466 --> 00:41:48,366
这里用了open friend的这个方式

1093
00:41:48,566 --> 00:41:52,133
所以这里头的每一个调用

1094
00:41:52,333 --> 00:41:53,566
就是reserves调用

1095
00:41:53,566 --> 00:41:55,866
我们都用open find的这个注解

1096
00:41:56,000 --> 00:41:57,566
把它转化成为了

1097
00:41:57,566 --> 00:42:00,133
我们接口上面的一个方法

1098
00:42:00,366 --> 00:42:01,799
那大家可以看到啊

1099
00:42:01,800 --> 00:42:03,133
这些的参数

1100
00:42:03,866 --> 00:42:05,866
他的参数是不一样

1101
00:42:05,866 --> 00:42:08,199
的他的返回值也是不一样的

1102
00:42:08,200 --> 00:42:08,500
那

1103
00:42:08,500 --> 00:42:11,900
因为他的接口的返回值是两种返回值

1104
00:42:12,000 --> 00:42:13,900
正常的时候是一种返回值

1105
00:42:14,300 --> 00:42:15,966
如果调查的接口出错了

1106
00:42:16,066 --> 00:42:17,299
它是另外一种返回值

1107
00:42:17,300 --> 00:42:19,000
所以我们没办法用一个对象

1108
00:42:19,200 --> 00:42:20,300
它是两种对象啊

1109
00:42:20,300 --> 00:42:21,366
没办法用一种对象

1110
00:42:21,366 --> 00:42:23,166
去接住它的两种返回值

1111
00:42:23,200 --> 00:42:24,466
那这里我们做的方式就是

1112
00:42:24,466 --> 00:42:26,366
我们干脆用一个支付串去接

1113
00:42:26,500 --> 00:42:28,900
因为大家知道这全是Reservo风格的API

1114
00:42:29,166 --> 00:42:30,266
所以它的返回值

1115
00:42:30,266 --> 00:42:32,466
它的86年全是节省的支串

1116
00:42:32,866 --> 00:42:33,866
那用词句去接

1117
00:42:33,866 --> 00:42:35,599
其实就是接到了一个阶层之串

1118
00:42:35,700 --> 00:42:37,366
那其实后面我们会看到

1119
00:42:37,366 --> 00:42:37,999
我们会去判断

1120
00:42:38,000 --> 00:42:40,300
那个阶层之串到底是哪一种对象

1121
00:42:40,666 --> 00:42:42,799
来决定说他到底是正常的返回值

1122
00:42:42,800 --> 00:42:44,100
还是不正常的返回值啊

1123
00:42:44,100 --> 00:42:46,166
所以这里返回值大家看到的都统一

1124
00:42:46,166 --> 00:42:47,199
都是用词句去接

1125
00:42:47,366 --> 00:42:48,799
但是参数

1126
00:42:48,966 --> 00:42:51,199
就是他在89年所犯的那个内容

1127
00:42:51,700 --> 00:42:52,733
都是不一样的

1128
00:42:53,166 --> 00:42:53,933
就是body

1129
00:42:53,933 --> 00:42:55,266
因为这里头全是reso的风格

1130
00:42:55,266 --> 00:42:57,766
所以往里面传的东西基本上是body

1131
00:42:57,900 --> 00:43:00,333
有一部分是那个

1132
00:43:00,766 --> 00:43:02,566
我看有一部分是那个parameter

1133
00:43:02,566 --> 00:43:03,966
request好像有一部啊

1134
00:43:03,966 --> 00:43:05,299
这个呃

1135
00:43:05,500 --> 00:43:07,566
阿里佩全是这个body

1136
00:43:07,566 --> 00:43:09,966
但是在微配里头

1137
00:43:09,966 --> 00:43:11,299
其实有一部分会用pass

1138
00:43:11,300 --> 00:43:13,000
variable和request parameter

1139
00:43:13,333 --> 00:43:14,666
所以大家可以看到它的

1140
00:43:15,966 --> 00:43:16,866
API不一样

1141
00:43:17,266 --> 00:43:18,199
参数不一样

1142
00:43:18,400 --> 00:43:20,133
返回值其实也是不一样的

1143
00:43:20,133 --> 00:43:21,866
那我们分别用两个Mapper

1144
00:43:21,866 --> 00:43:24,599
去实现了两个接口

1145
00:43:25,266 --> 00:43:26,599
的怎么去调法

1146
00:43:27,000 --> 00:43:29,166
那在这两个接口

1147
00:43:29,166 --> 00:43:30,699
在这两个Mac上面

1148
00:43:30,766 --> 00:43:31,766
我们可以看到

1149
00:43:31,766 --> 00:43:34,766
我们采用的方式就是间接的方式

1150
00:43:34,800 --> 00:43:37,466
我们把这一部分的代码

1151
00:43:37,933 --> 00:43:39,199
这边的这部分代码

1152
00:43:39,533 --> 00:43:41,599
称之为我们在支付模块里头

1153
00:43:41,600 --> 00:43:42,533
的主体代码

1154
00:43:42,533 --> 00:43:43,933
这其实是我们在支付模块中间

1155
00:43:43,933 --> 00:43:45,999
主要写的东西啊

1156
00:43:46,066 --> 00:43:48,099
那这部分代码

1157
00:43:48,100 --> 00:43:50,600
是我们在支付渠道有关的代码

1158
00:43:50,666 --> 00:43:54,299
我们的支付模块中间的主体的代码

1159
00:43:54,300 --> 00:43:57,300
没有直接调用它对应的这些API

1160
00:43:57,666 --> 00:44:00,166
而是通过了两个Adapter

1161
00:44:01,566 --> 00:44:04,066
去间接的使用它的API

1162
00:44:04,066 --> 00:44:06,466
这就是我们说的grasp中间的间接原则

1163
00:44:06,466 --> 00:44:07,699
我本来是可以直接调的

1164
00:44:08,200 --> 00:44:10,066
但是我没有直接钓

1165
00:44:10,133 --> 00:44:12,899
我去间接的通过他来钓

1166
00:44:13,133 --> 00:44:16,133
那不仅仅间接的通过他去钓

1167
00:44:16,200 --> 00:44:19,766
而且我还让这两个间接的对象

1168
00:44:20,000 --> 00:44:21,866
去实现了相同的接口

1169
00:44:21,933 --> 00:44:23,133
而我在调用他的时候

1170
00:44:23,133 --> 00:44:25,933
我不是调他的这个具体的对象

1171
00:44:26,300 --> 00:44:28,100
我是通过这个接口

1172
00:44:28,100 --> 00:44:31,100
来间接的使用了这个对象

1173
00:44:31,366 --> 00:44:32,999
这样做的好处就是

1174
00:44:33,000 --> 00:44:34,766
我们在这个设计图中你可以看到的

1175
00:44:34,766 --> 00:44:37,566
我们说的这个pay Adapter是一个接口

1176
00:44:37,700 --> 00:44:39,300
而不是具体的一个东西

1177
00:44:39,600 --> 00:44:40,766
我在用的时候

1178
00:44:40,966 --> 00:44:43,166
其实我就没有去区分说

1179
00:44:43,166 --> 00:44:46,166
我用的是支付宝还是微信

1180
00:44:46,200 --> 00:44:48,000
我用的是这个接口

1181
00:44:48,266 --> 00:44:51,399
而调支付宝还是调微信

1182
00:44:51,533 --> 00:44:54,966
他的这个转换是通过这个Adapter的

1183
00:44:55,200 --> 00:44:55,700
那当然

1184
00:44:55,700 --> 00:44:57,800
这个接口上面所定义的这个参数

1185
00:44:57,800 --> 00:45:00,333
还有它的返回值是我们自己定义的

1186
00:45:00,333 --> 00:45:02,899
我们相当于自己给所有的支付渠道

1187
00:45:02,900 --> 00:45:05,200
定义了一套中性的API

1188
00:45:05,733 --> 00:45:06,566
那中中性配置

1189
00:45:06,566 --> 00:45:08,166
定义在这个pay Adapter里头

1190
00:45:08,300 --> 00:45:08,566
然后

1191
00:45:08,566 --> 00:45:11,366
我们的这个微pay Adapter和阿里pay Adapter

1192
00:45:11,366 --> 00:45:14,933
目标是把中性的API的输入参数

1193
00:45:15,133 --> 00:45:18,999
转成阿里或者微信的参数

1194
00:45:19,466 --> 00:45:22,766
中信的API去转成调它对应的那个API

1195
00:45:22,933 --> 00:45:23,999
把它的返回值

1196
00:45:24,066 --> 00:45:25,499
转成我们中信的

1197
00:45:25,500 --> 00:45:27,733
自己定的这个API的返回值

1198
00:45:27,933 --> 00:45:28,499
这样的话

1199
00:45:28,500 --> 00:45:30,366
就使得我们在设计过程中间

1200
00:45:30,566 --> 00:45:31,566
在做的过程中间

1201
00:45:31,566 --> 00:45:32,366
主体代码中间

1202
00:45:32,366 --> 00:45:33,733
其实就没有看到

1203
00:45:33,733 --> 00:45:36,099
任何的微信和支付宝的痕迹了

1204
00:45:36,466 --> 00:45:37,266
看到的就是

1205
00:45:37,266 --> 00:45:42,066
我们去调我们的这个Adapter的接口

1206
00:45:42,200 --> 00:45:43,700
然后去得到相应的值

1207
00:45:43,700 --> 00:45:46,166
然后去弄到数据库里去

1208
00:45:46,666 --> 00:45:49,333
这个就是间接的方法

1209
00:45:49,500 --> 00:45:51,000
当然大家知道在这个里头

1210
00:45:51,000 --> 00:45:54,066
其实他不仅仅用了间接的一个方法

1211
00:45:54,333 --> 00:45:56,266
这个地方看到这个东西

1212
00:45:56,266 --> 00:45:57,099
你应该知道时候

1213
00:45:57,100 --> 00:45:58,400
他其实也用了多肽

1214
00:45:58,733 --> 00:45:59,933
所以说这个设计

1215
00:45:59,933 --> 00:46:03,933
其实是把间接和多肽两个方法

1216
00:46:04,600 --> 00:46:05,466
揉到一起了

1217
00:46:05,800 --> 00:46:07,300
用间接的方式啊

1218
00:46:07,300 --> 00:46:08,533
我们不去直接调用

1219
00:46:08,533 --> 00:46:09,699
他用多态的方式

1220
00:46:09,700 --> 00:46:11,066
把两个间接对象

1221
00:46:11,333 --> 00:46:15,366
把它做成一个接口的两个实线

1222
00:46:15,566 --> 00:46:17,466
从而我们可以调它的接口

1223
00:46:17,533 --> 00:46:21,999
而不再去管它的这个实线是什么了

1224
00:46:22,300 --> 00:46:25,500
这个就是我们的这个间接的例子

1225
00:46:26,133 --> 00:46:27,133
这块有问题吗

1226
00:46:27,500 --> 00:46:29,333
这块就是比前面那个

1227
00:46:29,400 --> 00:46:30,600
就陡然要难了一点

1228
00:46:30,600 --> 00:46:33,333
是吧因为我们在真正做的时候

1229
00:46:33,333 --> 00:46:35,766
其实不是孤立的在使用一个方法

1230
00:46:35,766 --> 00:46:37,333
这里头其实在讲间接的时候

1231
00:46:37,333 --> 00:46:37,733
就发现

1232
00:46:37,733 --> 00:46:40,866
他就是把间接和多肽两个方法

1233
00:46:40,933 --> 00:46:42,599
给他揉到一起去用

1234
00:46:45,000 --> 00:46:45,400
有问题吗

1235
00:46:45,400 --> 00:46:46,500
还有一分钟下课了

1236
00:46:47,966 --> 00:46:48,799
讲的慢一点啊

1237
00:46:48,800 --> 00:46:50,333
大家有问题就提出来

1238
00:46:51,000 --> 00:46:53,100
因为从这一周开始

1239
00:46:53,100 --> 00:46:55,333
我每一堂课讲的全是设计了

1240
00:46:56,600 --> 00:46:59,366
然后每一堂课其实都会是考试的内容

1241
00:46:59,366 --> 00:46:59,899
我们说了

1242
00:46:59,900 --> 00:47:00,366
考试内容

1243
00:47:00,366 --> 00:47:04,466
70%以上都是我们从这一周开始讲的

1244
00:47:04,466 --> 00:47:04,999
内容

1245
00:47:05,000 --> 00:47:07,066
就是我们主要考必做部分的内容

1246
00:47:07,266 --> 00:47:09,066
而不会去考选做部分的内容

1247
00:47:09,600 --> 00:47:10,666
所以每一堂课

1248
00:47:10,666 --> 00:47:12,699
大家如果有问题就要提出来

1249
00:47:12,933 --> 00:47:15,299
把这个问题解决到这个星期啊

1250
00:47:15,300 --> 00:47:16,000
不要拖到下个星

1251
00:47:16,000 --> 00:47:16,200
期

1252
00:47:16,200 --> 00:47:18,200
因为大家知道后面的设计会越来越难

1253
00:47:18,466 --> 00:47:20,966
我们的地区模块最简单

1254
00:47:20,966 --> 00:47:22,166
支付模块次值

1255
00:47:22,400 --> 00:47:23,866
其他的两个币种模块

1256
00:47:23,866 --> 00:47:24,966
比这两个模块还要麻

1257
00:47:24,966 --> 00:47:25,766
还要麻烦

1258
00:47:25,933 --> 00:47:27,899
所以设计会越来越难啊

1259
00:47:27,900 --> 00:47:28,700
那当然

1260
00:47:29,333 --> 00:47:31,466
呃你如果在前面跟不上的话

1261
00:47:31,466 --> 00:47:33,899
那后面就完全就看就听天书了啊

1262
00:47:34,733 --> 00:47:35,499
好没什么问题

1263
00:47:35,500 --> 00:47:36,100
我们先休息啊

1264
00:47:36,100 --> 00:47:37,533
我把前面那个设计改一下

1265
00:57:33,800 --> 00:57:35,066
好所以大家看一下

1266
00:57:35,066 --> 00:57:37,366
我把这个设计调了个顺序啊

1267
00:57:37,366 --> 00:57:38,966
把代码也改了过来

1268
00:57:39,333 --> 00:57:41,699
就是写的时候一定要注意

1269
00:57:41,700 --> 00:57:44,466
你要知道哪些是有状态的

1270
00:57:44,466 --> 00:57:45,899
哪些是没状态的

1271
00:57:46,400 --> 00:57:48,333
然后没状态的东西

1272
00:57:48,333 --> 00:57:50,966
设计时候没状态的东西都要靠后

1273
00:57:53,866 --> 00:57:55,566
所以原来的设计是这样

1274
00:57:56,366 --> 00:57:59,066
先调支付渠道去签约

1275
00:57:59,566 --> 00:58:01,399
去做分账关系绑定

1276
00:58:01,733 --> 00:58:03,666
然后再去查数据库

1277
00:58:03,666 --> 00:58:04,766
这是有问题的啊

1278
00:58:04,766 --> 00:58:06,533
因为后面数据库插错了

1279
00:58:06,733 --> 00:58:08,199
签约没办法回滚

1280
00:58:08,533 --> 00:58:10,399
所以把这个顺序调一下

1281
00:58:11,133 --> 00:58:14,066
这样的话就是先插数据库

1282
00:58:14,166 --> 00:58:15,499
再去签约

1283
00:58:15,533 --> 00:58:18,166
如果签约这边出问题了

1284
00:58:18,500 --> 00:58:21,066
就会把数据库回滚回来

1285
00:58:21,066 --> 00:58:24,799
因为我们的整个的事务边界

1286
00:58:24,800 --> 00:58:25,900
是在这个地方啊

1287
00:58:25,900 --> 00:58:26,766
在这个位置上

1288
00:58:31,933 --> 00:58:33,733
好那这个设计中间

1289
00:58:33,733 --> 00:58:34,399
我们可以看到

1290
00:58:34,400 --> 00:58:39,166
我们综合使用了两种grasp的设计方法

1291
00:58:39,300 --> 00:58:41,866
一种是多肽

1292
00:58:42,000 --> 00:58:43,866
一种是间接的

1293
00:58:43,866 --> 00:58:46,199
这样的一种方式啊

1294
00:58:46,200 --> 00:58:46,933
这里头注意

1295
00:58:46,933 --> 00:58:47,733
在这张图里头

1296
00:58:47,733 --> 00:58:48,799
我们并没有把

1297
00:58:48,800 --> 00:58:51,666
我并没有把所有的方法全部写上去

1298
00:58:51,666 --> 00:58:52,966
这只是我们在这个设计中间

1299
00:58:52,966 --> 00:58:54,399
有用到的方法

1300
00:58:54,933 --> 00:58:55,933
我才写上去了

1301
00:58:55,933 --> 00:58:58,566
其实在对象中间的方法

1302
00:58:58,566 --> 00:59:00,166
其实是比这个更多的啊

1303
00:59:00,166 --> 00:59:01,866
当然大家可以看到

1304
00:59:01,866 --> 00:59:04,199
从这类图的总总体能够看到

1305
00:59:04,600 --> 00:59:06,666
我们这样的一个设计的思路

1306
00:59:06,666 --> 00:59:07,766
我们这样的一个设计

1307
00:59:07,766 --> 00:59:10,366
的思路是把在收费时

1308
00:59:10,366 --> 00:59:11,499
中间的代码

1309
00:59:11,800 --> 00:59:17,000
尽量的分配给我们的Bo和do的对象

1310
00:59:17,366 --> 00:59:18,133
所以大家可以看到

1311
00:59:18,133 --> 00:59:21,599
在Bo和do对抗中间出现了很多的方法

1312
00:59:21,766 --> 00:59:25,366
这些方法就是我们称之为的业务方法

1313
00:59:25,900 --> 00:59:27,300
而设为史主要干嘛呢

1314
00:59:27,300 --> 00:59:28,933
设为史还是有方法

1315
00:59:28,933 --> 00:59:30,599
那些方法只是我们的入口

1316
00:59:30,600 --> 00:59:32,533
也是我们要做的这个功能

1317
00:59:32,600 --> 00:59:34,766
我们用面向对象的方式

1318
00:59:34,866 --> 00:59:38,333
把这些职责分给了我们的这个Bo对象

1319
00:59:38,466 --> 00:59:41,799
那Bo对象为什么能够承担这些职责

1320
00:59:42,200 --> 00:59:43,133
其根本的原因

1321
00:59:43,133 --> 00:59:43,499
是因为

1322
00:59:43,500 --> 00:59:45,966
我们在Bo对象中间置入了倒对象

1323
00:59:46,900 --> 00:59:48,200
对吧大家可以看到

1324
00:59:48,866 --> 00:59:51,099
在我们前面的代码中间

1325
00:59:51,100 --> 00:59:53,566
每一个倒对象在返回Bo对象时候

1326
00:59:53,566 --> 00:59:54,899
我们都会把它build一下

1327
00:59:55,200 --> 00:59:56,533
build的主要的原因

1328
00:59:56,533 --> 00:59:59,799
就是把这些Bo或者do对象中间

1329
00:59:59,800 --> 01:00:01,400
置入了这些倒对象

1330
01:00:01,600 --> 01:00:03,100
因为置入了这些倒对象

1331
01:00:03,100 --> 01:00:04,600
我们的Bo对象

1332
01:00:04,600 --> 01:00:10,000
就从一个仅仅只有属性的对象

1333
01:00:10,266 --> 01:00:13,533
变成了说他是能去操作数据库

1334
01:00:13,600 --> 01:00:16,333
能去操作外面的API的

1335
01:00:16,333 --> 01:00:18,199
我们把这个也放进去了

1336
01:00:18,333 --> 01:00:19,666
就能操作所有东西的

1337
01:00:19,666 --> 01:00:20,599
这样的一个Bo对象

1338
01:00:20,600 --> 01:00:21,933
我们称这样的Bo对象叫什么呢

1339
01:00:21,933 --> 01:00:23,799
叫做满血的Bo对象

1340
01:00:24,166 --> 01:00:27,133
就是相当于说给他打了激素

1341
01:00:27,500 --> 01:00:28,333
打了激素以后

1342
01:00:28,333 --> 01:00:31,899
我们才能够把在社会中间的一些职责

1343
01:00:32,100 --> 01:00:33,466
分给了这些Bo对象

1344
01:00:33,466 --> 01:00:34,566
在里头去写方法

1345
01:00:34,566 --> 01:00:37,733
去完成所以最后的这个结果

1346
01:00:37,733 --> 01:00:38,799
大家可以看到

1347
01:00:39,133 --> 01:00:39,699
在社会时

1348
01:00:39,700 --> 01:00:42,533
中间的方法的代码其实是比较少的

1349
01:00:42,800 --> 01:00:45,200
就是如果我们使用了面向对象的方式

1350
01:00:45,266 --> 01:00:47,399
用信息专家或者创建者的这个方式做

1351
01:00:47,400 --> 01:00:48,333
了分配以后

1352
01:00:49,066 --> 01:00:50,566
大量的代码

1353
01:00:50,566 --> 01:00:54,366
会被分散到我们的Bo对象中心来

1354
01:00:54,400 --> 01:00:57,300
或者叫做do对象里头来啊

1355
01:00:57,300 --> 01:00:59,733
这是这样的一个设计的思路

1356
01:00:59,733 --> 01:01:00,899
就是这样的一个结果

1357
01:01:01,600 --> 01:01:02,333
这边看到的

1358
01:01:02,333 --> 01:01:02,566
这个

1359
01:01:02,566 --> 01:01:07,933
综合使用了间接和多肽的这个方法的

1360
01:01:07,933 --> 01:01:08,799
这个设计

1361
01:01:08,800 --> 01:01:12,100
其实是一个经典的设计模式

1362
01:01:12,100 --> 01:01:15,866
这个设计模式叫做适配器的设计模式

1363
01:01:15,866 --> 01:01:16,966
叫做Adapter

1364
01:01:17,966 --> 01:01:19,166
Adapter设计模式

1365
01:01:19,166 --> 01:01:20,933
它的主要的用途

1366
01:01:20,933 --> 01:01:22,266
就是我们这里这个用途

1367
01:01:22,266 --> 01:01:23,266
我们这里这个用途

1368
01:01:23,266 --> 01:01:25,799
是一个标准的Adapter的用途

1369
01:01:26,166 --> 01:01:28,066
把一个类的接口

1370
01:01:28,066 --> 01:01:31,499
转化成为调用者所希望要的

1371
01:01:31,500 --> 01:01:32,333
另外一个接口

1372
01:01:32,900 --> 01:01:36,500
就是微信和支付宝的调用的API

1373
01:01:36,666 --> 01:01:39,733
我们把它转化成为一个统一的

1374
01:01:39,733 --> 01:01:42,099
我们自己定义的接口

1375
01:01:42,400 --> 01:01:45,466
那从而使得原本不兼容的

1376
01:01:45,466 --> 01:01:47,566
不能在一起工作的这些东西

1377
01:01:47,700 --> 01:01:50,933
把它变成了相同的东西

1378
01:01:51,066 --> 01:01:51,933
就这里所看到的

1379
01:01:51,933 --> 01:01:53,466
这是他的经典的内图

1380
01:01:53,766 --> 01:01:54,866
相当于这是微信的

1381
01:01:54,866 --> 01:01:55,766
这是支付宝的

1382
01:01:55,800 --> 01:01:57,733
然后我们通过这个Adapter

1383
01:01:57,900 --> 01:01:59,900
把它变成了一个相同的接口

1384
01:01:59,966 --> 01:02:01,133
然后我们的代码

1385
01:02:01,133 --> 01:02:04,066
只使用这个相同接口的这样一个东西

1386
01:02:04,333 --> 01:02:06,499
所以这个设计啊

1387
01:02:07,733 --> 01:02:09,466
就是一个标准的

1388
01:02:09,466 --> 01:02:14,599
没有做任何更变动的适配器的设计啊

1389
01:02:14,600 --> 01:02:17,266
适配器这个设计有什么样的好处呢

1390
01:02:17,266 --> 01:02:20,566
就是这个设计最大的好处就在于说

1391
01:02:20,766 --> 01:02:23,333
如果我们有一个新的支付渠道

1392
01:02:23,600 --> 01:02:24,566
支持的话

1393
01:02:24,766 --> 01:02:28,266
只需要在这边去做一套代码就好了

1394
01:02:28,533 --> 01:02:29,699
它不会影响到

1395
01:02:29,700 --> 01:02:31,533
我们现在的这些所有的代码

1396
01:02:31,533 --> 01:02:34,566
无论是我们的支付模块里头

1397
01:02:34,566 --> 01:02:36,799
去调用支付渠道的这些代码

1398
01:02:36,966 --> 01:02:39,333
还是微信和支付宝的代码

1399
01:02:39,500 --> 01:02:40,366
都不会影响

1400
01:02:40,366 --> 01:02:41,599
所以你只需要这边再做一

1401
01:02:41,600 --> 01:02:42,766
个新的Adapter

1402
01:02:42,766 --> 01:02:44,266
比如云闪付的Adapter

1403
01:02:44,533 --> 01:02:45,366
然后这里定义

1404
01:02:45,366 --> 01:02:47,466
云闪付的那个接口是什么样的

1405
01:02:47,566 --> 01:02:48,866
做一套新的代码

1406
01:02:49,566 --> 01:02:54,066
再在这个地方插入一个新的记录

1407
01:02:54,900 --> 01:02:56,333
做这两件事情就可以了

1408
01:02:56,600 --> 01:03:01,133
现有的所有的代码都不需要去做改动

1409
01:03:01,200 --> 01:03:02,733
这就是这个适配器模式

1410
01:03:02,733 --> 01:03:04,399
所带来的最大的好处

1411
01:03:04,500 --> 01:03:05,866
那同样比如说

1412
01:03:05,866 --> 01:03:09,399
我们今年把微信的这个API

1413
01:03:09,800 --> 01:03:11,600
从它最原始的那个API

1414
01:03:11,600 --> 01:03:16,366
改成了全面支持restful API的V3版本

1415
01:03:16,533 --> 01:03:19,933
那这个改动就仅限于在这和在这

1416
01:03:20,266 --> 01:03:21,333
这个定义改了

1417
01:03:21,866 --> 01:03:23,066
这个转换改了

1418
01:03:23,333 --> 01:03:25,499
而其他的部分都没有改

1419
01:03:25,766 --> 01:03:28,866
所以无论是新增一个支付渠道

1420
01:03:28,966 --> 01:03:32,599
还是现有的支付渠道的API的改动

1421
01:03:32,733 --> 01:03:35,933
你都会发现它具备一个很明显的特征

1422
01:03:36,133 --> 01:03:38,599
它跟其他的部分没关系

1423
01:03:39,466 --> 01:03:42,533
这就是这个模式所带来的好处啊

1424
01:03:42,533 --> 01:03:44,099
就是我们综合使用了

1425
01:03:44,100 --> 01:03:47,200
间接和多肽的模式

1426
01:03:47,200 --> 01:03:48,900
所带来的多肽的方法啊

1427
01:03:48,900 --> 01:03:49,933
所带来的好处

1428
01:03:51,166 --> 01:03:51,999
那我们再看一下

1429
01:03:52,000 --> 01:03:54,066
在这个上头做的另外一个功能

1430
01:03:54,066 --> 01:03:55,333
就是取消

1431
01:03:56,133 --> 01:03:58,866
取消这个支付渠道

1432
01:03:59,533 --> 01:04:00,666
这里头同样的啊

1433
01:04:00,666 --> 01:04:03,399
他其实是有一个啊

1434
01:04:03,400 --> 01:04:04,600
这个同样要改过来

1435
01:04:04,766 --> 01:04:07,466
对吧这个设计我写习惯了啊

1436
01:04:08,000 --> 01:04:09,333
大家知道为什么改过来吗

1437
01:04:11,000 --> 01:04:12,400
哪哪两句要改过来

1438
01:04:16,533 --> 01:04:18,133
这就是叫换个个啊

1439
01:04:19,400 --> 01:04:20,533
这两句要换个个

1440
01:04:20,566 --> 01:04:22,766
不能先去掉支付渠道

1441
01:04:23,566 --> 01:04:24,999
再去3数据库

1442
01:04:25,800 --> 01:04:27,000
原因是一样的

1443
01:04:27,366 --> 01:04:29,066
就是这里取消掉了

1444
01:04:29,066 --> 01:04:30,466
3数据库出了问题

1445
01:04:30,466 --> 01:04:31,733
这里是没办法回滚的

1446
01:04:31,766 --> 01:04:33,866
所以这都要换个个啊

1447
01:04:33,866 --> 01:04:35,766
这都要换个个啊

1448
01:04:35,766 --> 01:04:36,666
换了个以后啊

1449
01:04:36,666 --> 01:04:37,466
大家可以看到

1450
01:04:37,466 --> 01:04:39,699
同样在这个API中间

1451
01:04:39,900 --> 01:04:43,466
我们的基本的操作逻辑都是一样

1452
01:04:44,066 --> 01:04:45,499
第一思维是城进

1453
01:04:45,500 --> 01:04:47,733
来先用ID找到对象

1454
01:04:47,966 --> 01:04:50,466
因为我们是要取消一个支付渠道

1455
01:04:50,466 --> 01:04:51,733
商铺的支付渠道

1456
01:04:52,066 --> 01:04:53,699
所以我们去用ID

1457
01:04:53,766 --> 01:04:55,899
找到他的商铺的支付渠道

1458
01:04:56,100 --> 01:04:58,666
然后我们认为取消的这个职责

1459
01:04:59,066 --> 01:05:03,199
所需要的信息全在商铺的支付渠道里

1460
01:05:03,333 --> 01:05:05,133
所以就在商铺的里头

1461
01:05:05,133 --> 01:05:06,733
做了一个concel的方法

1462
01:05:06,800 --> 01:05:07,700
让他去取消

1463
01:05:07,700 --> 01:05:08,800
取消这两件事情

1464
01:05:08,933 --> 01:05:10,399
第一删数据库

1465
01:05:10,466 --> 01:05:14,266
第二调API去把它取消掉啊

1466
01:05:14,266 --> 01:05:17,099
所以这是我们的这个设计啊

1467
01:05:17,100 --> 01:05:19,366
所以你这个结构定下来以后

1468
01:05:19,366 --> 01:05:19,866
你会发现

1469
01:05:19,866 --> 01:05:22,999
我们所有的跟支付渠道有关系的

1470
01:05:23,000 --> 01:05:24,000
这样的一个做法

1471
01:05:24,300 --> 01:05:26,966
基本上都会采用这种类似的方式啊

1472
01:05:26,966 --> 01:05:27,766
去完成

1473
01:05:29,733 --> 01:05:31,866
这是间接

1474
01:05:32,266 --> 01:05:33,099
那第三个

1475
01:05:33,100 --> 01:05:34,966
我们要讲的是我们之前没有讲过的

1476
01:05:34,966 --> 01:05:36,533
我本来想要把它略过去啊

1477
01:05:36,533 --> 01:05:37,733
但是我发现略不过去

1478
01:05:37,933 --> 01:05:39,566
那就是虚构

1479
01:05:39,566 --> 01:05:41,533
叫做Puree fabrication

1480
01:05:41,900 --> 01:05:43,666
这是我们要讲的第五种方法

1481
01:05:43,666 --> 01:05:48,133
就是创建者信息专家多肽间接

1482
01:05:48,400 --> 01:05:51,200
然后我们加了一个叫做pure fabrication啊

1483
01:05:51,200 --> 01:05:52,500
虚构的模式

1484
01:05:52,766 --> 01:05:53,866
因为在这个设计中间

1485
01:05:53,866 --> 01:05:56,466
大家会发现我们没有管说

1486
01:05:57,900 --> 01:05:58,566
没有管说

1487
01:05:58,566 --> 01:06:00,799
这个pay Adapter

1488
01:06:01,066 --> 01:06:03,399
到底是一个什么样的对象

1489
01:06:03,533 --> 01:06:05,466
我们就直接去使用它了

1490
01:06:05,766 --> 01:06:08,533
那当然大家在看这张图的时候啊

1491
01:06:08,533 --> 01:06:09,533
大家应该知道

1492
01:06:09,733 --> 01:06:12,199
这个pay Adapter是一个对象

1493
01:06:12,200 --> 01:06:14,366
这个对象在这里头都没有看到是吧

1494
01:06:14,366 --> 01:06:14,966
在整张图里头

1495
01:06:14,966 --> 01:06:16,766
没有看到说他是从哪来的

1496
01:06:16,933 --> 01:06:19,533
所以这个信息你就只能到哪去找了

1497
01:06:20,000 --> 01:06:20,900
只能到哪去找

1498
01:06:22,366 --> 01:06:23,466
到类图上去找

1499
01:06:23,466 --> 01:06:26,466
我们只有两个静态模型和动态模型

1500
01:06:26,666 --> 01:06:29,199
所以我们知道在动态模型上面

1501
01:06:29,200 --> 01:06:31,666
上面画的这一溜全是对象

1502
01:06:31,900 --> 01:06:32,600
这些对象

1503
01:06:32,600 --> 01:06:33,900
第一个对象是我们要

1504
01:06:33,900 --> 01:06:34,766
描述的目标

1505
01:06:34,766 --> 01:06:37,133
所以我们不需要描述说他是谁啊

1506
01:06:37,133 --> 01:06:37,966
大部分情况下

1507
01:06:37,966 --> 01:06:40,333
头不需要描述他是谁

1508
01:06:40,466 --> 01:06:43,733
但是其他的对象都需要描述

1509
01:06:43,966 --> 01:06:47,166
这些对象的前面的这个名字

1510
01:06:47,466 --> 01:06:49,766
要么是他的变量

1511
01:06:49,766 --> 01:06:50,733
比如说这一个

1512
01:06:50,733 --> 01:06:51,666
大家可以看到

1513
01:06:51,966 --> 01:06:56,799
他是我们调这个方法的返回值

1514
01:06:57,100 --> 01:06:58,566
所以说他是他

1515
01:06:59,200 --> 01:07:00,766
那他呢

1516
01:07:01,466 --> 01:07:03,199
他呢他呢

1517
01:07:03,566 --> 01:07:04,999
在这里头你都没看到

1518
01:07:05,466 --> 01:07:10,699
那这些东西你则需要怎么办呢

1519
01:07:10,700 --> 01:07:12,600
则需要到类图上去看

1520
01:07:13,166 --> 01:07:16,199
所以我们在类图上可以看到

1521
01:07:19,533 --> 01:07:20,566
比如第一个啊

1522
01:07:20,566 --> 01:07:21,933
我们从收位史

1523
01:07:21,933 --> 01:07:25,599
来调这个对象的这一个方法

1524
01:07:25,700 --> 01:07:27,466
那这个对象在收位史中间

1525
01:07:27,466 --> 01:07:28,399
是一定要知道的

1526
01:07:28,400 --> 01:07:29,133
要不知道的话

1527
01:07:29,133 --> 01:07:31,066
他就不可能来调这个方法

1528
01:07:31,166 --> 01:07:33,966
所以我们从收位史中的方法来看

1529
01:07:34,300 --> 01:07:36,500
他的这个对象

1530
01:07:36,500 --> 01:07:37,866
其实就是在类图上的

1531
01:07:37,866 --> 01:07:38,999
所标识的这个属性

1532
01:07:39,000 --> 01:07:39,800
这条线

1533
01:07:40,733 --> 01:07:42,933
所以你在这里头就可以看到啊

1534
01:07:42,933 --> 01:07:43,699
原来在收费时

1535
01:07:43,700 --> 01:07:45,466
中间他去调这个方法的时候

1536
01:07:45,466 --> 01:07:49,733
他是调自己属性的这个方法对吧

1537
01:07:50,300 --> 01:07:53,300
然后这个我们知道是他的返回值啊

1538
01:07:53,300 --> 01:07:53,400
所以

1539
01:07:53,400 --> 01:07:55,566
我们去调查他的返回值的这个方法

1540
01:07:55,600 --> 01:07:57,566
那在他这个里头

1541
01:07:57,566 --> 01:08:00,099
他怎么知道这个pay adapter

1542
01:08:00,166 --> 01:08:02,666
怎么知道shop channel到

1543
01:08:03,066 --> 01:08:05,366
所以我们从这个对象channel

1544
01:08:05,366 --> 01:08:06,566
这个对象去看

1545
01:08:07,766 --> 01:08:08,566
这个对象

1546
01:08:09,333 --> 01:08:10,299
这个对象

1547
01:08:10,366 --> 01:08:13,366
他的pay Adapter是他的一个属性

1548
01:08:13,533 --> 01:08:15,899
他的shop channel也是他的一个属性

1549
01:08:15,966 --> 01:08:17,199
所以说他才能知道

1550
01:08:17,200 --> 01:08:18,900
说他的shop channel是这个

1551
01:08:19,000 --> 01:08:21,466
他的pay Adapter是这个对吧

1552
01:08:21,466 --> 01:08:23,499
是这样的一个关系

1553
01:08:23,800 --> 01:08:25,333
所以在这个类图上大家可以看到

1554
01:08:25,333 --> 01:08:26,966
我们对于每一个channel对象

1555
01:08:26,966 --> 01:08:29,099
其实都给他放了一个属性

1556
01:08:29,100 --> 01:08:30,400
这个属性是一个pay

1557
01:08:30,400 --> 01:08:31,533
adapter的接口

1558
01:08:31,800 --> 01:08:32,400
那当然

1559
01:08:32,400 --> 01:08:35,000
这个属性我们一定要成对的去放

1560
01:08:35,466 --> 01:08:38,599
比如说我们这个渠道是支付宝

1561
01:08:38,766 --> 01:08:40,366
那当然我们应该放的是他

1562
01:08:41,133 --> 01:08:42,933
那如果这个渠道是微信的话

1563
01:08:42,933 --> 01:08:44,166
我们应该是放他

1564
01:08:44,566 --> 01:08:46,999
如果这个渠道是什么呢

1565
01:08:47,000 --> 01:08:48,266
是云闪付的话

1566
01:08:48,266 --> 01:08:50,199
那我们就应该放第三个云闪付

1567
01:08:50,500 --> 01:08:52,966
那现在的问题就是谁来放的这个东西

1568
01:08:53,866 --> 01:08:55,133
谁把这个

1569
01:08:56,533 --> 01:08:57,866
合适的Adapter

1570
01:08:57,900 --> 01:09:00,600
跟这个channel建立的这样一个关联

1571
01:09:00,666 --> 01:09:03,366
使得我们在做所有的这些方法的时候

1572
01:09:03,866 --> 01:09:06,799
就能够直接去调对应的Adapter

1573
01:09:06,800 --> 01:09:08,366
去完成这样一个过程

1574
01:09:08,600 --> 01:09:09,966
谁做的这个事情呢

1575
01:09:11,000 --> 01:09:11,766
这个事情啊

1576
01:09:11,766 --> 01:09:12,566
大家知道

1577
01:09:13,733 --> 01:09:15,799
这要说到具体的spring的框架了

1578
01:09:15,933 --> 01:09:17,166
在spring的框架中间

1579
01:09:17,166 --> 01:09:17,966
我们知道

1580
01:09:19,300 --> 01:09:22,300
这一个对象不是spring的冰对象

1581
01:09:22,933 --> 01:09:24,599
所以说它里头的属性

1582
01:09:24,600 --> 01:09:27,300
不是由Supreme注射进来的

1583
01:09:27,600 --> 01:09:29,166
那不是由Supreme注射进来的

1584
01:09:29,166 --> 01:09:30,899
这个属性是从哪来的呢

1585
01:09:30,900 --> 01:09:33,100
我们知道我们的前面的原则上来说

1586
01:09:33,100 --> 01:09:34,466
就是我们这个对象

1587
01:09:34,733 --> 01:09:37,399
是从channel中间把它查出来的

1588
01:09:37,933 --> 01:09:39,266
查出来这个对象以后

1589
01:09:39,266 --> 01:09:40,999
我们要做一个build

1590
01:09:41,500 --> 01:09:42,266
build的作用

1591
01:09:42,266 --> 01:09:47,066
就是把这些东西给他关联上

1592
01:09:47,133 --> 01:09:48,799
因为只有把倒对象

1593
01:09:48,800 --> 01:09:50,333
还有这些东西给他关联上了

1594
01:09:50,333 --> 01:09:51,733
我们的这个channel对象

1595
01:09:51,733 --> 01:09:53,499
成为成为一个满血对象

1596
01:09:53,500 --> 01:09:55,300
才能去做这些方法

1597
01:09:55,300 --> 01:09:56,666
如果没有这些东西的话

1598
01:09:56,666 --> 01:09:58,333
他其实是不能做这些方法的

1599
01:09:58,566 --> 01:09:59,866
对吧那我们知道

1600
01:09:59,866 --> 01:10:02,966
这个对象的属性的设定

1601
01:10:03,166 --> 01:10:06,733
是在channel中间的build方法来完成的

1602
01:10:07,000 --> 01:10:09,066
所以在channel中间的build方法中间

1603
01:10:09,066 --> 01:10:10,333
就存在着一个问题

1604
01:10:10,366 --> 01:10:13,199
我到底是build的它的时候

1605
01:10:13,200 --> 01:10:14,533
是把它把它关联上来

1606
01:10:14,533 --> 01:10:17,133
呢还是把它给它关联上来

1607
01:10:18,066 --> 01:10:19,566
当然我们用最简单的代码

1608
01:10:19,566 --> 01:10:21,466
是可以用衣服l来写的

1609
01:10:21,466 --> 01:10:22,999
就在它的build方法中间

1610
01:10:23,066 --> 01:10:24,599
我们去写它的

1611
01:10:24,766 --> 01:10:26,899
衣服它是什么什么什么类型

1612
01:10:26,966 --> 01:10:27,999
写一个属性啊

1613
01:10:28,000 --> 01:10:29,600
衣服它是什么什么的类型

1614
01:10:29,600 --> 01:10:31,000
就是type

1615
01:10:31,000 --> 01:10:32,100
衣服它什么什么type

1616
01:10:32,100 --> 01:10:33,166
它就把它搞上来

1617
01:10:33,166 --> 01:10:34,299
衣服它是什么type

1618
01:10:34,300 --> 01:10:35,066
就把它搞上来

1619
01:10:35,066 --> 01:10:35,866
可以这么写

1620
01:10:36,266 --> 01:10:37,399
但是这么写有个毛病

1621
01:10:37,400 --> 01:10:38,133
这个毛病是什么

1622
01:10:38,133 --> 01:10:39,533
我们刚才说了我们的设计

1623
01:10:39,566 --> 01:10:40,466
我们希望

1624
01:10:40,466 --> 01:10:43,299
当我们增加一个新的支付渠道

1625
01:10:43,300 --> 01:10:44,133
进来的时候

1626
01:10:44,166 --> 01:10:47,333
我们希望除了这部分代码以外

1627
01:10:48,666 --> 01:10:49,599
其他码都不动

1628
01:10:50,500 --> 01:10:51,100
那意味着说

1629
01:10:51,100 --> 01:10:52,933
你在这里去写一个EFL的话

1630
01:10:52,933 --> 01:10:53,899
这就需要动了

1631
01:10:54,166 --> 01:10:56,199
这就违背了我们的设计初衷

1632
01:10:56,566 --> 01:10:59,499
意味着说我们不能写这样的一个EFLS

1633
01:11:00,000 --> 01:11:00,600
就是我们

1634
01:11:00,600 --> 01:11:01,400
因为设计目标就是

1635
01:11:01,400 --> 01:11:02,466
我们增加新的支付渠道

1636
01:11:02,466 --> 01:11:03,799
是我们希望所有的买的不动

1637
01:11:03,966 --> 01:11:05,399
那这里就不能写EFL

1638
01:11:05,766 --> 01:11:07,699
不能写EFL怎么办

1639
01:11:07,933 --> 01:11:11,399
我们把创建对象的这个逻辑

1640
01:11:12,333 --> 01:11:13,966
把它抽离出来

1641
01:11:14,500 --> 01:11:18,900
把它交给了一个叫做pay adapt factory对象

1642
01:11:18,933 --> 01:11:20,066
这个对象是怎么来的呢

1643
01:11:20,066 --> 01:11:22,766
这个对象就我们所说的虚构的

1644
01:11:23,533 --> 01:11:25,366
就是我们要建这样的一个东西

1645
01:11:25,366 --> 01:11:26,466
而这个东西呢

1646
01:11:26,866 --> 01:11:29,666
很复杂因为我们不想用EFL来写

1647
01:11:29,666 --> 01:11:30,999
EFL是比较简单

1648
01:11:31,000 --> 01:11:33,766
写出来以后这个代码就要跟着改

1649
01:11:34,066 --> 01:11:35,933
那如果不想用EFL写

1650
01:11:35,933 --> 01:11:37,399
那就会变得比较复杂一点

1651
01:11:37,766 --> 01:11:38,733
这个复杂的东西

1652
01:11:38,733 --> 01:11:41,099
我们把它放到抽出来啊

1653
01:11:41,100 --> 01:11:44,500
把它交给一个独立的对象去完成

1654
01:11:44,733 --> 01:11:47,499
这就是我们所说的虚构的对象

1655
01:11:47,500 --> 01:11:49,466
专门虚构了一个对象

1656
01:11:49,733 --> 01:11:52,099
去创建这个适配器

1657
01:11:52,466 --> 01:11:54,066
这个虚构对象啊

1658
01:11:54,066 --> 01:11:57,099
是怎样去完成这个创建过程的

1659
01:11:57,133 --> 01:11:58,099
这里头就涉及到了

1660
01:11:58,100 --> 01:12:00,166
spin框架的一些相关的技术

1661
01:12:22,766 --> 01:12:24,299
所以在类图上头啊

1662
01:12:24,300 --> 01:12:26,566
我们可以看到在channel中间

1663
01:12:26,933 --> 01:12:27,666
我们知道

1664
01:12:27,666 --> 01:12:30,999
那个关系是在be的方法中间完成的

1665
01:12:33,400 --> 01:12:35,200
所以恰恰我们所有的倒对象后面

1666
01:12:35,200 --> 01:12:37,400
基本都有两个build的方法啊

1667
01:12:37,400 --> 01:12:38,133
这个build方法

1668
01:12:38,133 --> 01:12:40,066
其实严格它应该返回一个值啊

1669
01:12:41,466 --> 01:12:42,199
标准来说

1670
01:12:42,200 --> 01:12:45,100
应该是我们用同样的方式来处理

1671
01:12:46,500 --> 01:12:47,933
是应该返回一个值的

1672
01:12:56,333 --> 01:12:56,666
啊

1673
01:12:56,666 --> 01:12:59,066
这个就是我们在做这个写代码的时候

1674
01:12:59,066 --> 01:12:59,966
一个好的习惯

1675
01:12:59,966 --> 01:13:00,566
虽然我们知道

1676
01:13:00,566 --> 01:13:02,466
我们传参传的是一个对象

1677
01:13:02,466 --> 01:13:04,099
对象传的是一个引用

1678
01:13:04,300 --> 01:13:05,933
所以我们去改这个对象的值

1679
01:13:05,933 --> 01:13:08,566
是能够把它带回去的

1680
01:13:08,900 --> 01:13:10,766
但是我们一般在写代码的时候

1681
01:13:10,766 --> 01:13:13,299
我们不要去让大家读代码的时候

1682
01:13:13,300 --> 01:13:14,766
有一个这么这么

1683
01:13:15,266 --> 01:13:17,166
好像要转一下才能反应过来哦

1684
01:13:17,166 --> 01:13:18,699
这个bo对象其实是改了词

1685
01:13:18,700 --> 01:13:19,766
他会带回去的啊

1686
01:13:19,866 --> 01:13:21,699
所以我们都会做的更加直白一点

1687
01:13:21,700 --> 01:13:24,366
就是在这里头改了Bo对象啊

1688
01:13:24,366 --> 01:13:25,466
然后把它传回去

1689
01:13:25,466 --> 01:13:26,733
这就是好习惯

1690
01:13:26,733 --> 01:13:29,099
让你的代码看起来更加容易理解

1691
01:13:29,100 --> 01:13:31,600
但其实这个返返回值返不返都无所谓

1692
01:13:31,600 --> 01:13:33,166
因为传进来的对象在里头改了以后

1693
01:13:33,166 --> 01:13:34,333
他会带回去啊

1694
01:13:34,333 --> 01:13:36,366
因为这要知道Java传对象

1695
01:13:36,366 --> 01:13:37,799
其实传的是他的引用

1696
01:13:38,166 --> 01:13:39,333
但是我们还是要写代码

1697
01:13:39,333 --> 01:13:40,299
有这样一个好习惯

1698
01:13:40,300 --> 01:13:42,366
让大家看起来不用不用转弯

1699
01:13:43,400 --> 01:13:44,133
用起来啊

1700
01:13:44,133 --> 01:13:44,899
也不用转弯

1701
01:13:44,900 --> 01:13:46,866
所以我们这里有两个build的方法

1702
01:13:47,166 --> 01:13:48,333
那在build的方法中间

1703
01:13:48,333 --> 01:13:50,099
我们知道我们在图上头

1704
01:13:50,366 --> 01:13:51,333
刚才看到图上头我

1705
01:13:51,333 --> 01:13:52,866
们把两个道设进去了

1706
01:13:53,200 --> 01:13:54,266
那除了设了道以外

1707
01:13:54,266 --> 01:13:57,133
我们其实还把这个pay adapter设进去了

1708
01:13:57,200 --> 01:13:58,666
但大家注意可以看到

1709
01:13:58,733 --> 01:14:02,133
如果说我们是写死代码的话

1710
01:14:02,366 --> 01:14:04,566
在say的就在这一句的时候

1711
01:14:06,700 --> 01:14:08,000
是要用EFL的

1712
01:14:08,300 --> 01:14:09,733
就是要判断说

1713
01:14:09,900 --> 01:14:12,166
这个channel到底是什么类型的channel

1714
01:14:12,333 --> 01:14:16,133
给它设we pay Adapter还是设Alipay Adapter

1715
01:14:16,200 --> 01:14:17,800
但我不想写EFLS

1716
01:14:18,133 --> 01:14:21,333
所以我就把到底设这个pay adapter

1717
01:14:21,333 --> 01:14:22,399
这个东西

1718
01:14:22,400 --> 01:14:23,666
到底设的是谁

1719
01:14:24,066 --> 01:14:25,966
交给了一个虚构的对象

1720
01:14:25,966 --> 01:14:26,966
这个对象是什么呢

1721
01:14:26,966 --> 01:14:28,399
这个对象就是一个factory

1722
01:14:29,533 --> 01:14:31,899
所以我设了一个factory进去

1723
01:14:31,900 --> 01:14:33,300
就把个虚构对象给他了

1724
01:14:33,366 --> 01:14:36,499
那虚构对象来告诉他说他是什么东西

1725
01:14:36,600 --> 01:14:37,866
那这个factory是什么呢

1726
01:14:37,866 --> 01:14:39,599
这个factory其实就是

1727
01:14:42,600 --> 01:14:44,966
我们在这里定义的一个虚构对象

1728
01:14:45,966 --> 01:14:47,066
这就是这个factory

1729
01:14:47,266 --> 01:14:47,899
这个factory呢

1730
01:14:47,900 --> 01:14:49,566
很简单你都只写了一个方法

1731
01:14:49,566 --> 01:14:53,566
就是他负责决定这个pay Adapter是什么

1732
01:14:53,600 --> 01:14:56,166
所以写了一个方法叫做create pay adapter

1733
01:14:56,333 --> 01:14:57,999
它来决定是谁

1734
01:14:58,100 --> 01:14:59,300
那它靠什么来决定

1735
01:14:59,300 --> 01:15:01,333
当然是靠着这个channel来决定的

1736
01:15:01,400 --> 01:15:03,066
就是当前这个渠道是什么

1737
01:15:03,166 --> 01:15:04,566
我们可以看到我们这个做法

1738
01:15:04,566 --> 01:15:06,666
我们不是在当前渠道里头去判断

1739
01:15:06,666 --> 01:15:07,699
它的type

1740
01:15:07,700 --> 01:15:08,333
衣服是什么

1741
01:15:08,333 --> 01:15:09,133
这是什么

1742
01:15:09,266 --> 01:15:10,933
而是我们在这个渠道

1743
01:15:10,933 --> 01:15:13,266
在channel中间写了一个be name

1744
01:15:13,766 --> 01:15:14,933
这个be name是什么呢

1745
01:15:14,933 --> 01:15:16,866
这个be name在对象模型中间

1746
01:15:16,866 --> 01:15:18,533
我们其实也已经看到了

1747
01:15:30,466 --> 01:15:31,266
在这

1748
01:15:33,366 --> 01:15:33,966
我们可以看到

1749
01:15:33,966 --> 01:15:34,799
在它的属性里头

1750
01:15:34,800 --> 01:15:36,966
我们其实完全没有写它是什么类型

1751
01:15:36,966 --> 01:15:37,999
它是支付宝还是微信

1752
01:15:38,000 --> 01:15:39,100
没有写但是我们给

1753
01:15:39,100 --> 01:15:41,066
它写了一个属性名称叫做be name

1754
01:15:41,266 --> 01:15:42,499
这个be name干嘛呢

1755
01:15:42,500 --> 01:15:43,100
这个be name

1756
01:15:43,100 --> 01:15:45,600
记得其实是我们在写好代码以后

1757
01:15:46,100 --> 01:15:49,266
他的screen中间所叫的并的名字

1758
01:15:49,466 --> 01:15:52,266
和他在screen中间中叫的并的名字

1759
01:15:52,400 --> 01:15:54,366
所以因为这一条记录

1760
01:15:54,366 --> 01:15:56,766
不是通过界面插进去的

1761
01:15:56,766 --> 01:15:57,733
就这个对象

1762
01:15:58,166 --> 01:16:00,166
是来自于一个数据库里的一条记录

1763
01:16:00,200 --> 01:16:02,133
这条记录不是在界面上有个API

1764
01:16:02,133 --> 01:16:02,933
插进去的

1765
01:16:02,933 --> 01:16:04,566
这条记录是怎么插进去的呢

1766
01:16:04,666 --> 01:16:04,866
是

1767
01:16:04,866 --> 01:16:07,599
我当做了一个云闪付的一套东西以后

1768
01:16:07,700 --> 01:16:11,200
我就会在这里头直接把这个数据库

1769
01:16:11,200 --> 01:16:12,600
这条记录给它插进去

1770
01:16:12,933 --> 01:16:15,133
说云闪付的这个东西是什么

1771
01:16:15,133 --> 01:16:17,766
所以他是不能从界面上去查的

1772
01:16:17,866 --> 01:16:21,966
必须得要靠维护的工程师去查记录

1773
01:16:22,100 --> 01:16:24,366
因为他为什么一定要查记录

1774
01:16:24,500 --> 01:16:26,133
是因为这个代码是要改的

1775
01:16:26,133 --> 01:16:28,499
你不能说你查一个云闪付的那条记录

1776
01:16:28,700 --> 01:16:30,000
没有云闪付的代码

1777
01:16:30,333 --> 01:16:31,266
这是没有用的

1778
01:16:31,266 --> 01:16:33,299
是吧所以说既然要改代嘛

1779
01:16:33,300 --> 01:16:35,266
所以说就是把数据库要做升级

1780
01:16:35,266 --> 01:16:35,999
升级系统

1781
01:16:36,000 --> 01:16:36,900
升级数据库

1782
01:16:37,100 --> 01:16:38,600
把这条记录插进去

1783
01:16:38,766 --> 01:16:39,599
插的时候

1784
01:16:39,600 --> 01:16:43,166
这个东西写的是他在spin对象

1785
01:16:43,800 --> 01:16:45,600
Supreme并的名称

1786
01:16:46,300 --> 01:16:49,266
写Supreme并的名称有什么样的作用

1787
01:16:49,266 --> 01:16:51,799
这就涉及到Supreme框架的一个特性了

1788
01:16:51,800 --> 01:16:52,400
大家知道

1789
01:16:52,400 --> 01:16:55,166
Supreme的所有的冰对象

1790
01:16:55,333 --> 01:16:58,133
都是由Supreme的容器来创建的

1791
01:16:58,400 --> 01:17:00,066
Supreme的容器靠什么来创建

1792
01:17:00,066 --> 01:17:00,733
靠两个东西

1793
01:17:00,733 --> 01:17:02,066
一个是冰factory

1794
01:17:02,166 --> 01:17:04,166
一个是application context

1795
01:17:04,166 --> 01:17:06,366
这个我们在joy一一的最早的课里头

1796
01:17:06,366 --> 01:17:07,399
就已经讲过了

1797
01:17:07,566 --> 01:17:08,199
那我们知道

1798
01:17:08,200 --> 01:17:08,866
我们在今天

1799
01:17:08,866 --> 01:17:10,966
已经不太使用它的冰factory了

1800
01:17:10,966 --> 01:17:13,733
而是会使用它的application contacts所

1801
01:17:13,733 --> 01:17:13,799
以

1802
01:17:13,800 --> 01:17:17,366
这里就使用了screen框架的uplication context

1803
01:17:17,400 --> 01:17:18,200
看见没有

1804
01:17:18,333 --> 01:17:20,399
怎么使用screen框架的uplication contest

1805
01:17:20,400 --> 01:17:23,200
这里其实看到在screen中其实很简单

1806
01:17:23,333 --> 01:17:24,099
你要用它

1807
01:17:24,100 --> 01:17:25,366
你就让它告诉我

1808
01:17:26,333 --> 01:17:30,266
所以我们让spin的框架把上下文

1809
01:17:30,266 --> 01:17:35,099
这个pink context注入到我们的这个factory

1810
01:17:35,100 --> 01:17:36,100
这是个冰对象

1811
01:17:36,100 --> 01:17:37,966
这也是由spin的容器创建的

1812
01:17:38,000 --> 01:17:41,000
所以spin容器在创建payer double factory时候

1813
01:17:41,000 --> 01:17:43,400
就把它的上下文给它注册进来

1814
01:17:43,666 --> 01:17:45,266
注册进来以后我们干什么用呢

1815
01:17:45,266 --> 01:17:46,299
就是干这个用的

1816
01:17:46,966 --> 01:17:49,299
就是我们在channel中间记了说

1817
01:17:49,400 --> 01:17:54,000
我们那个阿里佩和微配的spin

1818
01:17:54,000 --> 01:17:55,666
中间的并的名字是什么

1819
01:17:55,966 --> 01:17:57,933
那我现在就用这个名字找spin的

1820
01:17:57,933 --> 01:17:59,066
spin的框架

1821
01:17:59,300 --> 01:18:00,600
去把那个对象拿出来

1822
01:18:01,266 --> 01:18:03,299
所以这种方式来说

1823
01:18:03,300 --> 01:18:06,466
其实我们是有一种通用的设计方式

1824
01:18:06,666 --> 01:18:08,899
叫做数据驱动的设计方式

1825
01:18:10,366 --> 01:18:11,533
这不属于面向对象的啊

1826
01:18:11,533 --> 01:18:12,799
所以我们就在这里没有写

1827
01:18:12,800 --> 01:18:15,100
他是面向对象的设计方法

1828
01:18:15,100 --> 01:18:17,400
但是这是我们其实在做所有程序中间

1829
01:18:17,400 --> 01:18:20,000
经常会用到的一种设计方式

1830
01:18:20,000 --> 01:18:21,966
叫做数据驱动的设计方式

1831
01:18:22,400 --> 01:18:22,900
什么意思呢

1832
01:18:22,900 --> 01:18:26,666
就是把变化的东西写在数据里头

1833
01:18:26,800 --> 01:18:27,900
现在的我们做法是

1834
01:18:27,900 --> 01:18:30,933
把变化的东西写在数据库的表里头

1835
01:18:31,066 --> 01:18:34,766
最后变成我们在Bo对象的一个属性

1836
01:18:35,066 --> 01:18:36,199
然后呢我们的代码

1837
01:18:36,200 --> 01:18:38,933
其实是读取这个数据库表里头的

1838
01:18:38,933 --> 01:18:41,366
这个值来决定说

1839
01:18:42,100 --> 01:18:44,900
我应该给他一个什么样的pay Adapter

1840
01:18:44,933 --> 01:18:47,199
这就是数据驱动的设计方式啊

1841
01:18:47,200 --> 01:18:49,600
这个是不是面向对象的设计方法

1842
01:18:49,600 --> 01:18:52,000
但是它是我们基本上都设计时候

1843
01:18:52,000 --> 01:18:53,733
常用的一种做法把

1844
01:18:53,733 --> 01:18:54,533
这个变化的值

1845
01:18:54,533 --> 01:18:56,333
写到了channel的一个属性里

1846
01:18:56,533 --> 01:19:00,533
所以在pay Adapter的factory这个方法中间

1847
01:19:00,533 --> 01:19:02,566
我们把这个属性读出来

1848
01:19:02,566 --> 01:19:04,466
读到channel的这个getting name

1849
01:19:04,600 --> 01:19:06,866
然后利用screen框架的特性

1850
01:19:07,000 --> 01:19:08,500
在screen的容器里头

1851
01:19:08,500 --> 01:19:10,300
找到对应的being对象

1852
01:19:10,300 --> 01:19:12,500
然后把这个being对象给它返回回来

1853
01:19:12,800 --> 01:19:14,800
所以在build的方法中间

1854
01:19:16,400 --> 01:19:17,966
在它的这个build方法中间

1855
01:19:17,966 --> 01:19:20,099
它会去调build对象的say the Adapter

1856
01:19:20,100 --> 01:19:21,966
但是不是给它的一个Adapter

1857
01:19:22,000 --> 01:19:23,400
而是给它的一个factory

1858
01:19:25,600 --> 01:19:27,566
然后大家去看他的say the Adapter

1859
01:19:27,566 --> 01:19:28,799
其实干的事情就是

1860
01:19:28,933 --> 01:19:30,766
他不能直接拿到这个Adapter

1861
01:19:30,766 --> 01:19:31,166
但它可以

1862
01:19:31,166 --> 01:19:33,899
通过我们虚构的这个factory的对象

1863
01:19:34,133 --> 01:19:36,999
去调它的Crede payer Adapter的方法

1864
01:19:37,533 --> 01:19:39,733
把当前的channel传给他

1865
01:19:39,866 --> 01:19:41,266
就知道这个channel

1866
01:19:41,466 --> 01:19:44,299
应该配一个什么样的配adapter

1867
01:19:44,533 --> 01:19:47,133
所以这里用了两种设计方式

1868
01:19:47,300 --> 01:19:50,533
一个设计方式是我们虚构了一个对象

1869
01:19:51,933 --> 01:19:52,733
虚构在这

1870
01:19:53,666 --> 01:19:55,766
由这个对象去负责

1871
01:19:55,766 --> 01:19:59,866
决定说我们的这个channel

1872
01:19:59,866 --> 01:20:01,933
应该用什么样的pay Adapter

1873
01:20:02,133 --> 01:20:03,866
那它怎么样决定说

1874
01:20:03,866 --> 01:20:05,699
它用什么样的pay Adapter

1875
01:20:05,866 --> 01:20:07,533
靠的是数据驱动的方式

1876
01:20:07,533 --> 01:20:08,599
因为这个channel中间写了

1877
01:20:08,600 --> 01:20:10,100
说它要用哪个be named

1878
01:20:10,266 --> 01:20:12,166
利用Supreme框架的特性

1879
01:20:12,333 --> 01:20:13,333
用这个be named name

1880
01:20:13,333 --> 01:20:14,299
在Supreme框架中间

1881
01:20:14,300 --> 01:20:16,400
找到对应的这个being对象

1882
01:20:16,566 --> 01:20:19,166
给它设到枪的中间去啊

1883
01:20:19,166 --> 01:20:19,766
所以

1884
01:20:19,766 --> 01:20:23,099
这是我们在这个虚构的这个对象中间

1885
01:20:23,333 --> 01:20:24,566
所做的逻辑

1886
01:20:24,566 --> 01:20:26,533
就是为什么要做一个虚构对象

1887
01:20:26,733 --> 01:20:27,599
就是这么原因

1888
01:20:27,966 --> 01:20:29,766
把这一整套的东西

1889
01:20:30,000 --> 01:20:32,300
放到了这个虚构的这个对象中间

1890
01:20:32,300 --> 01:20:36,066
去这是一个也是一个标准设计模式

1891
01:20:36,066 --> 01:20:38,366
这个叫做工厂方法

1892
01:20:38,933 --> 01:20:42,566
工厂方法它是用来去创建一个对象的

1893
01:20:43,133 --> 01:20:46,199
所以创建对象本身是有逻辑的

1894
01:20:46,200 --> 01:20:47,333
我们刚才说到这个逻辑

1895
01:20:47,333 --> 01:20:48,466
就是我们创建对象时候

1896
01:20:48,466 --> 01:20:49,999
不是简单的溜一个对象

1897
01:20:50,166 --> 01:20:52,599
而是要去读一个数

1898
01:20:52,600 --> 01:20:54,733
数值读一个channel的属性

1899
01:20:54,933 --> 01:20:56,199
在spin的框架中间

1900
01:20:56,200 --> 01:20:59,500
把这个名字所对应的并对象

1901
01:20:59,500 --> 01:21:00,400
把它找出来

1902
01:21:00,733 --> 01:21:01,999
这一段的逻辑

1903
01:21:02,000 --> 01:21:03,966
我们把它没有放在

1904
01:21:03,966 --> 01:21:05,899
原本创建对象的那个地方

1905
01:21:06,000 --> 01:21:08,900
而是虚构了一个工厂方法的对象

1906
01:21:09,066 --> 01:21:11,966
让工厂方法把这个逻辑包含起来

1907
01:21:12,166 --> 01:21:13,999
然后我们调这个方法

1908
01:21:14,200 --> 01:21:16,333
这里看到的图上是create product

1909
01:21:16,466 --> 01:21:18,399
我们是create pay Adapter

1910
01:21:18,666 --> 01:21:21,899
来得到这个pay Adapter对象

1911
01:21:21,900 --> 01:21:23,600
而不是product对象

1912
01:21:23,866 --> 01:21:24,166
当然

1913
01:21:24,166 --> 01:21:27,266
我们在这里看到的经典的工厂方法

1914
01:21:27,266 --> 01:21:28,533
其实做的更复杂

1915
01:21:28,666 --> 01:21:32,133
我们只有一个factory

1916
01:21:32,266 --> 01:21:34,099
创建一个对象

1917
01:21:34,300 --> 01:21:36,666
但其实你如果比较复杂的话

1918
01:21:36,666 --> 01:21:38,866
你可以把它做成子类

1919
01:21:39,400 --> 01:21:41,733
然后创建对应的子类对象

1920
01:21:41,733 --> 01:21:43,366
但是我们的这个场景上头

1921
01:21:43,366 --> 01:21:44,333
没有这么复杂

1922
01:21:44,333 --> 01:21:47,399
我们只是创建一个对象啊

1923
01:21:47,400 --> 01:21:49,166
所以我们就做成了这个啊

1924
01:21:49,166 --> 01:21:52,366
我们其实比这个比这个不不太一样

1925
01:21:52,366 --> 01:21:54,333
就是我们不用去做纸类

1926
01:21:54,533 --> 01:21:55,799
工厂不用纸类

1927
01:21:55,933 --> 01:21:57,699
但是product那边是有纸类的

1928
01:21:57,700 --> 01:21:59,266
是有两个Adapter的

1929
01:21:59,300 --> 01:22:01,066
但是我们利用spin的框架

1930
01:22:01,300 --> 01:22:03,966
把这个部分给它砍掉了

1931
01:22:04,800 --> 01:22:06,366
就是把这个部分给他砍掉了

1932
01:22:06,366 --> 01:22:08,599
用spin的框架数据驱动的方式

1933
01:22:08,733 --> 01:22:09,966
使得他用一个factory

1934
01:22:09,966 --> 01:22:12,899
能造出两个东西出来啊

1935
01:22:12,933 --> 01:22:14,933
这是我们在这个例子中间

1936
01:22:14,933 --> 01:22:16,666
使用虚构的方式

1937
01:22:17,066 --> 01:22:20,399
来采用了一种工厂方法的方法啊工

1938
01:22:20,400 --> 01:22:21,933
厂方法的设计模式

1939
01:22:22,100 --> 01:22:23,733
来建立这样的一个东西

1940
01:22:24,733 --> 01:22:26,899
这是我们的这个虚构

1941
01:22:27,600 --> 01:22:30,666
那最后我们来讲一下它的价值观

1942
01:22:30,666 --> 01:22:33,333
就是低偶和和高类句

1943
01:22:33,933 --> 01:22:34,533
低偶和高类距

1944
01:22:34,533 --> 01:22:35,933
不是一种具体的设计方式啊

1945
01:22:35,933 --> 01:22:36,899
我们之前讲过了

1946
01:22:36,900 --> 01:22:38,466
它其实是一种价值观

1947
01:22:38,666 --> 01:22:41,333
也就是我们在用前述的这些

1948
01:22:41,333 --> 01:22:42,733
所有的设计的时候

1949
01:22:42,733 --> 01:22:44,566
其实我们追寻的都是一种

1950
01:22:44,800 --> 01:22:47,066
低偶和和高类距

1951
01:22:47,200 --> 01:22:49,100
我们首先说低偶和

1952
01:23:00,066 --> 01:23:04,733
d o核是一个能起到很大作用的价值观

1953
01:23:05,466 --> 01:23:07,299
比如说我们在这个地方看到的

1954
01:23:07,300 --> 01:23:09,066
我们做的d o核的设计

1955
01:23:09,066 --> 01:23:11,199
是降低了什么东西

1956
01:23:11,200 --> 01:23:14,133
o核呢降低了我们这一堆东西

1957
01:23:15,066 --> 01:23:17,366
和整体的这一类东西的吻合

1958
01:23:18,266 --> 01:23:19,266
所以就会使得说

1959
01:23:19,266 --> 01:23:21,199
我们这类东西在发生扩展

1960
01:23:21,600 --> 01:23:23,400
或者发生变更的时候

1961
01:23:23,566 --> 01:23:26,366
对于我们这一堆东西的影响

1962
01:23:26,400 --> 01:23:27,366
是比较小的

1963
01:23:27,966 --> 01:23:30,466
那DO核能起到这个作用

1964
01:23:30,466 --> 01:23:31,933
是有一个前提的

1965
01:23:32,000 --> 01:23:34,166
我们其实是没有必要在设计的

1966
01:23:34,166 --> 01:23:36,066
处处都做DO核的

1967
01:23:36,400 --> 01:23:40,400
如果说这个做DO核不用付出代价

1968
01:23:40,466 --> 01:23:43,299
就不用做特别的设计就能达成Dio核

1969
01:23:43,300 --> 01:23:45,166
那当然我们会希望Dio核

1970
01:23:45,166 --> 01:23:46,699
因为我们虽然不知道说

1971
01:23:46,866 --> 01:23:47,999
这里会发生什么

1972
01:23:48,100 --> 01:23:50,100
但是如果他是个Dio核的话

1973
01:23:50,133 --> 01:23:52,299
万一发生什么都是有好处的

1974
01:23:52,300 --> 01:23:53,066
对吧

1975
01:23:53,066 --> 01:23:55,499
但如果说做Dio核是要付出代价的

1976
01:23:55,500 --> 01:23:57,166
比如说我们这里看到这个做Dio核

1977
01:23:57,166 --> 01:23:58,899
是有发出付出了代价

1978
01:23:59,000 --> 01:24:00,400
我们没有直接去调用

1979
01:24:00,400 --> 01:24:02,166
他中间加了这些代码

1980
01:24:02,500 --> 01:24:03,266
这个代码是这

1981
01:24:03,266 --> 01:24:04,499
这是要多写代码的

1982
01:24:04,500 --> 01:24:06,400
加了这些代码来做这些转换

1983
01:24:07,200 --> 01:24:08,100
这是代价

1984
01:24:08,166 --> 01:24:10,099
那么为什么要做这个代价

1985
01:24:10,100 --> 01:24:11,866
来降低这部分跟

1986
01:24:11,933 --> 01:24:13,999
其他部分的的Dior和是

1987
01:24:14,000 --> 01:24:15,166
因为我们要判断说

1988
01:24:15,166 --> 01:24:16,899
这个部分到底是变化点

1989
01:24:20,733 --> 01:24:21,899
还是眼镜点

1990
01:24:27,800 --> 01:24:29,000
什么叫做变化点

1991
01:24:29,500 --> 01:24:30,000
比如说

1992
01:24:30,000 --> 01:24:33,000
我们看到的这个阿里佩的接口的变化

1993
01:24:33,366 --> 01:24:36,366
就是因为它受限于外部接口

1994
01:24:36,600 --> 01:24:37,533
那外部接口

1995
01:24:37,533 --> 01:24:39,133
我们不知道它说它会不会变

1996
01:24:39,133 --> 01:24:41,099
我们知道它肯定是会发生变化的

1997
01:24:41,166 --> 01:24:42,066
如果要变化

1998
01:24:42,066 --> 01:24:44,466
我们就必须把我们的代码要跟着它变

1999
01:24:44,466 --> 01:24:45,966
才能让它的接口接上

2000
01:24:46,400 --> 01:24:47,166
所以它是一个

2001
01:24:47,166 --> 01:24:49,066
我们知道未来会发生变化的点

2002
01:24:49,166 --> 01:24:50,866
那我们就会采用这种技术

2003
01:24:50,866 --> 01:24:52,166
额外去写这些代码

2004
01:24:52,366 --> 01:24:53,766
使得我们的代码

2005
01:24:53,766 --> 01:24:56,099
和他的这些代码隔离开

2006
01:24:56,300 --> 01:24:57,866
使得当他发生变化的时候

2007
01:24:57,866 --> 01:24:59,699
我控制在这个地方

2008
01:25:00,166 --> 01:25:01,699
控制在这个地方跟他的接口

2009
01:25:01,700 --> 01:25:04,066
控制在我的这个转换Adapter这个地方

2010
01:25:04,066 --> 01:25:05,899
把代码控在这个地方来做变化

2011
01:25:06,300 --> 01:25:07,400
这个好处在于什么呢

2012
01:25:07,400 --> 01:25:07,900
这个好处

2013
01:25:07,900 --> 01:25:09,166
当他发生变化的时候

2014
01:25:09,366 --> 01:25:10,966
我们其实只要去测试

2015
01:25:10,966 --> 01:25:12,399
这个部分是不是OK的

2016
01:25:12,966 --> 01:25:16,099
如果这个部分的做到是OK的

2017
01:25:16,100 --> 01:25:17,700
那整体就是OK的啊

2018
01:25:17,700 --> 01:25:19,600
不会动到其他的代码

2019
01:25:19,733 --> 01:25:20,899
这是变化点

2020
01:25:21,133 --> 01:25:22,333
那眼镜点的话

2021
01:25:22,333 --> 01:25:23,733
比如说我们增加一个新的渠道

2022
01:25:23,733 --> 01:25:24,766
这就是眼镜点

2023
01:25:25,166 --> 01:25:25,699
就是这个地方

2024
01:25:25,700 --> 01:25:27,200
不是他原有东西发生变化

2025
01:25:27,200 --> 01:25:28,100
而是这个东西

2026
01:25:28,100 --> 01:25:29,733
是要不断的增加新的内容的

2027
01:25:30,100 --> 01:25:32,133
那同样我们的努力的目标

2028
01:25:32,133 --> 01:25:33,799
做低有和的努力的目标

2029
01:25:34,100 --> 01:25:36,800
就是当我们增加一个新的内容的时候

2030
01:25:36,933 --> 01:25:39,099
不要影响现有的内容

2031
01:25:39,266 --> 01:25:42,766
那这就是我们说的Dio核的一个东西

2032
01:25:43,066 --> 01:25:47,066
所以Dio核如果说不需要付出代价

2033
01:25:47,333 --> 01:25:49,866
那你就宁愿处处做Dio核

2034
01:25:50,266 --> 01:25:52,666
如果Dio核要付出代价

2035
01:25:52,666 --> 01:25:54,099
比如说这里就是付出了代价的

2036
01:25:54,100 --> 01:25:55,466
我们写了额外的代码的

2037
01:25:56,066 --> 01:25:57,066
那你就要考虑说

2038
01:25:57,066 --> 01:25:59,699
这个地方会变还是不会变

2039
01:25:59,766 --> 01:26:01,566
如果你不加选择的

2040
01:26:01,866 --> 01:26:04,133
所有地方都要去做这个Dio核的设计

2041
01:26:04,266 --> 01:26:06,699
你的代码就会变得无比的臃肿

2042
01:26:06,900 --> 01:26:09,300
就是我们称之为无用的设计

2043
01:26:13,066 --> 01:26:13,866
或者叫做

2044
01:26:14,133 --> 01:26:17,766
或者有人说法叫做这个东西过设计了

2045
01:26:17,766 --> 01:26:19,066
就设计得过分了

2046
01:26:19,133 --> 01:26:21,799
没有必要在这个地方去付这个代价

2047
01:26:21,966 --> 01:26:23,566
去做这样的一个设计啊

2048
01:26:23,566 --> 01:26:25,266
这是Dior和

2049
01:26:25,600 --> 01:26:28,066
那高类距是我们的另外一个价值观

2050
01:26:35,200 --> 01:26:36,800
高类距不像低偶和

2051
01:26:36,933 --> 01:26:38,266
它不是那么直观

2052
01:26:38,333 --> 01:26:39,066
比如低偶和

2053
01:26:39,066 --> 01:26:39,599
我们可以看到

2054
01:26:39,600 --> 01:26:42,400
这是个很直观的低偶和的设计

2055
01:26:42,733 --> 01:26:44,366
但是高类距就不那么直观了

2056
01:26:44,366 --> 01:26:46,533
那高类距所体现出来是什么

2057
01:26:46,800 --> 01:26:47,700
体现出来就是

2058
01:26:47,700 --> 01:26:50,166
当你看到一段代码的时候

2059
01:26:50,500 --> 01:26:51,666
你觉得他不啰嗦

2060
01:26:52,266 --> 01:26:53,866
整个代码被分成了一段一段

2061
01:26:53,866 --> 01:26:54,466
一段一段的

2062
01:26:54,466 --> 01:26:56,533
然后每一段都在他合适的地方

2063
01:26:56,733 --> 01:27:00,066
那你就知道这就是一个高偶合的设计

2064
01:27:00,066 --> 01:27:01,399
我们在这些代码中间

2065
01:27:01,400 --> 01:27:02,700
我们其实在画这个图的时候

2066
01:27:02,700 --> 01:27:05,166
大家应该就能够体会到一点

2067
01:27:05,566 --> 01:27:07,866
就是我们可以看到在任何一个

2068
01:27:09,400 --> 01:27:10,666
这个bug的时候

2069
01:27:11,566 --> 01:27:13,933
都没有太多的限制出来

2070
01:27:14,366 --> 01:27:15,466
这个意味着什么

2071
01:27:16,066 --> 01:27:19,066
这个意味着我们在任何一个方法里头

2072
01:27:19,300 --> 01:27:22,666
都没有太多的逻辑写在里面

2073
01:27:23,366 --> 01:27:24,699
逻辑一定是这么多

2074
01:27:24,700 --> 01:27:25,566
比如说我们做这件事情

2075
01:27:25,566 --> 01:27:26,766
一定是有这么多逻辑

2076
01:27:27,066 --> 01:27:29,466
但是我们用面向对象的方式

2077
01:27:29,500 --> 01:27:33,166
把这个逻辑分散到不同的对象中间去

2078
01:27:33,400 --> 01:27:35,766
每一次的分散都是有理由的

2079
01:27:36,266 --> 01:27:37,666
你不是说没理由的

2080
01:27:37,666 --> 01:27:39,199
说我就要把它放到那边去

2081
01:27:39,333 --> 01:27:41,333
这个是没理由的

2082
01:27:41,333 --> 01:27:42,466
每一次的分散都

2083
01:27:42,466 --> 01:27:43,399
是有理由的

2084
01:27:43,466 --> 01:27:44,999
这样就会使得说

2085
01:27:45,000 --> 01:27:49,133
整体的这个设计显得是高内距的啊

2086
01:27:49,133 --> 01:27:50,499
所以从面对上的角度来说

2087
01:27:50,500 --> 01:27:52,200
大家可以看到我们塑出来的设计

2088
01:27:53,266 --> 01:27:56,266
这个样子看起来就是比较匀称的

2089
01:27:56,300 --> 01:27:58,000
我给大家看一个不匀称的啊

2090
01:27:58,000 --> 01:27:58,866
就是我们去年设计

2091
01:27:58,866 --> 01:28:01,966
我最后有拿了我们去年的一个设计

2092
01:28:02,933 --> 01:28:04,699
给大家看一下直观的感受

2093
01:28:06,300 --> 01:28:07,100
最后一张

2094
01:28:09,933 --> 01:28:11,266
这是我们去年的设计

2095
01:28:13,800 --> 01:28:14,866
能看清楚吗

2096
01:28:15,866 --> 01:28:16,799
看不清楚吧

2097
01:28:16,800 --> 01:28:17,866
也看不懂吧

2098
01:28:18,166 --> 01:28:20,299
这就是没有类矩性的设计

2099
01:28:20,500 --> 01:28:21,866
他没有做任何的分配

2100
01:28:22,133 --> 01:28:26,933
所有的线全在这一条上面

2101
01:28:27,766 --> 01:28:28,166
看见没有

2102
01:28:28,166 --> 01:28:29,466
这就是没有做任何设计

2103
01:28:30,333 --> 01:28:31,766
没有做任何的面向对象设计

2104
01:28:31,766 --> 01:28:32,899
没有把职责分配出来

2105
01:28:32,900 --> 01:28:34,100
没有任何高内距的

2106
01:28:34,100 --> 01:28:36,300
所以所有的逻辑全在这个代码里头

2107
01:28:36,300 --> 01:28:37,200
这个代码很长

2108
01:28:37,766 --> 01:28:38,766
大概有100多行

2109
01:28:39,566 --> 01:28:40,666
然后这一本兑换代码

2110
01:28:40,666 --> 01:28:41,466
你怎么看

2111
01:28:41,966 --> 01:28:42,766
功能是一样的

2112
01:28:42,766 --> 01:28:43,966
今天我们把这个设计

2113
01:28:44,800 --> 01:28:46,000
把它重新改了一下

2114
01:28:46,000 --> 01:28:47,666
就是把它做成面相对象了

2115
01:28:48,266 --> 01:28:49,566
所以大家可以看到

2116
01:28:50,366 --> 01:28:52,099
上面这个就是做成面向对象的

2117
01:28:52,300 --> 01:28:53,900
就是一样的东西啊

2118
01:28:53,900 --> 01:28:55,566
我们不看你它的具体的内容

2119
01:28:55,733 --> 01:28:57,766
你看一个高类距

2120
01:28:57,766 --> 01:28:59,866
和一个没有类距的设计

2121
01:28:59,900 --> 01:29:01,366
它的表现就是这个样

2122
01:29:01,400 --> 01:29:02,766
这就是有类距性的设计

2123
01:29:03,066 --> 01:29:04,533
我们把这个事情分成了好几块

2124
01:29:04,533 --> 01:29:05,333
一张图还画不下

2125
01:29:05,333 --> 01:29:06,733
因为它确实是有那么多事情

2126
01:29:06,933 --> 01:29:08,133
那些事情还都是要做的啊

2127
01:29:08,133 --> 01:29:09,533
没有一件事情是做的不对的

2128
01:29:09,533 --> 01:29:10,399
都是要做的

2129
01:29:10,666 --> 01:29:12,733
但是同样的事情我们换了种方式做

2130
01:29:12,733 --> 01:29:14,699
就是用设计把它做成一个

2131
01:29:14,900 --> 01:29:16,100
用面向对象把它做成一个

2132
01:29:16,100 --> 01:29:17,700
不断分配的东西

2133
01:29:17,733 --> 01:29:20,966
它就变成了这样的两张图去表现

2134
01:29:21,000 --> 01:29:23,000
其实他被分成了三块两

2135
01:29:23,000 --> 01:29:23,700
张图去表现

2136
01:29:23,700 --> 01:29:26,333
有一有一块没有去用图画出来

2137
01:29:26,733 --> 01:29:28,299
所以你就能看到

2138
01:29:28,300 --> 01:29:30,866
内聚性其实是一种价值观

2139
01:29:31,100 --> 01:29:32,500
内聚性做出来以后

2140
01:29:32,500 --> 01:29:35,400
你的整个的代码看起来设计啊

2141
01:29:35,400 --> 01:29:36,733
就会更加的匀称

2142
01:29:36,900 --> 01:29:38,066
无论是从图上来看

2143
01:29:38,066 --> 01:29:39,966
你会感觉看起来更加的舒适

2144
01:29:39,966 --> 01:29:41,266
不会觉得一慌

2145
01:29:41,266 --> 01:29:42,099
这是什么东西

2146
01:29:42,666 --> 01:29:44,333
还是从你去看代码的时候

2147
01:29:44,333 --> 01:29:46,699
同样都会这种感觉更好理解

2148
01:29:47,000 --> 01:29:51,200
但好理解其实是它的一个方面

2149
01:29:51,733 --> 01:29:52,733
做成这个样子

2150
01:29:52,733 --> 01:29:54,999
大家知道它的最基本的特征

2151
01:29:55,000 --> 01:29:57,200
就是它被更加的细分了

2152
01:29:57,666 --> 01:29:59,333
就是原来是这个样子的

2153
01:30:00,100 --> 01:30:01,300
花季全在一片

2154
01:30:01,466 --> 01:30:02,766
那这一整片

2155
01:30:02,766 --> 01:30:04,699
你要么就这一整块

2156
01:30:05,066 --> 01:30:06,266
你要么就都用

2157
01:30:06,266 --> 01:30:07,266
要么就都不用

2158
01:30:07,400 --> 01:30:09,166
他没有别的选择

2159
01:30:09,500 --> 01:30:12,166
当你把它切成若干片以后

2160
01:30:12,166 --> 01:30:13,933
当然这些切成若干片是有内菌的

2161
01:30:13,933 --> 01:30:15,066
切成若干片以后

2162
01:30:15,333 --> 01:30:17,333
每一片其实是可以重用的

2163
01:30:17,766 --> 01:30:19,166
对吧从用性会提高

2164
01:30:19,300 --> 01:30:21,300
就是切小了以后不太好理解

2165
01:30:21,466 --> 01:30:23,099
而且从用性会提高

2166
01:30:23,200 --> 01:30:25,100
而且当你发生修改的时候

2167
01:30:25,100 --> 01:30:27,766
他有可能会被控制在这一小片修改

2168
01:30:27,933 --> 01:30:30,266
而不会影响到其他地方

2169
01:30:30,366 --> 01:30:31,533
所以要切

2170
01:30:31,700 --> 01:30:32,366
这是第一

2171
01:30:32,366 --> 01:30:33,333
如果不切的话

2172
01:30:33,333 --> 01:30:36,899
他就是一块牢不可破的顽石

2173
01:30:37,366 --> 01:30:38,266
全部都在里头

2174
01:30:38,266 --> 01:30:39,466
不好懂不好改

2175
01:30:39,466 --> 01:30:41,333
不好测也没法重用

2176
01:30:41,933 --> 01:30:43,899
切就要有原则的切

2177
01:30:43,900 --> 01:30:45,400
你要用什么方法去切

2178
01:30:45,533 --> 01:30:47,599
让他切的更有内据性

2179
01:30:47,666 --> 01:30:50,899
我们面向对象的这种切的方式

2180
01:30:51,000 --> 01:30:53,766
就是无论是创建者信息专家

2181
01:30:54,100 --> 01:30:56,066
包括我们后面讲的多态

2182
01:30:56,066 --> 01:30:58,499
间接虚构的方式

2183
01:30:58,500 --> 01:30:59,700
其实都是讲

2184
01:30:59,700 --> 01:31:01,466
我们怎么把这些逻辑

2185
01:31:01,533 --> 01:31:03,966
给它切成不同的块

2186
01:31:04,066 --> 01:31:05,533
最后变成这个样子啊

2187
01:31:05,533 --> 01:31:07,766
这个我们放到下周去讲

2188
01:31:07,766 --> 01:31:09,166
让大家慢慢的去消化啊

2189
01:31:09,166 --> 01:31:10,766
大家应该知道这是我们整个支

2190
01:31:10,766 --> 01:31:11,666
付模块中间

2191
01:31:12,066 --> 01:31:16,733
业务最复杂的一块是什么呢是退款

2192
01:31:18,133 --> 01:31:20,166
就是退款其实是最复杂的

2193
01:31:20,166 --> 01:31:24,366
因为我们整个的的过程是先支付

2194
01:31:24,666 --> 01:31:25,666
再分账

2195
01:31:26,466 --> 01:31:29,466
最后会发生的是退款

2196
01:31:29,733 --> 01:31:31,799
那退款是发生在所有的事情

2197
01:31:31,800 --> 01:31:32,900
发生完了之后

2198
01:31:32,966 --> 01:31:33,166
所以

2199
01:31:33,166 --> 01:31:35,166
他先要把所有的事情反过来做一遍

2200
01:31:35,366 --> 01:31:37,699
所以他的业务是最复杂啊

2201
01:31:37,700 --> 01:31:38,500
所以他一无是反

2202
01:31:38,500 --> 01:31:40,366
所以我们放到下周再讲吧

2203
01:31:41,333 --> 01:31:43,533
啊今天我不想再讲太多的内容

2204
01:31:43,533 --> 01:31:45,599
让大家消化一下有没有什么问题

2205
01:31:45,766 --> 01:31:47,933
关于前面的这个东西

2206
01:31:48,766 --> 01:31:49,599
就我刚才说了啊

2207
01:31:49,600 --> 01:31:50,766
从11月份开始

2208
01:31:50,766 --> 01:31:53,199
我们每周都是这个内容

2209
01:31:53,200 --> 01:31:54,566
而且设计会越来越难

2210
01:31:54,900 --> 01:31:58,100
呃从设计的方法上来说

2211
01:31:58,100 --> 01:32:00,966
我们在下一周最后把七大原则讲完

2212
01:32:01,800 --> 01:32:04,000
就不会再有新的设计方法了

2213
01:32:04,333 --> 01:32:06,299
所有的UMI的类图

2214
01:32:06,300 --> 01:32:08,333
UMI的图全部都已经讲完了

2215
01:32:08,333 --> 01:32:10,399
没有再有新的UMI的图了

2216
01:32:10,666 --> 01:32:14,999
所以从11月份开始到12月 底

2217
01:32:15,000 --> 01:32:16,000
这么多周里头

2218
01:32:16,000 --> 01:32:18,166
其实我们都是在逐一逐一的讲

2219
01:32:18,166 --> 01:32:19,999
b座模块的设计

2220
01:32:20,200 --> 01:32:23,133
让大家通过这么一个多月的时间

2221
01:32:23,366 --> 01:32:26,333
慢慢的掌握这个设计的方法

2222
01:32:26,333 --> 01:32:29,466
能够写出看起来比较

2223
01:32:30,333 --> 01:32:31,766
就是大家现在能看到这些代码

2224
01:32:31,766 --> 01:32:34,133
很多都是网界的同学写的

2225
01:32:34,300 --> 01:32:35,566
所以大家也不用着急

2226
01:32:35,600 --> 01:32:37,300
既然网界的同学能做的到

2227
01:32:37,466 --> 01:32:40,733
我相信在座的同学大部分也能做的到

2228
01:32:40,866 --> 01:32:41,866
但你前提就是

2229
01:32:41,866 --> 01:32:43,799
你要一步步的跟着理解

2230
01:32:43,800 --> 01:32:47,000
说每一周的课到底讲的是什么内容

2231
01:32:47,133 --> 01:32:50,199
然后课上听不懂去看录课

2232
01:32:50,466 --> 01:32:52,466
录课看不懂再来问我

2233
01:32:52,600 --> 01:32:55,400
然后最关键的是要动手做

2234
01:32:55,666 --> 01:32:56,899
动手去设计

2235
01:32:56,900 --> 01:32:58,266
动手去写代码

2236
01:32:59,000 --> 01:32:59,266
然后

2237
01:32:59,266 --> 01:33:02,299
你才能慢慢的去理解和掌握这些东西

2238
01:33:02,300 --> 01:33:04,366
要不然真的是很困难

2239
01:33:04,366 --> 01:33:04,999
的一个过程

2240
01:33:05,000 --> 01:33:07,500
这个其实也就是一个程序员的蜕变

2241
01:33:07,900 --> 01:33:11,533
如果说你不没有能力去做设计

2242
01:33:12,066 --> 01:33:15,299
你在整个职场上的位置就是什么呢

2243
01:33:15,966 --> 01:33:19,266
就是被别人指派人家做设计

2244
01:33:19,333 --> 01:33:20,566
人家决定怎么做

2245
01:33:20,733 --> 01:33:23,666
然后你就按照人家的规定去做的

2246
01:33:23,666 --> 01:33:24,466
这样的人

2247
01:33:24,966 --> 01:33:25,599
大家知道啊

2248
01:33:25,600 --> 01:33:26,933
你如果想在职

2249
01:33:27,000 --> 01:33:29,566
想在你的职业生涯中间能往上走

2250
01:33:29,933 --> 01:33:31,299
无非是两条

2251
01:33:31,300 --> 01:33:32,400
无非是三条途径

2252
01:33:32,400 --> 01:33:33,666
就是如果做这个专业的话

2253
01:33:33,666 --> 01:33:34,733
无非是三条途径

2254
01:33:34,866 --> 01:33:36,466
一条是走技术的途径

2255
01:33:37,100 --> 01:33:38,866
一条是走产品的途径

2256
01:33:38,866 --> 01:33:41,299
一条是走管理的途径

2257
01:33:41,500 --> 01:33:44,466
对吧那我们知道如果做it界的话

2258
01:33:44,466 --> 01:33:46,533
管理是跟技术有有密切关系的

2259
01:33:46,666 --> 01:33:50,166
大家谁都不愿意说一个既不懂技术

2260
01:33:50,166 --> 01:33:51,566
也不懂产品的人

2261
01:33:51,700 --> 01:33:54,300
来管着一个做it的部门

2262
01:33:54,400 --> 01:33:55,466
那他管啥

2263
01:33:55,866 --> 01:33:57,599
所以在做这个

2264
01:33:57,600 --> 01:33:58,933
如果说在这个行业做的话

2265
01:33:58,933 --> 01:34:01,099
你其实主要的发展路线就是

2266
01:34:01,100 --> 01:34:02,166
要么往产品走

2267
01:34:02,466 --> 01:34:04,366
要么往技术走

2268
01:34:04,533 --> 01:34:05,366
往产品走

2269
01:34:05,366 --> 01:34:08,266
就是我们在这之前讲的所有的内容

2270
01:34:08,500 --> 01:34:10,266
其实就是在往产品走

2271
01:34:10,366 --> 01:34:12,133
你要了解这个产品

2272
01:34:12,266 --> 01:34:13,766
了解产品的需求

2273
01:34:13,900 --> 01:34:15,566
发现这个性质需求

2274
01:34:15,566 --> 01:34:17,799
给整个的设计部门去提要求

2275
01:34:17,800 --> 01:34:19,666
说我要做成一个什么样的东西

2276
01:34:20,133 --> 01:34:21,699
让设计部门能够了解出

2277
01:34:21,700 --> 01:34:23,000
你想做什么样的东西

2278
01:34:23,333 --> 01:34:25,066
让客户能够了解出

2279
01:34:25,066 --> 01:34:25,533
你做的东西

2280
01:34:25,533 --> 01:34:27,066
能帮助他解决什么样的问题

2281
01:34:27,266 --> 01:34:29,133
所以这是往产品走

2282
01:34:29,200 --> 01:34:31,133
对吧那往技术走呢

2283
01:34:31,133 --> 01:34:34,533
其实就是你要去决定整体的体系结构

2284
01:34:34,933 --> 01:34:36,666
你要去决定设计方案

2285
01:34:36,866 --> 01:34:38,199
然后你要把设计方案

2286
01:34:38,200 --> 01:34:39,700
分配给不同的人去做

2287
01:34:39,800 --> 01:34:42,066
然后你要知道说哪些人做的好

2288
01:34:42,066 --> 01:34:43,366
哪些人做的不好

2289
01:34:43,466 --> 01:34:45,599
然后对他们有一些这个评价

2290
01:34:45,866 --> 01:34:46,933
然后让好的人能

2291
01:34:46,933 --> 01:34:48,733
够突出出来能够继续升值

2292
01:34:48,733 --> 01:34:51,866
让做的差的人要么保持在那柜子上头

2293
01:34:52,000 --> 01:34:53,333
要么去把他淘汰掉

2294
01:34:54,600 --> 01:34:56,500
如果说你做不到往产品走

2295
01:34:56,500 --> 01:34:59,600
或者往这个技术走

2296
01:34:59,600 --> 01:35:02,466
你永远就是那个被管理

2297
01:35:02,566 --> 01:35:05,066
和有可能被淘汰的人

2298
01:35:05,133 --> 01:35:06,999
所以经常在网上有人说

2299
01:35:07,000 --> 01:35:09,666
为什么说程序员是有这个

2300
01:35:10,466 --> 01:35:12,966
这个35岁的忧虑的

2301
01:35:13,133 --> 01:35:15,166
这个忧虑其实是有一个前提

2302
01:35:15,300 --> 01:35:16,733
就是在35岁之前

2303
01:35:16,733 --> 01:35:19,999
如果你不能走上技术的管理岗位

2304
01:35:20,133 --> 01:35:22,933
或者产品的管理岗位

2305
01:35:23,000 --> 01:35:26,100
你永远只是在最底层

2306
01:35:26,133 --> 01:35:29,966
在被人家指派去做这个做那个的

2307
01:35:30,200 --> 01:35:32,200
你要知道到35岁以后

2308
01:35:32,500 --> 01:35:34,733
永远有比你年轻的

2309
01:35:35,200 --> 01:35:38,366
永远有愿意拿比你的工资低的人

2310
01:35:38,400 --> 01:35:39,600
来坐这个位置

2311
01:35:39,766 --> 01:35:41,133
所以你就会有职业的

2312
01:35:42,066 --> 01:35:43,599
职业的这个忧虑了

2313
01:35:43,600 --> 01:35:44,700
职业的危险了

2314
01:35:45,266 --> 01:35:48,066
所以啊大家如果下决心做这个行当

2315
01:35:48,066 --> 01:35:50,566
就是说你不是做那个算法

2316
01:35:50,566 --> 01:35:51,399
不是做科研

2317
01:35:51,400 --> 01:35:52,533
那是另外一条路

2318
01:35:52,533 --> 01:35:54,899
如果要去做开发的话

2319
01:35:55,133 --> 01:35:56,366
你其实就要想清楚

2320
01:35:56,366 --> 01:35:59,066
说你将来进入职场以后

2321
01:35:59,533 --> 01:36:03,366
你想走产品还是走技术

2322
01:36:03,533 --> 01:36:04,799
这两条路都是好路

2323
01:36:04,966 --> 01:36:06,999
但是如果说你不想走产品

2324
01:36:07,000 --> 01:36:07,766
不想走技术

2325
01:36:07,766 --> 01:36:08,733
想走其他路

2326
01:36:08,966 --> 01:36:10,066
那你就白瞎了

2327
01:36:10,066 --> 01:36:13,166
在大学四年所受的这些训练

2328
01:36:13,333 --> 01:36:15,533
就跟那些没有受过这些训练的人

2329
01:36:15,533 --> 01:36:18,599
在同一个层面上去做竞争

2330
01:36:18,966 --> 01:36:21,466
比如说你要去做营销对吧

2331
01:36:21,666 --> 01:36:23,766
那你虽然你的这个大学里头

2332
01:36:23,766 --> 01:36:25,899
所教你的东西是对你有帮助的

2333
01:36:25,966 --> 01:36:29,199
但是他的帮助就不是那么大啊

2334
01:36:29,200 --> 01:36:32,100
不像我们现在给大家的帮助

2335
01:36:32,100 --> 01:36:33,200
其实是帮助大家

2336
01:36:33,366 --> 01:36:34,499
无论是在产品方面

2337
01:36:34,500 --> 01:36:36,900
还是在技术方面去帮大家去

2338
01:36:36,900 --> 01:36:38,533
在这个过程中间去了解

2339
01:36:38,533 --> 01:36:39,999
说这个是怎么做的啊

2340
01:36:40,200 --> 01:36:41,366
所以大家到大三了

2341
01:36:41,366 --> 01:36:42,599
其实是如

2342
01:36:42,600 --> 01:36:44,900
果说不是想去考研

2343
01:36:44,900 --> 01:36:46,466
或者不是想去读研的同学

2344
01:36:46,466 --> 01:36:47,899
其实都要去考虑下这个问题

2345
01:36:47,900 --> 01:36:49,866
未来的职业怎么去做

2346
01:36:49,933 --> 01:36:52,299
那即算是去考研或者读研的同学

2347
01:36:52,300 --> 01:36:54,733
我们知道读硕士研究生的话

2348
01:36:55,333 --> 01:36:58,299
其实也不是所有的人都能去做算法

2349
01:36:58,566 --> 01:36:59,466
因为算法嘛

2350
01:36:59,466 --> 01:37:02,333
是我们在整个这个行业中间称之

2351
01:37:02,333 --> 01:37:03,133
为什么呢

2352
01:37:03,500 --> 01:37:06,166
称之为金字塔尖的那一群人

2353
01:37:06,566 --> 01:37:09,466
那一群人的人数需求量

2354
01:37:09,466 --> 01:37:10,699
其实是比较少的

2355
01:37:10,966 --> 01:37:12,266
所以每一个人

2356
01:37:12,266 --> 01:37:15,499
你其实都需要做多种方案

2357
01:37:15,500 --> 01:37:17,666
就是你比如说你觉得算法挺好

2358
01:37:17,666 --> 01:37:18,566
想去做算法

2359
01:37:18,566 --> 01:37:19,399
工资很高

2360
01:37:19,666 --> 01:37:20,499
但是你也知道

2361
01:37:20,500 --> 01:37:22,300
不是每个人都能去做算法的

2362
01:37:22,300 --> 01:37:22,600
而且

2363
01:37:22,600 --> 01:37:25,700
算法同样也存在着一个35岁的焦虑

2364
01:37:25,933 --> 01:37:28,933
对吧你的算法里头你也有高下之分

2365
01:37:28,933 --> 01:37:30,933
就你做开发有高下之分

2366
01:37:30,933 --> 01:37:32,366
算法里头也有高下之分

2367
01:37:32,466 --> 01:37:33,699
你到35岁之后

2368
01:37:33,700 --> 01:37:35,500
你不能成为算法中间的leader

2369
01:37:35,966 --> 01:37:38,733
同样有新毕业出来的博士和硕士

2370
01:37:39,100 --> 01:37:40,200
拿比你更低的工资

2371
01:37:40,200 --> 01:37:42,133
在算法岗里头就替代你的位置

2372
01:37:42,533 --> 01:37:45,766
对吧所以给每个就是

2373
01:37:45,766 --> 01:37:47,199
特别是搭线这个阶段

2374
01:37:47,200 --> 01:37:48,933
还没有确定自己方向的时候

2375
01:37:49,266 --> 01:37:50,466
给自己多个选择

2376
01:37:50,800 --> 01:37:52,600
就是无论是算法还是开发

2377
01:37:52,600 --> 01:37:54,400
其实在技术行当里头

2378
01:37:54,400 --> 01:37:57,866
都是一个可以长时间立足的东西

2379
01:37:57,866 --> 01:38:01,733
但前提是你要学会往上走

2380
01:38:01,933 --> 01:38:06,199
而不能满足于说我是被别人指派的

2381
01:38:06,200 --> 01:38:07,100
进去的时候啊

2382
01:38:07,100 --> 01:38:08,266
每个人进去的时候

2383
01:38:08,466 --> 01:38:09,733
肯定是要经历这个过程

2384
01:38:09,733 --> 01:38:11,533
你要经历被别人指派的过程

2385
01:38:11,933 --> 01:38:12,799
但是在这个过程中

2386
01:38:12,800 --> 01:38:15,733
你要知道说这个设计是怎么做的

2387
01:38:15,766 --> 01:38:16,899
产品是怎么做的

2388
01:38:16,900 --> 01:38:18,200
你才可能往上走啊

2389
01:38:18,200 --> 01:38:20,200
要不然永远就是在那个最底下

2390
01:38:20,200 --> 01:38:20,600
那个位置

2391
01:38:20,600 --> 01:38:22,700
然后到35岁的时候在那种

2392
01:38:22,700 --> 01:38:24,066
处于被别人选择

2393
01:38:24,066 --> 01:38:25,899
和被别人淘汰的那种位置上头

2394
01:38:27,200 --> 01:38:27,700
有问题吗

2395
01:38:27,700 --> 01:38:29,533
我不想再讲太多的内容了

2396
01:38:29,533 --> 01:38:30,699
可能怕大家接受不了

2397
01:38:30,800 --> 01:38:32,900
所以我们把整个课程的进度

2398
01:38:32,900 --> 01:38:34,400
给稍微拖慢一点啊

2399
01:38:34,400 --> 01:38:34,933
慢慢的来

2400
01:38:34,933 --> 01:38:36,999
让大家理解这部分的这个设计

2401
01:38:38,800 --> 01:38:39,533
好那没问题

2402
01:38:39,533 --> 01:38:40,999
我们就提前下课吧

2403
01:38:41,000 --> 01:38:42,266
有问题来单独问我

