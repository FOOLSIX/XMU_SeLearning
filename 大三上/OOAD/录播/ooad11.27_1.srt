1
00:00:44,166 --> 00:00:45,533
好呃

2
00:00:45,533 --> 00:00:48,333
我们上周有开始讲了一下

3
00:00:48,566 --> 00:00:50,666
怎么算商品运费的

4
00:00:50,666 --> 00:00:51,533
这个部分

5
00:00:52,000 --> 00:00:53,866
我们知道在商铺模块中间

6
00:00:53,866 --> 00:00:56,966
其实这是最复杂的一个API啊

7
00:00:56,966 --> 00:00:59,299
所以大家如果之后去看

8
00:00:59,700 --> 00:01:02,966
在这个部分的必做任务的话啊

9
00:01:02,966 --> 00:01:05,999
我的分的方式基本上是这样分的

10
00:01:06,466 --> 00:01:09,566
就是商铺是一个b座任务

11
00:01:09,733 --> 00:01:11,499
就是跟商铺有关的正常改差

12
00:01:11,500 --> 00:01:12,500
是一个b座任务

13
00:01:12,766 --> 00:01:17,399
然后跟这一堆有关的正常改差啊

14
00:01:17,400 --> 00:01:19,600
是一个b座任务然后

15
00:01:23,566 --> 00:01:25,799
这个API是一个b座人物

16
00:01:25,800 --> 00:01:27,800
所以这个b座人物别看它

17
00:01:29,300 --> 00:01:30,300
只有一个API

18
00:01:30,700 --> 00:01:32,333
但其实它是最麻烦的啊

19
00:01:32,333 --> 00:01:34,699
因为它涉及到的代码最多啊

20
00:01:34,700 --> 00:01:36,800
所以你要去做它的测试

21
00:01:36,800 --> 00:01:39,600
还有覆盖率的测试都是最麻烦的

22
00:01:39,600 --> 00:01:41,133
而且它的数据也最麻烦

23
00:01:41,466 --> 00:01:42,966
所以我们把这一个API啊

24
00:01:42,966 --> 00:01:44,966
单列了一个b座人物

25
00:01:45,133 --> 00:01:46,733
所以在商铺这一部分来说

26
00:01:46,733 --> 00:01:49,999
我们一共分出去了3个b座任务

27
00:01:50,000 --> 00:01:52,766
这样也就是第二批的b座任务

28
00:01:52,766 --> 00:01:53,899
就到此截止了

29
00:01:53,900 --> 00:01:54,733
然后再往后撤

30
00:01:54,733 --> 00:01:57,466
就是第三批和第四批的b座任务

31
00:01:58,966 --> 00:01:59,999
这个API啊

32
00:02:00,000 --> 00:02:02,000
我们说它主要的问题

33
00:02:02,066 --> 00:02:04,733
它主要解决的问题就是打包

34
00:02:04,733 --> 00:02:06,499
因为在订单那边

35
00:02:06,500 --> 00:02:08,166
当你下一个订单的时候

36
00:02:08,800 --> 00:02:10,533
这些定这些商品

37
00:02:10,533 --> 00:02:12,466
有可能超过了包裹的上限

38
00:02:12,733 --> 00:02:15,999
所以说他要按照不同的方式来打包

39
00:02:16,166 --> 00:02:16,866
那我们这里

40
00:02:16,866 --> 00:02:20,533
其实是有允许做不同的实现方式的

41
00:02:20,533 --> 00:02:22,266
就是比如说按照上限打包

42
00:02:22,333 --> 00:02:23,899
或者均匀的把所有的包裹

43
00:02:23,900 --> 00:02:25,733
打成一样的重量

44
00:02:26,166 --> 00:02:26,999
那还有一个呢

45
00:02:27,000 --> 00:02:29,366
就是啊

46
00:02:29,366 --> 00:02:30,299
贪心打包

47
00:02:30,333 --> 00:02:32,099
也就是尽量的把它打成

48
00:02:32,133 --> 00:02:34,899
用贪心算法啊来把它打成这个均匀

49
00:02:35,300 --> 00:02:37,466
打成这个均匀的这个结果

50
00:02:37,600 --> 00:02:40,000
还有一个就是按照这个啊

51
00:02:40,000 --> 00:02:41,600
费用最优打包

52
00:02:41,600 --> 00:02:42,100
那其实

53
00:02:42,100 --> 00:02:45,000
除了我们这里所列的这些方法以外

54
00:02:45,000 --> 00:02:47,500
应该还有新的方法出现

55
00:02:48,466 --> 00:02:49,399
所以在设计上头

56
00:02:49,400 --> 00:02:50,200
我们会认为

57
00:02:50,200 --> 00:02:50,800
这个地方

58
00:02:50,800 --> 00:02:54,333
是我们设计的变化点和眼镜点

59
00:02:54,600 --> 00:02:56,933
那我们需要在这个部分

60
00:02:56,933 --> 00:02:58,299
去让它满足

61
00:02:58,900 --> 00:03:01,133
我们设计上头的开闭原则

62
00:03:01,500 --> 00:03:03,533
那怎样去满足他的开闭原则呢

63
00:03:03,533 --> 00:03:05,866
我们这里用了这个策略模式

64
00:03:06,066 --> 00:03:08,899
那策略模式的最基本的特征就是

65
00:03:09,000 --> 00:03:11,566
我们在这个问题中间会发现

66
00:03:11,566 --> 00:03:12,733
说我们是要打包

67
00:03:13,200 --> 00:03:14,600
但具体怎么打包法

68
00:03:14,600 --> 00:03:16,200
它是有不同的方式的

69
00:03:16,366 --> 00:03:18,666
所以我们把不同的打包方式

70
00:03:18,666 --> 00:03:22,199
从打包的这个过程中间给它抽离出来

71
00:03:22,600 --> 00:03:24,266
把它抽到了外面

72
00:03:24,333 --> 00:03:27,699
然后用一个抽象的类

73
00:03:27,866 --> 00:03:29,333
或者是一个接口啊

74
00:03:29,333 --> 00:03:30,933
这个看具体的情况不一样

75
00:03:30,933 --> 00:03:31,933
上面是一个抽象类

76
00:03:31,933 --> 00:03:33,299
或者是一个具体的接口

77
00:03:33,500 --> 00:03:34,133
去定义

78
00:03:34,133 --> 00:03:36,533
说这个打包是应该怎么去完成

79
00:03:37,300 --> 00:03:39,766
然后底下用不同的纸类去实现

80
00:03:39,766 --> 00:03:43,566
说他不同的这个打包的方法

81
00:03:43,800 --> 00:03:45,500
那这样的一种方式

82
00:03:45,500 --> 00:03:46,266
我们可以看到

83
00:03:46,266 --> 00:03:49,599
他用了grasp的的动态的方啊

84
00:03:49,600 --> 00:03:51,100
多态的方法是吧

85
00:03:51,366 --> 00:03:53,299
Grasp的多态的方法

86
00:03:53,300 --> 00:03:54,966
来完成这样的一个过程

87
00:03:55,333 --> 00:03:56,566
那这个过程里头

88
00:03:56,566 --> 00:03:59,499
如果说我们的子类里头

89
00:03:59,500 --> 00:04:01,166
所定义的这个方法

90
00:04:02,666 --> 00:04:05,333
不会改变从负类中间的这个定义

91
00:04:05,600 --> 00:04:08,066
就是我们子类中间会实现这个方法

92
00:04:08,300 --> 00:04:10,300
那他不改变负类中间的这个定义

93
00:04:10,300 --> 00:04:12,700
他就满足历史可复可替换原则

94
00:04:13,000 --> 00:04:15,166
如果它满足Disco可替换原则

95
00:04:15,300 --> 00:04:18,700
那我们就可以任意的替换这个子类

96
00:04:18,733 --> 00:04:21,333
而不会影响到这边的这个代码

97
00:04:21,500 --> 00:04:22,566
从而就实现了我们所

98
00:04:22,566 --> 00:04:23,766
说的开闭原则

99
00:04:24,166 --> 00:04:26,933
也就是我们的这个算法

100
00:04:26,966 --> 00:04:28,533
如果产生一个新的算法的话

101
00:04:28,533 --> 00:04:29,399
如果有个新的算法的话

102
00:04:29,400 --> 00:04:30,700
我们这里做一个子类

103
00:04:30,866 --> 00:04:33,133
这边所有的就所有的代码都不会去动

104
00:04:33,700 --> 00:04:35,800
如果说现有的算法要做改进

105
00:04:35,800 --> 00:04:36,700
或者它里头有bug

106
00:04:36,700 --> 00:04:38,666
我们去改动现有的这个算法

107
00:04:38,800 --> 00:04:40,566
其他的代码也不会动啊

108
00:04:40,566 --> 00:04:45,566
这就是因为用了grasp的多肽的方法

109
00:04:46,000 --> 00:04:47,800
然后在多肽上面

110
00:04:47,800 --> 00:04:49,733
运用逆时可服可替换原则

111
00:04:49,733 --> 00:04:51,466
满足逆时可服可替换原则

112
00:04:51,700 --> 00:04:53,800
子类不会影响

113
00:04:53,800 --> 00:04:56,166
不会改变这个负类中间的这个定义

114
00:04:56,166 --> 00:04:57,799
造成子类是可以替换的

115
00:04:57,966 --> 00:05:00,866
从而实现了我们系统的这个开闭原则

116
00:05:01,066 --> 00:05:05,099
那这一套的东西其实是有一个啊

117
00:05:05,100 --> 00:05:06,366
固定的名称的

118
00:05:06,366 --> 00:05:08,866
这个名称称之为策略模式啊

119
00:05:08,866 --> 00:05:09,899
这是我们的设计模式

120
00:05:09,900 --> 00:05:11,100
中间的一种模式

121
00:05:11,100 --> 00:05:14,133
其实就是用的Grasp的多肽的方法

122
00:05:14,866 --> 00:05:16,899
让它满足历史可替换原则

123
00:05:16,900 --> 00:05:19,566
从而满足系统的开闭原则啊

124
00:05:19,566 --> 00:05:22,099
才形成的这种策略的模式

125
00:05:22,700 --> 00:05:24,800
我们在这个里头用到的策略模式

126
00:05:24,800 --> 00:05:26,700
其实就是下面这个绿色的部分

127
00:05:27,166 --> 00:05:29,599
但这个是他我们的一个传餐的字啊

128
00:05:29,600 --> 00:05:31,066
这是我们一个传餐的字

129
00:05:31,533 --> 00:05:32,866
主要是这一部分

130
00:05:34,200 --> 00:05:38,266
这一大块用到了这个策略模式

131
00:05:38,366 --> 00:05:40,766
那他所做的事情就是

132
00:05:40,766 --> 00:05:44,766
我们在我们来算这个啊

133
00:05:44,766 --> 00:05:47,866
怎么拆是由这个地区的模板

134
00:05:47,866 --> 00:05:49,299
这个对象来负责的

135
00:05:49,500 --> 00:05:50,266
就怎么拆

136
00:05:50,266 --> 00:05:52,499
怎么算运费都是由他来负责的

137
00:05:52,566 --> 00:05:54,466
算运费是在这里头去完成的

138
00:05:54,500 --> 00:05:57,400
但怎么拆这个就是有不同的拆法

139
00:05:57,533 --> 00:05:59,266
所以怎么拆这个部分

140
00:05:59,266 --> 00:06:02,599
我们从整个这个地区模板的这个里头

141
00:06:02,600 --> 00:06:04,400
给他弄出来

142
00:06:04,666 --> 00:06:05,966
弄出来以后我们这里做的是一个

143
00:06:05,966 --> 00:06:09,166
抽象的类抽象类里头

144
00:06:09,700 --> 00:06:11,800
Devite的方法是有写了代码的

145
00:06:12,400 --> 00:06:15,266
但是在这两个子类中间

146
00:06:15,266 --> 00:06:18,499
divide方法是没有去重载的

147
00:06:18,800 --> 00:06:22,100
而只是重载了下面的这个go to package size

148
00:06:22,100 --> 00:06:22,900
这个方法

149
00:06:22,900 --> 00:06:24,266
而这个go to package size方法

150
00:06:24,266 --> 00:06:26,199
是在divide方法中间有用到的

151
00:06:26,400 --> 00:06:28,933
所以这两个类

152
00:06:30,766 --> 00:06:33,133
是满足历史可复可替换原则的

153
00:06:33,133 --> 00:06:34,566
因为它没有改变

154
00:06:35,166 --> 00:06:38,766
它所调用的Dewite的这个方法的定义

155
00:06:39,200 --> 00:06:40,800
但是这两个类

156
00:06:40,900 --> 00:06:42,166
就是我们的贪心算法

157
00:06:42,166 --> 00:06:43,999
和最优的费用算法

158
00:06:44,166 --> 00:06:47,133
它是有重载了这个DIY的方法

159
00:06:47,333 --> 00:06:50,466
那就要看它重载的这个改变

160
00:06:50,466 --> 00:06:51,166
因为它重载了

161
00:06:51,166 --> 00:06:52,933
因为它重新写了这个DIY的方法

162
00:06:53,066 --> 00:06:55,299
那要看重新写的这个DIY的方法

163
00:06:55,300 --> 00:06:57,500
是否满足历史可复提换原则

164
00:06:58,066 --> 00:06:59,766
如果满足历史可符可替换原则

165
00:06:59,766 --> 00:07:00,866
那没问题

166
00:07:00,866 --> 00:07:01,733
它满足开币

167
00:07:01,900 --> 00:07:03,733
如果重新写的这个方法

168
00:07:03,733 --> 00:07:05,599
是不满足历史可符可替换原则的

169
00:07:06,066 --> 00:07:06,599
那就对不起了

170
00:07:06,600 --> 00:07:07,733
就不满足开币了

171
00:07:07,900 --> 00:07:10,700
所以这就当你在这两个子类中间

172
00:07:10,700 --> 00:07:12,666
他没有去重写这个独家的方法

173
00:07:12,666 --> 00:07:13,599
那你肯定知道

174
00:07:13,800 --> 00:07:15,766
他是满足历史古不可替换原则的

175
00:07:15,800 --> 00:07:17,666
但是这两个子类是有重写的

176
00:07:17,666 --> 00:07:19,099
为啥因为他的逻辑不一样

177
00:07:19,533 --> 00:07:20,966
所以他重写了啊

178
00:07:21,133 --> 00:07:24,533
所以这是这个策略模式的整个的这个

179
00:07:25,066 --> 00:07:27,699
呃样子这半边我们先不讲啊

180
00:07:27,700 --> 00:07:29,500
这半边我们用了一个调节器的模式

181
00:07:29,500 --> 00:07:31,400
我们放到后面来讲

182
00:07:31,866 --> 00:07:32,499
那我们来看

183
00:07:32,500 --> 00:07:34,333
他的计算是怎么来完成的啊

184
00:07:34,333 --> 00:07:36,299
先单纯来看这个策略模式

185
00:07:42,800 --> 00:07:43,866
策略模式里头

186
00:07:43,866 --> 00:07:45,766
它的就是这个里头

187
00:07:45,766 --> 00:07:49,699
它来做计算的时候从控制器层过来的

188
00:07:49,700 --> 00:07:52,166
所以控制器层会把我们刚才那些

189
00:07:52,166 --> 00:07:53,466
参数传过来

190
00:07:53,766 --> 00:07:54,566
那些参数呢

191
00:07:54,566 --> 00:07:56,499
会在控制器层转化成我们的IX

192
00:07:56,500 --> 00:07:57,900
这个参数就这边这个

193
00:07:58,100 --> 00:08:00,000
这是由它控制器层去完成的

194
00:08:00,100 --> 00:08:03,466
然后把我们的传贯的这个路径

195
00:08:03,466 --> 00:08:05,566
上面的两个参数

196
00:08:05,566 --> 00:08:08,799
就上面那个tempered ID和region ID

197
00:08:08,800 --> 00:08:11,133
最上面两个一样的

198
00:08:12,566 --> 00:08:13,966
作为后面两个参数传过来

199
00:08:14,800 --> 00:08:17,766
对吧所以过来以后在Server层的通力

200
00:08:17,766 --> 00:08:18,266
大家知道

201
00:08:18,266 --> 00:08:20,066
我们做的事情就是把ID换对象

202
00:08:20,533 --> 00:08:22,699
所以既然传过来了两个ID

203
00:08:22,700 --> 00:08:23,266
我们可以看到

204
00:08:23,266 --> 00:08:25,699
我们首先把time的ID换成time的对象

205
00:08:25,800 --> 00:08:26,466
那第二个呢

206
00:08:26,466 --> 00:08:28,299
我们不是把region ID换成region对象

207
00:08:28,300 --> 00:08:30,600
而是我们把region ID time的ID换成了我们

208
00:08:30,600 --> 00:08:33,766
什么呢换成了我们的region time的对象

209
00:08:33,800 --> 00:08:35,300
也就是我们在这个对象名中心

210
00:08:35,300 --> 00:08:36,366
看到的这个部分

211
00:08:38,066 --> 00:08:38,866
这个对象

212
00:08:39,366 --> 00:08:40,166
这个对象是什么

213
00:08:40,166 --> 00:08:42,133
这个对象就是我们其实定位到了

214
00:08:42,133 --> 00:08:44,399
说这个模板底下的这个地区

215
00:08:44,733 --> 00:08:45,733
是不是存在着

216
00:08:45,733 --> 00:08:47,599
这样的一个region top的对象

217
00:08:47,866 --> 00:08:50,199
大家知道这里头其实有更细的逻辑啊

218
00:08:50,200 --> 00:08:51,900
但我们就看赛马的时候可以看到

219
00:08:52,166 --> 00:08:55,166
他其实不是简单的用这个ID

220
00:08:55,600 --> 00:08:57,466
去在数据库里查到它

221
00:08:57,466 --> 00:08:59,466
因为其实用这个ID在数据库里去查

222
00:08:59,466 --> 00:09:00,566
是查不到的

223
00:09:00,700 --> 00:09:04,333
因为通常我们这个ID是街道委员会

224
00:09:04,866 --> 00:09:06,299
所以他需要从街道委员会

225
00:09:06,300 --> 00:09:09,066
去看他的所在的街道

226
00:09:09,100 --> 00:09:10,733
然后再去街道去看他的区

227
00:09:10,733 --> 00:09:11,399
去看他的区

228
00:09:11,400 --> 00:09:12,166
看他的市

229
00:09:12,166 --> 00:09:14,899
然后一层层去看看他上面这些地区

230
00:09:14,900 --> 00:09:18,200
哪一个地方定义了这个运费模板

231
00:09:18,533 --> 00:09:19,866
有定义了就把它返回来

232
00:09:19,866 --> 00:09:21,899
所以这个方法其实是不是这

233
00:09:21,900 --> 00:09:22,533
么简单的

234
00:09:22,533 --> 00:09:24,299
就是用这两个东西在数据库去查

235
00:09:24,300 --> 00:09:27,066
而是逐层逐层往上去去做的

236
00:09:27,366 --> 00:09:29,533
那我们不管他的这个逻辑啊

237
00:09:29,533 --> 00:09:31,566
因为这个逻辑都写到这个稻城了

238
00:09:31,700 --> 00:09:34,133
所以我我们关心的就是他最后拿到了

239
00:09:34,133 --> 00:09:35,966
就是如果能拿到一个region target

240
00:09:35,966 --> 00:09:37,733
就说明它是有运费模板的

241
00:09:37,866 --> 00:09:39,899
如果没拿到Reginald啊

242
00:09:39,900 --> 00:09:42,566
它其实就是没有运费模板的啊

243
00:09:42,566 --> 00:09:44,166
这是这样的一个

244
00:09:44,733 --> 00:09:46,866
这样的一个计算逻辑

245
00:09:46,900 --> 00:09:48,733
那拿到了他的这个运费模板

246
00:09:48,733 --> 00:09:51,333
我们则把计算的这个职责

247
00:09:51,333 --> 00:09:52,533
就分配给了运费模板

248
00:09:52,566 --> 00:09:53,466
这个应该好理解

249
00:09:53,466 --> 00:09:54,266
这是什么

250
00:09:54,733 --> 00:09:56,399
这是用了什么样的方法

251
00:09:56,600 --> 00:09:57,900
来把这个计算的职责

252
00:09:57,900 --> 00:10:00,200
分配给了这个地区的运费模板

253
00:10:01,366 --> 00:10:02,099
信息专家

254
00:10:02,100 --> 00:10:05,200
对吧因为怎么去算

255
00:10:06,000 --> 00:10:06,933
怎么去分

256
00:10:07,200 --> 00:10:10,000
其实都是跟这个地区模板的定义

257
00:10:10,166 --> 00:10:11,199
是有关系的

258
00:10:11,400 --> 00:10:12,766
所以我们把这个职责

259
00:10:12,766 --> 00:10:15,799
就分配给了这个地区的呃

260
00:10:16,000 --> 00:10:16,800
运费模板

261
00:10:18,300 --> 00:10:20,166
那地区的英文版是怎么去算的呢

262
00:10:20,166 --> 00:10:21,299
我们用一张单独的图

263
00:10:21,300 --> 00:10:23,166
去画它的算的过程

264
00:10:23,166 --> 00:10:24,966
我们可以看到它分成了两个过程

265
00:10:24,966 --> 00:10:26,399
一个过程是第一要分

266
00:10:27,066 --> 00:10:29,066
所以传过来的product item

267
00:10:30,533 --> 00:10:31,399
分给了他

268
00:10:31,666 --> 00:10:33,666
那我们就让这个运费模板

269
00:10:34,333 --> 00:10:37,099
去把它分成不同的包裹

270
00:10:37,133 --> 00:10:40,699
所以这个职责是把它分成不同的包裹

271
00:10:40,866 --> 00:10:41,766
但我们可以看到

272
00:10:41,766 --> 00:10:43,299
目前原本来说啊

273
00:10:43,300 --> 00:10:44,066
分成不同的包裹

274
00:10:44,066 --> 00:10:45,866
肯定是这个运费模板本身来做的

275
00:10:46,000 --> 00:10:46,966
但我们现在看到

276
00:10:46,966 --> 00:10:49,399
因为我们这个分法是不一样的

277
00:10:49,933 --> 00:10:50,766
所以大家可以看到

278
00:10:50,766 --> 00:10:52,533
我们把这一部分的代码

279
00:10:52,700 --> 00:10:54,933
这部分的职责应该首先是职责

280
00:10:55,300 --> 00:10:57,733
从运费模板里头把它抽离出来

281
00:10:57,733 --> 00:10:59,866
变成了一个抽象的类

282
00:11:00,066 --> 00:11:01,566
也是我们这里所看到的

283
00:11:03,600 --> 00:11:04,400
这个东西

284
00:11:04,766 --> 00:11:05,799
就本来来说

285
00:11:05,866 --> 00:11:07,299
按照这个运费模板的定义

286
00:11:07,300 --> 00:11:08,900
怎么分是他自己的事情

287
00:11:09,200 --> 00:11:10,266
这是他的职责

288
00:11:10,266 --> 00:11:12,466
但是因为这个会有不同的分法

289
00:11:12,600 --> 00:11:16,000
所以我们把这部分职责从他抽离出来

290
00:11:16,266 --> 00:11:17,866
变成了一个抽象的类

291
00:11:17,866 --> 00:11:20,499
然后在抽象的类底下是有若干个实现

292
00:11:20,766 --> 00:11:22,266
代表他的不同的分法

293
00:11:22,733 --> 00:11:25,466
那在运费模板里头我们可以看到

294
00:11:25,466 --> 00:11:27,999
这里头我们就是简单的把这个职责

295
00:11:28,000 --> 00:11:30,166
分配给了抽离出来的那个对象

296
00:11:30,700 --> 00:11:32,133
就是divide strategy

297
00:11:32,166 --> 00:11:33,266
让它怎么分法

298
00:11:33,333 --> 00:11:34,866
它可能会有不同的分的结果

299
00:11:34,866 --> 00:11:36,999
但我们在运费模板里头

300
00:11:37,000 --> 00:11:39,600
其实是不关心它是会怎么分的

301
00:11:39,600 --> 00:11:42,800
我们只要它最后分出来的这个结果

302
00:11:43,166 --> 00:11:44,599
分出来这个结果以后呢

303
00:11:44,600 --> 00:11:46,366
我们就会用它分出来的这个结果

304
00:11:46,366 --> 00:11:47,766
放到这个package里头

305
00:11:47,800 --> 00:11:49,300
然后这里做一个循环

306
00:11:50,066 --> 00:11:51,699
做这个循环的时候呢

307
00:11:51,700 --> 00:11:52,800
就是把它的一个

308
00:11:52,800 --> 00:11:54,366
我们就说它外层循环

309
00:11:54,500 --> 00:11:55,766
一个个的包裹拿出来

310
00:11:55,766 --> 00:11:58,266
去算这个包裹的运费是多少

311
00:11:59,300 --> 00:12:00,000
那大家知道

312
00:12:00,000 --> 00:12:01,600
我们在reading template上头

313
00:12:01,600 --> 00:12:04,400
它是一个抽象的类

314
00:12:04,400 --> 00:12:05,900
它不是一个具体的类

315
00:12:06,700 --> 00:12:08,566
在这它是一个抽象的类

316
00:12:08,766 --> 00:12:10,699
所以你去算它的运费

317
00:12:10,700 --> 00:12:11,466
这一个方法

318
00:12:11,466 --> 00:12:13,899
我们同样定义的是一个抽象的方法

319
00:12:14,100 --> 00:12:15,200
这个抽象的方法

320
00:12:15,200 --> 00:12:16,700
必然是在这个类

321
00:12:16,700 --> 00:12:18,300
和在这个类中间去实现

322
00:12:18,600 --> 00:12:20,933
因为按重量去算运费

323
00:12:20,933 --> 00:12:23,333
和按件数去算运费是不一样的

324
00:12:23,366 --> 00:12:24,566
整个逻辑都不一样

325
00:12:25,366 --> 00:12:26,899
那这一个方法

326
00:12:26,933 --> 00:12:28,999
都是在他和在他里头实现的

327
00:12:29,000 --> 00:12:29,733
而在复类中间

328
00:12:29,733 --> 00:12:32,166
只是定义了一个抽象的方法

329
00:12:32,400 --> 00:12:34,133
所以在这里我们可以看到

330
00:12:34,133 --> 00:12:35,466
在这个方法里头

331
00:12:35,566 --> 00:12:37,699
我们调这个方法

332
00:12:37,700 --> 00:12:39,166
实际上是在region time play的

333
00:12:39,166 --> 00:12:39,599
看起来是

334
00:12:39,600 --> 00:12:40,400
自己的方法

335
00:12:40,466 --> 00:12:41,133
但实际上

336
00:12:41,133 --> 00:12:43,466
是在它的指类对象中间实现的

337
00:12:43,766 --> 00:12:44,933
这是什么设计模式

338
00:12:48,166 --> 00:12:49,133
这什么设计模式

339
00:12:50,600 --> 00:12:51,366
啊我们首先不说

340
00:12:51,366 --> 00:12:53,999
你在设计时候用设计模式啊

341
00:12:54,133 --> 00:12:55,766
但至少你看到一个设计时候

342
00:12:55,766 --> 00:12:57,499
你应该知道这是用了一个设计模式

343
00:12:57,500 --> 00:12:58,500
这是什么设计模式

344
00:12:59,366 --> 00:13:00,166
这是

345
00:13:02,533 --> 00:13:03,766
temporary的method

346
00:13:13,366 --> 00:13:13,966
模板方法

347
00:13:13,966 --> 00:13:14,566
设计模式啊

348
00:13:14,566 --> 00:13:16,366
这个是非常非常常用的

349
00:13:16,600 --> 00:13:17,533
就是我们这里到

350
00:13:17,700 --> 00:13:19,566
基本上隔不了两三个地方

351
00:13:19,566 --> 00:13:20,133
你能看到

352
00:13:20,133 --> 00:13:22,133
我们在用这个temperature master设计模式

353
00:13:22,300 --> 00:13:24,300
因为当我们这里用了多肽以后

354
00:13:26,133 --> 00:13:28,066
因为在我们这里用了多肽以后

355
00:13:28,066 --> 00:13:30,799
我们基本的想法就是用了多肽以后

356
00:13:30,800 --> 00:13:32,733
它的共用的代码

357
00:13:32,733 --> 00:13:35,099
不应该在纸类中间重复去写

358
00:13:35,966 --> 00:13:37,899
那如何避免共用的代码

359
00:13:37,900 --> 00:13:39,733
不在指复类的东西重复去写

360
00:13:39,766 --> 00:13:41,166
就是把它提到负类上

361
00:13:41,533 --> 00:13:42,499
那提到负类上

362
00:13:42,500 --> 00:13:43,100
我们知道

363
00:13:43,100 --> 00:13:44,766
如果这个代码不在前面不在后面

364
00:13:44,766 --> 00:13:47,733
你就只能用他们怎么舍得去做

365
00:13:47,766 --> 00:13:48,733
所以大家可以看到

366
00:13:48,733 --> 00:13:49,933
这个部分就是这个样子

367
00:13:50,166 --> 00:13:51,766
这个代码不在前面不在后面

368
00:13:51,766 --> 00:13:52,566
他在中间

369
00:13:52,933 --> 00:13:55,166
就在整个这个代码的中间

370
00:13:55,166 --> 00:13:56,499
这一部分是不同的

371
00:13:56,933 --> 00:13:58,166
前面后面都是一样

372
00:13:58,733 --> 00:14:00,533
所以这样的一种做法来说

373
00:14:00,533 --> 00:14:02,866
你就只能用template message去做

374
00:14:03,166 --> 00:14:05,733
因为你如果说是在纸类中间继承的话

375
00:14:05,733 --> 00:14:07,399
你只能在他之前或者之后去做

376
00:14:07,400 --> 00:14:09,066
而不能在啊

377
00:14:09,100 --> 00:14:10,333
只能在他的之后去做啊

378
00:14:10,333 --> 00:14:11,599
还不能在他之前去做

379
00:14:11,666 --> 00:14:13,533
那你就就没办法去完成

380
00:14:13,533 --> 00:14:14,533
这样的一个过程

381
00:14:14,733 --> 00:14:18,266
所以这就是我们用的template method

382
00:14:18,266 --> 00:14:19,733
把这里做成一个填空题

383
00:14:19,733 --> 00:14:22,333
这个填空题的空是由指类去填出来的

384
00:14:22,333 --> 00:14:23,066
在负类中间

385
00:14:23,066 --> 00:14:24,533
这是一个抽象的方法

386
00:14:24,600 --> 00:14:26,166
指类中间会具体去实现

387
00:14:26,333 --> 00:14:29,799
所以件数模板和重量模板

388
00:14:29,800 --> 00:14:31,700
它的运费的算法不同

389
00:14:32,500 --> 00:14:33,666
在质量中心实验

390
00:14:33,733 --> 00:14:35,299
但对于负类来说

391
00:14:35,333 --> 00:14:37,499
我们只要他算出一个值出来

392
00:14:37,666 --> 00:14:38,566
算出个值干嘛呢

393
00:14:38,566 --> 00:14:40,066
我们会把这个值和这个包裹

394
00:14:40,066 --> 00:14:42,199
打成一个返回值的类型

395
00:14:42,200 --> 00:14:43,900
然后把这个类型变成一个list

396
00:14:43,900 --> 00:14:45,533
然后把这个list返回回去

397
00:14:46,533 --> 00:14:47,799
这里头大家特别注意下

398
00:14:47,800 --> 00:14:50,533
这张图的上面这些对象里头

399
00:14:51,133 --> 00:14:53,599
我们的第一个对象都写了名称

400
00:14:54,200 --> 00:14:54,800
看到没有

401
00:14:54,800 --> 00:14:56,000
之前的设计图中间

402
00:14:56,000 --> 00:14:59,400
我们极少看到第一个对象会写名称的

403
00:14:59,966 --> 00:15:02,066
但是这张图的第一个对象写了名称

404
00:15:02,800 --> 00:15:03,733
就在这个地方

405
00:15:07,366 --> 00:15:09,399
为什么这张图的第一个对象会写名称

406
00:15:10,000 --> 00:15:11,933
原因是这个名称在后面用到了

407
00:15:11,933 --> 00:15:12,866
在这个地方用到

408
00:15:15,133 --> 00:15:16,133
对吧那这个地方用到

409
00:15:16,133 --> 00:15:18,599
是不是跟代码上头是一样的嘛

410
00:15:19,000 --> 00:15:20,366
代码上不是这么写的

411
00:15:20,600 --> 00:15:22,800
但是这里头表示的意思是

412
00:15:23,066 --> 00:15:25,499
当我去调这个strategy的时候

413
00:15:25,500 --> 00:15:30,200
我把这个对象作为它的第一个参数

414
00:15:30,200 --> 00:15:31,133
传过去了

415
00:15:31,333 --> 00:15:33,133
大家知道代码里头是写成什么了

416
00:15:34,533 --> 00:15:36,133
如果写成代码的话是写成什么

417
00:15:38,133 --> 00:15:39,866
写成代码的话写成是this

418
00:15:39,866 --> 00:15:41,099
对写成是this

419
00:15:41,933 --> 00:15:44,299
这就是我们在画顺序图的时候

420
00:15:44,300 --> 00:15:46,000
和代码是不一样的

421
00:15:46,200 --> 00:15:48,066
顺序图上的你没办法去写z

422
00:15:48,066 --> 00:15:49,533
因为你不知道z是什么

423
00:15:50,100 --> 00:15:51,466
因为它有很多个对象

424
00:15:51,466 --> 00:15:53,133
这个z代代表哪个对象

425
00:15:53,333 --> 00:15:54,366
所以我们在画顺序图时

426
00:15:54,366 --> 00:15:56,933
我们需要把这个第一个对象

427
00:15:56,933 --> 00:15:57,666
给它标出来

428
00:15:57,666 --> 00:15:58,733
然后在传的时候

429
00:15:58,733 --> 00:16:00,966
把这个对象的属性给它标上去

430
00:16:00,966 --> 00:16:02,366
如果后面会用z的话

431
00:16:02,366 --> 00:16:02,966
同样的啊

432
00:16:02,966 --> 00:16:04,366
也是这个这样的一个原则

433
00:16:04,700 --> 00:16:06,800
不要去把认识写到这个上面

434
00:16:06,900 --> 00:16:10,200
而是应该把在这里应该明确指向他的

435
00:16:10,600 --> 00:16:12,566
这个对象的名称是什么啊

436
00:16:12,566 --> 00:16:14,333
那表示说他是什么样对象

437
00:16:14,800 --> 00:16:16,966
这是这一段代码里头啊

438
00:16:16,966 --> 00:16:20,166
特别讲一下他的这个啊

439
00:16:20,500 --> 00:16:22,866
属性的就是对象的名称

440
00:16:22,866 --> 00:16:24,599
其实是有特别的含义的

441
00:16:26,966 --> 00:16:28,999
那这个里头怎么去算运费

442
00:16:29,000 --> 00:16:29,700
就是下面这个

443
00:16:29,700 --> 00:16:31,000
第三个怎么去算运费

444
00:16:31,000 --> 00:16:32,133
我们就没有去画图

445
00:16:32,133 --> 00:16:32,666
去画了

446
00:16:32,666 --> 00:16:34,933
因为那纯粹是面向功能的方式啊

447
00:16:34,933 --> 00:16:36,266
就纯粹是面向功能的方式

448
00:16:36,266 --> 00:16:37,799
去完成了这个运费的计算

449
00:16:38,000 --> 00:16:41,000
我们给大家画的是它如何分的

450
00:16:41,300 --> 00:16:43,000
就是如何去做Devite的

451
00:16:44,000 --> 00:16:45,166
如何去做Devite的

452
00:16:45,166 --> 00:16:47,599
我们在Devite strategy中间

453
00:16:47,600 --> 00:16:50,000
是有做了一个方法的

454
00:16:50,566 --> 00:16:52,266
这个方法里头啊

455
00:16:52,266 --> 00:16:52,799
我们可以看到

456
00:16:52,800 --> 00:16:54,966
他做的事情其实就是这么几个

457
00:16:55,300 --> 00:16:57,366
第一个你要去分的话

458
00:16:57,466 --> 00:16:58,533
你首先要知道

459
00:16:58,533 --> 00:17:02,166
我要按照一个什么样的标准去做分配

460
00:17:02,866 --> 00:17:06,666
对吧按照上限还是按照均匀值

461
00:17:06,733 --> 00:17:09,299
我们这里首先说这两种啊

462
00:17:10,100 --> 00:17:11,200
画到这边这两种

463
00:17:12,166 --> 00:17:13,133
按照上限

464
00:17:13,166 --> 00:17:13,866
还是说均匀值

465
00:17:13,866 --> 00:17:15,899
因为我们显示写在附类中间的方法

466
00:17:15,900 --> 00:17:16,566
我们刚才说了

467
00:17:16,566 --> 00:17:19,466
这两个类是把这个方法给覆盖了

468
00:17:19,933 --> 00:17:21,533
所以写在这里

469
00:17:21,533 --> 00:17:22,133
这个方法

470
00:17:22,133 --> 00:17:23,699
其实对于他和对于他来说

471
00:17:23,700 --> 00:17:24,700
是没有作用的

472
00:17:24,700 --> 00:17:25,933
因为在这两个指的中间

473
00:17:25,933 --> 00:17:27,733
实际上是把这个方法给overrated了

474
00:17:28,133 --> 00:17:30,133
所以他会完全替代掉这个方法

475
00:17:30,300 --> 00:17:31,933
至于替代以后是不是符合历史

476
00:17:31,933 --> 00:17:32,766
可不可替换原则

477
00:17:32,766 --> 00:17:33,799
我们在之后来讲

478
00:17:33,933 --> 00:17:35,299
但是这两个方法

479
00:17:35,300 --> 00:17:38,066
是没有去替代他的这个方法的

480
00:17:38,066 --> 00:17:39,666
所以他会继承这个方法

481
00:17:39,933 --> 00:17:42,999
那这两个方法的这个debate的逻辑

482
00:17:43,500 --> 00:17:45,500
就是我们这里所看到的这个逻辑

483
00:17:47,766 --> 00:17:49,599
他首先会去计算一个

484
00:17:51,566 --> 00:17:53,933
总量我们只能说是总量

485
00:17:54,600 --> 00:17:55,266
为啥

486
00:17:55,266 --> 00:17:58,133
因为我们现在的这个运费模板是

487
00:17:58,133 --> 00:17:59,699
既可能是计重的

488
00:17:59,933 --> 00:18:01,266
也可能是计件

489
00:18:02,000 --> 00:18:04,866
那计重的这个总量是什么

490
00:18:04,866 --> 00:18:08,266
是重量的总总重量对吧

491
00:18:08,600 --> 00:18:09,933
计件的那种运算模板

492
00:18:09,933 --> 00:18:11,266
它的总量是什么呢

493
00:18:11,366 --> 00:18:13,599
是总件数对吧

494
00:18:13,600 --> 00:18:14,966
这里就涉及到一个问题

495
00:18:15,100 --> 00:18:15,866
我们在代码中间

496
00:18:15,866 --> 00:18:17,733
我们不想去区分说

497
00:18:17,733 --> 00:18:20,133
他到底是计件的还是计重的

498
00:18:20,400 --> 00:18:23,166
如果我们要试图去区分他是计重的

499
00:18:23,166 --> 00:18:24,166
还是计件的

500
00:18:24,500 --> 00:18:27,666
这里就不会满足历史可复可TY原则了

501
00:18:28,066 --> 00:18:29,366
因为万一有第三种呢

502
00:18:29,366 --> 00:18:30,733
但实际上是没有第三种啊

503
00:18:30,733 --> 00:18:31,899
但是我们在写代码上

504
00:18:31,900 --> 00:18:35,800
我们还是尽量避免说在这里会出现EFL

505
00:18:35,800 --> 00:18:37,133
去做这样的一个判断

506
00:18:37,300 --> 00:18:39,133
那我们的做法是什么呢

507
00:18:39,133 --> 00:18:40,533
我们的做法是

508
00:18:40,666 --> 00:18:43,366
我们把算总量的这个事情

509
00:18:43,733 --> 00:18:46,666
并不是在这个divide strategy中间来算的

510
00:18:46,766 --> 00:18:47,799
而是在这里

511
00:18:47,800 --> 00:18:51,200
把它付给了哪个对象去完成呢

512
00:18:51,333 --> 00:18:52,733
付给了这个对象去完成

513
00:18:55,200 --> 00:18:56,166
这个对象就完成

514
00:18:56,533 --> 00:18:56,933
这个对象

515
00:18:56,933 --> 00:18:57,933
怎么获得的

516
00:18:58,166 --> 00:18:58,866
这个对象是

517
00:18:58,866 --> 00:19:02,766
我们现在是在是在这里来做divide

518
00:19:03,333 --> 00:19:04,533
这里的第一个参数

519
00:19:04,533 --> 00:19:05,299
大家注意下

520
00:19:05,300 --> 00:19:06,900
就是我们所说的这个this

521
00:19:07,500 --> 00:19:08,966
就是他对吧

522
00:19:09,200 --> 00:19:11,733
他可以拿到他的这个template

523
00:19:12,100 --> 00:19:14,333
这个template中间可以拿到他的type

524
00:19:14,500 --> 00:19:18,166
这个type就会知道说我们怎么算重量

525
00:19:18,166 --> 00:19:18,799
所以我们可以看到

526
00:19:18,800 --> 00:19:21,066
这个职责其实绕了个大圈啊

527
00:19:21,066 --> 00:19:23,199
从他到他

528
00:19:23,200 --> 00:19:24,166
从他到他

529
00:19:24,166 --> 00:19:24,766
从他到他

530
00:19:24,766 --> 00:19:25,566
最后到他

531
00:19:26,000 --> 00:19:29,133
由他来决定说他怎么重量

532
00:19:29,133 --> 00:19:29,933
怎么去算

533
00:19:31,066 --> 00:19:32,499
那这个方法

534
00:19:34,133 --> 00:19:35,333
这个方法啊

535
00:19:35,766 --> 00:19:37,166
他其实是什么呢

536
00:19:37,333 --> 00:19:39,999
他其实里头会掉这个方法给他看

537
00:19:41,100 --> 00:19:43,100
那get CON是一个抽象方法

538
00:19:43,100 --> 00:19:46,200
因为它是在这两头去分别实现的

539
00:19:46,366 --> 00:19:47,299
重量的CON呢

540
00:19:47,300 --> 00:19:48,700
就是它按照重量来算

541
00:19:49,133 --> 00:19:51,299
件数的CON就是按照件数来算

542
00:19:51,366 --> 00:19:52,466
然后copper total呢

543
00:19:52,466 --> 00:19:54,066
其实就是把你到底按重量算

544
00:19:54,066 --> 00:19:55,166
还是按照件数算

545
00:19:55,500 --> 00:19:57,366
乘上那个商品的数量

546
00:19:58,066 --> 00:19:59,733
就是我们最后的值

547
00:19:59,733 --> 00:20:01,366
所以这个get看到方法

548
00:20:01,366 --> 00:20:02,933
在重量中间返回的就是重量

549
00:20:03,133 --> 00:20:04,299
这个件数呢

550
00:20:04,300 --> 00:20:05,600
get看的返回的是什么呢

551
00:20:05,600 --> 00:20:07,900
就是 1 就是恒定的

552
00:20:07,900 --> 00:20:11,166
就是一所以在type特效中间

553
00:20:11,166 --> 00:20:12,399
在这个代码中间所写的

554
00:20:12,400 --> 00:20:14,133
就是把这个get control值

555
00:20:14,133 --> 00:20:16,899
呈上这个product item的quantity

556
00:20:17,400 --> 00:20:18,533
把它返回回去了

557
00:20:18,900 --> 00:20:19,666
我再问一遍

558
00:20:19,666 --> 00:20:21,066
这里用了一个什么设计模式

559
00:20:21,200 --> 00:20:22,266
我这没画图

560
00:20:22,766 --> 00:20:24,066
这地方用了一个什么设计模式

561
00:20:24,066 --> 00:20:24,866
能看出来吗

562
00:20:27,400 --> 00:20:28,466
用了什么设计模式

563
00:20:33,800 --> 00:20:37,400
又是他所以但凡看到这个

564
00:20:38,400 --> 00:20:40,333
这个继承的时候

565
00:20:40,333 --> 00:20:42,133
然后我们想在负累中间

566
00:20:42,133 --> 00:20:43,566
去写共性代码的时候

567
00:20:43,766 --> 00:20:46,566
我们就会频繁的使用他们的master

568
00:20:46,566 --> 00:20:48,299
设计模式这个东西

569
00:20:48,300 --> 00:20:50,600
这个地方所写的代码就是这个

570
00:20:50,800 --> 00:20:53,100
因为算总量的时候

571
00:20:53,100 --> 00:20:55,466
我们就是乘上它的数量

572
00:20:55,766 --> 00:20:57,799
至于是什么乘它的数量

573
00:20:58,766 --> 00:20:59,866
这个和这个不同

574
00:20:59,866 --> 00:21:01,966
这个就是重量乘它的数量

575
00:21:02,266 --> 00:21:03,133
这个是什么

576
00:21:03,133 --> 00:21:04,866
这个是一乘它的数量

577
00:21:05,400 --> 00:21:07,466
对吧所以到底是重量乘它的数量

578
00:21:07,466 --> 00:21:08,666
还是一乘它的数量呢

579
00:21:08,666 --> 00:21:09,866
我们写成了这个方法

580
00:21:09,866 --> 00:21:11,133
在负类中间

581
00:21:11,466 --> 00:21:14,566
然后这个方法是在子类中间去实现的

582
00:21:14,566 --> 00:21:15,133
所以这里头

583
00:21:15,133 --> 00:21:17,766
我们又使用到了这个Tempter master

584
00:21:17,933 --> 00:21:19,399
所以大凡大家看到

585
00:21:19,400 --> 00:21:21,900
其实他没有做特别多的处理

586
00:21:21,900 --> 00:21:24,666
都会使用这个Tempter master的收集模式啊

587
00:21:25,100 --> 00:21:26,766
来完成这样的一个设计

588
00:21:27,266 --> 00:21:30,133
所以在这个设计中间

589
00:21:32,466 --> 00:21:33,266
大家应该可以看到

590
00:21:33,266 --> 00:21:34,399
我们的total是怎么来的

591
00:21:34,500 --> 00:21:35,400
我们的total

592
00:21:35,400 --> 00:21:37,900
是从传贯的这个template的中间

593
00:21:38,400 --> 00:21:42,000
去得到它的这个type

594
00:21:43,066 --> 00:21:45,533
啊其实其实这个图还画错了

595
00:21:45,533 --> 00:21:46,866
还不是直接得到他的type

596
00:21:46,933 --> 00:21:48,966
是得到他的template的type啊

597
00:21:49,100 --> 00:21:51,100
这个传过来的template是region template

598
00:21:51,333 --> 00:21:53,533
其实应该是得到这个region template的

599
00:21:53,533 --> 00:21:54,866
template的type

600
00:21:54,966 --> 00:21:58,333
然后才能得到他的这个对象

601
00:21:58,800 --> 00:21:59,666
他能得到这个对象

602
00:21:59,666 --> 00:22:01,133
其实上面这个应该写的是

603
00:22:01,366 --> 00:22:03,933
这个template的template的type啊

604
00:22:03,933 --> 00:22:05,199
是两个template type

605
00:22:05,300 --> 00:22:06,866
大家其实应该也能看出来

606
00:22:06,866 --> 00:22:08,166
这个地方就违背了

607
00:22:08,400 --> 00:22:09,400
违背了什么原则

608
00:22:10,133 --> 00:22:12,066
大黄人代码去看到这码头我都要问啊

609
00:22:12,066 --> 00:22:13,133
这个地方其实违背了一个

610
00:22:13,133 --> 00:22:14,133
我们的设计原则

611
00:22:14,566 --> 00:22:17,099
那算出它的总量以后

612
00:22:17,800 --> 00:22:18,900
我们现在其实就是

613
00:22:18,900 --> 00:22:21,066
不管它是重量还是件数

614
00:22:21,400 --> 00:22:24,733
反正算出来的总量就是一个整数

615
00:22:24,933 --> 00:22:26,599
这个整数也可能是重量整数

616
00:22:26,600 --> 00:22:27,933
也可能是件数整数

617
00:22:28,000 --> 00:22:30,166
那我们单纯的用这个总数去判断

618
00:22:30,166 --> 00:22:31,933
说它是否小于它的

619
00:22:32,766 --> 00:22:35,066
在运费模板中间定义的他的上限

620
00:22:35,066 --> 00:22:36,199
如果他小于他上限的话

621
00:22:36,200 --> 00:22:37,166
那其实也没什么好说的

622
00:22:37,166 --> 00:22:38,599
就直接把他放在一个包裹中间

623
00:22:38,766 --> 00:22:39,733
所以3和4

624
00:22:39,733 --> 00:22:42,099
这个实际上没有什么特别的做法

625
00:22:42,100 --> 00:22:43,800
就是直接把他放在一个包裹中间

626
00:22:44,166 --> 00:22:46,666
那如果说超过了他的上限的话

627
00:22:46,666 --> 00:22:47,999
因为他一个包裹放不下了

628
00:22:48,733 --> 00:22:49,399
那怎么办呢

629
00:22:49,400 --> 00:22:51,066
那就要进行分包

630
00:22:51,500 --> 00:22:54,066
所以当超过了它的这个上限以后

631
00:22:54,066 --> 00:22:55,699
我们进行分包的时候

632
00:22:55,733 --> 00:22:57,533
我们第一个我们要知道

633
00:22:57,533 --> 00:22:59,933
它的分包的标准是什么所

634
00:22:59,933 --> 00:23:01,199
以我们这里又写了一个方法

635
00:23:01,200 --> 00:23:02,566
get package size

636
00:23:04,266 --> 00:23:07,066
这个gate package size是一个抽象的方法

637
00:23:07,133 --> 00:23:08,399
这个抽象的方法

638
00:23:16,066 --> 00:23:17,999
对这个这个抽象的方法

639
00:23:18,000 --> 00:23:19,766
是在他和他里头实现的

640
00:23:19,933 --> 00:23:20,566
所以我们说

641
00:23:20,566 --> 00:23:24,733
这是一个模板方法的设计模式就是

642
00:23:28,166 --> 00:23:28,966
在这个地方

643
00:23:29,933 --> 00:23:30,766
这是个空

644
00:23:31,266 --> 00:23:32,799
这个空是个抽象的方法

645
00:23:33,133 --> 00:23:34,333
这是底下的

646
00:23:34,600 --> 00:23:37,366
Max size和average size的两个子类

647
00:23:37,366 --> 00:23:37,933
去实现所以

648
00:23:37,933 --> 00:23:38,899
这里第三次

649
00:23:38,900 --> 00:23:41,966
使用了模板方法的设计模式

650
00:23:41,966 --> 00:23:44,099
让他在指类中间去返回

651
00:23:44,100 --> 00:23:47,766
说你到底是上限呢还是均值

652
00:23:47,900 --> 00:23:49,666
当然我们传了两个参数啊

653
00:23:49,800 --> 00:23:50,966
上限其实没什么好说的

654
00:23:50,966 --> 00:23:51,966
就是后面这个字

655
00:23:52,266 --> 00:23:54,366
均值的话其实是要这两个值算出来的

656
00:23:54,366 --> 00:23:55,499
但我们给他传的参数

657
00:23:55,500 --> 00:23:56,600
就是把两个都给他了

658
00:23:56,766 --> 00:23:58,099
但其实上限

659
00:23:58,100 --> 00:23:59,933
就直接就把后面这个值反复回来了

660
00:24:00,066 --> 00:24:01,699
均值是把两个算了一下

661
00:24:01,766 --> 00:24:03,133
但得到了说

662
00:24:03,133 --> 00:24:05,266
我们分包的标准是这个package size

663
00:24:05,266 --> 00:24:07,199
以后我们就看它的这个标准呢

664
00:24:07,200 --> 00:24:08,000
分包了

665
00:24:08,300 --> 00:24:10,300
那分包之前我们首先做了一个预处理

666
00:24:10,300 --> 00:24:11,200
这个预处理是干嘛呢

667
00:24:11,200 --> 00:24:13,200
因为我们传过来是product items

668
00:24:13,266 --> 00:24:14,866
这里头每一个商品

669
00:24:14,866 --> 00:24:17,666
每一种商品可能是有两件或者3件的

670
00:24:17,900 --> 00:24:18,900
但是分包的时候

671
00:24:18,900 --> 00:24:21,700
它两三件会放到不同的包裹里去

672
00:24:21,700 --> 00:24:22,466
是允许这样的

673
00:24:22,466 --> 00:24:23,399
并不是我们规定说

674
00:24:23,400 --> 00:24:24,800
这一个商品

675
00:24:24,800 --> 00:24:27,066
三件也必须同样放在一个包裹里头

676
00:24:27,066 --> 00:24:28,333
我们没有这样的一个规定啊

677
00:24:28,333 --> 00:24:30,133
所以我们首先把它打散

678
00:24:30,366 --> 00:24:32,933
这是一个静态的方法

679
00:24:33,400 --> 00:24:34,766
这个静态的方法所做的事情

680
00:24:34,766 --> 00:24:35,699
就是把它打散

681
00:24:36,466 --> 00:24:38,066
就是所以说他如果里头有两间

682
00:24:38,066 --> 00:24:38,499
三间的话

683
00:24:38,500 --> 00:24:39,600
就全部拆成一个一个的

684
00:24:39,600 --> 00:24:40,000
所以叫做

685
00:24:40,000 --> 00:24:42,366
single items然后我们的分包

686
00:24:42,366 --> 00:24:46,133
就是由single item来做分包的

687
00:24:46,200 --> 00:24:46,966
大家可以看到

688
00:24:46,966 --> 00:24:48,199
我们在做分包的时候

689
00:24:48,200 --> 00:24:50,800
并不是在这一个方法里头写的

690
00:24:50,800 --> 00:24:52,866
并不是在direct strategy里头写的

691
00:24:52,966 --> 00:24:55,366
而是把它又付给了另外一个对象

692
00:24:55,366 --> 00:24:57,499
这个对象叫做aggres

693
00:24:57,800 --> 00:24:59,000
这个对象是什么呢

694
00:25:01,700 --> 00:25:03,000
这个对象就是这半边

695
00:25:04,366 --> 00:25:05,199
就这半边

696
00:25:05,666 --> 00:25:06,966
所以我们可以看到

697
00:25:06,966 --> 00:25:08,933
本身这个策略模式

698
00:25:08,933 --> 00:25:11,133
是从整体里头抽出来的

699
00:25:11,366 --> 00:25:12,866
所以当他要分的时候呢

700
00:25:12,866 --> 00:25:14,333
整体中间会给他去分

701
00:25:14,733 --> 00:25:15,866
分的过程中间我们可以看到

702
00:25:15,866 --> 00:25:18,199
从策略模式间我们又抽出来一部分

703
00:25:19,533 --> 00:25:20,333
变成了他

704
00:25:21,900 --> 00:25:22,733
变成了他

705
00:25:23,300 --> 00:25:26,500
然后我们由他来决定说如何打包

706
00:25:26,733 --> 00:25:27,999
他底下其实有两个算法

707
00:25:28,000 --> 00:25:28,566
如何打包

708
00:25:28,566 --> 00:25:30,333
一个是single AG预制

709
00:25:30,533 --> 00:25:32,599
一个是backpack AG预制

710
00:25:33,133 --> 00:25:35,066
这个是简单的打包法

711
00:25:35,066 --> 00:25:35,966
就按照那个顺序

712
00:25:35,966 --> 00:25:37,666
我不是心肝开始传过来了吗

713
00:25:38,066 --> 00:25:39,399
先从前面开始拿起

714
00:25:40,066 --> 00:25:40,866
第一个第二个第三个

715
00:25:40,866 --> 00:25:41,733
第四个就放去

716
00:25:41,733 --> 00:25:43,933
放到如果他超过上限了好

717
00:25:43,933 --> 00:25:45,866
那就后面的就放到第二个包裹里头

718
00:25:45,900 --> 00:25:46,866
然后又超过上限了

719
00:25:46,866 --> 00:25:48,099
好放到第三个包裹里头

720
00:25:48,100 --> 00:25:50,300
这就是其实就是没算法啊

721
00:25:50,300 --> 00:25:51,733
就是直接按照顺序放的

722
00:25:52,200 --> 00:25:53,766
这个呢就是用的背包算法

723
00:25:53,766 --> 00:25:55,733
这个应该大家刚刚学过背包算法

724
00:25:55,733 --> 00:25:57,499
应该知道啊

725
00:25:57,500 --> 00:26:00,333
比如说我有一个30公斤的货物

726
00:26:00,700 --> 00:26:02,366
30公斤货物里头有10件

727
00:26:02,566 --> 00:26:03,933
重量都是不一样的

728
00:26:04,066 --> 00:26:06,333
然后我的包裹上限是20公斤

729
00:26:06,800 --> 00:26:07,966
那问题就是

730
00:26:07,966 --> 00:26:10,399
我这30公斤不同重量的货物

731
00:26:10,700 --> 00:26:13,300
如何放到一个20公斤的背包里

732
00:26:14,533 --> 00:26:16,133
对吧这就是背包算法

733
00:26:16,333 --> 00:26:18,466
所以这就是个经典的背包算法啊

734
00:26:19,533 --> 00:26:23,333
先把30公斤的货物尽量的把那个20

735
00:26:23,333 --> 00:26:24,799
公斤的包裹给他塞满

736
00:26:25,300 --> 00:26:26,166
塞满了以后呢

737
00:26:26,200 --> 00:26:28,400
剩下的商品又是一个背包算法

738
00:26:28,666 --> 00:26:31,266
又塞到第二个这个里头来

739
00:26:31,266 --> 00:26:32,466
然后在第三个里头来

740
00:26:32,466 --> 00:26:34,999
所以他其实就是不断的在用背包算法

741
00:26:35,100 --> 00:26:36,100
最后打出来说

742
00:26:36,100 --> 00:26:38,466
我最后的这个包裹是什么

743
00:26:38,466 --> 00:26:39,766
就按道理来说啊

744
00:26:39,866 --> 00:26:42,066
这个背包算法打出来的包裹数

745
00:26:42,466 --> 00:26:46,566
应该是小于等于这个基本算法的

746
00:26:46,566 --> 00:26:48,966
对吧所以他应该是一个更优的

747
00:26:49,366 --> 00:26:51,566
能够把这些商品

748
00:26:51,566 --> 00:26:54,066
塞到这个包裹里头去的

749
00:26:54,066 --> 00:26:54,966
这个算法

750
00:26:55,700 --> 00:26:57,133
所以在这个设计中间

751
00:26:59,966 --> 00:27:00,966
我们可以看到

752
00:27:01,400 --> 00:27:02,400
把它拆成单个

753
00:27:02,400 --> 00:27:04,966
然后我们把它只交给了另外一个算法

754
00:27:04,966 --> 00:27:05,766
去做pack

755
00:27:05,766 --> 00:27:06,866
注意这是一个

756
00:27:07,733 --> 00:27:08,899
这是一个接口

757
00:27:09,266 --> 00:27:11,199
所以怎么pack法我们不管

758
00:27:11,200 --> 00:27:13,100
我们只管它pack回来的结果

759
00:27:13,300 --> 00:27:14,200
pack回来结果呢

760
00:27:14,200 --> 00:27:17,500
然后我们又把它恢复成为的那个

761
00:27:17,533 --> 00:27:18,366
那个project

762
00:27:18,366 --> 00:27:19,999
因为如果在一个报告中间

763
00:27:20,000 --> 00:27:21,366
是有同样商品

764
00:27:21,366 --> 00:27:22,366
是有两件3件的

765
00:27:22,366 --> 00:27:23,566
我们不要这个single at

766
00:27:23,566 --> 00:27:24,766
这个看起来太难看了

767
00:27:24,800 --> 00:27:26,100
所以这其实又做了一个合并

768
00:27:26,100 --> 00:27:26,900
就是同一个报告中间

769
00:27:26,900 --> 00:27:27,933
如果有相同的商品的话

770
00:27:27,933 --> 00:27:29,466
又把它合起来啊

771
00:27:29,466 --> 00:27:30,966
变成了这个商品有3件

772
00:27:30,966 --> 00:27:32,333
那个商品有两件啊

773
00:27:32,333 --> 00:27:34,166
这其实就是一个反过程

774
00:27:34,666 --> 00:27:38,366
最后把这个pack给它返回回去了啊

775
00:27:38,366 --> 00:27:40,499
就把这个packs给它返回回去了

776
00:27:40,566 --> 00:27:41,466
就是那个地方

777
00:27:42,766 --> 00:27:46,399
这就是它的整个的这个算法

778
00:27:46,400 --> 00:27:47,766
那这个部分来说

779
00:27:47,766 --> 00:27:48,733
我们可以看到

780
00:27:50,566 --> 00:27:52,533
把这个部分给它抽出来

781
00:27:53,200 --> 00:27:55,866
把Agreean怎么打包的方式把它抽出来

782
00:27:56,200 --> 00:27:58,400
然后通过一个抽象的接口

783
00:27:58,400 --> 00:28:00,966
里头有两种不同的实现的方式

784
00:28:01,066 --> 00:28:03,699
而这个逻辑是写在这个负类中间的

785
00:28:03,766 --> 00:28:05,966
子类中间是没有去做实现的

786
00:28:05,966 --> 00:28:07,566
我们就达成了另外一个效果

787
00:28:07,566 --> 00:28:08,733
这个效果是什么呢

788
00:28:08,933 --> 00:28:10,066
我们在Max的

789
00:28:10,066 --> 00:28:11,499
就是在上限的里头

790
00:28:11,500 --> 00:28:14,000
其实可以用这个算法来打包

791
00:28:14,000 --> 00:28:16,766
也可以用这个算法来打包对吧

792
00:28:16,800 --> 00:28:18,366
因为他调的是他的方法

793
00:28:18,366 --> 00:28:20,366
所以关键就是看你给他的是他呢

794
00:28:20,400 --> 00:28:21,566
还是他其实

795
00:28:21,566 --> 00:28:24,366
他就能够用两种不同的方法来打包

796
00:28:24,600 --> 00:28:26,733
那如果是这个方法的话呢

797
00:28:26,933 --> 00:28:29,599
我们其实也可以用他来打包

798
00:28:29,766 --> 00:28:33,199
也可以用他来打包对吧

799
00:28:33,400 --> 00:28:35,400
所以我们不看这两个被盖掉的

800
00:28:35,400 --> 00:28:36,266
这个方法啊

801
00:28:36,266 --> 00:28:36,999
因为这两个方法

802
00:28:37,000 --> 00:28:38,966
把这个devide给它盖掉了

803
00:28:38,966 --> 00:28:40,166
所以我们刚才看到那张图

804
00:28:40,166 --> 00:28:41,366
其实在这两张两个里头

805
00:28:41,366 --> 00:28:42,299
是完全不一样的

806
00:28:43,133 --> 00:28:43,799
没有盖掉

807
00:28:43,800 --> 00:28:44,466
这个Dys的

808
00:28:44,466 --> 00:28:47,466
这两个指类和这边之间

809
00:28:47,533 --> 00:28:49,199
就形成了一个组合关系

810
00:28:50,100 --> 00:28:52,733
也就是我们在用这样的一个设计

811
00:28:52,733 --> 00:28:53,766
我们可以打出

812
00:28:53,766 --> 00:28:56,166
做出四种不同的结果出来

813
00:28:56,400 --> 00:28:58,500
就是当上限的时候简单打包

814
00:28:58,500 --> 00:29:00,000
上限的时候用背包算法打包

815
00:29:00,200 --> 00:29:01,866
平均数的时候用简单打包

816
00:29:01,866 --> 00:29:06,099
平均数的时候用这个背包怎么打包

817
00:29:06,100 --> 00:29:07,766
就会打出四种不同的结果来

818
00:29:07,766 --> 00:29:08,866
就关键就是看说

819
00:29:08,866 --> 00:29:10,366
你两边的这个底牌的数学体

820
00:29:10,366 --> 00:29:13,099
到底是给一个什么样的子类啊

821
00:29:13,100 --> 00:29:14,366
给的是什么样的子类

822
00:29:14,800 --> 00:29:17,733
这个就是我们说的调节器的设计模式

823
00:29:18,800 --> 00:29:19,966
啊调节性的设计模式

824
00:29:19,966 --> 00:29:21,366
就是本来这是一个问题

825
00:29:21,366 --> 00:29:24,333
这都是分包的问题对吧

826
00:29:24,333 --> 00:29:25,599
但是我把分包的问题里头

827
00:29:25,600 --> 00:29:27,400
把它拆成了两半

828
00:29:27,933 --> 00:29:30,299
一半呢是分包的标准

829
00:29:30,900 --> 00:29:34,200
一半呢是在这个标准底下怎么分法

830
00:29:34,766 --> 00:29:37,533
然后这个分8的标准和怎么分法

831
00:29:37,700 --> 00:29:39,566
就能形成一个排列组合

832
00:29:39,800 --> 00:29:40,766
变成在每一个

833
00:29:40,766 --> 00:29:42,399
标准底下都可以有两种

834
00:29:42,400 --> 00:29:43,900
或者三种不同的分法

835
00:29:44,366 --> 00:29:45,699
对吧如果我这边的这个算法

836
00:29:45,700 --> 00:29:47,066
在不断的改进的话

837
00:29:47,300 --> 00:29:49,500
其实这个组合的数就会变得越来越多

838
00:29:50,133 --> 00:29:52,966
那这个调节器的设计模式

839
00:29:52,966 --> 00:29:55,466
为什么能够达成这样的一个效果

840
00:29:55,666 --> 00:29:56,366
这个效果就是

841
00:29:56,366 --> 00:29:59,466
当我这边有新的分包的标准的时候

842
00:30:00,200 --> 00:30:02,866
所有的现有的这些分包的算法

843
00:30:02,866 --> 00:30:05,099
都能跟新的标准去融合到一起去

844
00:30:05,900 --> 00:30:07,866
当我这边有新的分包的算法的时候

845
00:30:07,866 --> 00:30:10,299
所有的这些分包的标准

846
00:30:10,300 --> 00:30:10,766
用的跟我

847
00:30:10,766 --> 00:30:13,466
跟新的这个分包的算法合到一起去

848
00:30:13,733 --> 00:30:15,366
为什么能达成这样的一个效果

849
00:30:16,500 --> 00:30:17,400
我反过来问啊

850
00:30:17,400 --> 00:30:19,100
先把这个设计模式跟大家讲了

851
00:30:19,100 --> 00:30:21,266
那我们其实在设计设计模式

852
00:30:21,266 --> 00:30:21,966
都要搞清楚

853
00:30:21,966 --> 00:30:23,199
为什么这个设计模式

854
00:30:23,566 --> 00:30:24,999
能够达成这样的一个效果

855
00:30:31,066 --> 00:30:31,999
为啥这个设计模式

856
00:30:32,000 --> 00:30:33,300
为什么能达成这样的效果

857
00:30:37,600 --> 00:30:41,400
能达成的原因就是用了guapsup的多肽

858
00:30:41,600 --> 00:30:42,733
这个应该很明显吧

859
00:30:42,733 --> 00:30:45,299
是吧那单纯使用guapsup的多肽

860
00:30:45,300 --> 00:30:47,200
是肯定达不成这样的一个效果的

861
00:30:47,300 --> 00:30:49,566
是因为这两边的这个guapsup的多肽

862
00:30:49,566 --> 00:30:52,666
都满足Disco不可替换原则

863
00:30:53,366 --> 00:30:56,566
所以当这个替换他的时候

864
00:30:56,566 --> 00:30:58,166
或者他替换他的时候

865
00:30:58,466 --> 00:31:00,099
他不改变负累的行为

866
00:31:00,800 --> 00:31:02,200
这边替换他的时候

867
00:31:02,200 --> 00:31:03,733
也不改变负累的行为

868
00:31:03,966 --> 00:31:06,266
所以这两个组合就变成了可以组合的

869
00:31:07,066 --> 00:31:10,066
所以调节器的模式为什么能起作用

870
00:31:10,533 --> 00:31:13,099
前提就是用了多肽

871
00:31:13,366 --> 00:31:15,533
而且在多肽上面

872
00:31:15,533 --> 00:31:17,999
满足历史口服可替换原则

873
00:31:18,400 --> 00:31:21,166
那它就是可以变成调节器的

874
00:31:21,900 --> 00:31:26,500
而且调节器是一个更细致的什么呢

875
00:31:26,500 --> 00:31:27,566
开闭原则

876
00:31:27,600 --> 00:31:29,466
我们原来说策略模式的开闭原则

877
00:31:29,466 --> 00:31:30,499
是你只能改那个

878
00:31:30,500 --> 00:31:32,400
策略增加一个新的策略

879
00:31:32,600 --> 00:31:35,000
或者增加修改现有的策略

880
00:31:35,333 --> 00:31:36,899
调节器就把这个策略

881
00:31:36,933 --> 00:31:38,199
我们现在是两两敲啊

882
00:31:38,200 --> 00:31:40,066
就把这个策略一劈两半了

883
00:31:41,466 --> 00:31:42,599
变成了四个部分

884
00:31:42,600 --> 00:31:44,333
比如现在看到的就是四个部分

885
00:31:44,566 --> 00:31:45,199
这四个部分

886
00:31:45,200 --> 00:31:47,100
可以去改任何的一个小部分

887
00:31:47,100 --> 00:31:49,000
就变成了一种新的结果

888
00:31:49,266 --> 00:31:50,099
所以你可以看到

889
00:31:50,100 --> 00:31:52,733
调节器把问题切成了两个部分

890
00:31:53,200 --> 00:31:55,800
使得这两个部分都满足历史

891
00:31:55,800 --> 00:31:56,966
可复可替换原则

892
00:31:57,133 --> 00:31:59,599
那你可以去细分的部分

893
00:31:59,600 --> 00:32:01,133
或者可以去变化的部分

894
00:32:01,133 --> 00:32:02,533
就变得更小了

895
00:32:02,800 --> 00:32:04,200
变得更细微了啊

896
00:32:04,300 --> 00:32:05,066
那这样的话呢

897
00:32:05,066 --> 00:32:05,699
就会使得说

898
00:32:05,700 --> 00:32:07,700
你可以用更小的改变

899
00:32:07,700 --> 00:32:09,366
去做出一个更大的

900
00:32:10,333 --> 00:32:11,933
更大的结果出来啊

901
00:32:11,933 --> 00:32:13,466
这就是调节器的作用

902
00:32:13,733 --> 00:32:16,266
调节器在下学期还是会讲的啊

903
00:32:16,266 --> 00:32:18,099
会下局会讲的时候会告诉大家

904
00:32:18,600 --> 00:32:20,266
调节器目前看到的调节器

905
00:32:20,266 --> 00:32:21,766
是最简单的两两调

906
00:32:22,200 --> 00:32:23,600
可以3个调到1起

907
00:32:23,600 --> 00:32:24,700
可以4个调到1起

908
00:32:24,700 --> 00:32:25,566
n个调到1起

909
00:32:25,800 --> 00:32:27,700
那这个调节器可以变化的范围

910
00:32:27,700 --> 00:32:29,166
就会变得更多了

911
00:32:29,300 --> 00:32:30,900
那至于怎么样把3个调到1起

912
00:32:30,900 --> 00:32:31,966
或者把n个调到1起

913
00:32:31,966 --> 00:32:33,366
那我们留到下集去讲

914
00:32:33,500 --> 00:32:36,133
我们这集去看到的就是最简单的

915
00:32:36,700 --> 00:32:37,600
一切为二

916
00:32:38,100 --> 00:32:41,266
两个调到一起的这样一个效果

917
00:32:41,866 --> 00:32:43,099
所以我们在这个设计中间

918
00:32:43,933 --> 00:32:46,699
我们把分包的这个问题

919
00:32:46,700 --> 00:32:48,166
把它一切了两半

920
00:32:48,500 --> 00:32:49,566
一半是什么呢

921
00:32:49,566 --> 00:32:51,366
一半是分包的标准

922
00:32:52,200 --> 00:32:53,700
按照最高的上限分

923
00:32:53,700 --> 00:32:55,400
还是按照平均的数量分

924
00:32:55,866 --> 00:32:56,933
另外一半是什么呢

925
00:32:56,933 --> 00:32:58,799
另外一半是在这个标准底下

926
00:32:58,800 --> 00:33:01,133
他到底把商品按照一个什么样的方式

927
00:33:01,566 --> 00:33:03,333
装到这个包裹里去

928
00:33:03,366 --> 00:33:04,333
所以在这个标准底下

929
00:33:04,333 --> 00:33:05,566
到底是装出3个包裹

930
00:33:05,566 --> 00:33:06,133
还是装出两

931
00:33:06,133 --> 00:33:09,199
个包裹跟这个是有关系的

932
00:33:09,466 --> 00:33:11,133
跟你用什么算法是有关系的

933
00:33:11,733 --> 00:33:13,466
这样的话就能组合起来啊

934
00:33:13,466 --> 00:33:15,266
形成我们最后的这个结果

935
00:33:15,800 --> 00:33:17,466
那最后讲一下这两个

936
00:33:18,533 --> 00:33:21,933
这两个因为把debate的方法给它盖掉了

937
00:33:22,133 --> 00:33:26,566
一个是贪心的这个算法

938
00:33:26,900 --> 00:33:33,500
一个是这个呃最优费的这个算法

939
00:33:33,600 --> 00:33:35,200
那贪心的这个算法

940
00:33:35,200 --> 00:33:37,066
我们可以看一下他的这个代码

941
00:33:37,800 --> 00:33:40,266
我们先从这个贪心的这个算法开始看

942
00:33:40,266 --> 00:33:41,166
这个代码啊

943
00:33:45,866 --> 00:33:47,733
我们从这个最底下开始看代码

944
00:33:47,733 --> 00:33:50,133
就正常我们是从上面往下

945
00:33:50,400 --> 00:33:52,000
从前头往后看代码

946
00:33:52,466 --> 00:33:54,099
那我们今天就把它反过来

947
00:33:54,100 --> 00:33:54,866
从最底下

948
00:33:54,866 --> 00:33:56,166
就是因为讲到这个最底下了

949
00:33:56,166 --> 00:33:57,166
我们从最底下看代码

950
00:33:57,166 --> 00:33:58,466
再再一直往回讲

951
00:34:03,166 --> 00:34:05,166
我们这一批代码都在哪呢

952
00:34:05,166 --> 00:34:07,299
都是在Bo对象里头

953
00:34:07,800 --> 00:34:11,000
都是在这个Bo对象里头的这个

954
00:34:17,000 --> 00:34:18,166
divide里头啊

955
00:34:18,166 --> 00:34:20,133
就是我们说的这些绿色的对象

956
00:34:20,366 --> 00:34:21,666
所以我们首先看

957
00:34:21,766 --> 00:34:24,666
在设计图中间的那个divide strategy啊

958
00:34:25,566 --> 00:34:27,533
这个对象里头我们有写了什么呢

959
00:34:27,533 --> 00:34:30,666
有写了这个device的方法

960
00:34:30,666 --> 00:34:32,399
device就是我们在图上说的那个方法

961
00:34:32,400 --> 00:34:35,000
就是在复类中间所写的这个方法

962
00:34:35,500 --> 00:34:36,933
这个方法中间我们可以看到

963
00:34:36,933 --> 00:34:39,199
我们第一步就是

964
00:34:39,200 --> 00:34:41,266
我们要知道总量是多少

965
00:34:41,733 --> 00:34:43,299
这个总量是多少呢

966
00:34:43,300 --> 00:34:47,866
我们是根据这个region template的gottap

967
00:34:48,500 --> 00:34:49,500
它的类型

968
00:34:49,500 --> 00:34:52,466
然后去得到这个对象的

969
00:34:52,533 --> 00:34:53,766
所以第一啊

970
00:34:53,766 --> 00:34:54,999
这里违背了什么原则

971
00:34:57,666 --> 00:34:58,766
这里违背了什么原则

972
00:35:00,700 --> 00:35:01,366
我刚才说过

973
00:35:01,366 --> 00:35:03,266
这里违背了我们的一个软件设计原则

974
00:35:03,266 --> 00:35:04,333
这里违背了什么原则

975
00:35:08,466 --> 00:35:09,299
能看出来吗

976
00:35:09,533 --> 00:35:10,533
这个很简单

977
00:35:10,733 --> 00:35:12,766
迪米特不跟陌生人说话

978
00:35:12,966 --> 00:35:14,266
都点了两回了

979
00:35:15,200 --> 00:35:15,766
对吧

980
00:35:15,766 --> 00:35:17,933
所以这里是违背了迪米特原则的啊

981
00:35:17,933 --> 00:35:19,399
不跟陌生人说话

982
00:35:19,666 --> 00:35:20,299
所以

983
00:35:20,300 --> 00:35:22,400
这样的一个违背了迪米特原则的话

984
00:35:22,400 --> 00:35:23,500
就会使得说

985
00:35:23,500 --> 00:35:25,700
当我的correct total发生改变的时候

986
00:35:25,700 --> 00:35:29,466
会影响到我现在的这个divide strategy

987
00:35:29,466 --> 00:35:31,566
其实correct total那个事情

988
00:35:31,566 --> 00:35:33,533
是在temperate的type里头

989
00:35:33,533 --> 00:35:34,333
而不是在

990
00:35:35,700 --> 00:35:37,533
我的这个对象的直接关联里头

991
00:35:37,533 --> 00:35:38,599
我是通过Timeplay的

992
00:35:38,600 --> 00:35:40,566
跟着type才调到他的copilot TOTO

993
00:35:40,700 --> 00:35:42,166
但如果copilot TOTO发生改变的话

994
00:35:42,166 --> 00:35:43,133
就会跳过了

995
00:35:43,133 --> 00:35:44,966
直接会影响到我现在这个代码

996
00:35:45,300 --> 00:35:49,300
这就是因为我们违背了迪米特原则

997
00:35:49,300 --> 00:35:50,500
就会造成这个结果

998
00:35:51,066 --> 00:35:53,466
那会不会有危害呢

999
00:35:53,766 --> 00:35:54,933
就违背了迪米特原则

1000
00:35:54,933 --> 00:35:55,899
会不会有危害呢

1001
00:35:55,966 --> 00:35:58,199
就看你的Cory total会不会改变

1002
00:35:59,666 --> 00:36:00,866
Cory total会改变吗

1003
00:36:02,966 --> 00:36:04,933
我们的判断是它不会改变

1004
00:36:05,066 --> 00:36:07,099
因为它真的就只有一行代码

1005
00:36:07,700 --> 00:36:09,966
就是把它加起来太简单了

1006
00:36:10,200 --> 00:36:12,133
所以正是因为我们判断说

1007
00:36:12,133 --> 00:36:14,566
这个copper total是不会改变的

1008
00:36:14,733 --> 00:36:16,566
这是不大可能会发生变化的

1009
00:36:17,066 --> 00:36:17,733
那所以说

1010
00:36:17,733 --> 00:36:20,133
我们就直接在这里懒得去

1011
00:36:20,166 --> 00:36:23,466
去遵循这个迪米特原则了

1012
00:36:23,566 --> 00:36:25,066
就直接跟陌生人说话了啊

1013
00:36:25,066 --> 00:36:28,399
所以为什么这里会违背迪米特原则

1014
00:36:28,400 --> 00:36:30,366
就是因为我们的判断是开口的

1015
00:36:30,366 --> 00:36:31,933
total是不会发生改变的

1016
00:36:31,933 --> 00:36:32,866
就不会产生

1017
00:36:32,866 --> 00:36:36,666
说影响到不跟他直接关联的对象

1018
00:36:36,800 --> 00:36:38,266
因为迪米特原则啊

1019
00:36:38,266 --> 00:36:40,933
造成了他的这个影响啊

1020
00:36:40,933 --> 00:36:42,366
那这个方法是怎么做的啊

1021
00:36:42,366 --> 00:36:43,666
大家可以一步步看过去

1022
00:36:43,666 --> 00:36:45,066
我们的template的勾

1023
00:36:46,066 --> 00:36:47,533
这个其实我要改一下啊

1024
00:36:47,766 --> 00:36:50,366
它的这个gate template就是god template

1025
00:36:50,400 --> 00:36:50,733
其实

1026
00:36:50,733 --> 00:36:53,699
它是调的他自己的另外一个属性的

1027
00:36:53,700 --> 00:36:54,600
god template

1028
00:36:55,366 --> 00:36:58,266
这个呢其实也是一个射击模式

1029
00:36:58,266 --> 00:37:00,466
但这个射击模式我们用的太简单了

1030
00:37:00,466 --> 00:37:02,399
所以我就没说这个射击模式叫什么呢

1031
00:37:02,866 --> 00:37:03,666
叫做

1032
00:37:04,966 --> 00:37:05,766
proxy

1033
00:37:09,266 --> 00:37:10,966
叫做代理设计模式啊

1034
00:37:10,966 --> 00:37:12,766
就实际上大家可以看到

1035
00:37:13,400 --> 00:37:14,500
在template

1036
00:37:14,500 --> 00:37:15,666
在reaching template中间

1037
00:37:15,666 --> 00:37:18,266
其实是没有给它type这个东西的

1038
00:37:18,266 --> 00:37:20,133
它自己并没有type对吧

1039
00:37:20,133 --> 00:37:20,966
它的type是什么呢

1040
00:37:20,966 --> 00:37:24,299
它的type是来自于它的模板的type

1041
00:37:24,300 --> 00:37:25,566
我们并没有把这个type

1042
00:37:25,566 --> 00:37:27,099
写在了每一个地区模板里头

1043
00:37:27,100 --> 00:37:28,400
因为在一个模板中间

1044
00:37:28,400 --> 00:37:30,166
所有的地区都是同一个类型

1045
00:37:30,666 --> 00:37:34,266
那我们去调这个get type的时候

1046
00:37:34,266 --> 00:37:35,566
他其实自己并没有type

1047
00:37:35,666 --> 00:37:36,333
他怎么办呢

1048
00:37:36,333 --> 00:37:38,999
他就去调他自己的tablet get type

1049
00:37:39,133 --> 00:37:40,933
所以他只要代理了

1050
00:37:40,933 --> 00:37:41,733
过了一手

1051
00:37:42,500 --> 00:37:43,500
实际上是过了一手

1052
00:37:43,500 --> 00:37:46,700
就是通过了这个呃type的

1053
00:37:46,700 --> 00:37:47,800
去拿到他的get type

1054
00:37:47,800 --> 00:37:49,900
然后把它装作是自己的type

1055
00:37:50,100 --> 00:37:51,533
实际他自己没type啊

1056
00:37:51,566 --> 00:37:52,999
因为他自己没必要去type

1057
00:37:53,000 --> 00:37:55,000
因为所有的模板底下都是一个类型的

1058
00:37:55,366 --> 00:37:56,766
所以这里其实用了一个代理模式

1059
00:37:56,766 --> 00:37:58,566
但是这个代理模式呢

1060
00:37:58,566 --> 00:37:59,566
就用的太

1061
00:37:59,866 --> 00:38:01,099
怎么说太小了

1062
00:38:01,100 --> 00:38:03,700
所以我们就没有把它单独提出来来讲

1063
00:38:05,066 --> 00:38:06,899
他的这个get the template啊

1064
00:38:06,900 --> 00:38:07,400
大家应该知道

1065
00:38:07,400 --> 00:38:08,500
他会去查数据库

1066
00:38:08,966 --> 00:38:09,399
所以说

1067
00:38:09,400 --> 00:38:11,266
他会根据自己的这个template的ID

1068
00:38:12,966 --> 00:38:15,199
去在数据库里把它找出来

1069
00:38:15,266 --> 00:38:16,999
然后去find by ID

1070
00:38:17,500 --> 00:38:19,266
或者在缓存里把它找出来啊

1071
00:38:19,266 --> 00:38:20,866
去find by ID把它找出来

1072
00:38:20,866 --> 00:38:22,199
然后得到这个template

1073
00:38:22,333 --> 00:38:23,866
那如果得到这个template以后

1074
00:38:23,866 --> 00:38:26,199
他就会知道这个template的高高type了

1075
00:38:27,766 --> 00:38:28,599
就这个方法

1076
00:38:29,200 --> 00:38:29,933
这个高type

1077
00:38:29,933 --> 00:38:30,666
大家可以看到

1078
00:38:30,666 --> 00:38:31,599
我们的做法是

1079
00:38:31,600 --> 00:38:32,500
因为我们在数据库里

1080
00:38:32,500 --> 00:38:33,733
是没有去记这个type的

1081
00:38:33,733 --> 00:38:35,266
我们数据库里记了一个什么值呢

1082
00:38:35,733 --> 00:38:36,166
记了一个

1083
00:38:36,166 --> 00:38:37,199
这个是郡值

1084
00:38:37,200 --> 00:38:37,966
而这个是郡值

1085
00:38:37,966 --> 00:38:39,999
其实就是他或者他

1086
00:38:40,000 --> 00:38:41,300
我们之前也用到这个值了

1087
00:38:41,300 --> 00:38:43,133
因为用这个值就可以找到他的兵对象

1088
00:38:43,133 --> 00:38:44,499
是吧所以我们记了这个值

1089
00:38:44,600 --> 00:38:46,400
但是我们现在不是要这个制服串

1090
00:38:46,400 --> 00:38:47,300
我们要的是什么呢

1091
00:38:47,300 --> 00:38:48,500
我们要的是一个对象

1092
00:38:48,966 --> 00:38:51,466
也就是我们的piece对象和这个wet对象

1093
00:38:51,700 --> 00:38:52,566
所以我们可以看到

1094
00:38:52,566 --> 00:38:53,166
跟着tap里头

1095
00:38:53,166 --> 00:38:54,399
我们会用的一个map

1096
00:38:54,400 --> 00:38:55,600
来做了这样的一个支付

1097
00:38:55,600 --> 00:38:57,066
串和对象的转换

1098
00:38:57,366 --> 00:38:58,733
这是写到了这个

1099
00:38:59,200 --> 00:39:02,166
写到了这个tap it的这个方法里头

1100
00:39:02,533 --> 00:39:02,899
所以

1101
00:39:02,900 --> 00:39:06,366
当我们去调它的这个got template的时候

1102
00:39:06,733 --> 00:39:08,133
got got这个type的时候

1103
00:39:08,133 --> 00:39:09,133
这个方法的时候

1104
00:39:09,733 --> 00:39:10,933
那调到这个方法的时候

1105
00:39:10,933 --> 00:39:13,366
其实我们是调了这个map的

1106
00:39:13,366 --> 00:39:15,199
这个get的方法

1107
00:39:15,200 --> 00:39:16,900
然后用它自己的这个属性

1108
00:39:16,900 --> 00:39:18,700
去获得它这个type

1109
00:39:18,800 --> 00:39:21,266
获得这个type的目的是为了什么呢

1110
00:39:22,133 --> 00:39:22,933
获得这个

1111
00:39:28,866 --> 00:39:30,099
我们看word对象啊

1112
00:39:30,100 --> 00:39:32,300
我们这个word对象其实是继承了

1113
00:39:33,266 --> 00:39:37,133
继承了他继承了我们所说的这个type

1114
00:39:37,133 --> 00:39:37,899
type对象

1115
00:39:37,900 --> 00:39:40,166
这个里头就有我们说的current total

1116
00:39:40,166 --> 00:39:41,933
我们其实是把职责付给了他

1117
00:39:42,500 --> 00:39:44,066
那在他里头大家可以看到

1118
00:39:44,066 --> 00:39:47,199
我们是用了一个牛鞭层的方式啊

1119
00:39:47,200 --> 00:39:48,200
其实就是把

1120
00:39:49,700 --> 00:39:50,866
每一个东西

1121
00:39:51,100 --> 00:39:53,700
它的count重量就是重量

1122
00:39:55,000 --> 00:39:58,133
件数则是一乘上它的数量

1123
00:39:58,533 --> 00:39:59,799
然后后面这个reduce

1124
00:39:59,800 --> 00:40:01,200
其实是作为一个累加

1125
00:40:01,566 --> 00:40:03,466
就是我们用流变层的方式来做累加

1126
00:40:03,466 --> 00:40:05,899
而不是用循环的方式加加来过来

1127
00:40:05,933 --> 00:40:08,133
所以reduce其实是做循环做累加

1128
00:40:08,133 --> 00:40:11,299
就是前一个元素前一面的返回值

1129
00:40:11,900 --> 00:40:13,733
和当前的这个返回值

1130
00:40:13,800 --> 00:40:14,733
把它加起来

1131
00:40:14,733 --> 00:40:16,999
作为后一个的返回值啊

1132
00:40:17,000 --> 00:40:18,800
所以这个reduce的reduce函数的作用

1133
00:40:18,800 --> 00:40:19,933
就是做了一个累加

1134
00:40:20,200 --> 00:40:21,666
然后最后把它get出来

1135
00:40:21,666 --> 00:40:23,099
这个其实就最后就算出来说

1136
00:40:23,100 --> 00:40:24,100
整个流里头

1137
00:40:24,100 --> 00:40:27,133
整个历史里头所有的元素

1138
00:40:27,133 --> 00:40:29,733
最后算出来的累加值是多少

1139
00:40:30,133 --> 00:40:31,299
这个大家要熟悉啊

1140
00:40:31,300 --> 00:40:31,933
因为我们这里

1141
00:40:31,933 --> 00:40:34,066
大量都使用了这种流变层的方式

1142
00:40:34,066 --> 00:40:34,966
去解决问题

1143
00:40:35,366 --> 00:40:36,599
会使得代码变得

1144
00:40:37,000 --> 00:40:38,966
其实不是为了代码变得更加的简单

1145
00:40:38,966 --> 00:40:39,933
而是这是代表了

1146
00:40:39,933 --> 00:40:41,866
我们未来的一种编程的方式

1147
00:40:41,866 --> 00:40:44,099
就是我们大家知道在未来的

1148
00:40:44,333 --> 00:40:45,733
在目前的发展趋势来说

1149
00:40:45,733 --> 00:40:49,599
函数编程会在小到局部啊

1150
00:40:49,600 --> 00:40:50,900
大到整个整体

1151
00:40:50,900 --> 00:40:52,166
比如说我们整个食品的话

1152
00:40:52,166 --> 00:40:53,933
里面其实有一整套函数式变成

1153
00:40:53,933 --> 00:40:55,399
流变成的这个方案的

1154
00:40:55,666 --> 00:40:58,733
都会改由这个流变成的方式去完成

1155
00:40:59,266 --> 00:41:00,166
那这里我们其实

1156
00:41:00,333 --> 00:41:00,566
因为

1157
00:41:00,566 --> 00:41:02,966
我们现在整体还是命令式编程的框架

1158
00:41:03,133 --> 00:41:04,466
所以我们只是在局部

1159
00:41:04,466 --> 00:41:05,333
在大量的

1160
00:41:05,333 --> 00:41:07,466
采用这个流编程的方式去完成

1161
00:41:07,933 --> 00:41:08,566
那这个get

1162
00:41:08,566 --> 00:41:11,699
con则是在它的指内中间去实现的

1163
00:41:11,700 --> 00:41:13,266
所以它有两个音频的门推行

1164
00:41:13,466 --> 00:41:15,333
我们可以看到它返回的类型呢

1165
00:41:15,333 --> 00:41:18,066
其实是piece或者way

1166
00:41:18,200 --> 00:41:20,400
那piece里头大家可以看到就是11%

1167
00:41:21,166 --> 00:41:22,133
而在

1168
00:41:25,366 --> 00:41:26,299
wait里头呢

1169
00:41:26,300 --> 00:41:27,766
返回的则是他的重量

1170
00:41:33,100 --> 00:41:35,733
那wait里的返回只是它的重量啊

1171
00:41:35,733 --> 00:41:37,266
所以这个就是

1172
00:41:37,266 --> 00:41:40,566
我们用了一个模板方法的设计

1173
00:41:40,566 --> 00:41:42,399
模式在device

1174
00:41:42,400 --> 00:41:44,266
16指中间得到了它的

1175
00:41:46,166 --> 00:41:48,966
这个concrete total对吧

1176
00:41:50,100 --> 00:41:50,966
很简单一句话

1177
00:41:50,966 --> 00:41:52,266
违背了demiter原则

1178
00:41:52,366 --> 00:41:52,733
然后

1179
00:41:52,733 --> 00:41:56,066
那边用了这个模板方法的设计模式

1180
00:41:56,100 --> 00:41:59,666
去算出来它在重量模板上头

1181
00:41:59,666 --> 00:42:01,166
或者是在键数模板上头

1182
00:42:01,166 --> 00:42:03,799
他的这个total到底是一个什么样的值

1183
00:42:03,800 --> 00:42:05,700
所以这个值在这来说可能是重量

1184
00:42:05,700 --> 00:42:07,900
也可能是是键数啊

1185
00:42:07,900 --> 00:42:09,666
我我我并不管他

1186
00:42:10,266 --> 00:42:11,199
然后下面的声音就是

1187
00:42:11,200 --> 00:42:11,733
这个total

1188
00:42:11,733 --> 00:42:13,766
跟我们这模板中间所记的这个上限

1189
00:42:13,766 --> 00:42:15,066
是不是超过了

1190
00:42:15,066 --> 00:42:16,399
没超过就正常打包

1191
00:42:16,400 --> 00:42:17,333
所以这就正常打包

1192
00:42:17,333 --> 00:42:18,499
这个没什么好说的

1193
00:42:18,700 --> 00:42:20,400
如果超过的话则需要分包

1194
00:42:20,400 --> 00:42:21,100
所以我们可以看到

1195
00:42:21,100 --> 00:42:23,333
我们再去去调了下他的分包标准

1196
00:42:24,100 --> 00:42:25,400
get package size

1197
00:42:25,566 --> 00:42:27,299
这个get package size的主要目的就是

1198
00:42:27,300 --> 00:42:29,066
它到底按照一个什么标准来分包

1199
00:42:29,066 --> 00:42:30,799
我们底下的两个Max

1200
00:42:32,733 --> 00:42:33,333
我们可以看一下

1201
00:42:33,333 --> 00:42:34,566
这是一个抽象的方法

1202
00:42:34,666 --> 00:42:35,966
所以它是填了个空啊

1203
00:42:35,966 --> 00:42:37,299
这就是典型的模板方法

1204
00:42:37,300 --> 00:42:38,366
在这里填了个空

1205
00:42:38,666 --> 00:42:40,766
它到底是怎么值并不知道

1206
00:42:41,000 --> 00:42:43,700
而是由它的值类去把这个空去完成

1207
00:42:43,966 --> 00:42:45,166
这里有4个实现

1208
00:42:45,166 --> 00:42:46,133
因为它另外两个值类

1209
00:42:46,133 --> 00:42:47,499
其实也是实现了这个方法

1210
00:42:47,500 --> 00:42:48,500
因为必须要实现这个方法

1211
00:42:48,500 --> 00:42:49,733
但是它其实没有意义

1212
00:42:50,133 --> 00:42:50,599
我们可以看到

1213
00:42:50,600 --> 00:42:52,500
iverage中间就是算的均值

1214
00:42:53,533 --> 00:42:55,066
自然代码就是算的是均值

1215
00:42:55,200 --> 00:42:56,133
而Max的话

1216
00:42:56,133 --> 00:42:58,166
就直接把后面这个值返回回去了

1217
00:43:02,266 --> 00:43:03,866
MAS的话

1218
00:43:03,866 --> 00:43:07,266
就直接把这个up limit给他返回去了啊

1219
00:43:07,266 --> 00:43:09,866
所以底下的两个子类

1220
00:43:09,866 --> 00:43:12,166
会在这个god package size这个地方

1221
00:43:12,166 --> 00:43:14,266
给出不同的package size

1222
00:43:14,700 --> 00:43:15,100
然后

1223
00:43:15,100 --> 00:43:17,300
我们就按照他给出的这个package size来

1224
00:43:17,300 --> 00:43:18,566
进行分包

1225
00:43:18,766 --> 00:43:20,133
那这个就是我们的前处理

1226
00:43:20,133 --> 00:43:24,299
首先把这个product中间数量是大于2的

1227
00:43:24,300 --> 00:43:26,066
给它拆成不同的东西啊

1228
00:43:26,066 --> 00:43:27,366
所以就变成single item

1229
00:43:27,866 --> 00:43:31,799
然后呢汇去掉agorism的pack的方法

1230
00:43:32,933 --> 00:43:34,799
去把这个single item给他

1231
00:43:34,800 --> 00:43:38,066
打成我们所要的第一个包裹

1232
00:43:38,066 --> 00:43:39,466
这只是返回第一个包裹

1233
00:43:39,566 --> 00:43:40,733
这个方法做完以后

1234
00:43:40,733 --> 00:43:43,133
这些打成包裹的这些商品

1235
00:43:43,133 --> 00:43:44,799
会从single中间给他删除掉

1236
00:43:45,166 --> 00:43:46,666
然后变成第一个包裹

1237
00:43:46,666 --> 00:43:47,999
所以我们这里在不断循环

1238
00:43:48,000 --> 00:43:49,200
去看他的这个Pad

1239
00:43:49,400 --> 00:43:50,733
剩下的值是不是大于0

1240
00:43:50,733 --> 00:43:51,499
如果大于0的话

1241
00:43:51,500 --> 00:43:52,300
再继续打

1242
00:43:52,700 --> 00:43:53,966
一直打到他为0位置

1243
00:43:53,966 --> 00:43:55,866
就所有东西都分到不同包裹中间

1244
00:43:55,933 --> 00:43:57,966
这些pack都会加到那个package side

1245
00:43:57,966 --> 00:43:58,799
pack side中间

1246
00:43:58,800 --> 00:44:01,866
然后最后再把它合起来

1247
00:44:02,000 --> 00:44:03,866
因为当你合到了PAX

1248
00:44:03,933 --> 00:44:05,899
再使到了这个PAX里头

1249
00:44:06,166 --> 00:44:07,666
它都是single的item

1250
00:44:07,666 --> 00:44:08,966
那如果说在一个报告中间

1251
00:44:08,966 --> 00:44:10,466
同样上面有4件5件的话

1252
00:44:10,466 --> 00:44:12,299
我们这个方法就后面这个方法

1253
00:44:12,300 --> 00:44:13,266
又把它合起来

1254
00:44:13,266 --> 00:44:15,366
合成了就是它的数量是3

1255
00:44:15,366 --> 00:44:17,766
或者数量是4这样的一个东西啊

1256
00:44:17,766 --> 00:44:18,799
给它返回回去

1257
00:44:18,900 --> 00:44:19,966
好我们先休息一会

1258
00:56:56,700 --> 00:56:58,566
这一半它是按照简单上法把它打出来

1259
00:56:58,566 --> 00:56:59,799
它是按照背包上法把它打出来的

1260
00:56:59,800 --> 00:57:01,300
其实在我们这一部分里头

1261
00:57:01,300 --> 00:57:02,333
是看不出来的

1262
00:57:02,400 --> 00:57:03,800
因为满足历史客户可替换原则

1263
00:57:03,800 --> 00:57:05,500
可以任意的替换啊

1264
00:57:05,500 --> 00:57:06,066
所以这样的话

1265
00:57:06,066 --> 00:57:08,899
就形成了我们这边底下还有两个子类

1266
00:57:08,900 --> 00:57:10,133
那边还有两个子类

1267
00:57:10,133 --> 00:57:12,533
两个可以最后巧起来

1268
00:57:12,533 --> 00:57:13,399
变成了这个东西

1269
00:57:13,400 --> 00:57:15,166
因为我们现在看到的这个迪拜的方法

1270
00:57:15,166 --> 00:57:16,733
是会被子类继承的

1271
00:57:16,866 --> 00:57:18,499
而子类继承所改

1272
00:57:18,500 --> 00:57:19,133
变的行为

1273
00:57:19,133 --> 00:57:20,199
其实就是这个行为

1274
00:57:20,733 --> 00:57:21,799
就是size不同

1275
00:57:21,800 --> 00:57:24,066
所以size不同会给出不同的结果

1276
00:57:24,366 --> 00:57:26,066
会给出他打包的标准不同

1277
00:57:26,066 --> 00:57:26,966
而这边的这个呢

1278
00:57:26,966 --> 00:57:30,133
会使得他最后打包的这个算法不同

1279
00:57:30,166 --> 00:57:31,199
最后组合起来

1280
00:57:31,200 --> 00:57:33,066
形成了我们这样的一个结果

1281
00:57:33,200 --> 00:57:35,100
那最后又把它合到了一起啊

1282
00:57:35,100 --> 00:57:40,466
这就是我们所说的在这张图上头

1283
00:57:47,766 --> 00:57:51,399
我们所说的在这张图上头的这一半

1284
00:57:51,600 --> 00:57:54,300
这两个和这两个

1285
00:57:54,500 --> 00:57:56,700
因为在这两个的类中间

1286
00:57:56,700 --> 00:57:59,100
没有去重载这个depart的方法

1287
00:57:59,300 --> 00:58:00,900
所以他会继承

1288
00:58:00,900 --> 00:58:02,400
在副类中间的这个depart方法

1289
00:58:02,400 --> 00:58:05,966
去完全符合他的这个行为

1290
00:58:06,000 --> 00:58:07,900
所以满足历史可符可替换原则

1291
00:58:07,933 --> 00:58:09,766
所不同的是他的派级赛制不同

1292
00:58:10,100 --> 00:58:10,600
然后

1293
00:58:10,600 --> 00:58:13,000
会使得这边的这个分包算法的结果

1294
00:58:13,066 --> 00:58:13,866
是不同的

1295
00:58:14,466 --> 00:58:15,533
就是这两个啊

1296
00:58:15,533 --> 00:58:17,399
那我们看一下这两个

1297
00:58:18,866 --> 00:58:19,866
看一下这两个

1298
00:58:20,866 --> 00:58:22,933
这两个就相对比较复杂一点

1299
00:58:22,933 --> 00:58:24,366
我们不去讲它的细节

1300
00:58:24,700 --> 00:58:25,966
那大家可以看到

1301
00:58:25,966 --> 00:58:29,166
在这两个方法中间我们的

1302
00:58:31,066 --> 00:58:31,799
这个方法

1303
00:58:31,800 --> 00:58:33,300
比如说碳芯这个算法

1304
00:58:33,300 --> 00:58:36,166
它是有把Dey的方法去重载了

1305
00:58:37,466 --> 00:58:38,899
而在我们刚才看到的

1306
00:58:38,900 --> 00:58:40,800
那个average size和Max size

1307
00:58:40,800 --> 00:58:41,400
这两个方法中间

1308
00:58:41,400 --> 00:58:43,866
它是没有把迪拜的方法重载的

1309
00:58:44,000 --> 00:58:46,400
那重载了迪拜的方法说明了什么

1310
00:58:46,600 --> 00:58:48,800
那你要看出它重载的过程

1311
00:58:48,800 --> 00:58:50,066
它到底改了什么

1312
00:58:50,533 --> 00:58:51,933
重载的过程中间

1313
00:58:51,933 --> 00:58:54,599
我们可以看到啊

1314
00:58:54,733 --> 00:58:56,733
他改动的是什么呢

1315
00:59:02,166 --> 00:59:03,799
它改动的其实是

1316
00:59:05,333 --> 00:59:06,133
这个部分

1317
00:59:08,800 --> 00:59:09,866
就中间这个部分

1318
00:59:12,766 --> 00:59:14,333
其实其他的他都没有怎么动

1319
00:59:14,700 --> 00:59:17,866
他就是唯一改动了中间的这个部分

1320
00:59:17,933 --> 00:59:21,066
也就是他在打包的过程中间

1321
00:59:21,066 --> 00:59:22,399
他并没有使用

1322
00:59:22,400 --> 00:59:25,666
我们那边的就是在这张图上头的

1323
00:59:30,766 --> 00:59:32,799
这张图上的这半边的算法

1324
00:59:34,133 --> 00:59:35,499
没有使用到橱窗的日本名

1325
00:59:35,500 --> 00:59:36,533
的简单打包算法

1326
00:59:36,533 --> 00:59:38,066
或者说是背包打包算法

1327
00:59:38,166 --> 00:59:39,799
而是他在打包过程中间

1328
00:59:39,800 --> 00:59:43,533
采用了一个贪心打包的方式

1329
00:59:43,600 --> 00:59:45,566
去完成了这个打包过程

1330
00:59:45,900 --> 00:59:47,100
所以大家可以看到

1331
00:59:47,100 --> 00:59:49,066
对于这一个类来说

1332
00:59:49,100 --> 00:59:51,200
他重载了divide的方法

1333
00:59:51,533 --> 00:59:53,399
他改没改这个divide的行为

1334
00:59:54,533 --> 00:59:55,333
改了没有

1335
00:59:55,666 --> 00:59:56,466
你们觉得

1336
00:59:57,800 --> 00:59:59,666
改了改了divide的行为

1337
00:59:59,666 --> 01:00:01,899
他没有按照divide这个行为

1338
01:00:01,900 --> 01:00:03,466
去调这边的这个方法

1339
01:00:03,466 --> 01:00:06,299
来进行这个包裹的分配了

1340
01:00:06,800 --> 01:00:07,366
对吧

1341
01:00:07,366 --> 01:00:10,366
所以这个方法他改变了Deepmind的行为

1342
01:00:10,366 --> 01:00:12,499
就使得说他在这个部分

1343
01:00:12,500 --> 01:00:12,933
我们看到

1344
01:00:12,933 --> 01:00:13,733
这个部分

1345
01:00:14,300 --> 01:00:16,500
不满足历史科夫可替换行为了

1346
01:00:17,066 --> 01:00:20,299
不满足历史科夫可替换的规则了

1347
01:00:20,400 --> 01:00:22,100
不满足历史科夫替换规则

1348
01:00:22,100 --> 01:00:22,200
就

1349
01:00:22,200 --> 01:00:24,700
使得他没法跟这一边的这两个算法

1350
01:00:24,866 --> 01:00:25,733
合起来用

1351
01:00:27,200 --> 01:00:28,366
因为他压根就没调

1352
01:00:28,500 --> 01:00:29,900
这两边的这两个算法

1353
01:00:29,933 --> 01:00:31,499
所以他就没办法满足

1354
01:00:31,500 --> 01:00:34,200
我们在调节器模式里头

1355
01:00:34,800 --> 01:00:37,700
这个探寻算法和这个算法

1356
01:00:37,700 --> 01:00:39,866
和这个算法混合起来

1357
01:00:39,866 --> 01:00:43,466
变成简单贪心和背包贪心

1358
01:00:43,600 --> 01:00:44,933
但其实他也不需要

1359
01:00:44,933 --> 01:00:47,266
因为他既不善的简单也不善的背包

1360
01:00:47,500 --> 01:00:51,000
而是用贪心算法去完成的这个过程啊

1361
01:00:51,000 --> 01:00:52,766
因为简单和贪心

1362
01:00:52,766 --> 01:00:55,333
实际上是有事先确定了一个什么呢

1363
01:00:55,566 --> 01:00:58,266
确定了一个这个size啊

1364
01:00:58,266 --> 01:01:00,533
他印象法其实是没有确定这个size

1365
01:01:00,566 --> 01:01:01,133
他的目的

1366
01:01:01,133 --> 01:01:05,533
就是把两个包裹打得尽量的均匀

1367
01:01:05,700 --> 01:01:07,666
就这个目的就是他是均匀的

1368
01:01:07,666 --> 01:01:09,999
但这个均匀的不是有一个size的

1369
01:01:10,466 --> 01:01:12,666
不是说你直接算出一个筛子来均匀

1370
01:01:12,866 --> 01:01:15,199
而是就是根据这个包裹的状况

1371
01:01:15,200 --> 01:01:16,100
去均匀的

1372
01:01:16,133 --> 01:01:16,866
所以他有时候

1373
01:01:16,866 --> 01:01:18,966
可能比如说30公斤的包裹

1374
01:01:19,333 --> 01:01:22,599
他打出来的结果可能是一个是16公斤

1375
01:01:22,600 --> 01:01:24,066
一个是14公斤

1376
01:01:24,733 --> 01:01:25,666
会这样打出来

1377
01:01:25,866 --> 01:01:28,199
但是如果说是以average的这个size的话

1378
01:01:28,200 --> 01:01:29,733
他就会直接让所有的包裹

1379
01:01:29,733 --> 01:01:31,333
都小于15公斤

1380
01:01:31,800 --> 01:01:34,600
对吧他有可能就打出一个情况

1381
01:01:34,600 --> 01:01:36,200
就是要打三个包裹出来

1382
01:01:36,333 --> 01:01:37,966
但其实你把一个包裹打成16公斤

1383
01:01:37,966 --> 01:01:39,166
一个包裹打成14公斤

1384
01:01:39,166 --> 01:01:40,799
其实就能打出两个包裹出来

1385
01:01:40,900 --> 01:01:42,766
所以这个就是用穿行战法去实现

1386
01:01:43,366 --> 01:01:46,099
他就并不是用一个死的标准去卡死了

1387
01:01:46,100 --> 01:01:47,966
说这个用什么标准当

1388
01:01:47,966 --> 01:01:49,366
上限是不会超过的啊

1389
01:01:49,366 --> 01:01:50,699
上限是不会超过的

1390
01:01:50,700 --> 01:01:52,466
他其实主要就是这个

1391
01:01:52,900 --> 01:01:54,666
就是它是用的average的这个size

1392
01:01:54,666 --> 01:01:55,533
但这个average size

1393
01:01:55,533 --> 01:01:57,133
并不是一个恒定的标准

1394
01:01:57,300 --> 01:02:00,600
而是说可以上下偏移的一个标准

1395
01:02:00,700 --> 01:02:02,766
那它就没有使用这边的这个算法

1396
01:02:02,933 --> 01:02:04,966
所以它不满足历史可不可替换原则啊

1397
01:02:05,300 --> 01:02:07,100
那针对这个上面来说

1398
01:02:07,966 --> 01:02:08,899
针对这边来说

1399
01:02:08,900 --> 01:02:10,500
他不满足历史客户可替换原则

1400
01:02:10,966 --> 01:02:11,999
针对这个上面来说

1401
01:02:12,000 --> 01:02:14,000
他满不满足历史客户替换原则呢

1402
01:02:14,533 --> 01:02:15,266
也就换句话说

1403
01:02:15,266 --> 01:02:21,066
我把他替换成他对于这一个对象来说

1404
01:02:21,466 --> 01:02:23,133
他的行为发生改变了没有

1405
01:02:25,300 --> 01:02:26,300
啊你们觉得

1406
01:02:27,666 --> 01:02:29,066
对没有发生改变

1407
01:02:29,400 --> 01:02:32,966
所以历史可夫可替换原则是有与禁的

1408
01:02:33,400 --> 01:02:34,400
不是简单的说

1409
01:02:34,400 --> 01:02:36,266
这个东西满不满足历史客户挑选者

1410
01:02:36,266 --> 01:02:37,566
你从这个部分来说

1411
01:02:37,566 --> 01:02:38,733
他是不满足历史客户挑选者

1412
01:02:38,733 --> 01:02:40,299
因为他把这个方法给盖掉了

1413
01:02:40,700 --> 01:02:42,166
但是对于他来说

1414
01:02:42,166 --> 01:02:44,466
他所看到的这个divide strategy

1415
01:02:44,500 --> 01:02:45,700
是应该我给你模板

1416
01:02:45,700 --> 01:02:46,733
我给你这个商品

1417
01:02:46,733 --> 01:02:47,933
然后你告诉我说

1418
01:02:47,966 --> 01:02:49,466
你打出了什么样的包裹

1419
01:02:49,933 --> 01:02:52,466
他对于这一个类的要求来说

1420
01:02:52,466 --> 01:02:56,066
他的语境是我给你这个模板

1421
01:02:56,366 --> 01:02:57,699
给你说这堆商品

1422
01:02:57,700 --> 01:02:58,866
你告诉我的结果是

1423
01:02:58,866 --> 01:03:00,399
这堆商品分成了什么东西

1424
01:03:01,333 --> 01:03:02,599
这一个类

1425
01:03:02,666 --> 01:03:04,299
他是满足这个要求的

1426
01:03:05,000 --> 01:03:06,966
所以对于上面来说

1427
01:03:06,966 --> 01:03:08,199
你把他替换成为

1428
01:03:08,200 --> 01:03:11,333
他是不会受到任何影响的

1429
01:03:11,333 --> 01:03:12,333
所以对于上面和

1430
01:03:12,333 --> 01:03:14,299
是满足历史客户可替换原则的啊

1431
01:03:15,200 --> 01:03:18,066
那最后一个我们就给大家简单看一下

1432
01:03:18,066 --> 01:03:19,399
他其实也是一样的

1433
01:03:20,300 --> 01:03:22,800
就是这个optim的这个方法

1434
01:03:23,066 --> 01:03:24,866
这个方法写的更麻烦啊

1435
01:03:25,466 --> 01:03:28,066
呃它的总的特征就是

1436
01:03:28,066 --> 01:03:30,099
它是用费用最优的方式来决定

1437
01:03:30,100 --> 01:03:30,900
怎么打包

1438
01:03:30,933 --> 01:03:33,899
就是用算出来的费用最优的方式啊

1439
01:03:33,900 --> 01:03:34,566
那怎么打包

1440
01:03:34,566 --> 01:03:36,333
他的getting page size已经完全没有意义了

1441
01:03:36,333 --> 01:03:37,599
因为他会打出各种各样的size

1442
01:03:37,600 --> 01:03:38,533
只要不超过上限

1443
01:03:38,766 --> 01:03:39,733
什么size都有可能

1444
01:03:39,733 --> 01:03:42,133
只是看最后算出来的钱是不是最优的

1445
01:03:42,600 --> 01:03:44,000
那大家知道这是个NP

1446
01:03:44,666 --> 01:03:45,666
NP的问题

1447
01:03:45,666 --> 01:03:47,766
就是他没法在有限的时间

1448
01:03:47,766 --> 01:03:48,899
算出一个最优的结果

1449
01:03:48,900 --> 01:03:51,133
也找不到最优结果的这样的一个问题

1450
01:03:51,333 --> 01:03:54,166
所以这位同学采用的是什么方法呢

1451
01:03:55,333 --> 01:03:57,699
采用的是淬火算法

1452
01:03:58,066 --> 01:03:59,366
大家应该知道淬火算法吧

1453
01:03:59,366 --> 01:04:00,999
在算法里头讲了吗

1454
01:04:01,933 --> 01:04:02,966
啊没讲那

1455
01:04:02,966 --> 01:04:05,166
那这就同学自己做的淬火算法

1456
01:04:05,333 --> 01:04:06,666
淬火算法其实就是在讲

1457
01:04:06,666 --> 01:04:08,366
找一个局部最优啊

1458
01:04:08,366 --> 01:04:09,566
找一个局部最优

1459
01:04:11,200 --> 01:04:12,933
所以他用这个摧毁算法

1460
01:04:12,933 --> 01:04:15,066
去找了一个局部最优的

1461
01:04:16,000 --> 01:04:19,300
这个打包的策略啊

1462
01:04:19,300 --> 01:04:20,300
所以他重样的啊

1463
01:04:20,300 --> 01:04:20,800
大家可以看一下

1464
01:04:20,800 --> 01:04:21,800
他重载了

1465
01:04:22,000 --> 01:04:22,866
他不但重载了

1466
01:04:22,866 --> 01:04:23,899
而且他特别彻

1467
01:04:23,900 --> 01:04:25,966
彻底彻尾的改变了这个Devite的

1468
01:04:25,966 --> 01:04:26,766
这个方法

1469
01:04:27,666 --> 01:04:29,066
就完全跟原来devotion

1470
01:04:29,066 --> 01:04:30,199
是没有任何的相似性

1471
01:04:30,200 --> 01:04:32,266
的可以看一下

1472
01:04:35,966 --> 01:04:38,933
这个就前面那个

1473
01:04:39,300 --> 01:04:41,966
前面那个贪心还有一定的相似性啊

1474
01:04:42,300 --> 01:04:43,133
但是

1475
01:04:44,000 --> 01:04:47,000
这个方法就完全没有任何的相似性了

1476
01:04:47,000 --> 01:04:48,866
他把他DIY的方法全部都改了

1477
01:04:55,133 --> 01:04:58,166
啊这就是这个最优费用的的方法

1478
01:04:58,200 --> 01:04:58,933
看一看代码上

1479
01:04:58,933 --> 01:05:00,966
你完全没有完全没有相似性的

1480
01:05:01,066 --> 01:05:02,333
所以他跟他用算法一样的

1481
01:05:02,333 --> 01:05:04,299
他也不能跟这边的简单打包

1482
01:05:04,300 --> 01:05:07,366
和背包的算法去结合起来啊

1483
01:05:07,366 --> 01:05:10,099
所以他就是自己独立的一块

1484
01:05:10,466 --> 01:05:12,399
局部不满足历史客户可以替换原则

1485
01:05:12,500 --> 01:05:14,300
但是整体上来说

1486
01:05:14,300 --> 01:05:15,900
针对于我们的region time来说

1487
01:05:15,900 --> 01:05:17,533
它还是满足历史客户替换原则的

1488
01:05:17,666 --> 01:05:18,999
所以就可以这样去替换

1489
01:05:19,266 --> 01:05:21,099
算法部分我就不重点讲了啊

1490
01:05:21,100 --> 01:05:22,966
去年的同学为什么这么玩命的做算法

1491
01:05:22,966 --> 01:05:23,566
因为大家知道

1492
01:05:23,566 --> 01:05:27,466
去年其实有3个同学是拿了ACM金牌的

1493
01:05:27,533 --> 01:05:30,599
对吧其中好像是两个是卓越班的

1494
01:05:30,600 --> 01:05:31,866
一个不是卓越班的

1495
01:05:32,133 --> 01:05:33,066
呃大家应该知道

1496
01:05:33,066 --> 01:05:35,799
ACM金牌的分量其实挺重的

1497
01:05:35,800 --> 01:05:37,133
那个不是卓越班的同学

1498
01:05:37,133 --> 01:05:39,166
其实按照平时地点是没办法保研的

1499
01:05:39,466 --> 01:05:41,599
但就单纯凭了这个ACM的金牌

1500
01:05:41,600 --> 01:05:44,366
就一下子就挤到了保研队列中间啊

1501
01:05:44,366 --> 01:05:47,366
就相当于说它这个加分量特别高啊

1502
01:05:47,366 --> 01:05:48,733
那现在目前看到这些算法

1503
01:05:48,733 --> 01:05:50,666
就是这个组织同学写的啊

1504
01:05:50,666 --> 01:05:52,899
他们在里头其实写了不少的这个算法

1505
01:05:52,900 --> 01:05:53,800
不仅在这一块

1506
01:05:53,800 --> 01:05:54,866
在产品那一块

1507
01:05:54,866 --> 01:05:57,166
也写了不少的这个算法啊

1508
01:05:57,166 --> 01:05:58,799
那当然这个不是我们这门课的重点

1509
01:05:58,800 --> 01:06:00,133
如果大家有兴趣去看的话

1510
01:06:00,133 --> 01:06:02,399
或者在做这部分调试的同学

1511
01:06:02,533 --> 01:06:04,666
是需要去了解这部分的算法的啊

1512
01:06:04,666 --> 01:06:07,266
所以承担这个必做任务的同学

1513
01:06:07,266 --> 01:06:08,499
是需要把这些算

1514
01:06:08,500 --> 01:06:10,500
法去搞懂的

1515
01:06:10,500 --> 01:06:12,666
因为他们里头其实已经写了测试

1516
01:06:12,666 --> 01:06:14,866
这些测试我把别人的测试都删了

1517
01:06:14,866 --> 01:06:16,866
但是关于算法的测试我全部都留下了

1518
01:06:16,866 --> 01:06:17,533
所以大家可以看一下

1519
01:06:17,533 --> 01:06:19,333
他们去年是怎么做的这个算法的测试

1520
01:06:19,333 --> 01:06:20,399
来证明他们这个算法

1521
01:06:20,400 --> 01:06:21,900
比现有的算法要更好

1522
01:06:22,333 --> 01:06:24,466
然后呃今年做测试的时候

1523
01:06:24,466 --> 01:06:25,999
其实主要是测试这部分算法

1524
01:06:26,000 --> 01:06:28,500
在我们整体框架中间用的是不是OK的

1525
01:06:28,533 --> 01:06:30,166
就整体框架用上去以后

1526
01:06:30,166 --> 01:06:32,399
我们的这组数据是比

1527
01:06:32,800 --> 01:06:34,533
就是用这个算法的数据

1528
01:06:34,533 --> 01:06:36,999
会比用别的算法的数据会更好啊

1529
01:06:38,166 --> 01:06:39,799
这也是为什么我们会把这一个过程

1530
01:06:39,800 --> 01:06:42,700
任务一个API单滴落出来

1531
01:06:42,700 --> 01:06:44,333
成为一个必做的任务

1532
01:06:44,333 --> 01:06:46,299
是因为这部分的这个任务中间

1533
01:06:46,300 --> 01:06:49,100
是涉及到一部分跟算法有关的的任务

1534
01:06:49,200 --> 01:06:50,733
所以要做这部分的同学

1535
01:06:50,733 --> 01:06:53,366
实际上是要理解这个算法的代码的

1536
01:06:53,366 --> 01:06:55,399
他们其实有的都写了很多的注释

1537
01:06:55,566 --> 01:06:57,133
而且也有写了作者是谁

1538
01:06:57,533 --> 01:06:58,866
不知道你们认不认识他啊

1539
01:06:59,700 --> 01:07:04,933
这个是徐明义还是易明徐啊

1540
01:07:04,933 --> 01:07:06,666
徐明义你们应该认识他是吧

1541
01:07:07,100 --> 01:07:07,800
另外一个

1542
01:07:07,800 --> 01:07:11,500
那个呃贪心算法是

1543
01:07:14,700 --> 01:07:15,500
王文皓

1544
01:07:16,866 --> 01:07:18,966
王文皓写的这个你们认识吗

1545
01:07:33,533 --> 01:07:35,133
然后背包算法是

1546
01:07:38,366 --> 01:07:39,933
背包账法是周和写的

1547
01:07:41,533 --> 01:07:43,399
这和应该知道对吧

1548
01:07:43,900 --> 01:07:45,066
就是这三个算法

1549
01:07:45,066 --> 01:07:46,133
就这三个同学写的

1550
01:07:46,333 --> 01:07:48,199
所以你们如果做这个任务的同学

1551
01:07:48,200 --> 01:07:49,800
如果会觉得这些算法有问题

1552
01:07:49,800 --> 01:07:51,533
就去找这三位同学啊

1553
01:07:51,533 --> 01:07:53,299
他们的名字是留在这个里头的

1554
01:07:54,100 --> 01:07:57,200
这是我们的下面这个部分

1555
01:07:57,200 --> 01:07:59,300
我们从下面这个部分开始说起啊

1556
01:07:59,800 --> 01:08:03,900
那把图切到上面这个部分再往回倒

1557
01:08:11,133 --> 01:08:11,999
那我们知道Devite是

1558
01:08:12,000 --> 01:08:13,166
怎么做的是吧

1559
01:08:13,166 --> 01:08:14,466
然后我们回头看

1560
01:08:14,466 --> 01:08:16,899
这个reading template是怎么来做correct的

1561
01:08:17,000 --> 01:08:18,700
我们可以看到它首先做了Devite

1562
01:08:18,700 --> 01:08:20,000
就是我们刚才看的那一大部分

1563
01:08:20,000 --> 01:08:21,166
都是Devite

1564
01:08:21,700 --> 01:08:23,300
那它在分了包以后

1565
01:08:23,300 --> 01:08:26,933
它会去Cockrate这个它的运费

1566
01:08:26,966 --> 01:08:28,599
然后会把它打成一个包裹

1567
01:08:28,600 --> 01:08:31,100
所以我们看下这段代码是什么样的

1568
01:08:37,133 --> 01:08:38,966
最大码是在region temperate里头

1569
01:08:58,066 --> 01:08:58,499
啊这个

1570
01:08:58,500 --> 01:09:01,200
那么我们有一部分是没有画在图上的

1571
01:09:01,200 --> 01:09:02,333
其实我们前面是判断一下

1572
01:09:02,333 --> 01:09:03,466
他的这个分包策略

1573
01:09:03,466 --> 01:09:05,933
是不是在如果是空的话

1574
01:09:05,933 --> 01:09:07,466
就会抛出一个错啊

1575
01:09:08,466 --> 01:09:11,333
那这个部分就是我们在图上所画的

1576
01:09:11,566 --> 01:09:12,766
大家对比一下啊

1577
01:09:12,766 --> 01:09:17,699
在图上好像画了四五个东西是吧

1578
01:09:18,100 --> 01:09:20,133
四五次的调用对吧

1579
01:09:20,300 --> 01:09:21,100
在图上

1580
01:09:21,533 --> 01:09:25,299
那在代码里头大家看到的只有一行

1581
01:09:32,000 --> 01:09:34,100
这是代码中间大家看到的只有一行

1582
01:09:36,200 --> 01:09:37,300
为啥会这样呢

1583
01:09:37,800 --> 01:09:38,766
就是我们这部分

1584
01:09:38,766 --> 01:09:40,533
图跟代码画的是不一样的

1585
01:09:43,900 --> 01:09:46,133
一般我们是要求图跟代码是一致的

1586
01:09:46,133 --> 01:09:48,266
是吧你可以画的比代码少

1587
01:09:48,500 --> 01:09:48,766
但是

1588
01:09:48,766 --> 01:09:50,966
你不能画的跟代码看起来完全不一样

1589
01:09:51,733 --> 01:09:52,333
但这一部分

1590
01:09:52,333 --> 01:09:54,933
画的就是跟代码看起来完全不一样

1591
01:09:55,300 --> 01:09:55,700
原因是

1592
01:09:55,700 --> 01:09:58,500
因为这部分代码是用刘秉成写的

1593
01:09:58,800 --> 01:09:59,700
应该能看出来

1594
01:09:59,866 --> 01:10:01,266
就是首先做了一个divide

1595
01:10:01,533 --> 01:10:03,266
divide的结果直接把它stream

1596
01:10:03,266 --> 01:10:03,933
然后用map

1597
01:10:03,933 --> 01:10:07,199
把它转成了我们要的那个结构

1598
01:10:07,266 --> 01:10:09,066
然后把它connect的list

1599
01:10:09,066 --> 01:10:10,133
最后变成了一个list

1600
01:10:10,133 --> 01:10:13,099
返回就是用牛鞭成一行把他写完了

1601
01:10:13,200 --> 01:10:14,866
牛鞭成的好处不是在于说

1602
01:10:14,866 --> 01:10:16,466
他一行把他写完啊

1603
01:10:16,766 --> 01:10:18,466
牛鞭成的好处在于说

1604
01:10:18,666 --> 01:10:19,566
这个过程

1605
01:10:20,266 --> 01:10:22,666
会使得他的错误率减少了很多

1606
01:10:23,333 --> 01:10:25,099
就是他的代码写的更少啊

1607
01:10:25,100 --> 01:10:25,800
因为有很多东西

1608
01:10:25,800 --> 01:10:28,000
是交给了本身刘边成去完成了

1609
01:10:28,200 --> 01:10:29,766
所以说我们重点就在写

1610
01:10:29,766 --> 01:10:32,333
里头的每个元素的处理逻辑是什么

1611
01:10:32,500 --> 01:10:35,566
这其实也是函数式编程的一大好处啊

1612
01:10:35,800 --> 01:10:36,733
一大好处

1613
01:10:37,066 --> 01:10:40,533
那目前我们的umil图所面对的问题

1614
01:10:40,533 --> 01:10:41,366
就是这个部分

1615
01:10:41,366 --> 01:10:43,466
因为umil图在持续图

1616
01:10:43,466 --> 01:10:44,533
不管所有的图

1617
01:10:44,766 --> 01:10:47,366
其实都是出现在流编程之前的

1618
01:10:47,933 --> 01:10:48,933
所以当流编程

1619
01:10:48,933 --> 01:10:50,933
或者函数式编程这种东西出来以后

1620
01:10:51,866 --> 01:10:52,966
我们现在发现说

1621
01:10:53,200 --> 01:10:55,566
大家发现这个时序图没办法描述它

1622
01:10:56,166 --> 01:10:57,199
所以就这个结果

1623
01:10:57,200 --> 01:10:57,500
就是

1624
01:10:57,500 --> 01:10:59,500
我实际上用时序图是没办法描述

1625
01:10:59,500 --> 01:11:00,700
我们用流变成的方式

1626
01:11:00,700 --> 01:11:03,166
这么完成的这样的一个过程啊

1627
01:11:03,166 --> 01:11:03,499
当然

1628
01:11:03,500 --> 01:11:07,533
这个时序图需要去设计新的羽翼

1629
01:11:07,700 --> 01:11:09,866
才能把这个流编程的

1630
01:11:09,866 --> 01:11:11,266
这样的一种设计方式

1631
01:11:11,400 --> 01:11:12,266
给他描述出来

1632
01:11:12,266 --> 01:11:13,499
现有是没办法的

1633
01:11:13,500 --> 01:11:15,166
就现有的UML的二点

1634
01:11:15,566 --> 01:11:17,466
包括到现在最新的2.32.5

1635
01:11:17,466 --> 01:11:20,499
都没有办法去描述流边层的这个方式

1636
01:11:20,700 --> 01:11:23,333
那我们就只能用折中的方式去去做了

1637
01:11:23,333 --> 01:11:25,933
啊所以这段的这个设计

1638
01:11:26,133 --> 01:11:27,966
和图代码是不对的

1639
01:11:29,000 --> 01:11:29,766
是不对应的啊

1640
01:11:29,766 --> 01:11:30,999
但基本上是这个思想

1641
01:11:31,000 --> 01:11:34,333
那我们看其中的这个copilot frame算这个

1642
01:11:35,466 --> 01:11:36,399
这是个抽象方法

1643
01:11:36,400 --> 01:11:37,066
我们刚才说了

1644
01:11:37,066 --> 01:11:39,333
这是模板方法的设计模式

1645
01:11:39,533 --> 01:11:44,966
是因为它的这个是在键数模板里头

1646
01:11:44,966 --> 01:11:47,133
是它的两个指类中间去完成

1647
01:11:47,133 --> 01:11:49,166
键数模板中间去算价格的方式

1648
01:11:49,166 --> 01:11:51,166
根据键数模板的这个数据结构

1649
01:11:51,300 --> 01:11:53,133
去做的计算啊

1650
01:11:54,133 --> 01:11:55,899
重量模板中间的计算方式

1651
01:11:55,900 --> 01:11:56,066
是

1652
01:11:56,066 --> 01:11:58,933
按照重量模板的数据结构去做的计算

1653
01:12:03,166 --> 01:12:05,099
这就是典型的模板方法

1654
01:12:05,100 --> 01:12:06,166
因为这两个东西的数据结

1655
01:12:06,166 --> 01:12:06,799
构完全不一样

1656
01:12:06,800 --> 01:12:08,900
他算的规则也完全不一样啊

1657
01:12:08,900 --> 01:12:11,266
所以在里头就分别用两个方法

1658
01:12:11,500 --> 01:12:13,466
去做的这样的一个计算

1659
01:12:13,866 --> 01:12:16,566
那当然怎么计算这个就不用去讲

1660
01:12:16,566 --> 01:12:17,499
这跟设计没关系

1661
01:12:17,500 --> 01:12:19,700
就具体去很琐碎的实现啊

1662
01:12:19,700 --> 01:12:22,400
按照那个数据结构去把它算出来

1663
01:12:24,933 --> 01:12:27,199
啊所以这部分为什么单做一个任务

1664
01:12:27,200 --> 01:12:27,900
是大家会发现

1665
01:12:27,900 --> 01:12:30,100
这部分的计算的工作量也挺大的

1666
01:12:30,100 --> 01:12:31,500
万一这部分算错了

1667
01:12:31,666 --> 01:12:34,099
其实也要去找出来啊

1668
01:12:37,733 --> 01:12:40,799
所以这是这个计算的部分

1669
01:12:40,933 --> 01:12:41,999
那后面的部分就没什么

1670
01:12:42,000 --> 01:12:43,600
他就把算出来的这个结果

1671
01:12:43,800 --> 01:12:45,600
然后跟他分出来的这个包

1672
01:12:45,600 --> 01:12:47,366
构成一个新的返回值类型

1673
01:12:47,366 --> 01:12:51,466
然后把它用map转成了这个这个类型

1674
01:12:51,466 --> 01:12:54,199
然后把它变成list给他返回回去了

1675
01:12:54,400 --> 01:12:55,366
这是他

1676
01:12:55,666 --> 01:12:58,299
那再往上头一层就是我们的收费时辰

1677
01:13:06,733 --> 01:13:09,266
我们的收费时辰单写了一个类

1678
01:13:09,266 --> 01:13:11,299
这个类里头就只有他啊

1679
01:13:11,300 --> 01:13:14,100
就是他用来去算这个运费模板的

1680
01:13:14,533 --> 01:13:15,933
算这个价格的啊

1681
01:13:16,066 --> 01:13:20,266
所以这个代码中间我们可以看到

1682
01:13:20,266 --> 01:13:21,766
他的这个计算的方式

1683
01:13:21,766 --> 01:13:23,133
就跟我们的代码是一样的

1684
01:13:23,133 --> 01:13:25,533
我们首先找到他的模板对象

1685
01:13:25,666 --> 01:13:26,799
这是跟图上一样

1686
01:13:26,966 --> 01:13:28,566
找到他的地区对象

1687
01:13:28,900 --> 01:13:31,166
然后把这个职责分给了地区对象

1688
01:13:31,166 --> 01:13:31,966
去做计算

1689
01:13:31,966 --> 01:13:33,366
然后把结果返回来

1690
01:13:33,466 --> 01:13:35,933
然后把这个结果转成了这种格式

1691
01:13:36,200 --> 01:13:37,200
然后丢回去

1692
01:13:37,200 --> 01:13:38,700
丢到control层

1693
01:13:41,666 --> 01:13:43,566
然后大家如果看controls呢

1694
01:13:43,566 --> 01:13:45,699
controls其实它的内部的方法

1695
01:13:45,700 --> 01:13:46,800
也只有这么一个

1696
01:13:48,600 --> 01:13:50,100
control层里头啊

1697
01:13:50,100 --> 01:13:50,566
这个方法

1698
01:13:50,566 --> 01:13:52,199
其实就是直接从Server层的方法

1699
01:13:52,200 --> 01:13:53,133
直接把它返回了

1700
01:13:53,133 --> 01:13:54,733
把到return up这个中间把它返回

1701
01:13:54,733 --> 01:13:55,199
这是去年

1702
01:13:55,200 --> 01:13:56,366
同意就写成这个样子

1703
01:13:57,800 --> 01:13:58,366
有问题吗

1704
01:13:58,366 --> 01:13:59,666
你们觉得这个方法

1705
01:14:02,800 --> 01:14:04,766
我们今年在这一部分代码中间

1706
01:14:04,766 --> 01:14:06,366
故意遗留了很多的问题

1707
01:14:06,366 --> 01:14:07,399
让同学们去改

1708
01:14:08,500 --> 01:14:12,266
就是我们在我在那个支付模块中间

1709
01:14:12,266 --> 01:14:12,466
其实

1710
01:14:12,466 --> 01:14:14,299
我已经尽量的把这些问题全部改完了

1711
01:14:14,566 --> 01:14:17,399
但是到这个商铺模块中间

1712
01:14:17,400 --> 01:14:19,066
我就尽量把这些问题留着

1713
01:14:19,366 --> 01:14:21,666
让负责这部分的同学去做修改

1714
01:14:21,666 --> 01:14:22,999
各种各样的问题都有啊

1715
01:14:24,000 --> 01:14:26,866
比如说这三行代码

1716
01:14:29,566 --> 01:14:31,366
大家觉得写的这地方有问题吗

1717
01:14:39,733 --> 01:14:42,766
这是调那个对象返回的计算结果

1718
01:14:42,866 --> 01:14:44,166
然后这三行代码是干嘛呢

1719
01:14:44,166 --> 01:14:44,966
这三行代码

1720
01:14:45,000 --> 01:14:47,300
这一行是把那个计算结果加总

1721
01:14:47,500 --> 01:14:49,266
得到一个总运费是多少

1722
01:14:49,766 --> 01:14:50,533
这一行呢

1723
01:14:50,533 --> 01:14:54,299
是去组成它要返回的那个格式

1724
01:14:54,900 --> 01:14:56,133
然后这一行呢

1725
01:14:56,133 --> 01:14:58,466
是把它按照这个算出来的这个结果

1726
01:14:58,466 --> 01:15:00,333
把它变成那个

1727
01:15:00,933 --> 01:15:02,566
变成把这个

1728
01:15:04,266 --> 01:15:04,999
把这个值啊

1729
01:15:05,000 --> 01:15:07,133
把这个fee这个值给它丢进去

1730
01:15:07,166 --> 01:15:09,799
然后把后面的这一部分值给它丢进去

1731
01:15:09,800 --> 01:15:10,800
然后给它返回

1732
01:15:19,066 --> 01:15:19,866
这三行

1733
01:15:36,566 --> 01:15:37,966
好像觉得没问题是吧

1734
01:15:40,133 --> 01:15:42,066
至少这两行是有问题的

1735
01:15:43,733 --> 01:15:44,499
因为这两行

1736
01:15:44,500 --> 01:15:46,766
不属于在社会层所干的事情

1737
01:15:47,400 --> 01:15:49,533
你如果说计算这个总价

1738
01:15:50,400 --> 01:15:52,466
这属于在社会层会去干的事情

1739
01:15:53,133 --> 01:15:57,366
但是这个是不属于在社会层干的事情

1740
01:15:57,666 --> 01:16:00,333
因为这是在主往回传的

1741
01:16:00,333 --> 01:16:01,133
DTO

1742
01:16:01,866 --> 01:16:03,666
无论是他里头的明细Deto

1743
01:16:03,666 --> 01:16:05,133
就是他的包裹的Deto

1744
01:16:05,266 --> 01:16:06,599
product item的Deto

1745
01:16:06,900 --> 01:16:09,500
还是他最终的这个flight price Deto

1746
01:16:09,933 --> 01:16:11,366
这两句都是在主Deto

1747
01:16:11,733 --> 01:16:13,099
这两句应该放哪去呢

1748
01:16:15,766 --> 01:16:18,266
这两句应该是Controller层去完成的事情

1749
01:16:18,700 --> 01:16:20,400
这就是我们最基本的说

1750
01:16:20,466 --> 01:16:23,766
我们的Controller层service层道层

1751
01:16:24,600 --> 01:16:27,200
各自应该完成什么样的职责

1752
01:16:27,533 --> 01:16:31,666
我在这个商铺这个模块

1753
01:16:31,666 --> 01:16:33,933
以及在产品这个模块里头

1754
01:16:33,933 --> 01:16:36,366
我有大量的这些问题

1755
01:16:36,366 --> 01:16:37,866
我没有去把它纠正

1756
01:16:38,500 --> 01:16:40,666
就是留给同学们去纠正的

1757
01:16:40,733 --> 01:16:42,066
这就是我们最基本的问题

1758
01:16:42,066 --> 01:16:43,499
就是你的Controller层

1759
01:16:44,066 --> 01:16:47,533
设位时层盗层map层

1760
01:16:47,533 --> 01:16:51,199
这四层各自要写什么样的代码

1761
01:16:51,866 --> 01:16:52,966
这三行代码

1762
01:16:53,200 --> 01:16:55,166
至少这两行代码是有问题的

1763
01:16:55,166 --> 01:16:56,966
它是不能放到收费市城的

1764
01:16:57,300 --> 01:17:00,500
应该是在Controller城去负责完成

1765
01:17:00,500 --> 01:17:02,733
返回值应该是什么样的格式

1766
01:17:03,133 --> 01:17:05,333
收费市城只负责业务啊

1767
01:17:05,333 --> 01:17:07,299
只负责业务这是

1768
01:17:08,666 --> 01:17:09,766
这个代码啊

1769
01:17:09,766 --> 01:17:12,166
留下同学们自己去做更改

1770
01:17:12,166 --> 01:17:14,933
就是做这个必做任务的同学去做更改

1771
01:17:16,666 --> 01:17:18,899
这个我们就把商铺模块讲完了

1772
01:17:18,900 --> 01:17:20,533
那其他的部分

1773
01:17:20,766 --> 01:17:21,566
简单的部分啊

1774
01:17:21,566 --> 01:17:22,766
我们就不去讲了

1775
01:17:22,766 --> 01:17:25,666
我们把它分成了三个必做任务

1776
01:17:40,466 --> 01:17:41,199
做任务

1777
01:17:41,200 --> 01:17:44,166
主要是写代码和改代码的任务

1778
01:17:44,166 --> 01:17:47,766
所以我们就慢慢的从那个啊

1779
01:17:47,766 --> 01:17:49,333
课程网站上的去发布任务

1780
01:17:49,333 --> 01:17:52,999
改成了基于这个code二词去发布任务

1781
01:17:53,533 --> 01:17:54,666
好重新登录一下

1782
01:17:55,500 --> 01:17:57,500
不用可以过来

1783
01:17:57,766 --> 01:17:58,999
这个codarch的话

1784
01:17:59,000 --> 01:18:00,000
怎么用的话

1785
01:18:00,533 --> 01:18:01,966
阮公那边会有要求的

1786
01:18:01,966 --> 01:18:03,066
因为阮公的助教

1787
01:18:03,066 --> 01:18:06,133
应该是在最近的这一两周

1788
01:18:06,400 --> 01:18:07,700
会安排一次课

1789
01:18:07,733 --> 01:18:10,766
就是由助教来讲怎么用这个codarch

1790
01:18:11,300 --> 01:18:13,700
那我们这边其实也会用Codarch

1791
01:18:13,700 --> 01:18:14,700
就是我们的b座任务

1792
01:18:14,700 --> 01:18:18,166
也是基于华为的Codarch去使用的

1793
01:18:18,566 --> 01:18:21,466
呃我们是从这个需求管理

1794
01:18:21,566 --> 01:18:22,866
缺陷管理

1795
01:18:23,200 --> 01:18:26,866
到后面的这个代码的托管

1796
01:18:26,866 --> 01:18:27,966
这个答案您知道了

1797
01:18:28,600 --> 01:18:30,933
到后面的这个持续交付

1798
01:18:31,333 --> 01:18:34,133
到最后的这个制品仓库

1799
01:18:34,733 --> 01:18:38,799
到测试全部都会走完啊

1800
01:18:38,800 --> 01:18:40,600
就是整个后面这个过程全部走完

1801
01:18:40,600 --> 01:18:42,000
那我们现在目前这个

1802
01:18:42,000 --> 01:18:44,600
阶段还是在写代码的这个阶段

1803
01:18:44,766 --> 01:18:45,366
代码上啊

1804
01:18:45,366 --> 01:18:47,599
下一周我们就会把前面

1805
01:18:47,600 --> 01:18:48,933
因为有一部分同学已经开始

1806
01:18:48,933 --> 01:18:49,733
在

1807
01:18:50,000 --> 01:18:50,800
有第一个同学

1808
01:18:50,800 --> 01:18:52,866
已经把他的必做任务加上来了

1809
01:18:52,866 --> 01:18:55,333
所以当有阅读的必做任务上来以后

1810
01:18:55,500 --> 01:18:58,366
我们是要求必做任务完成单元测试

1811
01:18:58,366 --> 01:19:00,066
然后再扣大声的

1812
01:19:00,066 --> 01:19:00,699
我们会完成

1813
01:19:00,700 --> 01:19:01,566
集成测试

1814
01:19:01,733 --> 01:19:02,766
软工应该已经讲了

1815
01:19:03,533 --> 01:19:05,199
单元测试和集成测试的差别

1816
01:19:05,600 --> 01:19:07,800
单元测试测的是代码的覆盖率

1817
01:19:08,133 --> 01:19:10,266
集成测试主要采用就是单元测试

1818
01:19:10,266 --> 01:19:11,599
用的是白核测试法

1819
01:19:11,966 --> 01:19:14,566
测的主要是这个代码的覆盖率

1820
01:19:15,200 --> 01:19:16,933
保证说你所有写的代码

1821
01:19:16,966 --> 01:19:18,699
他的产生的预期值

1822
01:19:18,700 --> 01:19:20,933
和你的期望的预期值是一致的

1823
01:19:21,166 --> 01:19:22,866
所以这是单元测试啊

1824
01:19:22,866 --> 01:19:24,299
就是白盒测试的方法

1825
01:19:24,966 --> 01:19:26,866
其测试是用的是黑核测试的方法

1826
01:19:27,066 --> 01:19:27,966
黑核测试方法就是

1827
01:19:27,966 --> 01:19:30,133
我们不是去看你的代码覆盖率

1828
01:19:30,300 --> 01:19:32,600
而是尽量使得说

1829
01:19:32,600 --> 01:19:33,800
你的这个代码

1830
01:19:33,800 --> 01:19:36,400
和我们预想的功能是一致的

1831
01:19:36,733 --> 01:19:38,799
那黑盒测试比白盒测试更麻烦

1832
01:19:38,800 --> 01:19:40,500
因为黑盒测试我们是没办法知道

1833
01:19:40,500 --> 01:19:42,566
说我们的测试的用力

1834
01:19:42,566 --> 01:19:45,099
是否有覆盖到我们所有的问题域

1835
01:19:45,200 --> 01:19:46,933
所以软工里头有讲了

1836
01:19:46,933 --> 01:19:48,499
软工应该这部分已经讲了吧

1837
01:19:48,766 --> 01:19:51,599
等加类极限值对吧

1838
01:19:51,600 --> 01:19:53,133
这些我们全部都会用到

1839
01:19:53,200 --> 01:19:55,900
会要来做这个集成测试的部分啊

1840
01:19:56,933 --> 01:20:00,733
呃所以我想等软工的助教讲完以后

1841
01:20:00,733 --> 01:20:03,766
他前半段的基本的用法以后

1842
01:20:03,766 --> 01:20:06,966
我再来讲后半段可能软工不会讲到的

1843
01:20:06,966 --> 01:20:07,699
这个

1844
01:20:07,700 --> 01:20:10,933
持续交付制品仓库测试的这部分的

1845
01:20:10,933 --> 01:20:12,699
这个那我们整个的币种模块

1846
01:20:12,700 --> 01:20:14,166
都是在这个部分来做的

1847
01:20:14,266 --> 01:20:14,499
所以

1848
01:20:14,500 --> 01:20:16,600
从最开始的这个需求分析的部分来说

1849
01:20:16,600 --> 01:20:19,500
我们把我们的三阶

1850
01:20:19,500 --> 01:20:20,800
段四阶段的

1851
01:20:20,800 --> 01:20:22,933
其实二阶段三阶段四阶段的任务

1852
01:20:22,933 --> 01:20:24,366
都发布在这个上面了

1853
01:20:26,066 --> 01:20:26,999
那这个编号来说

1854
01:20:27,000 --> 01:20:27,933
因为这是第一阶段

1855
01:20:27,933 --> 01:20:29,566
是全纯需求飞行阶段

1856
01:20:29,566 --> 01:20:32,266
所以我们的这个设计的一阶段

1857
01:20:32,266 --> 01:20:33,766
其实就是我们的第二

1858
01:20:34,266 --> 01:20:35,966
第二批次的这个任务

1859
01:20:36,300 --> 01:20:37,133
那第二批次

1860
01:20:37,133 --> 01:20:40,533
目前我们已经全部全部发完了

1861
01:20:41,266 --> 01:20:42,533
所以在商铺这一块

1862
01:20:42,533 --> 01:20:45,666
我们发了两个第二阶段的这个任务

1863
01:20:45,666 --> 01:20:48,933
一个是商铺的本身的改进和测试

1864
01:20:48,933 --> 01:20:50,166
这是一堆API

1865
01:20:50,266 --> 01:20:52,133
全是商铺的征战改查的

1866
01:20:53,500 --> 01:20:54,933
这个里头既包括他有bug

1867
01:20:54,933 --> 01:20:56,099
也包括他现有写的代码

1868
01:20:56,100 --> 01:20:57,900
不满足分层体系结构的

1869
01:20:57,900 --> 01:20:59,400
都需要去做修改啊

1870
01:20:59,866 --> 01:21:01,133
另外一个是运费模板的

1871
01:21:01,133 --> 01:21:02,899
这张改差的啊

1872
01:21:02,900 --> 01:21:03,766
也是一堆的API

1873
01:21:03,766 --> 01:21:04,766
虽然看起来很多啊

1874
01:21:04,766 --> 01:21:07,466
但其实它都是生产改差啊

1875
01:21:07,466 --> 01:21:09,199
相对来说我们这里还公用了

1876
01:21:09,200 --> 01:21:09,700
大家应该知道

1877
01:21:09,700 --> 01:21:10,466
这部还公用了

1878
01:21:10,466 --> 01:21:12,199
虽然看起来比前面那个API还多

1879
01:21:12,333 --> 01:21:13,699
但是我们其实有公用的代码

1880
01:21:13,700 --> 01:21:15,466
所以它总体代码量并不是特别多

1881
01:21:15,866 --> 01:21:18,399
那第三个就是我们说的一个API

1882
01:21:18,933 --> 01:21:19,599
计算运费的

1883
01:21:19,600 --> 01:21:20,366
这个部分来说

1884
01:21:20,366 --> 01:21:21,733
涉及到了很多的代码

1885
01:21:21,966 --> 01:21:24,399
涉及到了比较难的算法的部分

1886
01:21:24,600 --> 01:21:26,300
所以我们这个API的测试

1887
01:21:26,300 --> 01:21:27,700
其实是要覆盖住

1888
01:21:28,300 --> 01:21:30,166
就是首先你做的单元测试

1889
01:21:30,166 --> 01:21:31,866
要覆盖住目前所有的代码

1890
01:21:31,900 --> 01:21:33,733
至少80%-90%的代码

1891
01:21:33,933 --> 01:21:36,099
然后你要保证这些80%9十代码

1892
01:21:36,100 --> 01:21:37,266
它的产生的值

1893
01:21:37,266 --> 01:21:40,099
和我们的预期值是一致的啊

1894
01:21:40,100 --> 01:21:42,066
这是这个三个

1895
01:21:42,066 --> 01:21:44,199
这个那之后的测

1896
01:21:44,333 --> 01:21:46,966
之后的第三批和第四批的任务

1897
01:21:46,966 --> 01:21:48,733
我也在逐步的放出来

1898
01:21:48,866 --> 01:21:50,299
所以大家可以看一下啊

1899
01:21:50,300 --> 01:21:52,000
就我们在周三会要讲到

1900
01:21:52,300 --> 01:21:54,200
我们的这个运费模

1901
01:21:54,200 --> 01:21:56,800
块啊物流模块等一部分任务

1902
01:21:56,800 --> 01:21:58,100
我也放出来了啊

1903
01:21:59,266 --> 01:22:00,333
这个是

1904
01:22:01,900 --> 01:22:04,566
呃我们在这里所做的这个必做任务

1905
01:22:04,566 --> 01:22:05,966
那我顺便给大家看一下

1906
01:22:05,966 --> 01:22:07,366
我们的成绩计算办法

1907
01:22:07,366 --> 01:22:09,066
其实我也做了一些修改

1908
01:22:10,200 --> 01:22:11,666
就是根据今年的情况

1909
01:22:29,366 --> 01:22:32,099
大家可能比较关心这个成绩啊

1910
01:22:32,733 --> 01:22:34,499
所以我们知道

1911
01:22:34,533 --> 01:22:39,299
除了20%是作业和讨论课以外

1912
01:22:40,266 --> 01:22:41,066
呃

1913
01:22:47,200 --> 01:22:49,366
我们的后半部分的课程设计

1914
01:22:49,366 --> 01:22:52,733
其实占了蛮大的比例啊

1915
01:22:55,600 --> 01:22:56,333
这份比例

1916
01:22:56,333 --> 01:22:56,966
我们知道

1917
01:22:56,966 --> 01:22:58,133
我们的b座模块

1918
01:22:58,133 --> 01:23:00,399
是要由b座任务来完成的

1919
01:23:00,400 --> 01:23:01,866
这个在个人分数中间

1920
01:23:01,866 --> 01:23:04,533
其实大家如果注意去看它的配比的话

1921
01:23:04,933 --> 01:23:09,399
其实这部分是20分然后

1922
01:23:11,566 --> 01:23:16,666
这部分是占到了总成绩的50分

1923
01:23:16,666 --> 01:23:17,666
而这50分中间

1924
01:23:17,666 --> 01:23:20,533
详细设计是占了20

1925
01:23:20,600 --> 01:23:22,266
而b重任务占了20

1926
01:23:22,266 --> 01:23:22,899
这意味着什么

1927
01:23:22,900 --> 01:23:25,066
意味着成组的成绩中间

1928
01:23:25,333 --> 01:23:27,099
在课程设计中间只占了一半

1929
01:23:27,933 --> 01:23:30,066
计算次你加上选做加上你早早了

1930
01:23:30,066 --> 01:23:31,166
这也是成组的啊

1931
01:23:31,533 --> 01:23:33,866
这一成组的话就只占到了25分

1932
01:23:35,166 --> 01:23:36,499
就是占到25分

1933
01:23:36,733 --> 01:23:41,066
然后b座的部分是20分

1934
01:23:41,400 --> 01:23:43,966
所以个人的表现就是个人在做

1935
01:23:43,966 --> 01:23:45,099
b座任务部分的

1936
01:23:45,100 --> 01:23:45,966
这个分数

1937
01:23:45,966 --> 01:23:47,699
其实在克斯斯汀中间

1938
01:23:47,700 --> 01:23:50,900
总体应该是占到了一半左右的分数

1939
01:23:50,900 --> 01:23:52,666
一半越小一点的分数

1940
01:23:53,000 --> 01:23:54,600
这个加起来只有45分

1941
01:23:54,600 --> 01:23:55,566
大家可以看到

1942
01:23:55,600 --> 01:23:59,366
那当然还有一些这个主观的这个部分

1943
01:23:59,366 --> 01:24:00,499
那这个扣分的部分

1944
01:24:00,500 --> 01:24:02,766
我们现在今年是不做公开用力测试啊

1945
01:24:02,766 --> 01:24:04,299
所以这个就不去扣分了

1946
01:24:04,333 --> 01:24:05,499
那我们现在可以看到

1947
01:24:05,500 --> 01:24:06,333
主要扣分的方式

1948
01:24:06,333 --> 01:24:08,333
是针对b座部分的扣分

1949
01:24:09,366 --> 01:24:10,899
是针对b座部分的扣分

1950
01:24:11,700 --> 01:24:13,400
呃这部分是按照排位的

1951
01:24:13,400 --> 01:24:15,466
所以说总数上的没有超过50分

1952
01:24:15,466 --> 01:24:16,266
没关系啊

1953
01:24:16,266 --> 01:24:18,066
到最后我们实际上按照你的这个排位

1954
01:24:18,066 --> 01:24:18,899
最后来算

1955
01:24:18,900 --> 01:24:20,533
说你的分是多少

1956
01:24:20,533 --> 01:24:23,466
来折算到50分到25分之间

1957
01:24:23,733 --> 01:24:25,766
我们这个部分来说一定注意一点

1958
01:24:25,766 --> 01:24:27,199
对于卓越班可能没有这个问题

1959
01:24:27,200 --> 01:24:29,333
对于普通班来说是有这个问题的

1960
01:24:29,366 --> 01:24:31,533
是有小组干脆就躺平了

1961
01:24:31,933 --> 01:24:33,866
期末完全不提交检查

1962
01:24:33,866 --> 01:24:34,666
也不约扣

1963
01:24:34,666 --> 01:24:35,933
不交检查报告

1964
01:24:35,933 --> 01:24:39,199
也不也不约口试

1965
01:24:39,533 --> 01:24:41,099
两个东西都不交的话

1966
01:24:41,200 --> 01:24:43,466
这门课就肯定挂了

1967
01:24:43,666 --> 01:24:45,399
因为这个会给你记0分的

1968
01:24:45,666 --> 01:24:49,199
而且不参加检查的小组

1969
01:24:49,200 --> 01:24:50,166
大家要看

1970
01:24:50,766 --> 01:24:53,299
他是没有算在排位里头的

1971
01:24:53,800 --> 01:24:55,000
所以这个要注意啊

1972
01:24:55,000 --> 01:24:56,500
就是整个就没有

1973
01:24:56,700 --> 01:24:58,333
最后参加检查的这个小组

1974
01:24:58,333 --> 01:24:59,866
是没有在排位里头的

1975
01:24:59,933 --> 01:25:03,333
我们的排位是有参加的小组的

1976
01:25:03,333 --> 01:25:06,199
参加了检查的小组来做排位的

1977
01:25:06,366 --> 01:25:08,066
所以你只要交了

1978
01:25:08,066 --> 01:25:09,866
就算你交的再烂

1979
01:25:10,400 --> 01:25:12,200
对于普对于普通班同学来说

1980
01:25:12,466 --> 01:25:14,299
他也有25分啊

1981
01:25:14,300 --> 01:25:15,133
也有25分

1982
01:25:15,133 --> 01:25:18,266
那你在期末考试的时候

1983
01:25:18,266 --> 01:25:20,099
如果作业做的还可以

1984
01:25:20,100 --> 01:25:21,400
期末考试超常发挥一下

1985
01:25:21,400 --> 01:25:22,566
还是有可能及格的

1986
01:25:22,666 --> 01:25:24,399
但是如果完全不交

1987
01:25:24,400 --> 01:25:26,733
躺平的小组是完全不可能及格的啊

1988
01:25:27,000 --> 01:25:28,766
那这个部分可能对作业班同学来说

1989
01:25:28,766 --> 01:25:29,966
你们应该意识到一点

1990
01:25:29,966 --> 01:25:31,933
就是必做部分的分数

1991
01:25:31,933 --> 01:25:33,599
其实会占到接近一半

1992
01:25:34,333 --> 01:25:35,133
小组也重要

1993
01:25:35,133 --> 01:25:36,266
小组是一半多

1994
01:25:36,333 --> 01:25:38,666
但是b座部分的个人成绩会做

1995
01:25:39,366 --> 01:25:41,066
做到一半左右

1996
01:25:41,266 --> 01:25:42,133
那b座部分

1997
01:25:42,133 --> 01:25:43,799
可能大家比较关心我们是怎么完成的

1998
01:25:43,800 --> 01:25:45,866
我们知道我们是分成了四个批次

1999
01:25:47,366 --> 01:25:49,966
然后外加一个自由批

2000
01:25:50,600 --> 01:25:52,400
那四个批次我们是限制了

2001
01:25:52,400 --> 01:25:53,966
说每个批次只能做一个任务

2002
01:25:53,966 --> 01:25:55,266
这是因为我们希望这

2003
01:25:55,266 --> 01:25:55,899
四个批次

2004
01:25:55,900 --> 01:25:59,133
让今天的多的同学来做必做任务

2005
01:25:59,266 --> 01:26:02,199
但是自由批我们是没有做做限制的

2006
01:26:02,200 --> 01:26:04,366
就自由批的话是可以任意去做的

2007
01:26:04,500 --> 01:26:05,800
目前提交的一个任务

2008
01:26:05,800 --> 01:26:07,133
就是这个自由批的

2009
01:26:07,600 --> 01:26:08,666
对于每一个同学来说

2010
01:26:08,666 --> 01:26:09,666
我们是总学

2011
01:26:09,900 --> 01:26:12,100
全学期不会超过四个任务

2012
01:26:12,200 --> 01:26:13,933
我们知道当你做了这个任务以后

2013
01:26:13,933 --> 01:26:16,699
会给你一个满分的5分

2014
01:26:16,866 --> 01:26:18,733
但是这5分是会扣分的啊

2015
01:26:19,000 --> 01:26:19,700
怎么扣法

2016
01:26:19,700 --> 01:26:20,866
大家可以看到啊

2017
01:26:21,400 --> 01:26:23,000
我们在提交的时候

2018
01:26:23,600 --> 01:26:24,533
在做避重的时候

2019
01:26:24,533 --> 01:26:26,399
是要完成单元测试代码的

2020
01:26:26,400 --> 01:26:28,300
那单元测试代码的主要的目标

2021
01:26:28,300 --> 01:26:31,800
是要完成他的白盒测试的覆盖率啊

2022
01:26:31,800 --> 01:26:34,133
所以我们当然不会苛求你说

2023
01:26:34,133 --> 01:26:35,666
你要达到100%的覆盖率

2024
01:26:35,766 --> 01:26:38,499
但是至少来说一般应该能达到80%

2025
01:26:38,600 --> 01:26:39,966
然后如果少于80%的话

2026
01:26:39,966 --> 01:26:41,566
你需要给出一定的解释

2027
01:26:42,133 --> 01:26:43,099
那有一些的覆盖率

2028
01:26:43,100 --> 01:26:44,300
是跟你的测试数据有关

2029
01:26:44,300 --> 01:26:46,100
因为在数据库里没有这个测试数据

2030
01:26:46,100 --> 01:26:47,666
所以你达不到那个覆盖率

2031
01:26:47,733 --> 01:26:49,766
你就需要去加新的测试数据

2032
01:26:49,766 --> 01:26:50,766
如果加测试数据的话

2033
01:26:50,766 --> 01:26:51,866
你需要单写

2034
01:26:52,400 --> 01:26:54,900
如果是Mac口里头就是单写Sic语句

2035
01:26:54,900 --> 01:26:55,766
如果是Mango的话

2036
01:26:55,766 --> 01:26:59,066
就需要写一个Mango的这样的

2037
01:26:59,066 --> 01:27:01,799
一个inside money的这样的一个语句

2038
01:27:01,800 --> 01:27:04,566
然后由我来帮你插到这个

2039
01:27:05,366 --> 01:27:07,499
我们的最终的这个数据库里去啊

2040
01:27:07,666 --> 01:27:10,533
这个是一般的这个部分

2041
01:27:10,733 --> 01:27:11,933
那过程我们已经说过

2042
01:27:11,933 --> 01:27:14,099
就是你在本地开了一个单的版本

2043
01:27:14,100 --> 01:27:14,933
然后去做

2044
01:27:15,066 --> 01:27:16,299
我们待会给大家看一下

2045
01:27:16,300 --> 01:27:18,000
我们现在有一个同学已经提交了

2046
01:27:18,266 --> 01:27:19,199
然后做完了以后

2047
01:27:19,200 --> 01:27:21,066
提交到服务器上发出Mr

2048
01:27:21,066 --> 01:27:24,666
然后啊我去看一下他的MR是什么样

2049
01:27:24,800 --> 01:27:25,266
我们现在

2050
01:27:25,266 --> 01:27:25,666
还没有做

2051
01:27:25,666 --> 01:27:26,299
下面这一步

2052
01:27:26,300 --> 01:27:26,600
就是

2053
01:27:26,600 --> 01:27:29,200
我们这个平台是会去做集成测试的

2054
01:27:29,766 --> 01:27:32,533
就是你们在提交之前做了单元测试

2055
01:27:32,733 --> 01:27:34,366
那这个平台

2056
01:27:34,400 --> 01:27:35,333
我们会利用这个平台

2057
01:27:35,333 --> 01:27:37,099
每4小时去完成一次

2058
01:27:37,533 --> 01:27:38,866
提交上来的单元测试

2059
01:27:38,866 --> 01:27:40,699
和做这个集成测试

2060
01:27:40,700 --> 01:27:43,700
所以4小时会做一次单元测试啊

2061
01:27:43,700 --> 01:27:45,566
6小时会去做一次集成测试

2062
01:27:46,333 --> 01:27:47,966
那单元测试就是以大家提交上的测试

2063
01:27:47,966 --> 01:27:48,899
用力来做的

2064
01:27:49,000 --> 01:27:52,000
所以说你给我看的报告是

2065
01:27:52,066 --> 01:27:53,133
单元测试是OK的

2066
01:27:53,133 --> 01:27:54,266
覆盖率能达到了

2067
01:27:54,533 --> 01:27:56,666
但是如果在提交上的代码

2068
01:27:56,666 --> 01:27:58,166
是存在这个编译错误的话

2069
01:27:58,166 --> 01:28:00,399
这个就会直接扣0.5分

2070
01:28:00,533 --> 01:28:03,499
这就没有没有那个妥协的余地啊

2071
01:28:03,500 --> 01:28:06,600
直接扣0.5分会那个扣完

2072
01:28:06,666 --> 01:28:09,766
那如果说是在平台上做单元测试

2073
01:28:09,766 --> 01:28:10,366
是有错的

2074
01:28:10,366 --> 01:28:11,966
那还是允许你去修改

2075
01:28:12,200 --> 01:28:13,933
去重新再提交上来啊

2076
01:28:13,933 --> 01:28:16,899
那如果到期末如果这个错误

2077
01:28:18,333 --> 01:28:19,366
还存在的话

2078
01:28:19,366 --> 01:28:21,299
那也会去扣你的b座分数

2079
01:28:21,933 --> 01:28:23,299
集成测试的部分

2080
01:28:23,366 --> 01:28:26,199
是会发现你的代码中间

2081
01:28:26,200 --> 01:28:28,366
在单元图中间没有发现的这个错误

2082
01:28:28,366 --> 01:28:29,666
那集成测试的同学

2083
01:28:29,900 --> 01:28:32,066
是要去负责完成的

2084
01:28:32,300 --> 01:28:34,800
所以如果说在学这些书之前

2085
01:28:34,800 --> 01:28:37,566
所有的就是所有的这些bug

2086
01:28:37,566 --> 01:28:38,999
在五天之内没有解决的话

2087
01:28:39,000 --> 01:28:40,800
不论是前面的这个自己单元测试

2088
01:28:40,800 --> 01:28:42,066
还是后面的这个集成测试

2089
01:28:42,066 --> 01:28:43,099
如果没有解决的话

2090
01:28:43,333 --> 01:28:44,699
都会扣0.5分

2091
01:28:45,100 --> 01:28:47,266
直到扣到全部的分数结束为止

2092
01:28:47,366 --> 01:28:49,566
所以我说做b做任务的同学

2093
01:28:49,566 --> 01:28:51,899
是要一直维护到期末的

2094
01:28:51,900 --> 01:28:54,166
这个主要的错误

2095
01:28:54,166 --> 01:28:55,933
就是你自己提压上去的

2096
01:28:55,933 --> 01:28:57,166
这个单元测试的错误

2097
01:28:57,400 --> 01:28:58,966
系统的集成测试的错误

2098
01:28:59,066 --> 01:29:00,799
还有其他同学在用的过程中间

2099
01:29:00,800 --> 01:29:02,933
发现了在集成出集

2100
01:29:02,933 --> 01:29:03,299
成测试

2101
01:29:03,300 --> 01:29:06,866
没有测出来的这些问题都会提交

2102
01:29:07,533 --> 01:29:09,533
那我们在做任务中间

2103
01:29:09,533 --> 01:29:11,066
除了前面的这些任务以外

2104
01:29:11,066 --> 01:29:12,499
我们其实还有一类的任务

2105
01:29:12,500 --> 01:29:14,133
是要做测试类的必做任务

2106
01:29:14,133 --> 01:29:15,399
这个是放到自由轮的

2107
01:29:15,400 --> 01:29:18,066
是没有限定这个数目的啊

2108
01:29:18,066 --> 01:29:20,199
也就是我们这里说的集成测试的

2109
01:29:20,200 --> 01:29:21,100
这些测试用力

2110
01:29:21,100 --> 01:29:23,066
是由同学们

2111
01:29:23,133 --> 01:29:24,733
主要是由同学们来写的

2112
01:29:24,733 --> 01:29:28,066
然后经过我的同意去Mr到系统中间的

2113
01:29:28,066 --> 01:29:30,299
我给大家写一些范例啊

2114
01:29:30,300 --> 01:29:32,300
就怎么去写集成测试的这个用力

2115
01:29:32,400 --> 01:29:33,366
把它提加上去

2116
01:29:33,366 --> 01:29:34,333
让大家去看

2117
01:29:34,800 --> 01:29:36,200
那我们这部分的集成测试的

2118
01:29:36,200 --> 01:29:37,166
这个自由轮的任务

2119
01:29:37,166 --> 01:29:39,199
是以10个测试用力来计算

2120
01:29:39,200 --> 01:29:40,700
成为一个b组任务

2121
01:29:40,933 --> 01:29:42,966
因为我们没有限制上下

2122
01:29:42,966 --> 01:29:44,899
没有设置上上限

2123
01:29:45,066 --> 01:29:46,766
所以如果前面都没有机会

2124
01:29:46,766 --> 01:29:48,333
做任何b组任务的同学

2125
01:29:48,500 --> 01:29:51,333
你可以发夹狠写40个测试用力

2126
01:29:51,566 --> 01:29:54,399
就把b作任务给写满啊

2127
01:29:54,400 --> 01:29:55,133
可能b座

2128
01:29:55,133 --> 01:29:56,866
可能卓越班同学会比较有动力

2129
01:29:56,866 --> 01:29:57,666
是吧

2130
01:29:57,666 --> 01:30:00,066
那就是你可能对于具体去写代码

2131
01:30:00,066 --> 01:30:00,999
觉得太难了

2132
01:30:01,133 --> 01:30:01,899
那没问题

2133
01:30:01,900 --> 01:30:03,800
你去做测试的工作

2134
01:30:03,800 --> 01:30:05,500
就是我们前面有需求工作

2135
01:30:05,666 --> 01:30:07,066
后面有测试的工作

2136
01:30:07,166 --> 01:30:09,066
让那些觉得你动手

2137
01:30:09,066 --> 01:30:10,899
直接去写那些实现代码

2138
01:30:10,900 --> 01:30:12,900
比较难做的同学

2139
01:30:12,900 --> 01:30:16,566
也有机会去把4个b组任务做满啊

2140
01:30:16,566 --> 01:30:18,566
所以后面这个就是10个测试用力

2141
01:30:18,566 --> 01:30:19,799
去完成一个批准

2142
01:30:19,800 --> 01:30:21,000
5所有的测试用力

2143
01:30:21,000 --> 01:30:21,900
我们会单开一个

2144
01:30:21,900 --> 01:30:22,966
集成测试用力会单开一个

2145
01:30:22,966 --> 01:30:24,899
工程同样需要做Mr

2146
01:30:25,066 --> 01:30:25,799
那这个标准

2147
01:30:25,800 --> 01:30:28,500
就是按照我们在软工中间

2148
01:30:28,500 --> 01:30:31,000
做黑核测试的那个标准

2149
01:30:31,133 --> 01:30:32,533
就是你要做一个测试用力

2150
01:30:32,533 --> 01:30:35,299
你肯定是说你是基于一个什么样

2151
01:30:35,300 --> 01:30:36,133
的想法来做

2152
01:30:36,133 --> 01:30:38,333
这个测试用力的基于极限值

2153
01:30:38,500 --> 01:30:40,600
还是基于等价类

2154
01:30:40,700 --> 01:30:42,333
然后你说的这个极限值

2155
01:30:42,333 --> 01:30:43,566
或者你这个等价类

2156
01:30:43,600 --> 01:30:46,533
跟现在已有的测试用力是没有的

2157
01:30:46,533 --> 01:30:48,666
就是你首先要看你已有的测试用力

2158
01:30:48,666 --> 01:30:49,099
然后你发现

2159
01:30:49,100 --> 01:30:51,133
你都有一个极限值没写啊

2160
01:30:51,133 --> 01:30:52,399
这个极限值值得一测

2161
01:30:52,600 --> 01:30:54,166
那你就写一个测试用力

2162
01:30:54,266 --> 01:30:57,066
如果你发现他的这个等加类的划分

2163
01:30:57,066 --> 01:30:58,066
有一个等加类

2164
01:30:58,200 --> 01:30:59,733
里头没有任何一个测试用力

2165
01:30:59,733 --> 01:31:00,899
去测这个等加类

2166
01:31:01,100 --> 01:31:02,766
那你就去做这个等加类

2167
01:31:02,800 --> 01:31:05,600
所以这个部分就是所有的知识

2168
01:31:05,600 --> 01:31:07,200
在软工中间应该有教了

2169
01:31:07,600 --> 01:31:08,266
软工中间

2170
01:31:08,266 --> 01:31:10,999
可能让大家写的是手工的测试用力

2171
01:31:11,166 --> 01:31:12,266
我们这门课中间

2172
01:31:12,266 --> 01:31:13,966
是让大家把那个知识

2173
01:31:13,966 --> 01:31:16,133
用来去写代码的

2174
01:31:16,133 --> 01:31:16,866
测试兄弟

2175
01:31:16,866 --> 01:31:19,066
去自动的去测我们的这个东西

2176
01:31:19,066 --> 01:31:20,166
当然怎么去写极限测试呢

2177
01:31:20,166 --> 01:31:21,566
我会给大家一个范例啊

2178
01:31:21,733 --> 01:31:23,466
我会把地区那个模块

2179
01:31:23,466 --> 01:31:26,199
因为地区模块的最基本就是我写的

2180
01:31:26,333 --> 01:31:28,166
所以会把地区模块的那个集成资金

2181
01:31:28,166 --> 01:31:29,466
用力把它写好

2182
01:31:29,533 --> 01:31:32,066
放上去然后其他两个模块呢

2183
01:31:32,066 --> 01:31:33,333
我尽量写一些啊

2184
01:31:33,333 --> 01:31:34,566
然后写一些

2185
01:31:34,566 --> 01:31:36,899
然后呢大家可以去在上面去做扩展

2186
01:31:38,166 --> 01:31:40,166
这个是这个

2187
01:31:40,166 --> 01:31:41,333
然后最后期末检查

2188
01:31:41,333 --> 01:31:42,866
主要检查的是什么呢

2189
01:31:42,866 --> 01:31:43,966
是选做模块

2190
01:31:44,166 --> 01:31:46,566
那选做模块我们今年跟去年一样

2191
01:31:46,566 --> 01:31:48,566
也就不再去要求大家

2192
01:31:48,566 --> 01:31:50,399
一定要通过测试了

2193
01:31:50,533 --> 01:31:52,999
我们主要是看大家的设计文档代码

2194
01:31:53,000 --> 01:31:54,866
还有假Coco的测试报告

2195
01:31:55,000 --> 01:31:56,333
主要测三个东西

2196
01:31:56,566 --> 01:31:59,499
所以在检查之前

2197
01:31:59,500 --> 01:32:02,200
先把这三个东西提交到课程网站上

2198
01:32:02,200 --> 01:32:04,166
我会开一个检查之前

2199
01:32:04,166 --> 01:32:06,733
提交这个报告的一个作业啊

2200
01:32:06,733 --> 01:32:07,699
把它提交上来

2201
01:32:08,066 --> 01:32:09,299
那我们的检查是什么方式

2202
01:32:09,300 --> 01:32:10,533
我们是用口试的方式

2203
01:32:10,533 --> 01:32:12,866
我大家可能没有考试

2204
01:32:12,866 --> 01:32:14,566
没有经历过考试的方式啊

2205
01:32:14,766 --> 01:32:16,966
考试其实也是一种重要的方式

2206
01:32:17,366 --> 01:32:20,133
那考试之前你们把这个东西提交上来

2207
01:32:20,133 --> 01:32:22,966
那我先就会看你们的设计代码

2208
01:32:22,966 --> 01:32:24,299
和覆盖报告

2209
01:32:24,933 --> 01:32:27,133
我会看完以后会产生一些问题

2210
01:32:27,533 --> 01:32:29,333
那我就会把这些问题

2211
01:32:29,933 --> 01:32:32,066
向你们这个小组来提出来

2212
01:32:32,266 --> 01:32:33,699
因为我不知道你们小组里头

2213
01:32:33,700 --> 01:32:35,566
每一个同学做的任务是什么

2214
01:32:35,566 --> 01:32:37,199
所以我首先是会以

2215
01:32:37,200 --> 01:32:39,366
我看完的详细设计和代码

2216
01:32:39,866 --> 01:32:40,999
我会针对这个详细设计

2217
01:32:41,000 --> 01:32:43,266
中间和代码的问题去提出来

2218
01:32:43,266 --> 01:32:45,499
那你们自己选择说哪个同学去回答

2219
01:32:45,500 --> 01:32:48,900
因为要求考试的时候所有同学都在

2220
01:32:49,166 --> 01:32:51,333
所以你们自己选择哪个同学去回答

2221
01:32:51,566 --> 01:32:52,133
我的问题

2222
01:32:52,133 --> 01:32:53,166
全部问完以后

2223
01:32:53,200 --> 01:32:54,566
如果我发现说

2224
01:32:54,566 --> 01:32:57,399
有一些同学还没有回答过问题

2225
01:32:58,200 --> 01:32:59,266
那我就会要问

2226
01:32:59,266 --> 01:33:00,966
这些同学到底做了哪部分工作

2227
01:33:01,133 --> 01:33:03,499
这个有可能是因为这部同学做的太好

2228
01:33:03,866 --> 01:33:05,166
没有产生任何问题

2229
01:33:05,500 --> 01:33:06,533
那我没问到

2230
01:33:06,666 --> 01:33:08,799
那你就要告诉我说你做了哪部分工作

2231
01:33:08,800 --> 01:33:10,700
然后我去看一下你做了这部分工作

2232
01:33:10,700 --> 01:33:11,266
再来问你

2233
01:33:11,266 --> 01:33:13,199
问题终究的目的

2234
01:33:13,200 --> 01:33:16,400
是叫所有的同学都要被问到

2235
01:33:17,000 --> 01:33:18,500
大家知道这个目的是为了什么

2236
01:33:19,166 --> 01:33:19,933
这个目的就是因为

2237
01:33:19,933 --> 01:33:21,499
我们为什么以小组方式

2238
01:33:21,500 --> 01:33:22,666
来完成这个东西

2239
01:33:22,733 --> 01:33:25,099
我们是希望小组里头的每一个同学

2240
01:33:25,100 --> 01:33:26,100
都要有参与

2241
01:33:26,200 --> 01:33:28,600
你有参与才会知道有什么问题

2242
01:33:28,600 --> 01:33:30,166
才会在小组里头去沟通

2243
01:33:30,166 --> 01:33:31,199
去解决这个问题

2244
01:33:31,333 --> 01:33:33,099
我们最忌讳的事情就是

2245
01:33:33,100 --> 01:33:34,700
小组中间只有3个同学

2246
01:33:34,933 --> 01:33:36,199
或者只有两个同学做

2247
01:33:36,733 --> 01:33:39,899
剩下的3个同学或者两个同学不做

2248
01:33:40,100 --> 01:33:41,000
完全都不做

2249
01:33:41,366 --> 01:33:42,399
那虽然说你们最

2250
01:33:42,400 --> 01:33:45,266
后有可能这两三个同学的能力非常强

2251
01:33:45,533 --> 01:33:46,966
最后交出来这个报告

2252
01:33:46,966 --> 01:33:49,099
或者整个代码都完美无缺

2253
01:33:50,000 --> 01:33:51,000
会打到满分

2254
01:33:51,133 --> 01:33:51,999
但是我也会

2255
01:33:52,000 --> 01:33:53,200
因为这个小组中间

2256
01:33:53,200 --> 01:33:54,866
有两个或者三个同学

2257
01:33:55,100 --> 01:33:56,900
在考试里头被我发现

2258
01:33:56,900 --> 01:33:58,500
他完全没有做任何事情

2259
01:33:59,066 --> 01:34:00,466
会相应的扣一些分数

2260
01:34:00,466 --> 01:34:03,899
就是我会有主观的奖惩的分数

2261
01:34:04,000 --> 01:34:06,733
这个惩的分数就是我在口子里发现

2262
01:34:06,733 --> 01:34:09,599
说这个小组里头有同学完全没有做

2263
01:34:10,100 --> 01:34:11,200
在口子里被发现了

2264
01:34:11,200 --> 01:34:12,866
那我就会在

2265
01:34:13,166 --> 01:34:14,699
虽然你的整个的这个报告

2266
01:34:14,700 --> 01:34:16,266
和前面的过程都很完美

2267
01:34:16,400 --> 01:34:18,733
但是我依然会扣一定的分数

2268
01:34:18,866 --> 01:34:20,133
就是在惩罚说

2269
01:34:20,300 --> 01:34:21,733
小组里头有人

2270
01:34:21,733 --> 01:34:23,533
完全没有参与到这个过程中间

2271
01:34:24,166 --> 01:34:24,999
这个明白吗

2272
01:34:25,700 --> 01:34:28,066
所以还有一个多月的过程中间

2273
01:34:28,100 --> 01:34:29,866
每个小组要想获得高分

2274
01:34:30,000 --> 01:34:32,933
就不要给我扣你分的机会

2275
01:34:33,600 --> 01:34:35,966
口试里头是每个同学都会问到的

2276
01:34:36,366 --> 01:34:37,366
那口试的模式

2277
01:34:37,366 --> 01:34:38,966
我们今年还打算采取这样

2278
01:34:38,966 --> 01:34:41,533
疫情中间的这个钉钉预约的方式啊

2279
01:34:41,766 --> 01:34:42,299
疫情之前

2280
01:34:42,300 --> 01:34:44,166
其实我们并没有依赖于钉钉预约

2281
01:34:44,333 --> 01:34:45,599
所以每年的口试

2282
01:34:45,600 --> 01:34:46,533
就会有一大堆同学

2283
01:34:46,533 --> 01:34:48,733
在我的办公室门口排很长的队

2284
01:34:49,200 --> 01:34:50,200
所以也很麻烦

2285
01:34:50,200 --> 01:34:51,166
大家也很辛苦

2286
01:34:51,166 --> 01:34:53,933
因为每一个小组的考试的时间

2287
01:34:54,600 --> 01:34:56,066
长短不太一样

2288
01:34:56,300 --> 01:34:58,766
看你的问题问的长还是问的短

2289
01:34:58,800 --> 01:35:00,933
一般我们是30分钟之内会解决

2290
01:35:01,333 --> 01:35:04,299
但是有些小组就会问的很长啊

2291
01:35:04,500 --> 01:35:06,966
所以我们还是以钉钉预约的方式

2292
01:35:06,966 --> 01:35:08,599
这样的话大家都会比较舒服一点

2293
01:35:08,600 --> 01:35:10,366
也不用跑到现场来

2294
01:35:10,366 --> 01:35:12,599
但是所有同学都要在线啊

2295
01:35:12,600 --> 01:35:13,733
我们用钉钉会议的方式

2296
01:35:13,733 --> 01:35:15,699
来完成这样的一个口试的过程

2297
01:35:16,500 --> 01:35:17,333
这个有问题吗

2298
01:35:17,333 --> 01:35:18,566
我们今年就是用这种方

2299
01:35:18,566 --> 01:35:19,733
式去检查

2300
01:35:19,733 --> 01:35:22,099
所以选做部分的

2301
01:35:22,166 --> 01:35:26,499
这个其实就是20%的百分之 50左右的

2302
01:35:26,500 --> 01:35:27,300
这个分数

2303
01:35:27,300 --> 01:35:28,800
其实是不会去做测试的

2304
01:35:28,800 --> 01:35:31,866
只是看你们提供的详细设计代码

2305
01:35:31,866 --> 01:35:34,299
和你们针对你们代码

2306
01:35:34,300 --> 01:35:36,166
所做的这个加快过的测试报告

2307
01:35:36,600 --> 01:35:38,700
然后我根据这个静态的

2308
01:35:38,700 --> 01:35:39,966
你们所写的文档

2309
01:35:40,133 --> 01:35:41,899
静态的代码和测试报告

2310
01:35:42,200 --> 01:35:42,933
去判断

2311
01:35:42,933 --> 01:35:45,599
说你们这个设计和实现做的咋样

2312
01:35:47,166 --> 01:35:48,599
然后针对这个去问问题

2313
01:35:49,666 --> 01:35:52,066
这个是我们今年的这个检查办法

2314
01:35:54,533 --> 01:35:55,933
所以检查的最后截止日

2315
01:35:55,933 --> 01:35:59,499
就是我们这个学期的考试周的之前啊

2316
01:35:59,500 --> 01:36:02,300
12月31号 1月1号开始就进入到考试周了

2317
01:36:02,300 --> 01:36:05,566
我们争取在考试前做完啊

2318
01:36:05,566 --> 01:36:07,066
所有班的同学一般会努力

2319
01:36:07,066 --> 01:36:08,199
争取提前一周

2320
01:36:08,300 --> 01:36:11,166
去拿到这个早站了的分数

2321
01:36:12,866 --> 01:36:15,133
是吧努力提前一周完成

2322
01:36:15,133 --> 01:36:16,933
去拿到爪爪鸟的分数

2323
01:36:17,400 --> 01:36:20,866
这个爪爪鸟的奖励就是使得

2324
01:36:20,866 --> 01:36:23,199
不要所有的小组都提到最后一天啊

2325
01:36:23,200 --> 01:36:25,600
这个其实那一天检查也会变得很辛苦

2326
01:36:25,600 --> 01:36:26,166
大家都很辛苦

2327
01:36:26,166 --> 01:36:27,099
我也很辛苦

2328
01:36:27,300 --> 01:36:29,166
所以我们会有爪爪鸟的奖励啊

2329
01:36:29,266 --> 01:36:29,799
尽量多的

2330
01:36:29,800 --> 01:36:31,366
同尽量同学往前提

2331
01:36:33,000 --> 01:36:34,666
这是记分的办法

2332
01:36:34,900 --> 01:36:36,766
那最后我们还有几分钟

2333
01:36:36,766 --> 01:36:37,699
给大家看一下

2334
01:36:38,000 --> 01:36:39,000
我们现在有一位同学

2335
01:36:39,000 --> 01:36:41,966
提交的这个过程是怎么样

2336
01:36:42,400 --> 01:36:44,133
我把他的Mr给关了

2337
01:36:44,133 --> 01:36:45,266
没让他通过

2338
01:36:52,500 --> 01:36:54,800
所以当同学们提交了这个Mr前

2339
01:36:54,800 --> 01:36:56,166
他又提交上来了是吧

2340
01:36:58,300 --> 01:36:59,600
那我待会课后跟你讲说

2341
01:36:59,600 --> 01:37:00,900
我为什么把你关掉啊

2342
01:37:01,500 --> 01:37:02,733
我先可以给大家看一下

2343
01:37:02,733 --> 01:37:04,333
我关掉关掉

2344
01:37:04,533 --> 01:37:07,199
他提交上来的这个已被我关闭了

2345
01:37:09,766 --> 01:37:11,133
当他提交到服务器上去

2346
01:37:11,133 --> 01:37:12,933
大家都能看到他做的是啥啊

2347
01:37:12,933 --> 01:37:13,566
那第一来说

2348
01:37:13,566 --> 01:37:14,499
你的这个标题

2349
01:37:14,500 --> 01:37:16,200
应该把你的任务的编号任

2350
01:37:16,200 --> 01:37:18,466
务的这个写上去啊

2351
01:37:23,866 --> 01:37:25,599
我刚才一直没有切到这个

2352
01:37:25,600 --> 01:37:27,166
这个吗你们的一直没提

2353
01:37:32,100 --> 01:37:33,100
呃大家可以看到

2354
01:37:33,100 --> 01:37:35,200
在这上面提的这个Mr的请求

2355
01:37:40,900 --> 01:37:42,600
我会针对他的所有

2356
01:37:42,600 --> 01:37:43,700
他其实提交上来以后

2357
01:37:43,700 --> 01:37:44,366
他所有的代码

2358
01:37:44,366 --> 01:37:45,499
大家都能看到他做了啥

2359
01:37:45,500 --> 01:37:48,366
他做的是那个Kobe from的修改

2360
01:37:48,866 --> 01:37:51,199
所以你能看到他对原有代码改了什么

2361
01:37:51,933 --> 01:37:52,166
呃

2362
01:37:52,166 --> 01:37:53,999
我之前有跟他说测试用力是不要写的

2363
01:37:54,000 --> 01:37:56,000
但是我后来发现这个还是要写

2364
01:37:56,000 --> 01:37:57,533
因为他这个影响面太大了

2365
01:37:57,600 --> 01:37:58,933
不写测试代码的话

2366
01:37:59,300 --> 01:38:01,966
这个改进去会造成很大的问题

2367
01:38:02,066 --> 01:38:02,799
那第一个是

2368
01:38:02,800 --> 01:38:04,700
他这部分是不需要改泡沫键的

2369
01:38:05,066 --> 01:38:06,199
所以他改装了泡沫键

2370
01:38:06,200 --> 01:38:08,533
我就会毫不犹豫的把它关掉

2371
01:38:08,533 --> 01:38:10,466
因为泡沫键对大家的影响太大了

2372
01:38:10,966 --> 01:38:14,533
第二是他这里是不会动到这个文件的

2373
01:38:14,533 --> 01:38:16,299
但是他这里动到这个文件了

2374
01:38:16,300 --> 01:38:18,100
所以你改到你没有动到的文件

2375
01:38:18,100 --> 01:38:19,966
我也会把它干掉啊

2376
01:38:20,400 --> 01:38:22,066
那其他的部分来说

2377
01:38:22,066 --> 01:38:23,366
我会针对他的

2378
01:38:23,366 --> 01:38:24,966
里头写的代码有什么问题

2379
01:38:24,966 --> 01:38:26,733
目前看好像看不出什么问题

2380
01:38:26,966 --> 01:38:28,099
所以这个你从代码看

2381
01:38:28,100 --> 01:38:28,900
看不出问题了

2382
01:38:28,900 --> 01:38:31,000
那我只能要求他要做测试用力了

2383
01:38:31,333 --> 01:38:32,666
所以课后找我一下

2384
01:38:32,666 --> 01:38:33,766
我告诉你怎么做测试用力

2385
01:38:33,766 --> 01:38:34,399
其实你能看到

2386
01:38:34,400 --> 01:38:36,366
去年陈一鸣同学做的测试用力

2387
01:38:36,366 --> 01:38:38,599
就按照他那个方式去做测试用力

2388
01:38:38,766 --> 01:38:42,566
去测试说你这个写的代码是否是OK的

2389
01:38:42,800 --> 01:38:43,566
好吧

2390
01:38:43,566 --> 01:38:46,133
所以同样要达到一定的代码覆盖率

2391
01:38:46,133 --> 01:38:47,533
保证说你改动他的代码

2392
01:38:47,533 --> 01:38:48,733
他的代码也是正确的

2393
01:38:48,733 --> 01:38:50,099
因为这个color object的

2394
01:38:50,100 --> 01:38:52,600
这个就是cloud factory

2395
01:38:52,600 --> 01:38:53,900
这个类太重要了

2396
01:38:53,900 --> 01:38:54,666
如果它错的话

2397
01:38:54,666 --> 01:38:56,799
我们整体的代码就全会错

2398
01:38:56,800 --> 01:38:58,700
掉所以它提交上来

2399
01:38:58,700 --> 01:39:00,066
大家能看到它改了什么

2400
01:39:00,066 --> 01:39:03,099
然后能看到说我提的意见

2401
01:39:03,333 --> 01:39:06,166
这个部分其实对于大家学会去做设计

2402
01:39:06,166 --> 01:39:08,499
以及学会去写代码的时候非常的重要

2403
01:39:08,866 --> 01:39:10,199
因为一直在说

2404
01:39:10,200 --> 01:39:12,666
设计和代码不是一个单项的过程

2405
01:39:12,733 --> 01:39:15,166
如果大家盲盲目的去自学

2406
01:39:15,166 --> 01:39:17,199
或者自己去闷头去学

2407
01:39:17,866 --> 01:39:19,499
这个需要付出很大的代价

2408
01:39:19,500 --> 01:39:21,800
因为所有的弯路你都需要走到

2409
01:39:21,933 --> 01:39:23,699
你才会知道这个东西是什么

2410
01:39:23,700 --> 01:39:24,066
但现在

2411
01:39:24,066 --> 01:39:26,133
我们采用这种公开的code review的方式

2412
01:39:26,133 --> 01:39:26,733
你就能看到

2413
01:39:26,733 --> 01:39:27,899
特别做同样的任务

2414
01:39:28,066 --> 01:39:30,199
你能看到其他同学提交上来的代码

2415
01:39:30,266 --> 01:39:32,133
能看到我在其他同学的代码上的

2416
01:39:32,133 --> 01:39:33,333
提出的这个意见

2417
01:39:33,500 --> 01:39:34,533
所以如果你做同样的任务

2418
01:39:34,533 --> 01:39:35,766
你就赶快把这个问题

2419
01:39:35,766 --> 01:39:37,166
在你代码中间把它改掉

2420
01:39:37,366 --> 01:39:38,366
然后提交上来

2421
01:39:38,366 --> 01:39:40,566
我最后是以更新的日期来看

2422
01:39:40,566 --> 01:39:45,499
说这个这个呃问题的这个东西的

2423
01:39:45,500 --> 01:39:49,333
啊所以这是如何来做这个必做任务

2424
01:39:49,333 --> 01:39:50,899
因为第一个有提交上来了

2425
01:39:50,966 --> 01:39:51,699
给大家看一下

2426
01:39:51,700 --> 01:39:54,100
所以大家自己可以看一下这个过程

2427
01:39:54,100 --> 01:39:55,766
其他一提交上来大家都能看得见

2428
01:39:56,533 --> 01:39:57,733
好今天课就到这里

