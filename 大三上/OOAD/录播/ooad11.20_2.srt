1
00:00:23,700 --> 00:00:24,966
好第二节课

2
00:00:24,966 --> 00:00:29,666
我们把支付模块在今天再讲几个例子

3
00:00:29,666 --> 00:00:32,733
然后就结束了这个支付模块

4
00:00:33,000 --> 00:00:36,333
然后周三开始我们开始讲产品模块

5
00:00:37,566 --> 00:00:38,199
支付模块

6
00:00:38,200 --> 00:00:41,800
我们还想讲这么三个例子啊

7
00:00:41,800 --> 00:00:42,700
我现在讲的时候

8
00:00:42,700 --> 00:00:45,566
就以我在考试时候会出题的方式来讲

9
00:00:45,566 --> 00:00:46,899
啊我们考试时候

10
00:00:46,900 --> 00:00:49,000
我们后面说的两道分析题

11
00:00:49,000 --> 00:00:49,866
和一道设计题

12
00:00:49,866 --> 00:00:51,933
就基本上是从我们讲过的

13
00:00:51,933 --> 00:00:52,666
这一个个的例子

14
00:00:52,666 --> 00:00:53,599
中间出的

15
00:00:54,200 --> 00:00:57,500
那我们讲的第一个例子是这个支付

16
00:00:58,100 --> 00:00:59,700
支付是一个内部APR

17
00:01:00,366 --> 00:01:03,066
这个APR并不是完成我们的支付过程

18
00:01:03,066 --> 00:01:03,566
我们知道

19
00:01:03,566 --> 00:01:04,299
支付过程

20
00:01:04,300 --> 00:01:10,333
需要在前端去通过调他的支付宝

21
00:01:10,500 --> 00:01:13,400
或者调微信支付去完成

22
00:01:13,500 --> 00:01:14,933
不是在后端来完成

23
00:01:15,500 --> 00:01:18,800
但是在前端开始调那个APP之前

24
00:01:19,066 --> 00:01:21,199
是需要提供一系列的参数的

25
00:01:21,466 --> 00:01:24,466
这些参数是需要通过后端的API

26
00:01:24,666 --> 00:01:25,399
去调一下

27
00:01:25,400 --> 00:01:28,266
支付渠道把返回值返回给前端

28
00:01:28,400 --> 00:01:30,566
前端才能用返回这些参数

29
00:01:30,733 --> 00:01:33,799
去调那个对应的APP的

30
00:01:34,700 --> 00:01:37,466
那我们在后端设计这个APM

31
00:01:37,466 --> 00:01:37,966
我们可以看到

32
00:01:37,966 --> 00:01:40,966
我们定义了一系列的这个输入值

33
00:01:40,966 --> 00:01:44,466
输入值其实主要是说这个啊

34
00:01:44,466 --> 00:01:45,566
支付的时间

35
00:01:45,866 --> 00:01:46,866
支付多少钱

36
00:01:46,900 --> 00:01:47,966
分账多少钱

37
00:01:48,300 --> 00:01:48,900
这个注意

38
00:01:48,900 --> 00:01:49,733
因为支付的时候

39
00:01:49,733 --> 00:01:51,666
要有平台分给平台的钱

40
00:01:51,766 --> 00:01:52,766
所以我们其实支付的时候

41
00:01:52,766 --> 00:01:53,666
是要把支付多少钱

42
00:01:53,666 --> 00:01:55,599
分账多少钱都要告诉我们的

43
00:01:55,600 --> 00:01:57,733
这里返回值是什么呢

44
00:01:57,733 --> 00:01:59,133
返回值其实我们现在

45
00:01:59,133 --> 00:02:02,333
因为后端只支持了两个支付渠道

46
00:02:02,733 --> 00:02:05,099
我们的微信支付渠道

47
00:02:05,100 --> 00:02:06,700
只需要一个值就够了

48
00:02:06,700 --> 00:02:07,466
prepaid ID

49
00:02:07,466 --> 00:02:08,466
当然还有别的

50
00:02:08,566 --> 00:02:09,966
那些别的我们就把它省了

51
00:02:09,966 --> 00:02:10,866
它那个加密啊

52
00:02:10,866 --> 00:02:12,166
那些密钥我们都省了

53
00:02:12,333 --> 00:02:15,299
它需要的有意义的值就是一个prepaid ID

54
00:02:15,900 --> 00:02:19,600
那这个值是用来去调取前端支付的

55
00:02:21,066 --> 00:02:22,533
支付宝需要4个值

56
00:02:22,533 --> 00:02:23,866
需要这个alternate number

57
00:02:23,866 --> 00:02:24,899
需要total amount

58
00:02:24,900 --> 00:02:26,300
需要这个sailor ID

59
00:02:26,566 --> 00:02:31,899
还需要这个叫做merchant order啊number

60
00:02:31,900 --> 00:02:32,900
需要这四个字

61
00:02:33,200 --> 00:02:35,766
才能调取它的前端的支付

62
00:02:35,966 --> 00:02:36,866
那我们可以看到

63
00:02:36,866 --> 00:02:38,866
我们在返回值的这个部分的时候

64
00:02:38,933 --> 00:02:40,699
的设计是一个简单粗暴

65
00:02:41,100 --> 00:02:43,333
就是我们两个支付渠道

66
00:02:43,333 --> 00:02:44,799
所需要的返回值

67
00:02:44,800 --> 00:02:45,766
是完全不一样

68
00:02:45,866 --> 00:02:47,133
我们把它简单粗暴的

69
00:02:47,133 --> 00:02:49,499
合到了这个最终的结果里头

70
00:02:49,500 --> 00:02:50,766
就全合在一起

71
00:02:51,266 --> 00:02:52,733
所以大家知道这个设计

72
00:02:53,133 --> 00:02:54,166
从API设计上说

73
00:02:54,166 --> 00:02:55,899
这个API设计有什么样问题呢

74
00:02:56,533 --> 00:02:57,333
大家觉得

75
00:02:59,400 --> 00:03:00,100
这个iPad设计

76
00:03:00,100 --> 00:03:03,733
如果说云闪付上来这个API是要改的

77
00:03:04,900 --> 00:03:06,100
不但API要改

78
00:03:06,133 --> 00:03:07,699
而且接口也要改

79
00:03:07,700 --> 00:03:08,566
所有东西都要改

80
00:03:09,000 --> 00:03:11,166
所以我们说的开闭原则

81
00:03:11,600 --> 00:03:13,800
前提是我们那个抽象

82
00:03:14,100 --> 00:03:14,933
能够涵盖

83
00:03:14,933 --> 00:03:17,533
我们未来所发生的所有的事情

84
00:03:17,533 --> 00:03:19,599
就是在这个图里头啊

85
00:03:20,466 --> 00:03:20,866
大家知道

86
00:03:20,866 --> 00:03:22,666
我们从现在这个API就能看出来

87
00:03:22,666 --> 00:03:23,966
说我们现在的设计

88
00:03:24,300 --> 00:03:26,766
其实是没有办法做到理想的

89
00:03:26,766 --> 00:03:27,733
开辟原则的

90
00:03:27,733 --> 00:03:28,199
原因是

91
00:03:28,200 --> 00:03:30,666
当我们出现一个新的支付渠道的时候

92
00:03:31,000 --> 00:03:32,800
我们这个接口会要发生变动

93
00:03:32,800 --> 00:03:34,133
因为我们现在接口设计

94
00:03:34,133 --> 00:03:36,566
没有考虑到第三个渠道

95
00:03:36,566 --> 00:03:37,933
就未来会出现的渠道

96
00:03:37,933 --> 00:03:38,799
它会是什么

97
00:03:38,966 --> 00:03:40,933
如果出现这个渠道的返回值

98
00:03:40,933 --> 00:03:43,133
恰好跟微信和支付宝是一样的

99
00:03:43,300 --> 00:03:44,666
或者涵盖在这个里头

100
00:03:44,966 --> 00:03:46,566
那就不需要改动

101
00:03:46,700 --> 00:03:49,700
如果出现了它有它自己很特别的值

102
00:03:50,133 --> 00:03:51,099
这个就会感动

103
00:03:51,366 --> 00:03:53,166
所以所有的设计原则都是

104
00:03:53,166 --> 00:03:54,333
理想状态下的

105
00:03:54,566 --> 00:03:57,199
但是我们如果在这理想状态下头

106
00:03:57,200 --> 00:03:58,000
他能够

107
00:03:59,300 --> 00:04:00,966
呃去做到这一点

108
00:04:00,966 --> 00:04:01,733
那是最好

109
00:04:01,733 --> 00:04:03,499
但实际上我们在做设计的时候

110
00:04:03,500 --> 00:04:03,933
我们可以看到

111
00:04:03,933 --> 00:04:07,566
我们现在的原则是试用为准

112
00:04:07,866 --> 00:04:09,099
并没有去预想说

113
00:04:09,100 --> 00:04:12,000
我们现在还没有做到的这些支付渠道

114
00:04:12,000 --> 00:04:13,000
它会是什么样

115
00:04:13,000 --> 00:04:15,200
而是完全根据我们当前是什么样的

116
00:04:15,200 --> 00:04:16,100
我们做成什么样的

117
00:04:16,300 --> 00:04:18,266
那如果说当前这个样子

118
00:04:18,266 --> 00:04:20,266
不能满足未来的支付渠道的话

119
00:04:20,300 --> 00:04:22,333
我们就会去动那个中间

120
00:04:22,333 --> 00:04:23,399
那个接口的定义

121
00:04:23,400 --> 00:04:24,533
会动前面这个定义

122
00:04:24,533 --> 00:04:26,933
当然他就不能完全满足支付渠道啊

123
00:04:26,933 --> 00:04:28,866
不能完全满足开闭原则

124
00:04:29,333 --> 00:04:32,733
但是我们其实也没有去做一个

125
00:04:32,733 --> 00:04:34,399
这种未来性的设计啊

126
00:04:34,700 --> 00:04:35,566
这是这个API

127
00:04:35,566 --> 00:04:36,566
大家所看到的

128
00:04:36,600 --> 00:04:38,333
这个我们现在的局限性

129
00:04:40,500 --> 00:04:42,900
设计大家从这张图上应该能看到

130
00:04:42,900 --> 00:04:44,566
说他基本的逻辑

131
00:04:44,566 --> 00:04:47,133
我们被分配到了shop channel里头

132
00:04:48,266 --> 00:04:49,866
也就是总体上来说

133
00:04:49,866 --> 00:04:50,899
我们在这个部分来说

134
00:04:50,900 --> 00:04:53,200
我们把业务逻辑分配到业务对象里

135
00:04:53,700 --> 00:04:55,466
所以当我把这张图

136
00:04:55,466 --> 00:04:56,566
就是我们以考试的方式

137
00:04:56,566 --> 00:04:57,799
我会把这张图给你

138
00:04:58,100 --> 00:05:00,466
会跟你说这是这个API

139
00:05:00,966 --> 00:05:02,599
用来创建支付单的

140
00:05:02,766 --> 00:05:04,299
然后把这张图给你

141
00:05:04,733 --> 00:05:05,899
你说这个设计怎么样

142
00:05:06,866 --> 00:05:07,866
有没有什么问题

143
00:05:09,133 --> 00:05:10,899
那如果是分析题的话

144
00:05:11,466 --> 00:05:13,599
就是基本上是不会让你挑错的

145
00:05:13,600 --> 00:05:15,466
分析题就是让让你看出来

146
00:05:15,466 --> 00:05:16,599
说在这个设计中间

147
00:05:16,933 --> 00:05:19,199
到底我们在哪些地方

148
00:05:19,200 --> 00:05:21,900
用了面向对象的Grasp的7种方法

149
00:05:22,133 --> 00:05:25,566
还有软件设计的七个原则

150
00:05:25,666 --> 00:05:27,733
就是在这个七个方法和七个原则

151
00:05:27,766 --> 00:05:30,533
在上面所以我们是不会不会跟你说

152
00:05:30,533 --> 00:05:31,599
这个需求是什么啊

153
00:05:31,600 --> 00:05:33,400
就直接就把这个东西

154
00:05:33,400 --> 00:05:35,100
丢给你让你去做分析

155
00:05:35,300 --> 00:05:36,400
所以在这个设计中间

156
00:05:36,600 --> 00:05:39,933
他的面向对象的设计原则

157
00:05:40,100 --> 00:05:42,533
他的刮手方法用在什么地方呢

158
00:05:45,200 --> 00:05:46,466
这个设计来说啊

159
00:05:46,533 --> 00:05:47,799
第一是用在这个地方

160
00:05:48,733 --> 00:05:51,566
这个地方的抉择是

161
00:05:51,566 --> 00:05:55,333
我们用了创建者的模式

162
00:05:55,333 --> 00:05:57,299
因为我们认为一个支付

163
00:05:58,266 --> 00:05:59,299
就是支付对象

164
00:05:59,300 --> 00:06:01,366
这个paychen的这个对象

165
00:06:02,566 --> 00:06:03,766
这个支付对象

166
00:06:03,966 --> 00:06:08,966
他是跟渠道对象是组合关系

167
00:06:09,200 --> 00:06:10,933
因为任何一个支付

168
00:06:11,000 --> 00:06:12,766
必是一个渠道的支付

169
00:06:13,066 --> 00:06:15,099
他不可能是两个渠道的支付

170
00:06:15,166 --> 00:06:16,999
也不可能脱离任何一个渠道

171
00:06:17,000 --> 00:06:18,566
而存在的一个支付对象

172
00:06:18,766 --> 00:06:22,533
所以支付对象和他是一个组合关系

173
00:06:23,100 --> 00:06:24,600
那正是因为这个组合关系

174
00:06:24,600 --> 00:06:27,266
所以当我们要去创建一个支付的时候

175
00:06:27,333 --> 00:06:30,066
我们用创建者模式

176
00:06:30,100 --> 00:06:33,400
把这个职责分配给了shop channel的对象

177
00:06:33,600 --> 00:06:35,533
那从而使得创建这个逻辑

178
00:06:35,533 --> 00:06:37,699
就全部到了

179
00:06:37,700 --> 00:06:41,066
这个so channel的这个对象里头啊

180
00:06:41,066 --> 00:06:43,799
去实现这个是第一个

181
00:06:44,000 --> 00:06:45,266
那分过来以后

182
00:06:45,266 --> 00:06:45,799
大家可以看到

183
00:06:45,800 --> 00:06:48,533
里头的这个做法都不是面向对象

184
00:06:48,533 --> 00:06:49,399
我们的做法是

185
00:06:49,400 --> 00:06:52,000
我们首先把这个配圈的对象

186
00:06:52,000 --> 00:06:53,400
插到数据库里去了

187
00:06:53,666 --> 00:06:55,133
这个配圈的对象

188
00:06:55,733 --> 00:06:56,733
我们说这个配件对象

189
00:06:56,733 --> 00:06:59,099
就是从最前面传过来的

190
00:06:59,100 --> 00:07:00,000
这个配件对象

191
00:07:00,133 --> 00:07:04,133
就是从control层把它包装好了以后

192
00:07:04,333 --> 00:07:05,733
丢给service层

193
00:07:05,733 --> 00:07:07,999
service层要把它丢给了我们的

194
00:07:08,000 --> 00:07:09,700
这个selfchannel的对象传过来

195
00:07:09,700 --> 00:07:11,700
然后我们用它把它插进去

196
00:07:12,100 --> 00:07:14,666
这个对象我们给它专门叫个名称

197
00:07:14,966 --> 00:07:17,866
这种对象我们称之为值对象

198
00:07:26,300 --> 00:07:27,666
英文叫做value object

199
00:07:27,966 --> 00:07:29,599
为什么我们称它为直对象

200
00:07:29,600 --> 00:07:30,200
是因为

201
00:07:30,200 --> 00:07:32,766
我们要跟后面的这个对象来做区分

202
00:07:33,066 --> 00:07:33,799
我们可以看到

203
00:07:33,800 --> 00:07:35,600
当我们把这个对象插进去以后

204
00:07:35,600 --> 00:07:37,100
我们又立马从数据库里

205
00:07:37,333 --> 00:07:39,666
就是又调它的稻城的方法翻的BYD

206
00:07:39,666 --> 00:07:41,533
又把这个对象给找出来

207
00:07:42,133 --> 00:07:45,599
大家会觉得很很很啰嗦是吧

208
00:07:45,900 --> 00:07:48,800
为什么把它插进去以后又把它找出来

209
00:07:48,866 --> 00:07:51,066
因为插进去之前它是直对象

210
00:07:51,400 --> 00:07:53,866
找出来以后它是满血对象

211
00:07:54,300 --> 00:07:55,700
也就是它里头是有

212
00:07:55,733 --> 00:07:57,599
我们在这个设计中间

213
00:08:03,800 --> 00:08:05,566
我们在设计中间的这个pay圈对象

214
00:08:05,566 --> 00:08:07,799
实际上是跟这些倒对象有关联

215
00:08:08,300 --> 00:08:09,366
有关联的这些

216
00:08:09,366 --> 00:08:12,066
当这些陪衬对象称之为满血对象

217
00:08:12,266 --> 00:08:13,299
那如果说

218
00:08:13,300 --> 00:08:15,933
我们在最开始传建的那个陪衬对象

219
00:08:16,066 --> 00:08:18,299
其实这些关联都是没有的

220
00:08:18,566 --> 00:08:19,899
他只指简简单单

221
00:08:19,900 --> 00:08:21,966
就是为了承担一个值的

222
00:08:22,100 --> 00:08:23,966
这个值是在它的属性里头

223
00:08:24,133 --> 00:08:27,099
所以那种对象我们称之为value object

224
00:08:27,100 --> 00:08:28,866
或者称之为值对象

225
00:08:30,866 --> 00:08:33,333
所以这里我们插进去的是直对象

226
00:08:33,666 --> 00:08:34,933
这是一个只有直的东西

227
00:08:34,933 --> 00:08:36,066
从前面传过来的

228
00:08:36,266 --> 00:08:37,999
用它来插入数据库

229
00:08:38,733 --> 00:08:39,399
做完了以后

230
00:08:39,400 --> 00:08:40,966
我们在这数据里找出来的

231
00:08:40,966 --> 00:08:43,566
就是因为经过了稻城的那个build方法

232
00:08:43,866 --> 00:08:45,699
build出来的一个满血对象

233
00:08:45,700 --> 00:08:48,133
里头所有的稻都有做好

234
00:08:48,333 --> 00:08:50,466
那为什么我们需要一个满血对象

235
00:08:50,466 --> 00:08:51,733
因为这个满血对象

236
00:08:52,000 --> 00:08:55,733
是作为我们的这个接口的方法的参数

237
00:08:55,733 --> 00:08:56,533
传过去的

238
00:08:56,900 --> 00:08:58,466
我们在传一个餐的时候

239
00:08:58,466 --> 00:09:00,266
在面向对象人员传餐的时候

240
00:09:00,266 --> 00:09:03,199
我们通常是传他最根本的对象

241
00:09:03,266 --> 00:09:05,599
因为大家去看这个credit payment这个方法

242
00:09:05,600 --> 00:09:08,100
无论是阿里pay的还是Wechat pay的

243
00:09:08,400 --> 00:09:08,733
其实里头

244
00:09:08,733 --> 00:09:11,133
都不仅仅用到了这个支付对象

245
00:09:11,266 --> 00:09:12,699
他还用到了渠道对象

246
00:09:12,800 --> 00:09:13,900
但是我们在传的时候

247
00:09:13,900 --> 00:09:15,900
我们传的是支付对象

248
00:09:16,133 --> 00:09:17,733
啊没有传渠道对象

249
00:09:17,733 --> 00:09:18,666
原因是什么

250
00:09:18,766 --> 00:09:20,499
原因是因为我们在对象模型里头

251
00:09:20,500 --> 00:09:21,466
我们可以看到

252
00:09:28,866 --> 00:09:29,666
我们可以看到

253
00:09:29,666 --> 00:09:32,599
支付对象和渠道对象是存在的关联

254
00:09:33,733 --> 00:09:35,966
对吧所以我们传的这个支付对象

255
00:09:35,966 --> 00:09:37,733
其实传的是这个支付对象

256
00:09:38,533 --> 00:09:39,966
这个支付对象是有一个关联

257
00:09:39,966 --> 00:09:41,266
直接靠的渠道对象的

258
00:09:41,266 --> 00:09:44,366
而这个关联靠的是用刀对象查出来的

259
00:09:44,366 --> 00:09:45,599
就是我们的满血对象

260
00:09:45,600 --> 00:09:46,333
是具备说

261
00:09:46,333 --> 00:09:48,066
把我们的这张图上看到的

262
00:09:48,066 --> 00:09:49,499
所有对象的关联

263
00:09:49,500 --> 00:09:52,866
全部给他恢复出来的这样的一个能力

264
00:09:53,333 --> 00:09:55,933
所以我们需要把一个满血的陪衬对象

265
00:09:55,933 --> 00:09:57,399
传到后面去

266
00:09:57,600 --> 00:09:59,900
传到那个支付渠道里去

267
00:09:59,900 --> 00:10:02,300
而支付渠道会通过这个关系

268
00:10:02,466 --> 00:10:04,666
获得他关联的其他的对象

269
00:10:05,266 --> 00:10:07,466
所以这是面向对象中间的一个设计的

270
00:10:07,466 --> 00:10:08,466
最基本的原则

271
00:10:08,700 --> 00:10:09,533
船只的时候

272
00:10:09,533 --> 00:10:10,999
船最根本的对象

273
00:10:11,266 --> 00:10:12,266
而不是船

274
00:10:12,466 --> 00:10:13,099
把它分开

275
00:10:13,100 --> 00:10:16,600
船让我们再传过去以后

276
00:10:16,600 --> 00:10:18,900
在里头去得到他其他对象

277
00:10:18,966 --> 00:10:19,966
那这个里头大家知道

278
00:10:19,966 --> 00:10:23,866
这是会去调阿里配或者微配的接口

279
00:10:23,900 --> 00:10:24,466
调完了以后

280
00:10:24,466 --> 00:10:27,599
把它的返回值再刷新到这个对象上头

281
00:10:27,700 --> 00:10:30,066
然后存到数据库里返回

282
00:10:30,333 --> 00:10:32,466
这是这个设计

283
00:10:32,533 --> 00:10:34,566
我们看一下它的代码啊

284
00:10:39,333 --> 00:10:40,966
我们从controls开始看起

285
00:10:42,166 --> 00:10:43,733
这个看代码的时候

286
00:10:43,733 --> 00:10:45,133
因为它是一个内部接口

287
00:10:45,133 --> 00:10:46,999
所以我们在这个internal的

288
00:10:47,000 --> 00:10:48,133
这个payment里头

289
00:10:48,800 --> 00:10:51,533
这是它的内部的接口啊

290
00:10:51,533 --> 00:10:52,566
这是因为单内部接口

291
00:10:52,566 --> 00:10:53,899
中心在这个方面的中间

292
00:10:54,333 --> 00:10:54,999
这个就是它的

293
00:10:55,000 --> 00:10:56,800
这个在control存代码

294
00:10:56,800 --> 00:10:57,500
我们可以看到

295
00:10:57,500 --> 00:10:59,666
我们在一些图上没有画的内容

296
00:10:59,766 --> 00:11:02,133
这部分的衣服在判断的是什么

297
00:11:02,600 --> 00:11:04,366
判断的是输入的合法性

298
00:11:04,533 --> 00:11:05,566
我们的输入合法性

299
00:11:05,566 --> 00:11:07,299
其实有部分不是靠代码来写的

300
00:11:07,300 --> 00:11:11,300
是靠这个VO的界项的validate去完成的

301
00:11:11,400 --> 00:11:12,966
所以靠的是validate

302
00:11:13,000 --> 00:11:14,333
就去做了合法性认证

303
00:11:14,533 --> 00:11:16,066
但是那个合法行证不够

304
00:11:16,133 --> 00:11:17,299
因为有一些的合法行证

305
00:11:17,300 --> 00:11:19,533
是没办法用这个validate去完成的

306
00:11:19,600 --> 00:11:21,600
比如说他的啊

307
00:11:21,600 --> 00:11:24,533
过期时间必须在开始时间之后

308
00:11:25,166 --> 00:11:27,333
比如说他的分账的金额

309
00:11:27,333 --> 00:11:31,766
必须要小于这个付款的支付的金额

310
00:11:31,766 --> 00:11:33,599
对吧像这些逻辑

311
00:11:33,600 --> 00:11:35,700
是没办法在那个window中间去写

312
00:11:35,700 --> 00:11:36,733
那就没办法

313
00:11:36,933 --> 00:11:39,499
只好写在了Controller层的代码中间

314
00:11:39,766 --> 00:11:42,366
所以这里啊再次给大家强调一下

315
00:11:42,366 --> 00:11:44,466
我们每一层写什么样的代码

316
00:11:44,766 --> 00:11:46,533
是有一定的规则的

317
00:11:46,800 --> 00:11:47,533
这个也就是说

318
00:11:47,533 --> 00:11:49,966
我们每一层是有特定的职责的

319
00:11:50,166 --> 00:11:51,999
在控制层我再强调一下

320
00:11:52,000 --> 00:11:54,066
他做的是输入和输出

321
00:11:54,766 --> 00:11:56,199
输入数据的合法性

322
00:11:56,800 --> 00:12:00,066
输入数据转成我们的面向对象的模型

323
00:12:00,500 --> 00:12:05,100
输出数据从对象模型转成我们所要的

324
00:12:05,200 --> 00:12:07,333
前端所要的那个数据结构

325
00:12:07,600 --> 00:12:08,533
所以大家可以看到

326
00:12:08,533 --> 00:12:09,299
在这段代码中间

327
00:12:09,300 --> 00:12:11,333
就明显的做了这三件事情

328
00:12:11,333 --> 00:12:12,933
第一输入数据的合法性

329
00:12:13,366 --> 00:12:14,699
无论是通过它的body day

330
00:12:14,766 --> 00:12:15,499
还是通过它

331
00:12:15,500 --> 00:12:17,600
在里头用代码去写的合法性检查

332
00:12:17,933 --> 00:12:20,399
第二把这个VO的对象

333
00:12:20,800 --> 00:12:23,666
转成了我们说的这个配券的对象

334
00:12:23,900 --> 00:12:25,566
这个转的过程大家知道

335
00:12:25,566 --> 00:12:27,533
它不是一个满血模型

336
00:12:27,700 --> 00:12:29,566
它转出来的是一个直对象

337
00:12:29,566 --> 00:12:32,333
就我们这里说的这个值对象

338
00:12:32,733 --> 00:12:34,333
只是把VO里头的值

339
00:12:34,333 --> 00:12:37,399
拷贝到了我们的配圈对象中间

340
00:12:37,400 --> 00:12:40,366
那配圈中间所有的关系都拿不到的

341
00:12:40,700 --> 00:12:42,533
所以你在用这个对象的时候

342
00:12:42,533 --> 00:12:44,533
我们这里写代码其实没有写的很规范

343
00:12:44,533 --> 00:12:45,799
我们其实应该在标志说

344
00:12:45,800 --> 00:12:46,966
这不是一个满血对象

345
00:12:46,966 --> 00:12:48,199
而是一个普通的对象

346
00:12:48,400 --> 00:12:49,400
你是不能去调他的

347
00:12:49,400 --> 00:12:50,700
什么get那些东西

348
00:12:50,700 --> 00:12:51,733
拿到其他东西的

349
00:12:51,733 --> 00:12:54,133
拿不到只是用来传职的

350
00:12:54,300 --> 00:12:56,800
而把这个传职的对象作为参数

351
00:12:56,966 --> 00:12:59,466
给他送到了收费层去

352
00:12:59,666 --> 00:13:00,933
收费层的返回值

353
00:13:00,933 --> 00:13:01,533
我们可以看到

354
00:13:01,533 --> 00:13:03,099
这里我们并没有去做加工

355
00:13:03,133 --> 00:13:05,566
就直接把它返回回去了啊

356
00:13:05,566 --> 00:13:07,799
所以这个就是直接把收费层的返回值

357
00:13:07,800 --> 00:13:09,133
直接丢丢回去了

358
00:13:09,266 --> 00:13:10,366
但是其他的代码

359
00:13:10,366 --> 00:13:12,333
很多其他代码其实都有做了加工的

360
00:13:12,900 --> 00:13:15,700
这是Controller层的代码

361
00:13:15,933 --> 00:13:17,266
那收费层代码就我们图上画的

362
00:13:17,266 --> 00:13:17,933
只有两件事情

363
00:13:17,933 --> 00:13:19,199
第一找到渠道对象

364
00:13:19,200 --> 00:13:20,966
第二把这个职责分配给了渠道对象

365
00:13:20,966 --> 00:13:23,133
这是用创建者的原则

366
00:13:23,700 --> 00:13:26,133
交给渠道对象去创建一个支付

367
00:13:26,366 --> 00:13:27,499
而在渠道对象中间

368
00:13:27,500 --> 00:13:29,600
我们可以看到他做的方式是

369
00:13:29,600 --> 00:13:32,366
他判断当前这个渠道是不是有效

370
00:13:32,466 --> 00:13:33,933
如果有效的才能支付啊

371
00:13:33,933 --> 00:13:35,733
不有效的其实就不能支付

372
00:13:35,733 --> 00:13:37,866
虽然在前端界面上已经做了筛选

373
00:13:37,966 --> 00:13:40,766
但是在后端还要做二次二次的判断

374
00:13:40,766 --> 00:13:42,299
所以这是做的这个判断

375
00:13:42,466 --> 00:13:42,899
然后呢

376
00:13:42,900 --> 00:13:46,300
就是把这个值对象存到数据库里去了

377
00:13:47,100 --> 00:13:49,266
存进去以后我们再把它找出来

378
00:13:49,266 --> 00:13:50,933
这就是一个满血的对象

379
00:13:51,333 --> 00:13:53,799
把这个满血对象作为参数

380
00:13:53,800 --> 00:13:55,500
去调这个渠道

381
00:13:55,533 --> 00:13:56,366
我们可以看到

382
00:13:56,366 --> 00:13:58,566
为什么要用满血对象去调

383
00:13:59,466 --> 00:14:00,899
我们选Alipay里头的

384
00:14:00,900 --> 00:14:02,366
这个create payment的方法

385
00:14:03,400 --> 00:14:04,266
大家可以看到

386
00:14:04,266 --> 00:14:06,133
我们在拿到这个满血定项以后

387
00:14:06,133 --> 00:14:07,699
我们去get的show channel

388
00:14:07,900 --> 00:14:09,866
这个不是一个简单的get属性

389
00:14:09,900 --> 00:14:13,066
因为你看它的方法就知道它要用到

390
00:14:16,066 --> 00:14:17,466
要用到他的倒对象

391
00:14:19,933 --> 00:14:20,333
对吧用

392
00:14:20,333 --> 00:14:22,599
到他倒对象的这个查询的方法

393
00:14:22,733 --> 00:14:24,599
才能从数据库里把他找过来

394
00:14:24,600 --> 00:14:24,900
所以

395
00:14:24,900 --> 00:14:28,200
我们必须得要把满血对象作为他的

396
00:14:31,200 --> 00:14:32,733
必须把满血对象作为他的

397
00:14:32,733 --> 00:14:33,933
这个参数传过来

398
00:14:33,933 --> 00:14:36,399
因为我们在这个里头是要去调到

399
00:14:36,466 --> 00:14:38,499
不仅仅是用到Paycheck

400
00:14:38,600 --> 00:14:41,066
还要用到Paycheck所关联的所有对象

401
00:14:41,066 --> 00:14:43,733
也就是我们传授是传一个对象

402
00:14:43,733 --> 00:14:45,566
但其实带过去的是这个对象

403
00:14:45,566 --> 00:14:49,999
所有在我们Bo我们的这个关系啊

404
00:14:50,000 --> 00:14:50,800
其实都带过去

405
00:14:50,800 --> 00:14:52,000
关联关系都带过去了

406
00:14:52,933 --> 00:14:54,166
所以在一个

407
00:14:55,500 --> 00:14:56,500
Adapter里头

408
00:14:56,500 --> 00:14:57,066
大家可以看到

409
00:14:57,066 --> 00:14:58,333
其实就是分成了三段

410
00:14:58,333 --> 00:15:02,366
前半段是用来去构造我们的参数

411
00:15:02,366 --> 00:15:04,499
就这一段是用来构造我们的参数

412
00:15:05,466 --> 00:15:09,499
这一段是去调真正的阿里佩的接口

413
00:15:09,766 --> 00:15:12,666
下面这一段就是它的返回值

414
00:15:12,700 --> 00:15:15,700
要变成我们所定义的那个返回值

415
00:15:15,866 --> 00:15:16,933
就从这三段啊

416
00:15:16,933 --> 00:15:19,733
就完成了这样的一个支付的过程

417
00:15:30,333 --> 00:15:33,166
然后我们再回到我们的channel的方法

418
00:15:34,966 --> 00:15:37,066
所以完成了这个过程以后

419
00:15:37,200 --> 00:15:38,066
我们可以看到

420
00:15:38,066 --> 00:15:39,566
我们会把它的返回值

421
00:15:39,900 --> 00:15:41,800
把它更新到我们的配券里头去

422
00:15:41,800 --> 00:15:43,500
所以这一段是根据它的返回值

423
00:15:43,500 --> 00:15:44,800
去把它设到我们的配券里头

424
00:15:44,800 --> 00:15:46,600
然后再次去做更新

425
00:15:46,966 --> 00:15:48,866
然后把这个返回值返回到前段

426
00:15:49,133 --> 00:15:51,333
这就是我们看到的这个代码

427
00:15:51,733 --> 00:15:52,299
这个代码呢

428
00:15:52,300 --> 00:15:53,166
如果在考试的时候

429
00:15:53,166 --> 00:15:55,333
其实是不需要大家去讲的

430
00:15:55,333 --> 00:15:56,566
这么仔细说

431
00:15:56,566 --> 00:15:58,099
你说每一段每一段干嘛

432
00:15:58,500 --> 00:15:59,733
我们在考试之后分析时候

433
00:15:59,733 --> 00:16:01,399
其实主要是大家从这张单网中间

434
00:16:01,400 --> 00:16:01,900
看出来

435
00:16:01,900 --> 00:16:04,000
他的面向对象的设计用在什么地方

436
00:16:04,266 --> 00:16:06,733
我们一二三四五六七八九十

437
00:16:06,733 --> 00:16:07,566
这么多里头

438
00:16:07,566 --> 00:16:10,933
并不是每一个调用都是体现了

439
00:16:10,933 --> 00:16:12,466
面向对象的设计原则的

440
00:16:12,866 --> 00:16:13,666
我们刚才讲到

441
00:16:13,666 --> 00:16:14,199
这个地方

442
00:16:14,200 --> 00:16:16,466
体现了面向对象的Graspler

443
00:16:17,000 --> 00:16:18,300
创建者的模式

444
00:16:18,300 --> 00:16:19,400
所以你要讲清楚说

445
00:16:19,400 --> 00:16:21,600
为什么要这里要用创建者的模式

446
00:16:21,800 --> 00:16:22,600
创建者的方法

447
00:16:22,766 --> 00:16:24,566
是因为我们的shop channel

448
00:16:24,566 --> 00:16:26,499
和这个pay Chan的这个对象

449
00:16:26,600 --> 00:16:28,200
是一个组合关系

450
00:16:28,333 --> 00:16:31,299
所以我们认为创建一个pay支付对象

451
00:16:31,766 --> 00:16:33,799
应该交由他的shop channel

452
00:16:33,800 --> 00:16:34,700
这个对象去完成

453
00:16:34,700 --> 00:16:36,133
所以把整个这段代码

454
00:16:36,133 --> 00:16:39,533
把它全部拉到了pay shop channel这个里头

455
00:16:39,533 --> 00:16:40,666
做了一个独立的方法

456
00:16:40,666 --> 00:16:41,866
叫做create payment

457
00:16:41,866 --> 00:16:42,966
这是第一个地方啊

458
00:16:43,266 --> 00:16:44,699
第二个地方是我们在这

459
00:16:45,333 --> 00:16:47,866
因为这个其实跟前面的是一模一样的

460
00:16:47,866 --> 00:16:49,766
就是在重复使用那一个接口

461
00:16:50,066 --> 00:16:51,799
这个pairdog

462
00:16:51,800 --> 00:16:52,600
这个接口

463
00:16:52,866 --> 00:16:54,933
其实就是体现了我们所说的

464
00:16:55,333 --> 00:16:57,399
间接多态的方法

465
00:16:57,800 --> 00:16:59,933
达成的这个都是一样的

466
00:17:00,733 --> 00:17:01,566
开辟原则

467
00:17:01,900 --> 00:17:03,266
你可不可替换原则

468
00:17:03,666 --> 00:17:04,799
依赖党制原则

469
00:17:05,000 --> 00:17:07,200
不满足的是什么

470
00:17:08,000 --> 00:17:09,400
接口隔离的原则

471
00:17:09,466 --> 00:17:10,733
这个我之前讲过了

472
00:17:10,733 --> 00:17:13,566
是吧所以这个设计中间

473
00:17:13,566 --> 00:17:15,966
我们所体现的面向对象的这个设计

474
00:17:15,966 --> 00:17:19,166
其实就在这个地方和这个地方

475
00:17:19,166 --> 00:17:21,199
其他的都是分面向对象

476
00:17:22,100 --> 00:17:24,800
所以这就是10分或者15分的设计题

477
00:17:24,800 --> 00:17:27,200
分析题就是让你说

478
00:17:27,200 --> 00:17:27,866
这个设计里头

479
00:17:27,866 --> 00:17:30,999
到底哪些体现了面向对象的设计啊

480
00:17:31,966 --> 00:17:34,166
我们来看第二个例子

481
00:17:34,300 --> 00:17:35,200
get payment

482
00:17:36,000 --> 00:17:38,933
get payment的主要的作用就是返回支付单

483
00:17:39,100 --> 00:17:41,166
但是我们其实在这个API里头

484
00:17:41,166 --> 00:17:45,266
做了比单纯的返回支付单更多的内容

485
00:17:45,500 --> 00:17:46,700
我们可以看下这张设计图

486
00:17:46,700 --> 00:17:48,000
它做了什么样的内容啊

487
00:17:48,400 --> 00:17:50,533
他做了一个第一次

488
00:17:50,600 --> 00:17:53,200
到到里头把这个支付单的ID

489
00:17:53,200 --> 00:17:54,066
找到这个对象

490
00:17:54,066 --> 00:17:58,399
其实正常查支付单找到他就结束了

491
00:17:58,400 --> 00:18:00,333
但是我们在后面做了很多的事情

492
00:18:00,500 --> 00:18:01,333
这个事情是什么呢

493
00:18:01,333 --> 00:18:03,666
就是判断这个支付单是不是6的状态

494
00:18:04,000 --> 00:18:05,300
如果是6的状态

495
00:18:05,300 --> 00:18:08,066
其实我们就去和去看一下

496
00:18:08,066 --> 00:18:09,266
这个支付渠道

497
00:18:09,266 --> 00:18:12,566
当前的这个支付单是什么状态

498
00:18:13,066 --> 00:18:15,566
如果当前的这个支付单的状态

499
00:18:15,933 --> 00:18:18,266
跟这个状态不一样

500
00:18:18,266 --> 00:18:19,733
我们就去改变他的状态

501
00:18:19,733 --> 00:18:19,933
所以

502
00:18:19,933 --> 00:18:22,266
他不仅仅做查了一个支付单的作用

503
00:18:22,366 --> 00:18:24,066
而且还到支付渠道里去查了下

504
00:18:24,066 --> 00:18:24,933
他最新的状态

505
00:18:24,933 --> 00:18:26,066
是不是有发生的改变

506
00:18:26,066 --> 00:18:27,299
如果是6的状态啊

507
00:18:27,700 --> 00:18:29,333
最新的状态是不是有发生改变

508
00:18:29,533 --> 00:18:32,866
其实他做的不仅仅是在查这两个

509
00:18:32,866 --> 00:18:35,066
是去查因为这个支付单里头

510
00:18:35,066 --> 00:18:36,266
可能是有全三险ID

511
00:18:36,266 --> 00:18:37,199
也可能没有全三险ID

512
00:18:37,200 --> 00:18:40,666
所以他其实掉了这个阿里这个payer

513
00:18:40,666 --> 00:18:42,266
dot的两个方法

514
00:18:42,266 --> 00:18:43,366
去做这个查询

515
00:18:43,366 --> 00:18:44,766
反正返回来的结果都是他做过

516
00:18:44,766 --> 00:18:45,799
查到这个东西

517
00:18:45,900 --> 00:18:47,666
然后他做了一个社会使人

518
00:18:47,666 --> 00:18:48,266
做了另外一个方法

519
00:18:48,266 --> 00:18:49,366
叫做checker的方法

520
00:18:49,533 --> 00:18:51,466
去检查说这个圈的对象

521
00:18:51,466 --> 00:18:54,266
和查出来这个对象是不是一致的

522
00:18:54,800 --> 00:18:57,733
这个主要是指他的金额是不是一致的

523
00:18:57,900 --> 00:18:59,100
如果金额是不一致

524
00:18:59,100 --> 00:19:00,800
就会产生要去对账

525
00:19:00,800 --> 00:19:02,733
要去对账的问题

526
00:19:02,733 --> 00:19:04,066
啊如果金额是一致的

527
00:19:04,066 --> 00:19:06,366
那只是改变他的状态就好

528
00:19:06,800 --> 00:19:09,533
这就是我们在find payment的

529
00:19:09,533 --> 00:19:10,799
这个里头的设计

530
00:19:10,800 --> 00:19:11,600
就这么做

531
00:19:11,966 --> 00:19:14,766
那我们会假设这道设计的话

532
00:19:14,766 --> 00:19:17,066
我们会出另外一种题型

533
00:19:17,066 --> 00:19:19,066
就是分析设计题

534
00:19:19,400 --> 00:19:20,533
除了分析以外

535
00:19:20,533 --> 00:19:21,866
你还要加上设计

536
00:19:21,900 --> 00:19:23,666
所以分析设计题一般是20分

537
00:19:25,100 --> 00:19:29,100
大家觉得这道题分析设计要怎么做呢

538
00:19:29,566 --> 00:19:30,333
我们的问题

539
00:19:30,333 --> 00:19:30,866
一般就是

540
00:19:30,866 --> 00:19:32,366
大家觉得这个设计里头

541
00:19:32,533 --> 00:19:33,799
存在什么样的问题

542
00:19:34,800 --> 00:19:36,000
然后你怎么改进他

543
00:19:36,366 --> 00:19:37,166
他放了太多

544
00:19:37,166 --> 00:19:39,466
到那个配那个

545
00:19:40,700 --> 00:19:42,533
对你应该发现到这个问题

546
00:19:42,533 --> 00:19:43,366
就是这个设计

547
00:19:43,366 --> 00:19:45,999
其实大量的代码是在配设备室里头

548
00:19:46,266 --> 00:19:47,399
应该把它多放点

549
00:19:47,400 --> 00:19:49,166
然后倒出来

550
00:19:49,500 --> 00:19:50,300
那你觉得

551
00:19:50,300 --> 00:19:52,466
他为什么都在payment设备室里头呢

552
00:19:53,366 --> 00:19:55,133
因为他这是贫血模型

553
00:19:55,966 --> 00:19:57,566
对这个是贫血模型

554
00:19:58,000 --> 00:20:01,666
所以说他没有把职责分配到对象上

555
00:20:02,166 --> 00:20:03,899
这个很明显的一个特征就是

556
00:20:03,900 --> 00:20:04,500
大家可以看到

557
00:20:04,500 --> 00:20:08,600
前一个设计在这个上面是有Bo对象的

558
00:20:09,200 --> 00:20:10,933
但这个设计在上面这16里头

559
00:20:10,933 --> 00:20:11,733
你看见没有

560
00:20:12,166 --> 00:20:13,333
基本没有就没有

561
00:20:13,333 --> 00:20:15,599
不是基本没有就没有Bo对象

562
00:20:15,733 --> 00:20:16,733
所以这说明一个问题

563
00:20:16,733 --> 00:20:18,399
他们要把职责分给Bo对象

564
00:20:18,700 --> 00:20:19,366
那现在问题是

565
00:20:19,366 --> 00:20:21,599
这个设计能不能把职责分给Bo对象呢

566
00:20:22,933 --> 00:20:25,066
能把他怎么分给Bo对象呢

567
00:20:27,733 --> 00:20:30,133
这就是分析设计题

568
00:20:30,400 --> 00:20:31,900
所以你要找出它的问题

569
00:20:31,900 --> 00:20:32,900
问题你看出来了

570
00:20:32,966 --> 00:20:35,599
它没有做面向对象的分配

571
00:20:35,900 --> 00:20:38,900
这是一个纯的非面向对象的设计

572
00:20:40,066 --> 00:20:41,099
那现在的问题就是

573
00:20:41,100 --> 00:20:42,300
它能不能做成面向对象

574
00:20:42,566 --> 00:20:43,799
能不能把在收尾词中

575
00:20:43,800 --> 00:20:46,366
代码分配到Bo对象中

576
00:20:46,366 --> 00:20:47,999
进去怎么分配法

577
00:20:48,733 --> 00:20:52,166
这就是这个20分的分析设计题

578
00:20:52,166 --> 00:20:53,499
所以你要把它分配了

579
00:20:53,533 --> 00:20:55,566
然后用设计图

580
00:20:55,566 --> 00:20:56,599
用顺顺序图

581
00:20:56,733 --> 00:20:59,166
把你的分配方案给我描述出来

582
00:21:00,100 --> 00:21:03,166
这个题通常来说耗时会比较长

583
00:21:03,300 --> 00:21:05,566
我们往年的经验教训

584
00:21:06,400 --> 00:21:08,300
不做不做

585
00:21:08,300 --> 00:21:09,766
不做你就大概就会挂掉

586
00:21:10,066 --> 00:21:10,733
就这个题

587
00:21:10,733 --> 00:21:14,299
通常来说都要花30-40分钟来做

588
00:21:14,666 --> 00:21:17,733
就是我们整个考试20分钟的时长

589
00:21:17,966 --> 00:21:20,766
你至少都要分配30-40分钟用在这

590
00:21:20,766 --> 00:21:22,199
个20分的题上

591
00:21:22,366 --> 00:21:22,999
原因是什么

592
00:21:23,000 --> 00:21:24,566
因为这个题是要画图的

593
00:21:26,466 --> 00:21:28,266
我就说说这个时长分配

594
00:21:28,266 --> 00:21:29,399
这个是要画图的

595
00:21:29,500 --> 00:21:31,133
很多同学在最后考试的时候

596
00:21:31,133 --> 00:21:32,366
才发现一个问题

597
00:21:32,666 --> 00:21:33,766
原来我在整个学期

598
00:21:33,766 --> 00:21:35,999
都还没有手绘过一张图

599
00:21:36,600 --> 00:21:38,700
甚至有同学就完全没有手

600
00:21:38,700 --> 00:21:39,566
没有绘过图

601
00:21:40,000 --> 00:21:40,866
那你就会知道

602
00:21:40,866 --> 00:21:42,799
你这道题你干脆就放弃算了

603
00:21:42,900 --> 00:21:44,733
你是在二三十分钟之内

604
00:21:44,733 --> 00:21:45,899
你是画不出来的

605
00:21:46,166 --> 00:21:48,199
因为这个过程中间涉及到了说

606
00:21:48,266 --> 00:21:49,699
你第一要找到问题

607
00:21:49,866 --> 00:21:51,266
第二你要怎样设计

608
00:21:51,333 --> 00:21:51,733
第三

609
00:21:51,733 --> 00:21:53,733
你要怎样用图把这个设计表述出来

610
00:21:54,766 --> 00:21:55,166
对吧

611
00:21:55,166 --> 00:21:57,066
这才是一个相对比较简单的问题啊

612
00:21:57,066 --> 00:22:00,366
所以说我不给出这个东西的答案

613
00:22:00,533 --> 00:22:02,066
因为现在代码就这么写的

614
00:22:02,133 --> 00:22:02,766
就目前

615
00:22:02,766 --> 00:22:04,899
你的代码就是非面向对象设计的

616
00:22:05,300 --> 00:22:06,766
这个属于负责这一个

617
00:22:06,766 --> 00:22:07,933
我们把它分成了若空格

618
00:22:07,933 --> 00:22:08,799
必做任务嘛

619
00:22:09,100 --> 00:22:10,000
负责这一块

620
00:22:10,000 --> 00:22:11,966
这个API的必做任务的同学

621
00:22:12,100 --> 00:22:15,366
你其实在做这个调试代码的时候

622
00:22:15,366 --> 00:22:17,399
我们的任务是让你做测试代码

623
00:22:17,400 --> 00:22:20,300
把所有的这个代码全覆盖了

624
00:22:20,700 --> 00:22:21,733
你在覆盖这些代码时候

625
00:22:21,733 --> 00:22:22,766
你先要思考一个问题

626
00:22:22,766 --> 00:22:24,133
这个代码能这么写吗

627
00:22:24,300 --> 00:22:25,900
如果你觉得这个代码不能这么写

628
00:22:25,900 --> 00:22:27,733
那你就改他的这个代码

629
00:22:27,733 --> 00:22:30,499
改这个设计出新的设计图

630
00:22:31,066 --> 00:22:32,999
按照新的设计图去写新的代码

631
00:22:33,000 --> 00:22:33,800
然后写测试

632
00:22:33,800 --> 00:22:35,566
用力最后完成这个过程

633
00:22:35,733 --> 00:22:37,333
所以我们的必做任务

634
00:22:37,333 --> 00:22:39,599
不是简单让大家去写测试

635
00:22:39,600 --> 00:22:41,800
用力去覆盖住现有的代码

636
00:22:42,000 --> 00:22:43,366
是大家通过测试用力

637
00:22:43,366 --> 00:22:44,733
首先第一个找到这个设计

638
00:22:44,733 --> 00:22:46,899
中间现在是不是有问题

639
00:22:47,566 --> 00:22:49,466
然后如果说他有问题

640
00:22:49,466 --> 00:22:50,333
就去改正他

641
00:22:50,333 --> 00:22:52,466
无论是设计的问题还是代码的问题

642
00:22:52,700 --> 00:22:53,500
去把他改正了

643
00:22:53,500 --> 00:22:55,666
然后用测试代码证明这个改好的

644
00:22:55,666 --> 00:22:56,799
这个东西是正确的

645
00:22:56,933 --> 00:22:58,466
这个就是必做任务

646
00:22:58,866 --> 00:23:02,799
所以啊要能够做好这个分析设计题

647
00:23:03,766 --> 00:23:05,066
同学们要去做必做任务

648
00:23:05,933 --> 00:23:07,133
不做必做任务

649
00:23:08,100 --> 00:23:10,166
你是不会知道他有什么问题的

650
00:23:10,166 --> 00:23:12,866
而且所有分析设计题的答案

651
00:23:12,933 --> 00:23:14,499
我在上课是不会讲的

652
00:23:14,666 --> 00:23:15,866
比如说这个我就不会讲

653
00:23:16,666 --> 00:23:17,933
所以要同学们自己去做

654
00:23:18,266 --> 00:23:19,666
分析题的答案我都会讲

655
00:23:19,966 --> 00:23:22,299
但是这20分的分析设计题的答案

656
00:23:22,300 --> 00:23:23,200
我是不会讲

657
00:23:23,600 --> 00:23:24,600
但我会告诉大家说

658
00:23:24,600 --> 00:23:26,700
这个就是需要大家去做分析设计题的

659
00:23:26,866 --> 00:23:28,566
因为他是设计

660
00:23:28,566 --> 00:23:29,099
是有问题的

661
00:23:29,100 --> 00:23:31,333
他没有用面向对象的这样一个设计啊

662
00:23:31,666 --> 00:23:33,566
所以留待同学们自己去做

663
00:23:33,566 --> 00:23:34,566
自己去思考

664
00:23:42,966 --> 00:23:44,266
这个分析式议题啊

665
00:23:44,266 --> 00:23:47,499
其实一个是我在这里头故意留的这个

666
00:23:47,500 --> 00:23:48,666
其实还有一个更多的

667
00:23:48,666 --> 00:23:50,366
会出现在我们的物流模块

668
00:23:50,466 --> 00:23:52,133
因为那是同学们做的设计

669
00:23:52,400 --> 00:23:54,100
里头一定是有大量的问题的

670
00:23:54,100 --> 00:23:56,100
所以所有的问题都是可以改进的

671
00:23:56,300 --> 00:23:57,766
所以大家也可以关注一下

672
00:23:57,800 --> 00:23:58,133
最后

673
00:23:58,133 --> 00:24:00,666
我们在物流模块里到底会出多少问题

674
00:24:01,100 --> 00:24:03,166
然后这些问题都会留在考试的时候

675
00:24:03,166 --> 00:24:05,266
大家去分析设计

676
00:24:05,266 --> 00:24:06,366
去改进它啊

677
00:24:07,133 --> 00:24:07,766
主要就这个部分

678
00:24:07,766 --> 00:24:10,766
我考试的我会我会留一些

679
00:24:10,766 --> 00:24:11,933
比如说这个就是会

680
00:24:11,933 --> 00:24:14,733
是一个可以出题的地方啊

681
00:24:14,733 --> 00:24:16,566
但是我在上课不会讲

682
00:24:16,566 --> 00:24:17,733
说这个怎么改这个

683
00:24:17,733 --> 00:24:18,599
同学们自己去改

684
00:24:21,866 --> 00:24:23,466
这就是我们的这个类图

685
00:24:23,566 --> 00:24:24,566
这个类图可以看到

686
00:24:24,566 --> 00:24:26,699
我们当用了灭号对象的设计以后

687
00:24:26,800 --> 00:24:27,533
我们的

688
00:24:27,533 --> 00:24:30,166
为什么能把这些职责分配给这些Bo

689
00:24:30,200 --> 00:24:31,100
或者do对象

690
00:24:31,100 --> 00:24:34,566
原因就是因为我们把这些倒对象

691
00:24:34,566 --> 00:24:35,733
制造了这个

692
00:24:36,000 --> 00:24:36,866
Bo对象中心去

693
00:24:36,866 --> 00:24:38,266
他是一个满选模型

694
00:24:38,400 --> 00:24:41,066
这样才能把一些原本在收费时

695
00:24:41,066 --> 00:24:41,933
成的代码

696
00:24:42,133 --> 00:24:44,533
分配到了这些对象上去啊

697
00:24:44,666 --> 00:24:46,699
那就会使用了面向对象的一些原则

698
00:24:46,733 --> 00:24:48,666
最基本的是创建者心理专家

699
00:24:48,666 --> 00:24:49,499
大家应该知道

700
00:24:50,333 --> 00:24:51,566
创业者的信息专家

701
00:24:51,566 --> 00:24:52,333
最简单的

702
00:24:52,333 --> 00:24:54,566
会分配大量的这些代码

703
00:24:54,733 --> 00:24:57,299
到这些Bo或者do对象上去

704
00:24:58,800 --> 00:25:01,466
最后一个我们要讲的API是最复杂的

705
00:25:01,466 --> 00:25:03,599
这个API叫做退款

706
00:25:04,500 --> 00:25:05,966
这个API为什么最复杂呢

707
00:25:05,966 --> 00:25:08,899
因为退款是在所有的过程做完了以后

708
00:25:08,900 --> 00:25:10,166
才会做退款

709
00:25:10,366 --> 00:25:10,599
所以

710
00:25:10,600 --> 00:25:13,100
他实际上要把所有的过程反做一次

711
00:25:13,500 --> 00:25:14,800
从API设计上走了来说

712
00:25:14,800 --> 00:25:15,733
它是比较简单的

713
00:25:15,733 --> 00:25:16,999
因为它只要描述说

714
00:25:17,000 --> 00:25:19,500
退款额和分账退款额

715
00:25:19,700 --> 00:25:20,566
实际上两个退款额

716
00:25:20,566 --> 00:25:22,533
一个是退给顾客的钱

717
00:25:22,533 --> 00:25:24,199
一个是平台退给商户的钱

718
00:25:24,200 --> 00:25:25,333
这两个钱告诉我

719
00:25:25,700 --> 00:25:26,966
我要怎么退款啊

720
00:25:26,966 --> 00:25:28,133
同样这是个内部API

721
00:25:28,300 --> 00:25:30,666
所以不能用外部去调

722
00:25:30,666 --> 00:25:31,966
说要退多少就退多少

723
00:25:31,966 --> 00:25:34,066
必须是我们的内部的各个模块

724
00:25:34,200 --> 00:25:35,733
按照你的业务规则算出来

725
00:25:35,733 --> 00:25:36,866
说要退多少钱

726
00:25:36,900 --> 00:25:37,900
分账要退多少钱

727
00:25:37,900 --> 00:25:40,200
然后来调我们支付模块的这个内部API

728
00:25:40,500 --> 00:25:43,900
去完成这个分账退款的过程

729
00:25:43,900 --> 00:25:45,866
这是没有放出去给外面用

730
00:25:46,066 --> 00:25:47,366
那返回值比较复杂

731
00:25:47,366 --> 00:25:50,266
返回值其实是返回的所有的这个啊

732
00:25:50,266 --> 00:25:51,733
违放的这个对象

733
00:25:53,300 --> 00:25:54,866
我们来看这张设计图

734
00:25:55,866 --> 00:25:56,699
这张设计图啊

735
00:25:56,700 --> 00:25:57,700
首先大家一看这张图

736
00:25:57,700 --> 00:25:59,200
就知道它是用了面向对象设计的

737
00:25:59,200 --> 00:26:01,166
是吧用了面向对象设计

738
00:26:01,166 --> 00:26:02,399
和没用面向对象设计的

739
00:26:02,400 --> 00:26:04,200
最基本的差别就在于说

740
00:26:04,200 --> 00:26:06,100
设备成到底有多少方法放出来

741
00:26:06,266 --> 00:26:07,499
在于这个横向来看

742
00:26:07,500 --> 00:26:07,733
你到

743
00:26:07,733 --> 00:26:11,166
底有没有把职责分配给Bo对象上去

744
00:26:11,500 --> 00:26:12,266
所以从这张图上

745
00:26:12,266 --> 00:26:13,966
他就是你不看具体的设计

746
00:26:13,966 --> 00:26:15,966
大家都知道说他是有这种影响对象

747
00:26:16,133 --> 00:26:18,133
他没有把所有的代码放到收费层

748
00:26:18,200 --> 00:26:21,000
而且横向来看是有Bo对象的

749
00:26:21,166 --> 00:26:22,966
那我们要看的关注点就是

750
00:26:22,966 --> 00:26:25,366
我们到底把哪一些的职责

751
00:26:25,800 --> 00:26:27,966
分配给了这些Bo对象

752
00:26:28,300 --> 00:26:28,666
就换句话说

753
00:26:28,666 --> 00:26:30,533
我在问你的这个分析题的时候

754
00:26:30,700 --> 00:26:31,733
说他用了面对象

755
00:26:31,733 --> 00:26:34,266
用在哪最容易找到的一点就是

756
00:26:34,266 --> 00:26:36,299
你在这个横向这个上头看到

757
00:26:36,300 --> 00:26:37,366
这些Bo对象

758
00:26:37,600 --> 00:26:39,733
到底有出现了一些什么样的方法

759
00:26:39,733 --> 00:26:42,699
比如说这个地方的这个位置

760
00:26:42,866 --> 00:26:45,733
以及这个是Bo对象的这个位置

761
00:26:46,000 --> 00:26:47,900
这两个位置就是第二和第八

762
00:26:47,900 --> 00:26:48,400
这两个位置

763
00:26:48,400 --> 00:26:49,100
大家应该知道

764
00:26:49,100 --> 00:26:50,666
就是用来面对看的分配的

765
00:26:51,100 --> 00:26:52,000
所以下一个问题就是

766
00:26:52,000 --> 00:26:52,700
你要知道

767
00:26:52,700 --> 00:26:55,933
这是用一个什么原则来进行分配的

768
00:26:56,100 --> 00:26:58,600
那我们从头往下看一下

769
00:26:58,966 --> 00:26:59,899
我们进来以后

770
00:26:59,900 --> 00:27:02,866
同样的第一个是由这个ID找对象

771
00:27:03,000 --> 00:27:05,100
因为我们是这个退款

772
00:27:05,333 --> 00:27:06,299
所以大家注意看

773
00:27:06,300 --> 00:27:08,133
在这个API的路径上面

774
00:27:08,133 --> 00:27:09,499
我们其实有给出来说

775
00:27:09,500 --> 00:27:11,400
要对哪一个支付的退款

776
00:27:11,766 --> 00:27:12,999
因为他不能任意退款

777
00:27:13,366 --> 00:27:14,166
任何一个退款

778
00:27:14,166 --> 00:27:16,599
都是基于一个现有的支付来做的退款

779
00:27:16,733 --> 00:27:18,099
所以在路径上的一个现金来说

780
00:27:18,100 --> 00:27:20,600
必须要给出说是哪一个payment

781
00:27:21,100 --> 00:27:22,700
那进入到社会层以后

782
00:27:22,700 --> 00:27:24,666
大家看到第一件事情就是把ID变对象

783
00:27:24,733 --> 00:27:25,699
这个是一个逻辑

784
00:27:25,700 --> 00:27:26,666
你要做面向对象设计

785
00:27:26,666 --> 00:27:28,933
没有对象怎么把职责分配给他

786
00:27:29,166 --> 00:27:31,099
所以我们的第一个逻辑就是

787
00:27:31,100 --> 00:27:32,900
把payment的ID

788
00:27:32,900 --> 00:27:35,066
变成了一个payment transaction的对象

789
00:27:35,800 --> 00:27:37,533
找稻城得到这个对象

790
00:27:37,866 --> 00:27:38,333
第二是你

791
00:27:38,333 --> 00:27:40,866
就是我们把这些逻辑全部给他

792
00:27:40,866 --> 00:27:43,666
归到了推荐的全三行当中

793
00:27:43,766 --> 00:27:44,866
那理由是什么

794
00:27:45,800 --> 00:27:47,100
我们知道这个逻辑是干嘛的

795
00:27:47,100 --> 00:27:49,733
这是创建一个退款的对象

796
00:27:50,333 --> 00:27:52,766
就是他是为了产产生一个退款

797
00:27:53,133 --> 00:27:55,266
所以说他这个做出来的结果就会创造

798
00:27:55,266 --> 00:27:57,566
一会创建一个退款对象出来

799
00:27:57,933 --> 00:27:58,533
那我们知道

800
00:27:58,533 --> 00:28:01,399
这个逻辑就是一个创建者的逻辑

801
00:28:01,900 --> 00:28:03,266
我们基于创建者的逻辑

802
00:28:03,266 --> 00:28:05,499
让创建一个退款对象的

803
00:28:05,566 --> 00:28:06,599
这样的一个职责

804
00:28:06,800 --> 00:28:09,266
交给了支付对象去完成

805
00:28:09,666 --> 00:28:10,399
原因是什么

806
00:28:10,400 --> 00:28:11,066
原因在于

807
00:28:11,066 --> 00:28:13,666
退款对象和支付对象是组合关系

808
00:28:14,333 --> 00:28:15,933
因为任何一个退款对象

809
00:28:15,933 --> 00:28:17,533
一定是针对一个支付来做

810
00:28:17,800 --> 00:28:20,733
不可能一个退款对象是有两个支付的

811
00:28:20,966 --> 00:28:23,799
所以说他跟支付对象是一个组合关系

812
00:28:23,933 --> 00:28:25,099
所以基于组合关系

813
00:28:25,100 --> 00:28:26,733
我们把这个职责分配给他

814
00:28:26,733 --> 00:28:28,499
这是创建者的原则啊

815
00:28:28,500 --> 00:28:29,300
这一步

816
00:28:29,800 --> 00:28:30,766
那分配给他以后

817
00:28:30,766 --> 00:28:31,466
我们可以看到

818
00:28:31,466 --> 00:28:34,099
在里头他创建了一个退款对象

819
00:28:34,366 --> 00:28:36,499
这个部分来说其实有更复杂的逻辑

820
00:28:36,500 --> 00:28:37,800
但我们在美图上没画

821
00:28:37,900 --> 00:28:38,533
因为我们知道

822
00:28:38,533 --> 00:28:40,866
当我们创建一个退款对象的时候

823
00:28:41,200 --> 00:28:43,366
我们其实不能任意的去退款

824
00:28:43,366 --> 00:28:44,533
我们需要判断出

825
00:28:44,533 --> 00:28:48,166
这个退款金额是少于支付金额

826
00:28:48,566 --> 00:28:49,733
我们需要判断说

827
00:28:49,733 --> 00:28:51,366
他这个退分账的金额

828
00:28:51,600 --> 00:28:55,700
是少于当时这个商户分给平台的金额

829
00:28:56,066 --> 00:28:58,566
只有这两个金额少于支付金额

830
00:28:58,600 --> 00:29:01,000
才可以完成这个退款

831
00:29:01,000 --> 00:29:02,733
所以这种是有做这个判断的

832
00:29:02,733 --> 00:29:03,366
而这个判断

833
00:29:03,366 --> 00:29:06,766
是放到了创建对象的这个里头

834
00:29:06,766 --> 00:29:08,299
这个其实用的是什么呢

835
00:29:08,500 --> 00:29:09,333
在这一步

836
00:29:09,800 --> 00:29:12,733
这个逻辑其实用的是信息专家的原则

837
00:29:12,766 --> 00:29:14,166
就是由谁来判断

838
00:29:14,166 --> 00:29:17,766
这个创建退款对象是能够成功的

839
00:29:17,766 --> 00:29:19,166
这个事情我们交给了

840
00:29:19,533 --> 00:29:20,533
交给了什么呢

841
00:29:20,766 --> 00:29:23,899
交给了这个陪劝的对象去完成

842
00:29:23,900 --> 00:29:25,766
所以我们把陪劝对象传进去

843
00:29:25,933 --> 00:29:27,933
让他在这里头去利用陪劝对象

844
00:29:27,933 --> 00:29:30,799
去知道说这个对象能不能把他

845
00:29:31,466 --> 00:29:32,799
能不能把它建出来啊

846
00:29:32,800 --> 00:29:35,266
这个是这个构造的方法

847
00:29:35,800 --> 00:29:38,933
那如果把支付推广对象能够完成

848
00:29:38,933 --> 00:29:40,666
我们就把它插到数据库里去

849
00:29:40,666 --> 00:29:41,866
同样的插进去以后

850
00:29:41,866 --> 00:29:42,933
我们也把它查出来

851
00:29:43,166 --> 00:29:45,333
因为是插进去的时候是一个什么呢

852
00:29:45,333 --> 00:29:46,466
是一个直对象

853
00:29:47,500 --> 00:29:49,300
查出来的时候是一个满血对象

854
00:29:49,300 --> 00:29:51,333
因为查出来之后他造成有bill

855
00:29:51,600 --> 00:29:53,200
把它bill成一个满血对象

856
00:29:53,533 --> 00:29:53,866
之后

857
00:29:53,866 --> 00:29:56,333
我们用这个满血对象去做其他的事情

858
00:29:56,333 --> 00:29:57,066
要做什么事情

859
00:29:57,066 --> 00:29:58,766
首先判断这个对象的状态

860
00:29:59,100 --> 00:30:01,466
是不是支付对象的这个状态啊

861
00:30:01,900 --> 00:30:03,000
是不是分账

862
00:30:03,666 --> 00:30:05,299
因为他可以在分站前退款

863
00:30:05,300 --> 00:30:06,566
也可以在分站后退款

864
00:30:06,733 --> 00:30:09,166
如果分站前退款就直接退回去就好

865
00:30:09,366 --> 00:30:10,266
分站后退款

866
00:30:10,266 --> 00:30:12,733
需要把他分给平台的钱退给商户

867
00:30:12,733 --> 00:30:14,366
商户再退给顾客

868
00:30:14,600 --> 00:30:16,066
所以这里判断的就是这个

869
00:30:16,066 --> 00:30:17,999
这笔支付交易是不是有做了分账

870
00:30:18,200 --> 00:30:19,333
如果有分账的话

871
00:30:19,333 --> 00:30:20,899
则去调他的所有

872
00:30:20,900 --> 00:30:21,600
调他的分账

873
00:30:21,600 --> 00:30:22,666
因为我们只有一笔分账

874
00:30:22,666 --> 00:30:23,599
只是给平台分账

875
00:30:23,600 --> 00:30:25,000
去拿他的分账

876
00:30:25,266 --> 00:30:27,866
这个部分大家知道是调了倒对象

877
00:30:27,933 --> 00:30:29,066
是因为是满血模型

878
00:30:29,066 --> 00:30:30,766
所以他会去调倒对象

879
00:30:30,766 --> 00:30:33,299
去查到这个他的分账对象

880
00:30:33,666 --> 00:30:35,266
然后我们可以看到

881
00:30:35,266 --> 00:30:39,699
分账退款再次使用了创建者的模式

882
00:30:40,300 --> 00:30:42,800
把它分配给了这个对象

883
00:30:43,533 --> 00:30:44,733
分账的这个对象

884
00:30:44,766 --> 00:30:48,133
所以我们让分账的这个交易去完成

885
00:30:48,166 --> 00:30:49,733
他的退款的职责

886
00:30:50,533 --> 00:30:51,366
做完了以后

887
00:30:51,766 --> 00:30:52,066
然后

888
00:30:52,066 --> 00:30:55,799
我们去调支付渠道去完成分账的退款

889
00:30:56,000 --> 00:30:57,100
然后再去调

890
00:30:57,733 --> 00:30:58,666
把它存起来

891
00:30:58,766 --> 00:31:01,466
然后这里其实回来还有一个没画啊

892
00:31:01,466 --> 00:31:03,866
他再去调了这个渠道

893
00:31:04,100 --> 00:31:06,966
去完成前面的这个退款

894
00:31:07,000 --> 00:31:09,366
其实他调两次这个支付渠道

895
00:31:09,366 --> 00:31:10,566
一次是分账退款

896
00:31:10,900 --> 00:31:12,533
一次是外面做完了以后

897
00:31:12,533 --> 00:31:14,799
再去调这个渠道

898
00:31:14,800 --> 00:31:19,800
去完成从商户退到顾客的这个过程

899
00:31:19,900 --> 00:31:20,966
最后这个查完

900
00:31:21,300 --> 00:31:22,566
那中间的这个

901
00:31:24,133 --> 00:31:26,399
支付的分账支付的交易

902
00:31:26,666 --> 00:31:28,966
分账的支付交易如何去完成退款

903
00:31:28,966 --> 00:31:30,499
我们用一张独立的图去画

904
00:31:30,500 --> 00:31:31,566
他的逻辑类似

905
00:31:31,566 --> 00:31:32,799
但是没有做那么多判断

906
00:31:32,800 --> 00:31:34,400
因为判断在外头已经做了

907
00:31:34,900 --> 00:31:37,066
所以这里说他是由这个退款交易

908
00:31:37,066 --> 00:31:38,599
分账交易去创建一个退款

909
00:31:38,600 --> 00:31:39,766
分账的交易

910
00:31:39,866 --> 00:31:40,999
然后把它插数据汇头

911
00:31:41,000 --> 00:31:41,900
把它查回来

912
00:31:42,000 --> 00:31:45,166
调支付的渠道去完成这样的一个退款

913
00:31:45,366 --> 00:31:46,299
然后就回来了

914
00:31:50,100 --> 00:31:51,966
对是这样的一个逻辑啊

915
00:31:53,566 --> 00:31:56,099
这是我们的这个设计图

916
00:31:56,700 --> 00:31:58,000
所以在这张设计图里头

917
00:31:58,000 --> 00:32:00,266
如果说我们让大家分析说

918
00:32:00,266 --> 00:32:04,133
它的面向对象的部分用了多少

919
00:32:04,800 --> 00:32:05,733
用了什么地方

920
00:32:05,966 --> 00:32:07,466
这个就相对比较复杂

921
00:32:07,866 --> 00:32:09,599
因为这里头用到了第三

922
00:32:09,900 --> 00:32:11,600
这是用的创建者的方式

923
00:32:11,933 --> 00:32:15,133
第四这是用了信息增加的方式

924
00:32:15,333 --> 00:32:18,299
第八再次使用了创建者的方式

925
00:32:18,333 --> 00:32:21,299
所以用了三个地方来做的职责分配

926
00:32:21,900 --> 00:32:25,466
把这个职责分配给了不同的对象去做

927
00:32:25,466 --> 00:32:27,466
完成我们看下他的代码

928
00:32:34,066 --> 00:32:36,499
看一下这个代码其实写的更复杂

929
00:32:36,500 --> 00:32:38,500
因为里头有些技术的细节

930
00:32:42,100 --> 00:32:45,600
这是我们的service成的create refund

931
00:32:45,600 --> 00:32:48,700
在这一个部分来说相对比较简单

932
00:32:48,700 --> 00:32:50,933
因为就是把payment对象变成ID

933
00:32:50,933 --> 00:32:52,566
然后ID变成对象

934
00:32:52,566 --> 00:32:53,899
然后去掉paychen

935
00:32:53,900 --> 00:32:54,700
的refund

936
00:32:55,500 --> 00:32:56,866
在拍去的人放的里头

937
00:32:56,866 --> 00:32:57,733
其实大家会看到

938
00:32:57,733 --> 00:32:59,699
有一些我们在图上没有画的蛋

939
00:33:00,000 --> 00:33:03,000
就是在第一段我们会创建一个圈对象

940
00:33:03,000 --> 00:33:03,866
然后给他

941
00:33:04,466 --> 00:33:05,933
就是把他的ID设回来

942
00:33:05,933 --> 00:33:08,733
然后这个其实是把我们正在用的

943
00:33:08,733 --> 00:33:10,733
这个支付对象的状态

944
00:33:10,866 --> 00:33:12,066
改成了方顶

945
00:33:12,066 --> 00:33:13,899
不是状态改它的一个属性

946
00:33:14,000 --> 00:33:17,100
改成了正在退款中这样的一个值

947
00:33:17,500 --> 00:33:19,366
这个大家知道有什么用吗

948
00:33:20,133 --> 00:33:23,933
这个其实就是我们利用数据库的行数

949
00:33:24,166 --> 00:33:28,199
携手来实现我们代码的信号量

950
00:33:29,066 --> 00:33:29,733
我们的代码中间

951
00:33:29,733 --> 00:33:30,533
就这段代码中间

952
00:33:30,533 --> 00:33:32,333
因为他是会并行调用

953
00:33:32,766 --> 00:33:34,866
所以我们要避免一个什么情况呢

954
00:33:34,866 --> 00:33:35,733
避免说

955
00:33:36,100 --> 00:33:39,933
当一个用户在对退款的过程中间

956
00:33:39,966 --> 00:33:42,866
这个用户又对同一笔的支付交易

957
00:33:42,866 --> 00:33:44,599
发生了二次退款

958
00:33:45,066 --> 00:33:46,733
就一笔退款还没有处理完

959
00:33:46,733 --> 00:33:49,566
他立马像黑客一样的去刷这个接口

960
00:33:49,666 --> 00:33:51,266
去发起了另外一笔退款

961
00:33:51,533 --> 00:33:53,399
如果两笔退款同时做的话

962
00:33:53,400 --> 00:33:54,900
我们的逻辑是有问题的

963
00:33:55,400 --> 00:33:58,166
那为了避免两笔退款同时做

964
00:33:58,200 --> 00:34:02,100
是针对同一笔支付交易的退款同时做

965
00:34:02,100 --> 00:34:03,466
这样的一种可能性

966
00:34:03,533 --> 00:34:04,933
我们用这种方式

967
00:34:04,933 --> 00:34:09,333
把这个支付退款交易给锁死

968
00:34:10,066 --> 00:34:11,199
大家知道怎么锁的吗

969
00:34:13,400 --> 00:34:14,766
好像没看到锁啊

970
00:34:14,866 --> 00:34:16,133
但是他实际锁死了

971
00:34:16,366 --> 00:34:17,166
为什么呢

972
00:34:17,300 --> 00:34:18,400
是大家在看

973
00:34:18,400 --> 00:34:20,800
我们焦瓦依依的那个my Batis

974
00:34:21,166 --> 00:34:22,533
的事物那一节的视频

975
00:34:22,533 --> 00:34:24,366
中间大家应该能够发现一个现象

976
00:34:24,566 --> 00:34:26,333
就是当我们对同一条记录

977
00:34:26,333 --> 00:34:28,066
进行写操作的时候

978
00:34:28,566 --> 00:34:31,099
如果第一个事物没有结束

979
00:34:31,200 --> 00:34:33,933
第二个事物会被卡死在这句话上

980
00:34:34,800 --> 00:34:36,500
就卡死在这个safe这句话上

981
00:34:36,500 --> 00:34:37,533
他就后头就走不了

982
00:34:38,100 --> 00:34:41,900
所以他会把第二个事物被锁死

983
00:34:41,900 --> 00:34:43,566
在这条这个这句上了

984
00:34:43,566 --> 00:34:45,499
后面这些句没办法运行

985
00:34:45,766 --> 00:34:48,299
直到第一个事物有结束了

986
00:34:49,066 --> 00:34:51,799
他才可以去做这个动作

987
00:34:51,866 --> 00:34:55,199
才能去做这样的一个写的动作啊

988
00:34:55,200 --> 00:34:57,900
所以用这样的一种方式

989
00:34:57,933 --> 00:34:58,899
使得说

990
00:34:58,900 --> 00:35:02,366
我们在这一句话后面的这些代码

991
00:35:02,400 --> 00:35:03,333
如果是针对

992
00:35:03,333 --> 00:35:06,299
同一个支付交易的请求的话

993
00:35:06,733 --> 00:35:09,866
只有一个县城能够跑到后面去

994
00:35:10,133 --> 00:35:13,066
其他的县城都被锁死在这句话里

995
00:35:13,800 --> 00:35:14,900
所以啊大家应该知道

996
00:35:14,900 --> 00:35:16,966
这个其实就是操作系统中间所说的

997
00:35:16,966 --> 00:35:19,999
什么关键区的信号量

998
00:35:20,000 --> 00:35:21,100
信号量是一

999
00:35:21,366 --> 00:35:21,599
但是

1000
00:35:21,600 --> 00:35:25,333
我们其实并没有使用很明显的那种

1001
00:35:25,333 --> 00:35:26,766
关键区的那种方式

1002
00:35:26,766 --> 00:35:30,533
而是利用了数据库本身的行数

1003
00:35:31,466 --> 00:35:32,733
来利用他的行锁

1004
00:35:33,066 --> 00:35:34,799
把其他的县城

1005
00:35:34,966 --> 00:35:36,699
针对同一条支付交易的

1006
00:35:36,700 --> 00:35:38,666
这个退款的县城

1007
00:35:39,066 --> 00:35:40,533
给他锁死在这里

1008
00:35:40,533 --> 00:35:43,966
不同的不同的支付交易的退款

1009
00:35:44,166 --> 00:35:45,166
是没有问题的

1010
00:35:45,300 --> 00:35:47,666
但如果针对同一笔支付交易的退款

1011
00:35:47,900 --> 00:35:49,600
其他的县城就会被锁死在这里

1012
00:35:49,600 --> 00:35:51,100
等待后面做完

1013
00:35:52,500 --> 00:35:53,300
这个

1014
00:35:54,300 --> 00:35:55,566
如果他没有被锁死

1015
00:35:55,566 --> 00:35:56,399
那进来的话

1016
00:35:56,400 --> 00:35:58,400
他就会去创建退款交易

1017
00:35:58,400 --> 00:35:59,533
我们可以看到这个里头

1018
00:35:59,533 --> 00:36:00,366
我们就会知道说

1019
00:36:00,366 --> 00:36:02,333
为什么我们要把其他的锁死

1020
00:36:02,333 --> 00:36:03,533
因为这里做了判断

1021
00:36:03,900 --> 00:36:04,966
这个判断是

1022
00:36:06,133 --> 00:36:08,299
他的金额必须要小于支付金额

1023
00:36:08,700 --> 00:36:09,966
就是现在这个金额

1024
00:36:10,066 --> 00:36:12,199
加上目前的退款金额

1025
00:36:12,366 --> 00:36:15,733
必须要大于配券的支付金额

1026
00:36:16,100 --> 00:36:18,166
这个不是简单的去get属性啊

1027
00:36:18,166 --> 00:36:18,566
大家知道

1028
00:36:18,566 --> 00:36:20,533
因为我们得到的是一个满血模型

1029
00:36:20,666 --> 00:36:21,533
所以在这背后

1030
00:36:21,533 --> 00:36:23,566
其实都存在着数据库的操作

1031
00:36:23,800 --> 00:36:24,100
比如说

1032
00:36:24,100 --> 00:36:26,333
我们看到这个get refund的这个方法

1033
00:36:26,466 --> 00:36:29,866
其实会去调自己的get refund train list啊

1034
00:36:29,866 --> 00:36:30,666
这个会去调刀

1035
00:36:30,666 --> 00:36:32,066
对象去完成

1036
00:36:32,400 --> 00:36:34,366
这就是因为我们做成了满血模型以后

1037
00:36:34,366 --> 00:36:36,333
会使得我们的代码写的

1038
00:36:36,333 --> 00:36:37,733
看起来更加的简单

1039
00:36:38,166 --> 00:36:41,066
但实际上这些事情都还是去做

1040
00:36:41,333 --> 00:36:42,566
而这些做的事情

1041
00:36:42,566 --> 00:36:44,333
其实是被分配到了什么呢

1042
00:36:44,366 --> 00:36:46,133
分配到了不同的对象中间去

1043
00:36:46,600 --> 00:36:48,133
就是由信息专家的原则

1044
00:36:48,133 --> 00:36:49,466
在不停的做分配

1045
00:36:49,466 --> 00:36:50,999
我们的图上没有画这么细

1046
00:36:51,200 --> 00:36:53,400
但大家如果去看里头代码的话

1047
00:36:53,400 --> 00:36:55,333
会发现里头做了若干次

1048
00:36:55,333 --> 00:36:56,299
信息专家的指责

1049
00:36:56,300 --> 00:36:58,966
分配把最后这样的一件事情

1050
00:36:59,766 --> 00:37:00,766
比如说这样的一件事情

1051
00:37:00,766 --> 00:37:03,366
大家看起来轻松云淡的一个加起来

1052
00:37:03,366 --> 00:37:04,133
等于这件事情

1053
00:37:04,133 --> 00:37:06,133
其实是由很多对象协作来完成

1054
00:37:06,566 --> 00:37:07,866
就这个里头大家可以看到

1055
00:37:07,866 --> 00:37:09,966
他其实是有不同对象去协作

1056
00:37:10,133 --> 00:37:11,166
去完成了这样的一个事情

1057
00:37:11,166 --> 00:37:12,166
最后在我们这里看到的

1058
00:37:12,166 --> 00:37:14,366
就是这个金额

1059
00:37:14,366 --> 00:37:16,599
退款金额加上现在已有的退款金额

1060
00:37:16,666 --> 00:37:18,133
必须要大于他的支付金额

1061
00:37:18,400 --> 00:37:19,466
这也就是为什么

1062
00:37:19,466 --> 00:37:21,599
我们要把其他的这个支付

1063
00:37:21,600 --> 00:37:23,266
针对这一个支付交易的退款

1064
00:37:23,266 --> 00:37:24,533
全部锁死的原因

1065
00:37:24,866 --> 00:37:25,766
因为这个计算值

1066
00:37:25,766 --> 00:37:28,099
是根据当前的这个值来算的

1067
00:37:28,266 --> 00:37:30,066
如果大家同时来退款的话

1068
00:37:30,066 --> 00:37:31,599
就大家同时都能退回去

1069
00:37:32,100 --> 00:37:34,000
所以需要前面用数据库的函数

1070
00:37:34,100 --> 00:37:35,766
把他其他的锁死在那

1071
00:37:35,766 --> 00:37:36,566
让他进不来

1072
00:37:36,666 --> 00:37:40,499
而这里根据这个进来的这个当前来算

1073
00:37:40,500 --> 00:37:41,166
啊

1074
00:37:41,166 --> 00:37:42,933
那这里其实我们在数据库隔离上呢

1075
00:37:42,933 --> 00:37:45,399
也要把它从我们最基本的

1076
00:37:45,400 --> 00:37:46,866
那个repeatable的

1077
00:37:47,100 --> 00:37:49,866
就是read repeatable read的这个隔离

1078
00:37:50,000 --> 00:37:51,900
改成read committed的隔离

1079
00:37:52,166 --> 00:37:53,333
这个原因就是因为

1080
00:37:53,400 --> 00:37:55,100
我们的被锁死的事物

1081
00:37:55,100 --> 00:37:55,966
其实已经到了

1082
00:37:55,966 --> 00:37:57,266
已经进入到事物了

1083
00:37:57,366 --> 00:37:58,499
但是他到这里读的时候

1084
00:37:58,500 --> 00:38:01,366
他必须要读到当前的的这个值

1085
00:38:01,533 --> 00:38:03,733
而不是事物开始的那个值

1086
00:38:04,266 --> 00:38:05,066
这则就涉及到了

1087
00:38:05,066 --> 00:38:07,099
我们在数据库的隔离级别

1088
00:38:07,100 --> 00:38:09,066
数据库的数等等的相关知识

1089
00:38:09,066 --> 00:38:10,066
来写这段代码

1090
00:38:10,066 --> 00:38:12,333
所以他的这个代码为什么复杂

1091
00:38:12,333 --> 00:38:14,133
不是简单的把这个逻辑写下来

1092
00:38:14,133 --> 00:38:14,966
而要综合利用

1093
00:38:14,966 --> 00:38:15,966
我们的技术方向中的

1094
00:38:15,966 --> 00:38:17,733
一系列的这些特性啊

1095
00:38:17,733 --> 00:38:18,899
来完成这个过程

1096
00:38:19,866 --> 00:38:21,266
分站同样做这样一个判断

1097
00:38:21,266 --> 00:38:22,199
这个判断大家知道

1098
00:38:22,200 --> 00:38:23,366
也会去查数据库

1099
00:38:23,966 --> 00:38:24,799
但在这里写的话

1100
00:38:24,800 --> 00:38:26,000
其实是相对比较简单

1101
00:38:26,000 --> 00:38:29,000
因为我们把这个职责分配给了这个

1102
00:38:30,066 --> 00:38:31,966
分配给了这个其他的这些对象

1103
00:38:33,966 --> 00:38:35,733
分配给了这个配券的对象去完成

1104
00:38:35,733 --> 00:38:37,899
所以我们只需要知道配券对象问他要

1105
00:38:38,266 --> 00:38:39,866
你到现在分了多少钱

1106
00:38:40,366 --> 00:38:44,399
所有的分账的交易的这个钱

1107
00:38:44,600 --> 00:38:48,266
然后去掉他的这个get refund

1108
00:38:48,266 --> 00:38:50,066
分账交易的get refund

1109
00:38:50,866 --> 00:38:52,966
among这个大家应该知道

1110
00:38:52,966 --> 00:38:54,133
这是违背了什么原则

1111
00:38:56,366 --> 00:38:57,166
这一段

1112
00:39:01,733 --> 00:39:02,666
准备了什么原则

1113
00:39:03,000 --> 00:39:04,200
不和陌生人说话

1114
00:39:04,200 --> 00:39:06,400
对啊这就是梅菲尔低比特原则

1115
00:39:06,400 --> 00:39:07,333
低米特原则

1116
00:39:07,933 --> 00:39:09,666
是啊所以我我如果任意挑一段

1117
00:39:09,666 --> 00:39:11,266
问你说这一段违背了什么原则

1118
00:39:11,266 --> 00:39:12,499
你应该能找出来给你

1119
00:39:12,600 --> 00:39:14,666
就是我们如果说考简单的

1120
00:39:14,666 --> 00:39:16,466
就是把这段代码杀出给你看

1121
00:39:16,466 --> 00:39:18,599
然后你说这里头到底违背了什么原则

1122
00:39:18,600 --> 00:39:19,866
应该也能看出来啊

1123
00:39:20,066 --> 00:39:21,566
这一段违背了迪比特原则

1124
00:39:22,600 --> 00:39:25,300
对吧所以他加上这个金额

1125
00:39:25,300 --> 00:39:27,166
必须大于他的这个支付金额

1126
00:39:27,200 --> 00:39:28,100
这样的话呢

1127
00:39:28,100 --> 00:39:29,766
小于他的金额才能退

1128
00:39:29,900 --> 00:39:30,700
才能退款

1129
00:39:30,866 --> 00:39:32,533
所以在这个构造函数里面

1130
00:39:32,533 --> 00:39:33,733
大家看似CO的函数

1131
00:39:33,733 --> 00:39:35,399
其实把我们把这些逻辑

1132
00:39:36,100 --> 00:39:38,200
把他用信息增压的原则分配到这个构

1133
00:39:38,200 --> 00:39:38,900
造函数里

1134
00:39:38,900 --> 00:39:40,966
然后让他去完成这样一个判断

1135
00:39:41,333 --> 00:39:45,933
最后把这个对象给他构造出来

1136
00:39:46,066 --> 00:39:48,299
那如果他能成功的构造出这个对象

1137
00:39:48,300 --> 00:39:49,100
就说明说

1138
00:39:49,100 --> 00:39:51,566
他这个退款是满足这些逻辑的

1139
00:39:52,000 --> 00:39:54,366
我们则把这个退款对象

1140
00:39:54,366 --> 00:39:55,499
给他插到数据库里去

1141
00:39:55,500 --> 00:39:57,933
然后把他再查回来

1142
00:39:57,933 --> 00:39:59,733
是满血的模型

1143
00:39:59,966 --> 00:40:01,099
满血模型是为什么

1144
00:40:01,100 --> 00:40:04,400
是因为我们在后面去调用它的

1145
00:40:04,400 --> 00:40:06,200
这个分脏的时候

1146
00:40:07,000 --> 00:40:07,733
大家可以看到

1147
00:40:07,733 --> 00:40:09,333
同样它里头会去调

1148
00:40:10,466 --> 00:40:12,066
会去调它的这个

1149
00:40:13,700 --> 00:40:14,500
其他的方法啊

1150
00:40:14,500 --> 00:40:15,266
我们就不去看了

1151
00:40:15,266 --> 00:40:17,166
不去调他的这个shop channel

1152
00:40:17,166 --> 00:40:17,933
等等这些方法

1153
00:40:17,933 --> 00:40:19,733
所以需要把一个满血模型给他

1154
00:40:20,100 --> 00:40:22,400
那这是这个如果有分叉的话

1155
00:40:22,400 --> 00:40:24,566
就会走中间这一段分叉的话

1156
00:40:24,566 --> 00:40:25,133
我们可以看到

1157
00:40:25,133 --> 00:40:26,699
我们把这个

1158
00:40:27,800 --> 00:40:28,966
如果他是有分账的话

1159
00:40:28,966 --> 00:40:30,399
那我们得到他的分账对象

1160
00:40:30,400 --> 00:40:32,733
然后把分账交易的退款职责

1161
00:40:32,733 --> 00:40:34,999
分给了他的分账对象去完成

1162
00:40:37,000 --> 00:40:38,666
所以在这里头大家可以看到

1163
00:40:39,600 --> 00:40:41,300
分账对象的这张独立的图

1164
00:40:41,300 --> 00:40:42,266
就是发这里的

1165
00:40:42,500 --> 00:40:44,100
他这里同样的有这个逻辑

1166
00:40:44,100 --> 00:40:45,700
去构造分账对象

1167
00:40:45,700 --> 00:40:46,933
然后把它存进去

1168
00:40:46,933 --> 00:40:47,999
把它找出来

1169
00:40:48,866 --> 00:40:49,666
然后呢

1170
00:40:50,166 --> 00:40:52,533
再去调这个支付渠道

1171
00:40:52,566 --> 00:40:54,266
去把分账退回来

1172
00:40:54,333 --> 00:40:56,266
把分账退回来的这个结果

1173
00:40:56,333 --> 00:41:00,133
更新到我们的这个呃交易中间

1174
00:41:00,133 --> 00:41:01,333
把它存到数据库里啊

1175
00:41:01,333 --> 00:41:02,466
然后把它返还回去

1176
00:41:02,466 --> 00:41:04,733
这就是我们这个退款

1177
00:41:04,733 --> 00:41:06,399
交易的总体的逻辑啊

1178
00:41:06,400 --> 00:41:07,533
就是这样一个逻辑

1179
00:41:08,766 --> 00:41:11,566
所以这张设计相对比较麻烦一点

1180
00:41:11,566 --> 00:41:13,566
他用到了我们多次的

1181
00:41:13,566 --> 00:41:15,799
面向对象的创建者和信息专家

1182
00:41:16,333 --> 00:41:19,166
然后呢再加上我们在之前说到过的

1183
00:41:19,166 --> 00:41:23,399
当我们去调这个渠道的API的时候

1184
00:41:23,400 --> 00:41:26,266
这个都是Disco复刻替换原则

1185
00:41:26,800 --> 00:41:27,800
开闭原则

1186
00:41:28,000 --> 00:41:29,000
依赖导致原则

1187
00:41:29,100 --> 00:41:30,200
对吧因为三个

1188
00:41:30,200 --> 00:41:31,500
其实我们这里所有的API

1189
00:41:31,566 --> 00:41:33,399
走到这一块都是一样

1190
00:41:33,900 --> 00:41:34,933
那除了这个以外

1191
00:41:34,933 --> 00:41:36,166
就是我们这里说到的

1192
00:41:36,166 --> 00:41:37,799
两次用到的创建者

1193
00:41:37,900 --> 00:41:39,500
一次用到了信息专家

1194
00:41:39,566 --> 00:41:41,333
信息专家的原则

1195
00:41:41,866 --> 00:41:45,166
这就是我们的最复杂的和支付谋划

1196
00:41:45,166 --> 00:41:46,466
中间最复杂的一个API

1197
00:41:46,466 --> 00:41:47,266
就是这个API

1198
00:41:48,333 --> 00:41:48,999
所以这个API

1199
00:41:49,000 --> 00:41:50,966
如果没有做任何职责分配的话

1200
00:41:50,966 --> 00:41:51,766
就长这样

1201
00:41:53,700 --> 00:41:55,066
没有做任何资质分分化

1202
00:41:55,066 --> 00:41:56,299
就就长成这样

1203
00:41:57,666 --> 00:41:59,466
啊这个还是有一定的误导性

1204
00:41:59,466 --> 00:42:00,966
因为你从这个来看的话

1205
00:42:00,966 --> 00:42:03,199
上面还有Bo对象

1206
00:42:04,366 --> 00:42:06,133
但是这些Bo对象这里画上去

1207
00:42:06,133 --> 00:42:08,066
其实只是作为评选的Bo对象

1208
00:42:08,066 --> 00:42:09,966
并没有任何的业务分给他

1209
00:42:10,066 --> 00:42:12,666
所有的业务还是在这个里头

1210
00:42:13,000 --> 00:42:15,266
所以当你去分析一个设计的时候

1211
00:42:15,566 --> 00:42:16,999
他存在的问题在哪

1212
00:42:17,200 --> 00:42:18,100
就是你可以看到

1213
00:42:18,100 --> 00:42:19,933
设备层有长长的一串这个代码

1214
00:42:20,200 --> 00:42:20,700
你就知道

1215
00:42:20,700 --> 00:42:23,200
他没有用面向对象的方式去做的分配

1216
00:42:23,400 --> 00:42:26,200
所以你要用面向对象的方式去做分配

1217
00:42:26,800 --> 00:42:26,966
啊

1218
00:42:26,966 --> 00:42:28,999
这个设计是我们今天已经改进完了的

1219
00:42:29,000 --> 00:42:30,500
所以我们不大可能把这个设计

1220
00:42:30,500 --> 00:42:32,966
作为一个考题来考

1221
00:42:32,966 --> 00:42:35,099
去年是把这个设计作为考题来考

1222
00:42:35,466 --> 00:42:36,599
就这个就这个题

1223
00:42:36,600 --> 00:42:39,166
大家应该看最后道题的20分的改进

1224
00:42:39,166 --> 00:42:39,899
设计题就这个

1225
00:42:39,900 --> 00:42:41,000
你考他们怎么改

1226
00:42:42,166 --> 00:42:43,066
同学做不完

1227
00:42:43,300 --> 00:42:45,000
所以所以我们今年发现

1228
00:42:45,000 --> 00:42:47,133
就不能把这么复杂的问题交给同学们

1229
00:42:47,133 --> 00:42:49,066
在考试的时候三四十分钟报完

1230
00:42:49,333 --> 00:42:50,666
因为大部分同学

1231
00:42:50,666 --> 00:42:52,299
其实没有办法在三四十分钟之内

1232
00:42:52,300 --> 00:42:53,933
把事情想清楚

1233
00:42:54,566 --> 00:42:56,599
然后再把图完整的画出来

1234
00:42:56,733 --> 00:42:57,999
这个有难度啊

1235
00:42:58,066 --> 00:42:59,333
所以今天我们会稍微

1236
00:42:59,800 --> 00:43:01,700
选一些相对比较简单的问题

1237
00:43:01,700 --> 00:43:02,900
让大家去发现啊

1238
00:43:02,900 --> 00:43:05,133
不可能把这么复杂的这个

1239
00:43:05,266 --> 00:43:06,399
去给大家去考

1240
00:43:08,100 --> 00:43:10,466
好这就是我们今天要讲的内容

1241
00:43:10,466 --> 00:43:11,399
有什么问题吗

1242
00:43:14,066 --> 00:43:14,899
所以大家应该知道

1243
00:43:14,900 --> 00:43:16,500
从这一周开始

1244
00:43:16,500 --> 00:43:19,766
我们实际上就是在讲说我们会考试的

1245
00:43:19,766 --> 00:43:22,499
后面40分或者50分的分题题

1246
00:43:22,500 --> 00:43:24,066
和分题设计题

1247
00:43:24,066 --> 00:43:26,099
就是我们所讲的这些内容

1248
00:43:26,600 --> 00:43:28,366
其中分析式例题我不会讲答案

1249
00:43:28,366 --> 00:43:29,966
大家自己去做啊

1250
00:43:30,066 --> 00:43:31,099
但是问题基本就是

1251
00:43:31,100 --> 00:43:33,300
我们在上课中间会提到这些问题

1252
00:43:33,733 --> 00:43:34,933
好今天推荐到这里

