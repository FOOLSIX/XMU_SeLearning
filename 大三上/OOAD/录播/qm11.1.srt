1
00:00:33,700 --> 00:00:37,933
好啊周一我们开始讲这个设计了啊

2
00:00:37,933 --> 00:00:42,666
所以大家会觉得我们的设计这个部分

3
00:00:43,100 --> 00:00:46,133
会相对比较难以理解一点

4
00:00:46,666 --> 00:00:49,366
因为这个是我们真正面行

5
00:00:49,366 --> 00:00:51,566
对行设计的最核心的部分

6
00:00:51,566 --> 00:00:53,299
也就是前面的需求啊

7
00:00:53,300 --> 00:00:54,066
包括那些东西

8
00:00:54,066 --> 00:00:58,266
都是为后面的这个部分来做准备的

9
00:00:58,733 --> 00:01:01,866
那我因为在稍微回顾一下

10
00:01:01,866 --> 00:01:03,166
我们的周一讲的

11
00:01:03,166 --> 00:01:05,299
快速的回顾下我们的周一讲的内容

12
00:01:05,666 --> 00:01:09,866
我们从地区这个最简单的模块着手

13
00:01:10,366 --> 00:01:12,933
来讲说我们整体的体系结构

14
00:01:13,066 --> 00:01:14,966
整体的面向对行设计啊

15
00:01:14,966 --> 00:01:16,599
是怎样来做的

16
00:01:17,400 --> 00:01:18,666
从体系结构来说啊

17
00:01:18,666 --> 00:01:20,966
我们的这个设计的结构

18
00:01:20,966 --> 00:01:23,866
其实是融合了两种体系结构

19
00:01:23,933 --> 00:01:27,266
就是层次型的MVC的体系结构

20
00:01:27,700 --> 00:01:30,200
和六边形的结构

21
00:01:30,500 --> 00:01:34,133
为什么会是说融合了两种结构呢

22
00:01:34,166 --> 00:01:36,166
就是我们在大的结构上头

23
00:01:36,166 --> 00:01:39,533
还是看起来像MVC的层次结构

24
00:01:39,533 --> 00:01:43,699
特别是控制器service到和Mapper

25
00:01:43,900 --> 00:01:45,166
从上往下

26
00:01:45,166 --> 00:01:46,599
不允许跨

27
00:01:47,133 --> 00:01:49,333
不允许这个从下往上的

28
00:01:49,333 --> 00:01:50,399
这样的一个调用

29
00:01:51,133 --> 00:01:53,933
呃在这个四层中间

30
00:01:53,933 --> 00:01:56,066
控制气层和map层

31
00:01:56,066 --> 00:01:56,599
相当于

32
00:01:56,600 --> 00:02:00,266
我们在六层六边形结构中间的最外围

33
00:02:01,100 --> 00:02:02,266
也就是控制器程

34
00:02:02,266 --> 00:02:04,766
负责去完成输入和输出

35
00:02:04,866 --> 00:02:06,566
形成restful API

36
00:02:06,966 --> 00:02:09,199
就相当于我们这里的restful Adapter

37
00:02:09,666 --> 00:02:10,766
map层呢

38
00:02:10,766 --> 00:02:16,299
是负责真正去存储存储或者获取数据

39
00:02:16,733 --> 00:02:17,533
我们在这里

40
00:02:17,566 --> 00:02:19,499
在这个模块中间的map程

41
00:02:19,500 --> 00:02:20,900
其实就做了一件事情

42
00:02:21,066 --> 00:02:23,699
就是往关系数据库里头去存记录

43
00:02:24,066 --> 00:02:27,666
所以这里相当于它的ORM的Adapter啊

44
00:02:27,666 --> 00:02:28,399
相当于

45
00:02:28,400 --> 00:02:33,200
所以在层次结构中间的最上面一层

46
00:02:33,200 --> 00:02:34,666
和最下面一层

47
00:02:34,666 --> 00:02:36,899
我们对照到六边形结构中间

48
00:02:36,900 --> 00:02:37,500
就是最外头

49
00:02:37,500 --> 00:02:38,300
这一圈

50
00:02:39,100 --> 00:02:42,100
那中间的seven层和稻层

51
00:02:42,900 --> 00:02:45,266
其实是我们的什么呢

52
00:02:45,533 --> 00:02:49,599
稻层有一半其实是在这个圈的外围

53
00:02:49,600 --> 00:02:53,266
就是我们会有一半跟存储有关

54
00:02:53,666 --> 00:02:57,099
那有一半是在应用的这个范围

55
00:02:57,333 --> 00:02:57,699
所以

56
00:02:57,700 --> 00:03:02,300
service和道这两层其实是属于什么呢

57
00:03:02,300 --> 00:03:03,466
属于我们这个

58
00:03:05,500 --> 00:03:09,133
application这一块中间的Bo

59
00:03:11,600 --> 00:03:15,933
中间的那个Bo相当于我们的领域模型

60
00:03:16,466 --> 00:03:19,699
这是混合了两种体系结构啊

61
00:03:19,700 --> 00:03:22,766
就是我们大的层次结构和大的结构上

62
00:03:22,966 --> 00:03:25,766
遵循了MVC的层次体系结构

63
00:03:25,766 --> 00:03:28,766
但是其实在MVC的层次体格结构里头

64
00:03:28,933 --> 00:03:29,766
每一层

65
00:03:30,133 --> 00:03:32,966
又融入了六边形的这样一个概念

66
00:03:33,300 --> 00:03:35,866
所以这是第一这样的一个思路

67
00:03:35,866 --> 00:03:37,933
那第二个就是我们在上面要做啥

68
00:03:38,400 --> 00:03:39,766
我们这里既

69
00:03:41,133 --> 00:03:43,899
体现了在MVC的这样层次体系结构

70
00:03:43,900 --> 00:03:47,200
相同每一层有对应的职责

71
00:03:47,466 --> 00:03:49,733
特别是上下两层

72
00:03:49,733 --> 00:03:52,133
控制器层和map程

73
00:03:52,500 --> 00:03:53,866
职责是非常清晰的

74
00:03:53,866 --> 00:03:56,133
控制层就是用来去做research VPI的

75
00:03:56,533 --> 00:03:57,299
输入数据

76
00:03:57,300 --> 00:03:58,133
输出数据

77
00:03:58,133 --> 00:03:59,199
没有别的事情

78
00:03:59,566 --> 00:04:01,866
map程就是用来去存数据的

79
00:04:02,000 --> 00:04:04,100
所以数据怎么存到数据库里

80
00:04:04,100 --> 00:04:05,600
在这个模块中间

81
00:04:05,600 --> 00:04:07,400
数据怎么存到数据库里

82
00:04:07,800 --> 00:04:09,566
这是由mark层去做的

83
00:04:09,600 --> 00:04:13,133
所以上下两层的这个职责的分配

84
00:04:13,533 --> 00:04:14,566
就是沿用了

85
00:04:14,566 --> 00:04:15,699
在MVC中间

86
00:04:15,700 --> 00:04:17,966
每一层有非常清晰的职责

87
00:04:18,400 --> 00:04:19,533
中间的两层

88
00:04:19,533 --> 00:04:20,733
service层和盗层

89
00:04:20,733 --> 00:04:23,666
我们采用了六边形的方式

90
00:04:24,200 --> 00:04:29,200
也就是我们力图把尽量多的逻辑

91
00:04:30,166 --> 00:04:32,299
冲到领域模型里头去

92
00:04:32,666 --> 00:04:33,866
就换句话说

93
00:04:33,866 --> 00:04:34,999
形象的来说

94
00:04:35,133 --> 00:04:35,333
就是

95
00:04:35,333 --> 00:04:38,599
我们尽量把代码写到Bo对象中间去

96
00:04:38,666 --> 00:04:40,733
就是我们中间所指的领域模型

97
00:04:40,766 --> 00:04:42,299
而尽量使得

98
00:04:43,766 --> 00:04:45,133
application的代码变

99
00:04:45,133 --> 00:04:46,666
得非常的单薄

100
00:04:46,933 --> 00:04:47,966
这个单薄化

101
00:04:47,966 --> 00:04:49,333
会造成一个什么样的结果呢

102
00:04:49,333 --> 00:04:51,299
对于service层来说

103
00:04:51,466 --> 00:04:53,499
它的代码变得非常的少

104
00:04:54,000 --> 00:04:57,466
它的代码就是用来去分配任务的

105
00:04:58,100 --> 00:04:59,300
对于稻城来说

106
00:04:59,300 --> 00:05:00,700
他代码不会变少

107
00:05:00,700 --> 00:05:02,800
但是代码会变得非常的单调

108
00:05:03,000 --> 00:05:06,066
也就是所有的稻城的代码就4个事情

109
00:05:06,066 --> 00:05:08,899
真相改查三个方法是固定的

110
00:05:08,900 --> 00:05:11,500
新增修改和删除

111
00:05:11,500 --> 00:05:12,200
有的还没有

112
00:05:12,200 --> 00:05:15,333
这个删除查是很多样的

113
00:05:15,466 --> 00:05:17,533
因为我们在Bo对象中间

114
00:05:17,533 --> 00:05:19,566
会有各种各样要去查的需求

115
00:05:19,566 --> 00:05:22,166
所以他查的方法是会非常多的

116
00:05:22,300 --> 00:05:26,100
但是对于新增删除和修改

117
00:05:26,200 --> 00:05:27,700
这三个方法就是固定的

118
00:05:27,700 --> 00:05:30,000
所有的盗城方法都是固定的

119
00:05:30,200 --> 00:05:31,800
这样的一种做法啊

120
00:05:31,800 --> 00:05:33,800
我们尽量的把逻辑

121
00:05:33,800 --> 00:05:36,066
吸到中间的Bo对象来

122
00:05:36,066 --> 00:05:36,366
或者

123
00:05:36,366 --> 00:05:39,766
尽量把代码吸到中间的Bo对象里头来

124
00:05:40,933 --> 00:05:43,199
使得我们整个的体系结构

125
00:05:43,266 --> 00:05:45,199
变成一个充血模型

126
00:05:45,466 --> 00:05:47,266
我们在设计中间可以看到

127
00:05:47,266 --> 00:05:47,499
其实

128
00:05:47,500 --> 00:05:50,566
我们比在滴滴中间提出来的充血模型

129
00:05:50,566 --> 00:05:51,466
更加接近

130
00:05:51,866 --> 00:05:52,733
因为我们在学校里头

131
00:05:52,733 --> 00:05:53,866
经常是可以做一些

132
00:05:53,866 --> 00:05:56,533
比业内更加激进的做法

133
00:05:56,733 --> 00:05:58,466
就是你要知道这样的做法好不好

134
00:05:58,466 --> 00:05:59,799
你其实就是鲁迅说的

135
00:05:59,800 --> 00:06:00,800
我想开个窗

136
00:06:01,000 --> 00:06:03,766
我首先把一堵墙给他打掉啊

137
00:06:03,766 --> 00:06:05,899
所以我们会做更激进的的做法

138
00:06:06,100 --> 00:06:09,000
让中间的领域模型尽量的壮大

139
00:06:09,400 --> 00:06:11,266
变成一个满血模型

140
00:06:11,466 --> 00:06:14,799
使得我们在应用层的代码

141
00:06:14,800 --> 00:06:16,600
变得尽量的铅薄

142
00:06:17,133 --> 00:06:18,799
少或者单调

143
00:06:19,266 --> 00:06:20,966
对于社会层代码来说就是少

144
00:06:21,000 --> 00:06:23,133
对于道层代码来说就是单调

145
00:06:23,400 --> 00:06:25,366
就是都是看起来都是一样的啊

146
00:06:25,366 --> 00:06:26,899
没有任何营养的代码

147
00:06:27,000 --> 00:06:29,400
有营养的东西全部在独门层

148
00:06:29,566 --> 00:06:31,766
所以外面那一层控制器层负

149
00:06:31,766 --> 00:06:34,599
责去解决输入输出buff层

150
00:06:34,600 --> 00:06:36,000
负责去解决技术的问题

151
00:06:36,000 --> 00:06:37,100
怎么去存数据啊

152
00:06:37,100 --> 00:06:40,200
这都是跟具体的技术架构是有关的

153
00:06:40,533 --> 00:06:43,733
中间的这个部分来说啊

154
00:06:44,533 --> 00:06:46,133
让应用层变得纤薄

155
00:06:46,566 --> 00:06:49,066
Doman的对象变得丰满

156
00:06:49,266 --> 00:06:52,299
这是我们整体的设计的意图啊

157
00:06:52,300 --> 00:06:53,700
设计是要有意图的

158
00:06:54,000 --> 00:06:55,933
那为什么想要这么做

159
00:06:56,900 --> 00:06:58,100
这就是这个意图

160
00:06:58,200 --> 00:06:59,800
为什么要这么做的意图

161
00:06:59,900 --> 00:07:01,100
大家为什么要这么做

162
00:07:02,600 --> 00:07:04,000
啊为什么要这么做

163
00:07:05,166 --> 00:07:06,566
你你不能说啊

164
00:07:06,700 --> 00:07:07,700
有人说MVC

165
00:07:07,700 --> 00:07:08,600
你就做MVC

166
00:07:08,600 --> 00:07:09,866
有人说滴滴滴

167
00:07:09,866 --> 00:07:10,899
你就做滴滴滴

168
00:07:11,066 --> 00:07:13,499
然后你不知道你到底想要干嘛

169
00:07:13,500 --> 00:07:14,700
为什么要做MVC

170
00:07:14,700 --> 00:07:15,733
为什么要做滴滴滴

171
00:07:15,933 --> 00:07:17,466
我们这么做的目的

172
00:07:17,466 --> 00:07:18,966
其实最根本的原因

173
00:07:18,966 --> 00:07:21,066
其实就是一个什么呢

174
00:07:21,900 --> 00:07:22,766
模块化

175
00:07:29,133 --> 00:07:31,966
无论面向对象还是面向工人

176
00:07:32,166 --> 00:07:33,766
设计的主要的目的

177
00:07:33,766 --> 00:07:36,266
就是把复杂的问题变成简单的问题

178
00:07:36,533 --> 00:07:38,333
只不是面向工人的做法

179
00:07:38,333 --> 00:07:40,199
和面向对象的做法不一样而已

180
00:07:40,700 --> 00:07:43,466
变向功能的做法就是简单粗暴

181
00:07:43,533 --> 00:07:44,766
大问题变成小问题

182
00:07:44,766 --> 00:07:45,766
小问题变成更小的问题

183
00:07:45,766 --> 00:07:47,699
反正就这么擦擦擦切就好了

184
00:07:47,766 --> 00:07:49,066
这个大家都会啊

185
00:07:49,533 --> 00:07:50,966
那面向对象呢

186
00:07:50,966 --> 00:07:52,799
试图用另外一种方式去做

187
00:07:53,066 --> 00:07:53,366
但是

188
00:07:53,366 --> 00:07:58,299
他归根结底还是把它分解成为小块

189
00:07:58,300 --> 00:07:59,966
只不是分解的标准不一样

190
00:08:00,066 --> 00:08:03,366
没有像面相功能那样那么简单粗暴

191
00:08:03,500 --> 00:08:04,366
怎么分解法

192
00:08:04,366 --> 00:08:07,266
就是我们在GRASP中讲的创建者的方式

193
00:08:07,300 --> 00:08:08,466
信息专家的方式

194
00:08:08,500 --> 00:08:09,900
是两个最主流的

195
00:08:09,900 --> 00:08:12,533
可以说 80%的分解

196
00:08:12,533 --> 00:08:15,133
都是用创建者和信息专家的方式

197
00:08:15,133 --> 00:08:16,066
去完成的

198
00:08:16,300 --> 00:08:18,366
那为什么我们要用一种不同的方式

199
00:08:18,366 --> 00:08:19,866
去分解这些功能

200
00:08:20,466 --> 00:08:21,099
原因就是

201
00:08:21,100 --> 00:08:23,766
因为大家在这张图上就能看到

202
00:08:24,800 --> 00:08:27,566
我们如果做评选模型的话

203
00:08:27,666 --> 00:08:30,966
所有的代码全部在service的层上

204
00:08:31,200 --> 00:08:32,733
和稻城的代码上

205
00:08:32,733 --> 00:08:34,299
就在这两个类上面

206
00:08:35,400 --> 00:08:37,800
那我们现在做成满血模型

207
00:08:37,900 --> 00:08:40,400
目的是使得这个部分的代码尽量的少

208
00:08:40,533 --> 00:08:41,366
代码跑哪去了

209
00:08:41,366 --> 00:08:42,699
代码因为你事情做出来

210
00:08:42,700 --> 00:08:43,766
代码都这样写的

211
00:08:43,766 --> 00:08:45,266
不是说你代码可以不写

212
00:08:45,566 --> 00:08:46,266
代码跑到哪了

213
00:08:46,266 --> 00:08:47,199
跑到这里来了

214
00:08:48,166 --> 00:08:49,199
这个部分的代码呢

215
00:08:49,200 --> 00:08:49,766
还有

216
00:08:49,766 --> 00:08:53,199
但这个大部分代码变得尽量的单调

217
00:08:53,333 --> 00:08:54,266
登山改查

218
00:08:54,600 --> 00:08:56,500
所有跟业务有关的代码

219
00:08:56,533 --> 00:08:57,666
也跑到这里来了

220
00:08:57,666 --> 00:09:01,699
这就是我们说的领域模型的障大

221
00:09:02,800 --> 00:09:04,533
中间的这个领域模型的壮大

222
00:09:04,533 --> 00:09:05,899
代码代码往里头跑了

223
00:09:06,300 --> 00:09:08,133
为什么要把代码跑到这里来

224
00:09:08,300 --> 00:09:11,133
在这个模块不明显

225
00:09:11,533 --> 00:09:14,199
但是如果大家去看支付模块的话

226
00:09:15,066 --> 00:09:17,733
收费时成大概就是三四个类

227
00:09:18,400 --> 00:09:20,266
稻城的话七八个类

228
00:09:20,733 --> 00:09:22,533
bo的话十几个

229
00:09:23,200 --> 00:09:27,266
所以在整个的这个结构中间

230
00:09:27,266 --> 00:09:29,866
Bo层的东西是最多的

231
00:09:29,866 --> 00:09:31,566
我们的领域越复杂

232
00:09:31,600 --> 00:09:33,166
Bo层就变得越多

233
00:09:33,933 --> 00:09:35,266
所以你想说

234
00:09:35,266 --> 00:09:38,599
你把逻辑分到这些这么多的地方上去

235
00:09:38,600 --> 00:09:40,166
必然就会有一个结果

236
00:09:40,766 --> 00:09:41,933
分的会更细

237
00:09:42,366 --> 00:09:43,466
分的会更小

238
00:09:44,200 --> 00:09:45,966
模块化分得越小

239
00:09:45,966 --> 00:09:46,766
大家知道

240
00:09:46,766 --> 00:09:49,799
必然就会使得复杂的问题变得更简单

241
00:09:50,000 --> 00:09:51,933
所以你会知道这个问题怎么去实现

242
00:09:52,100 --> 00:09:54,700
因为我们做分解的首要的原因

243
00:09:54,700 --> 00:09:56,933
是要把复杂问题简单化

244
00:09:57,366 --> 00:09:59,099
简单化了以后你就好实现

245
00:09:59,100 --> 00:10:01,133
而且这个简单化过程要自然

246
00:10:01,666 --> 00:10:03,333
因为你如果分解的不自然的话

247
00:10:03,333 --> 00:10:05,333
别人还要理解说你是怎么分的

248
00:10:05,800 --> 00:10:07,466
如果这个分解过程很自然

249
00:10:07,466 --> 00:10:08,266
其实大家觉得哎

250
00:10:08,266 --> 00:10:09,199
就是应该这么分

251
00:10:09,333 --> 00:10:10,466
看起来很舒服

252
00:10:10,466 --> 00:10:11,566
然后最后分下来以后

253
00:10:11,566 --> 00:10:13,499
每一块写代码也变得很容易

254
00:10:13,700 --> 00:10:17,400
这就是一个好写好懂的代码

255
00:10:17,500 --> 00:10:21,533
这是我们面向对象的第一个目标

256
00:10:21,766 --> 00:10:23,566
那同样变小了以后

257
00:10:23,566 --> 00:10:26,866
不仅仅就是每个模块变小了以后

258
00:10:26,866 --> 00:10:28,366
每一段代码变小了以后

259
00:10:28,366 --> 00:10:30,133
不仅仅是为了好写好懂

260
00:10:30,200 --> 00:10:32,333
更多重要的是为了什么呢

261
00:10:32,533 --> 00:10:33,599
是为了重用

262
00:10:35,766 --> 00:10:36,199
大家知道

263
00:10:36,200 --> 00:10:38,166
我们设计的主要的目标

264
00:10:41,500 --> 00:10:44,066
其实就是为了模块化和重用性

265
00:10:44,466 --> 00:10:47,999
要使得变小的代码被多次重用

266
00:10:48,100 --> 00:10:49,166
这样会使得什么

267
00:10:49,333 --> 00:10:51,066
整体的代码变得更少

268
00:10:51,400 --> 00:10:53,066
出错误的概率更小

269
00:10:53,366 --> 00:10:55,466
代码更加的结实

270
00:10:56,100 --> 00:10:59,866
那面向对象在模块化重用性的上头

271
00:10:59,866 --> 00:11:02,099
就加了第三条什么呢

272
00:11:02,100 --> 00:11:03,366
就是可扩展性

273
00:11:03,700 --> 00:11:05,066
当我们增加一个新的功能

274
00:11:05,066 --> 00:11:06,266
或者变对一个功能的时候

275
00:11:06,266 --> 00:11:08,566
我们的改动或者增加最小的

276
00:11:08,766 --> 00:11:13,199
所以面向对象的设计的终究的目的

277
00:11:13,200 --> 00:11:14,800
就是要模块化

278
00:11:14,933 --> 00:11:16,766
这是跟面相功能一样的

279
00:11:16,966 --> 00:11:17,799
从用性

280
00:11:17,900 --> 00:11:19,800
这个其实也是跟面相功能是一样的

281
00:11:19,866 --> 00:11:21,899
但是可扩展性

282
00:11:23,966 --> 00:11:28,133
是面向对象比面向功能的优势所在

283
00:11:28,366 --> 00:11:29,533
怎么达成的

284
00:11:29,666 --> 00:11:31,166
靠的其实就是我们所说的

285
00:11:31,166 --> 00:11:32,533
这种分解方式造成的

286
00:11:32,966 --> 00:11:34,666
其实它就是分解的方式不同

287
00:11:35,066 --> 00:11:37,399
所以说它能够达成模块化

288
00:11:37,466 --> 00:11:40,733
从用性和可扩展性这三个特点

289
00:11:42,333 --> 00:11:43,699
那我们来看一下

290
00:11:44,133 --> 00:11:46,466
回顾一下我们在周一讲过的

291
00:11:46,466 --> 00:11:49,066
这个创建者的

292
00:11:49,066 --> 00:11:52,666
这个创建者的这个设计的方法

293
00:11:52,666 --> 00:11:55,599
其实主要解决我们分解中间的

294
00:11:55,733 --> 00:11:56,866
间对下的问题

295
00:11:57,466 --> 00:11:58,733
如果说你不分解的话

296
00:11:58,733 --> 00:12:00,299
建对象的部分

297
00:12:00,533 --> 00:12:02,799
比如说你要有a对象b对象

298
00:12:02,866 --> 00:12:04,133
中间有一个关系

299
00:12:04,266 --> 00:12:06,533
你就会写一个代码去建一个a对象

300
00:12:06,533 --> 00:12:07,699
劝一个b对象

301
00:12:07,866 --> 00:12:09,966
然后把a对象和b对象

302
00:12:09,966 --> 00:12:12,466
关联起来写3行代码对吧

303
00:12:12,766 --> 00:12:14,099
当然如果对象更复杂的话

304
00:12:14,100 --> 00:12:15,100
你是要写更多的

305
00:12:15,100 --> 00:12:16,200
如果他的关系更复杂

306
00:12:16,200 --> 00:12:16,966
对象更多的话

307
00:12:16,966 --> 00:12:18,199
你要写更多的代码

308
00:12:18,200 --> 00:12:20,200
去把这样的一个对象实际化出来

309
00:12:20,333 --> 00:12:22,966
把对象的关系给他建出来啊

310
00:12:22,966 --> 00:12:23,499
我们说

311
00:12:23,500 --> 00:12:26,566
这样的代码是可以被分成多个部分的

312
00:12:27,400 --> 00:12:28,000
所以

313
00:12:28,000 --> 00:12:30,166
你如果用面向功能的方式去分的话

314
00:12:30,166 --> 00:12:31,133
都是见对象

315
00:12:31,133 --> 00:12:32,366
你就不知道说这个

316
00:12:32,366 --> 00:12:34,333
到底把这一长串

317
00:12:34,333 --> 00:12:36,699
见对象和见对象之间关系的代码

318
00:12:36,933 --> 00:12:38,733
到底分成多少个部分

319
00:12:38,966 --> 00:12:39,866
它是没办法分的

320
00:12:39,866 --> 00:12:41,099
因为它就是一件事情

321
00:12:41,466 --> 00:12:43,266
但是在面向对象的设计中间

322
00:12:43,266 --> 00:12:45,366
觉得这样的分解

323
00:12:45,733 --> 00:12:48,966
是要看对象和对象之间的关系

324
00:12:49,500 --> 00:12:50,400
我们在

325
00:12:57,133 --> 00:12:58,666
我们在创建者这个魔术中间

326
00:12:58,666 --> 00:13:00,166
认为对象和对象之间

327
00:13:00,166 --> 00:13:02,566
如果存在着组合关系的话

328
00:13:02,766 --> 00:13:05,133
我们就会让整体去创建局部

329
00:13:05,133 --> 00:13:06,166
那其他的话

330
00:13:06,333 --> 00:13:07,333
除了组合一

331
00:13:07,700 --> 00:13:09,466
除了组合关系以外

332
00:13:09,466 --> 00:13:10,666
如果有关联关系

333
00:13:10,900 --> 00:13:12,100
如果有依赖关系

334
00:13:12,100 --> 00:13:13,600
如果有他的初始化数据

335
00:13:13,900 --> 00:13:14,866
这个是可以考虑的

336
00:13:14,866 --> 00:13:16,333
对象就是后面三个

337
00:13:16,333 --> 00:13:19,533
不是特别明确的条件

338
00:13:19,533 --> 00:13:22,399
但是组合关系其实是一个强烈的暗示

339
00:13:22,800 --> 00:13:25,333
说你应该有整体去创建局部

340
00:13:25,700 --> 00:13:29,800
我们以创建子弟区来说

341
00:13:31,133 --> 00:13:33,999
创建此地区这样的一个功能啊

342
00:13:34,000 --> 00:13:34,700
这是个功能

343
00:13:34,700 --> 00:13:35,700
对于后端来说

344
00:13:35,700 --> 00:13:36,400
每一个API

345
00:13:36,400 --> 00:13:38,300
就是我们要去实现的一个功能

346
00:13:38,800 --> 00:13:40,733
对于这个功能来说

347
00:13:41,333 --> 00:13:43,099
我们要做的事情是

348
00:13:43,100 --> 00:13:45,066
要去建一个新的地区对象

349
00:13:45,066 --> 00:13:47,533
然后把它放到建一个新的地区

350
00:13:47,533 --> 00:13:50,199
把它放到上级地区的下面

351
00:13:53,400 --> 00:13:55,066
那我们是怎么做的

352
00:13:55,333 --> 00:13:57,799
我们这张图是唯一的一张

353
00:13:57,800 --> 00:14:00,566
从控制器层画到了最后面的图

354
00:14:00,800 --> 00:14:01,900
那之后的图里头

355
00:14:01,900 --> 00:14:04,300
我们其实不会再去画控制器层

356
00:14:04,566 --> 00:14:05,266
为什么呢

357
00:14:05,266 --> 00:14:08,133
你也看到控制器的逻辑非常的简单

358
00:14:08,700 --> 00:14:10,000
进来的数据

359
00:14:10,166 --> 00:14:11,666
传进来的数据是个VO

360
00:14:12,000 --> 00:14:15,200
首先把VO变成对象的Bo对象

361
00:14:15,533 --> 00:14:18,199
也就是我们后面是面向对象的世界

362
00:14:18,266 --> 00:14:20,533
所以说当我们传进来的东西

363
00:14:20,533 --> 00:14:23,299
跟我们面向对象的世界是不一样的

364
00:14:23,366 --> 00:14:25,799
情况下头你要去做映射

365
00:14:25,900 --> 00:14:27,500
当然我们现在这个模块很简单

366
00:14:27,500 --> 00:14:28,366
只有一个对象

367
00:14:28,366 --> 00:14:30,199
所以传这样的就可以直接映射过来

368
00:14:30,400 --> 00:14:32,600
有些时候是不能直接映射的

369
00:14:32,666 --> 00:14:34,133
需要去做转换啊

370
00:14:34,333 --> 00:14:36,866
所以第二句进来就是去做映射

371
00:14:37,133 --> 00:14:40,066
然后中间的逻辑就去调service层了

372
00:14:40,100 --> 00:14:42,866
做完了以后再把结果再映射成为do

373
00:14:43,000 --> 00:14:44,100
再把它返回去

374
00:14:44,466 --> 00:14:46,533
所以控制气层的逻辑

375
00:14:46,533 --> 00:14:49,399
就是做输入和输出的转换

376
00:14:49,566 --> 00:14:50,566
其他没有啥

377
00:14:50,900 --> 00:14:51,333
所以一般

378
00:14:51,333 --> 00:14:54,599
我们不会在做面向对象设计的时候

379
00:14:54,600 --> 00:14:57,600
去关心说控制气层要做什么

380
00:14:57,600 --> 00:14:59,166
我们关心的是什么呢

381
00:14:59,466 --> 00:15:00,999
关心的是中间这一段

382
00:15:03,066 --> 00:15:04,466
关心的是中间这一段

383
00:15:04,500 --> 00:15:07,466
就是我们在service层以下的这一段

384
00:15:07,800 --> 00:15:10,933
service层以上的提供的是功能

385
00:15:11,666 --> 00:15:14,466
稻城以下的提供的是

386
00:15:14,466 --> 00:15:17,133
我们怎么去操作那个具体的数据库

387
00:15:17,500 --> 00:15:18,866
我们关心的是什么呢

388
00:15:18,866 --> 00:15:21,766
就是设尾层和稻层之间的部分

389
00:15:21,933 --> 00:15:23,666
所以以后我们在画图的时候

390
00:15:23,666 --> 00:15:25,666
我们其实就不会再画到

391
00:15:25,866 --> 00:15:27,199
设尾层以上的东西

392
00:15:27,700 --> 00:15:29,100
和稻城以下的东西

393
00:15:29,366 --> 00:15:30,599
其实最关心的就是

394
00:15:30,600 --> 00:15:32,666
从生物之城到稻城这中间

395
00:15:33,400 --> 00:15:36,133
在这个中间到底发生了什么

396
00:15:36,133 --> 00:15:37,299
这中间是什么呢

397
00:15:37,533 --> 00:15:39,599
中间就是我们所说的Bo对象

398
00:15:39,700 --> 00:15:41,066
到底发生了什么

399
00:15:41,300 --> 00:15:42,533
所以面向对象的设计

400
00:15:42,533 --> 00:15:43,666
归根结底的问题就是

401
00:15:43,666 --> 00:15:45,766
当我们在

402
00:15:45,766 --> 00:15:47,866
这样的一个分层体系结构上头

403
00:15:47,900 --> 00:15:49,966
我们的收尾值层实现的是功能

404
00:15:50,166 --> 00:15:51,766
我们怎么把这个功能

405
00:15:51,966 --> 00:15:55,499
分解给了不同的Bo对象

406
00:15:55,700 --> 00:15:58,066
这就是我们在面向对象设计中间的

407
00:15:58,066 --> 00:15:59,199
最根本的问题

408
00:16:00,000 --> 00:16:01,800
所以在这个设计中心大家可以看到啊

409
00:16:01,800 --> 00:16:03,533
进来从社会层开始看起

410
00:16:03,533 --> 00:16:04,099
进来以后

411
00:16:04,100 --> 00:16:06,000
第一件事情就是把ID变成对象

412
00:16:06,600 --> 00:16:07,166
这个是面向对象

413
00:16:07,166 --> 00:16:09,766
是面向对象的设计的一个惯例

414
00:16:10,066 --> 00:16:12,333
因为从前端过来的是数据

415
00:16:12,333 --> 00:16:14,099
它不是对象

416
00:16:14,100 --> 00:16:17,000
就前面用户给你的是数据

417
00:16:17,566 --> 00:16:19,566
面向对象的设计的第一步

418
00:16:19,600 --> 00:16:23,333
就是应该尽可能的把数据变成对象

419
00:16:23,666 --> 00:16:26,533
然后再把职责分给这个对象

420
00:16:26,600 --> 00:16:28,566
我们现在可以看到第一句就第四句

421
00:16:28,566 --> 00:16:32,733
这个就是把前端场外的一个数据ID

422
00:16:33,200 --> 00:16:34,466
变成了一个对象

423
00:16:34,466 --> 00:16:37,566
这个对象是一个微景对象啊

424
00:16:37,566 --> 00:16:38,599
是一个reading对象

425
00:16:38,733 --> 00:16:40,366
所以这个对象

426
00:16:40,366 --> 00:16:41,733
我们就会把职责分配给他

427
00:16:41,733 --> 00:16:43,299
这因为我们在这个领域中间

428
00:16:43,500 --> 00:16:44,800
没有其他对象

429
00:16:44,800 --> 00:16:45,700
只有一个

430
00:16:46,366 --> 00:16:50,166
那我们就把如何创建子弟区的

431
00:16:50,166 --> 00:16:50,999
这个职责

432
00:16:51,000 --> 00:16:51,866
分配给他

433
00:16:52,000 --> 00:16:52,933
分配给他的原因

434
00:16:52,933 --> 00:16:55,599
就是因为我们在他的对象模型上的

435
00:16:55,600 --> 00:16:57,166
大家可以看到他是一个

436
00:16:58,866 --> 00:16:59,799
组合关系

437
00:17:00,133 --> 00:17:01,899
是一个conversation关系

438
00:17:02,466 --> 00:17:02,966
对吧

439
00:17:02,966 --> 00:17:05,266
所以我们把这个职责分给了什么呢

440
00:17:05,266 --> 00:17:07,566
分给了他的上级地区这个对象

441
00:17:08,000 --> 00:17:08,966
让他去完成

442
00:17:08,966 --> 00:17:10,499
你把下级地区给他建出来

443
00:17:12,100 --> 00:17:13,666
这样的一个做法

444
00:17:14,566 --> 00:17:15,799
就会使得我们这个代码

445
00:17:15,800 --> 00:17:17,933
是不可能做出另外一种可能性的

446
00:17:18,000 --> 00:17:18,766
这种可能性是

447
00:17:18,766 --> 00:17:20,999
我建出一个孤立的

448
00:17:21,000 --> 00:17:24,700
没有上级地区的地区出来

449
00:17:25,500 --> 00:17:26,500
就是这个设计

450
00:17:26,500 --> 00:17:27,566
就保证了

451
00:17:27,566 --> 00:17:29,999
我们的代码是不会出现这样的错误的

452
00:17:30,200 --> 00:17:31,533
是不可能出现这样的错误的

453
00:17:31,533 --> 00:17:34,999
因为这个间下级地区的这个事情

454
00:17:35,000 --> 00:17:36,400
就不可能孤立去做

455
00:17:36,566 --> 00:17:38,799
他就是交给上级地区的一个职责

456
00:17:38,800 --> 00:17:39,700
去完成的

457
00:17:39,766 --> 00:17:41,133
那上级地区

458
00:17:41,133 --> 00:17:42,533
是怎样去完成

459
00:17:42,533 --> 00:17:44,299
这样的一个间地区的过程的呢

460
00:17:45,066 --> 00:17:46,366
他进去以后

461
00:17:46,366 --> 00:17:48,899
首先判断一下当前的地区的状态

462
00:17:48,900 --> 00:17:50,600
是不是能见下级地区

463
00:17:51,166 --> 00:17:52,666
对吧这个职责

464
00:17:52,666 --> 00:17:55,299
其实为什么要在这个里头去做

465
00:17:55,400 --> 00:17:57,266
而不在身份证去做

466
00:17:57,800 --> 00:17:59,466
就是我们后面场的信息专家

467
00:17:59,733 --> 00:18:01,733
因为你要知道自己能不能建

468
00:18:01,733 --> 00:18:02,999
你需要知道自己的状态

469
00:18:03,000 --> 00:18:04,733
自己的状态这个信息在哪呢

470
00:18:04,733 --> 00:18:07,099
这个信息在地区里头

471
00:18:07,166 --> 00:18:09,766
所以这个职责只就这一段的代码

472
00:18:09,766 --> 00:18:10,499
这个判断

473
00:18:10,500 --> 00:18:13,800
这一段代码只能放到region里头去做

474
00:18:14,133 --> 00:18:16,266
但具体是放在他的一个方法里头

475
00:18:16,266 --> 00:18:17,666
还是放到他两个方法去做

476
00:18:17,733 --> 00:18:18,933
这个你可以去讨论

477
00:18:18,966 --> 00:18:19,966
我们现在做法

478
00:18:19,966 --> 00:18:22,933
就是把它放到了create reading里头去做

479
00:18:22,933 --> 00:18:24,866
所以他判断一下当前的状态

480
00:18:24,866 --> 00:18:28,333
是不是啊wallet或者是spend啊

481
00:18:28,333 --> 00:18:29,466
band是不能建的

482
00:18:29,500 --> 00:18:31,333
如果是这两个状态的话

483
00:18:31,733 --> 00:18:33,999
他则去掉他的刀对象

484
00:18:34,000 --> 00:18:35,666
去把这个reading对象

485
00:18:35,800 --> 00:18:38,266
给他插到数据库里去

486
00:18:38,666 --> 00:18:41,099
因为我们是在特定的结构上面去做

487
00:18:41,100 --> 00:18:42,366
这样的一个创建对象

488
00:18:42,466 --> 00:18:43,399
不是在内存里面

489
00:18:43,400 --> 00:18:45,066
创建一个子对象就完了

490
00:18:45,366 --> 00:18:46,666
创建一个子地区就完了

491
00:18:46,666 --> 00:18:48,999
我们的目标是把这个地区创建出来

492
00:18:49,000 --> 00:18:50,900
然后要存到数据库里去

493
00:18:50,966 --> 00:18:52,499
而存到数据库里

494
00:18:52,733 --> 00:18:56,533
靠的是我们的稻城的代码去完成的

495
00:18:56,733 --> 00:18:59,933
我们在bo城里头并不管出他怎么去存

496
00:19:00,000 --> 00:19:00,566
这个职责

497
00:19:00,566 --> 00:19:01,366
我们不管

498
00:19:01,400 --> 00:19:03,566
这个职责我们交给了稻城的方法去做

499
00:19:03,566 --> 00:19:04,966
所以我们调他的稻城的

500
00:19:04,966 --> 00:19:05,999
方法insert

501
00:19:06,166 --> 00:19:08,266
去把我们要建的对象和随建的

502
00:19:08,266 --> 00:19:09,266
把它存进去

503
00:19:09,266 --> 00:19:10,133
就完成了

504
00:19:10,566 --> 00:19:12,866
这个过程其实也是一个职责分配

505
00:19:12,866 --> 00:19:15,099
但这个职责分配不是面向对象

506
00:19:15,366 --> 00:19:16,933
这个职责分配是一个什么呢

507
00:19:16,933 --> 00:19:18,299
是一个面向功能的

508
00:19:18,300 --> 00:19:18,700
相当于说

509
00:19:18,700 --> 00:19:20,800
我把这个差数据库的这部分功能

510
00:19:20,966 --> 00:19:23,966
交给了道的这个一个方法去完成

511
00:19:23,966 --> 00:19:25,766
这就是我们的音色的方法

512
00:19:25,966 --> 00:19:28,333
所以道的方法怎么去音色的

513
00:19:29,200 --> 00:19:30,666
这是跟面相对象无关的

514
00:19:31,100 --> 00:19:32,266
就是在这个设计中间

515
00:19:32,266 --> 00:19:33,499
它是跟面相对象无关的

516
00:19:33,566 --> 00:19:35,166
所以我们在图里头也没有去

517
00:19:35,166 --> 00:19:37,566
话说它怎么音色的

518
00:19:37,566 --> 00:19:39,466
反正你知道调它去音色的就好了

519
00:19:39,466 --> 00:19:40,599
如果你想看的话

520
00:19:40,600 --> 00:19:42,933
你可以去看它的代码啊

521
00:19:42,966 --> 00:19:45,566
然后这就完成了

522
00:19:45,600 --> 00:19:46,733
如果他状态不对

523
00:19:46,766 --> 00:19:49,333
会抛出这个abandon回来

524
00:19:49,700 --> 00:19:51,366
这就是我们的一张设计图

525
00:19:52,300 --> 00:19:53,333
所以大家应该知道

526
00:19:53,333 --> 00:19:55,899
在面向对象的设计领域中间

527
00:19:56,133 --> 00:19:57,799
你画一张设计图

528
00:19:58,600 --> 00:19:59,933
你的目的是为了什么

529
00:20:00,066 --> 00:20:01,933
我们时我们时时刻刻在讲说

530
00:20:02,266 --> 00:20:03,666
画这个东西的目的在什么

531
00:20:03,666 --> 00:20:06,566
为什么我们可以不用画Controller

532
00:20:06,566 --> 00:20:08,499
这张图的画的地方在于

533
00:20:08,500 --> 00:20:10,066
说它从control开始画起了

534
00:20:10,333 --> 00:20:11,566
其实是不用画control的

535
00:20:11,566 --> 00:20:13,199
因为control的这部分内容

536
00:20:13,200 --> 00:20:13,966
在这张图上呢

537
00:20:13,966 --> 00:20:14,799
没有营养

538
00:20:15,400 --> 00:20:18,100
有营养的部分在这个地方

539
00:20:18,666 --> 00:20:21,266
这个地方或者是这个地方

540
00:20:22,566 --> 00:20:23,699
对吧是在这个地方

541
00:20:23,700 --> 00:20:26,266
这个这两个地方说明了什么

542
00:20:26,533 --> 00:20:27,533
说明了说

543
00:20:27,866 --> 00:20:30,799
收费层到底做这个功能是怎么分解的

544
00:20:30,800 --> 00:20:32,266
它分解的它有两个事情

545
00:20:32,266 --> 00:20:33,333
一件是找到对象

546
00:20:33,333 --> 00:20:34,599
第二个是让这对象去做

547
00:20:35,266 --> 00:20:36,599
那这个地方描述了

548
00:20:36,600 --> 00:20:38,133
他怎么去找到这个对象

549
00:20:39,000 --> 00:20:41,066
这个部分他描述了他怎么去做

550
00:20:41,466 --> 00:20:43,466
那我这里还描述了他做的过程

551
00:20:43,466 --> 00:20:45,399
他到底是怎么把东西存进去的

552
00:20:45,533 --> 00:20:46,799
都把他描述出来了

553
00:20:46,866 --> 00:20:49,366
所以这是这张图有意义的地方

554
00:20:49,800 --> 00:20:52,500
如果说你觉得怎么去做这件事情

555
00:20:52,500 --> 00:20:53,966
你根本就不想去了解

556
00:20:54,266 --> 00:20:55,999
比如说这个部分你不想去了解

557
00:20:56,133 --> 00:20:57,599
我在这张设计图上的

558
00:20:57,600 --> 00:20:59,500
我的意图就是表现出来

559
00:20:59,500 --> 00:21:01,566
说我东西怎么分解的

560
00:21:01,933 --> 00:21:05,933
因为设计的目的有设计前和设计后啊

561
00:21:05,933 --> 00:21:06,733
设计前的话

562
00:21:06,733 --> 00:21:08,799
你可能很多的细节没有考虑清楚

563
00:21:08,933 --> 00:21:10,133
但是我已经想清楚了

564
00:21:10,133 --> 00:21:12,533
就是当我要去创建一个地区的时候

565
00:21:12,600 --> 00:21:13,900
我第一要找到对象

566
00:21:13,900 --> 00:21:17,266
第二要让这个富地区去建此地区

567
00:21:17,700 --> 00:21:18,866
至于复题区怎么去建

568
00:21:18,866 --> 00:21:20,333
那是你写代码去完成的

569
00:21:20,400 --> 00:21:21,266
如果你的设计图

570
00:21:21,266 --> 00:21:22,766
只是为了表述这样的一个内容

571
00:21:22,766 --> 00:21:26,599
其实可以把这一部分全部都抹掉

572
00:21:26,866 --> 00:21:27,733
不用画了

573
00:21:28,100 --> 00:21:32,000
只要画这个这个和这个就够了

574
00:21:32,300 --> 00:21:33,533
就能够描述出来

575
00:21:33,533 --> 00:21:37,099
说我在中间的这个部分

576
00:21:37,566 --> 00:21:39,199
红色的框的这个部分

577
00:21:39,566 --> 00:21:42,866
我的面向对象的任务分解

578
00:21:42,933 --> 00:21:43,933
职责的分解

579
00:21:43,933 --> 00:21:46,399
或者模块的分解是怎么分解的

580
00:21:46,966 --> 00:21:47,966
就可以了啊

581
00:21:47,966 --> 00:21:51,899
所以设计图纸的主要目的

582
00:21:51,900 --> 00:21:55,566
不是把代码一行一行的把它描述上去

583
00:21:55,733 --> 00:21:57,766
这不是我们画设计图的目的

584
00:21:57,766 --> 00:21:59,666
你如果想要知道代码的细节

585
00:22:00,066 --> 00:22:01,199
你应该去看代码

586
00:22:01,933 --> 00:22:03,466
你在画一张设计图的时候

587
00:22:03,466 --> 00:22:06,199
你应该清楚说你这张图是想干嘛

588
00:22:06,466 --> 00:22:07,799
比如说我画这张设计图的时候

589
00:22:07,800 --> 00:22:08,600
我想干嘛

590
00:22:09,666 --> 00:22:12,599
我想告诉大家从control层到稻城

591
00:22:12,600 --> 00:22:13,600
它到底是怎么做的

592
00:22:14,000 --> 00:22:15,166
所以我画这张图

593
00:22:15,400 --> 00:22:16,800
但这张图其实画出来以后

594
00:22:16,800 --> 00:22:17,666
你会觉得

595
00:22:18,000 --> 00:22:20,500
前半部分control层太没有营养

596
00:22:20,766 --> 00:22:22,799
后半部分太琐碎

597
00:22:22,933 --> 00:22:25,466
就是control层里头太太没有

598
00:22:25,466 --> 00:22:28,466
营养微景里头看起来太琐碎

599
00:22:28,866 --> 00:22:31,166
其实它真正最闪光

600
00:22:31,166 --> 00:22:32,399
最有意义的地方

601
00:22:32,400 --> 00:22:34,566
在于设备师的这个部分

602
00:22:34,866 --> 00:22:39,566
这是面向对象作分解的最主要的部分

603
00:22:39,666 --> 00:22:40,799
所以大家应该知道

604
00:22:40,800 --> 00:22:43,266
我们说面向对象设计

605
00:22:43,400 --> 00:22:47,000
其根本的问题是你怎么去分解模块

606
00:22:47,566 --> 00:22:50,066
而不是你怎么去实现它

607
00:22:50,300 --> 00:22:52,900
实现它是你在特定的架构上面

608
00:22:52,933 --> 00:22:55,533
在加瓦伊的这种特定的架构上面

609
00:22:55,733 --> 00:22:56,466
去实现它

610
00:22:56,466 --> 00:22:58,266
那个是属于技术的细节

611
00:22:58,300 --> 00:22:59,166
而设计的话

612
00:22:59,166 --> 00:23:00,799
主要是要确定说

613
00:23:00,800 --> 00:23:02,333
我到底要做什么样的事情

614
00:23:02,333 --> 00:23:03,866
要怎么去做啊

615
00:23:03,866 --> 00:23:05,166
要做什么样的事情啊

616
00:23:05,166 --> 00:23:05,966
怎么去做

617
00:23:06,866 --> 00:23:07,966
其实在设计中间

618
00:23:08,366 --> 00:23:10,866
特别是在写代码之前的设计

619
00:23:10,866 --> 00:23:13,333
其实是不用画的那么仔细的啊

620
00:23:13,933 --> 00:23:16,466
这是创建者的方法

621
00:23:18,000 --> 00:23:20,500
那第二个我们要讲的就是信息专家

622
00:23:21,200 --> 00:23:21,766
信息专家

623
00:23:21,766 --> 00:23:22,599
其实主要是为了

624
00:23:22,600 --> 00:23:24,133
达成这样的一个封装性

625
00:23:24,200 --> 00:23:25,933
大家学面相对象的语言都知道

626
00:23:25,933 --> 00:23:26,733
面相对象的语言

627
00:23:26,733 --> 00:23:28,533
从一开始就在讲封装性

628
00:23:29,000 --> 00:23:29,866
所谓封装性啊

629
00:23:29,866 --> 00:23:32,366
大家从比较粗浅的理解来说

630
00:23:32,366 --> 00:23:34,933
就是属性都是private的

631
00:23:34,933 --> 00:23:36,333
你不能直接去访问

632
00:23:36,333 --> 00:23:39,199
对吧我想大家之前写的很多的

633
00:23:39,200 --> 00:23:40,933
不论是用C++还是用Java

634
00:23:40,933 --> 00:23:42,399
还是用cxhab写的代码

635
00:23:42,900 --> 00:23:45,333
都知道应该把属性变成private的

636
00:23:45,666 --> 00:23:48,466
然后呢做了一堆的gotta say的方法

637
00:23:48,466 --> 00:23:49,599
去访问那些属性

638
00:23:50,766 --> 00:23:52,566
然后没了

639
00:23:53,066 --> 00:23:56,499
那这个其实不能叫做封装性

640
00:23:56,800 --> 00:23:58,566
封装性的意思是说

641
00:23:58,566 --> 00:24:00,733
当我的对象有属性的时候

642
00:24:01,300 --> 00:24:04,700
你除了修改他或者想看到他的属性

643
00:24:04,700 --> 00:24:05,966
就是从界面上头

644
00:24:05,966 --> 00:24:06,933
如果想修改他

645
00:24:06,933 --> 00:24:08,366
或者想看到他的属性以外

646
00:24:08,700 --> 00:24:10,900
你应该不会去调他的get say的方法

647
00:24:11,766 --> 00:24:12,366
就换句话说

648
00:24:12,366 --> 00:24:12,999
当别的

649
00:24:13,000 --> 00:24:14,933
一个地方要用到它的值的时候

650
00:24:15,666 --> 00:24:17,666
这个代码不在这个类里头

651
00:24:17,900 --> 00:24:19,333
就是很奇怪的事情

652
00:24:20,100 --> 00:24:22,900
所有跟这个数据有关的代码

653
00:24:22,900 --> 00:24:24,666
都应该在这个类里面啊

654
00:24:24,666 --> 00:24:25,766
不应该在别的地方

655
00:24:26,066 --> 00:24:27,733
这就是我们所说的封装性

656
00:24:27,966 --> 00:24:29,966
这就是面向对象的这个封装性

657
00:24:30,100 --> 00:24:31,533
那这封装性怎么来的

658
00:24:31,933 --> 00:24:32,366
封装性怎么来

659
00:24:32,366 --> 00:24:33,799
就当你写一行代码的时候

660
00:24:33,800 --> 00:24:35,733
当你发现这个代码又用到另外一个

661
00:24:35,733 --> 00:24:37,766
不是这个类里头的属性的时候

662
00:24:38,200 --> 00:24:38,966
你都要想一想

663
00:24:38,966 --> 00:24:41,166
为什么为什么胶原蛋白不能去那

664
00:24:41,700 --> 00:24:43,700
而要在我这个类里面

665
00:24:44,066 --> 00:24:46,366
对吧而要从在这个类里面

666
00:24:46,366 --> 00:24:47,699
去拿另外一个类的属性

667
00:24:47,700 --> 00:24:48,733
来做这样的一个判断

668
00:24:48,733 --> 00:24:50,166
这都要思考的问题

669
00:24:50,866 --> 00:24:51,799
这个问题啊

670
00:24:51,800 --> 00:24:53,333
其实就是在不断的使用

671
00:24:53,333 --> 00:24:54,533
我们的信息专家

672
00:24:54,666 --> 00:24:55,366
就换句话说

673
00:24:55,366 --> 00:24:57,133
这个职责不应该在这个类里头

674
00:24:57,133 --> 00:24:58,266
不应该在这个代码中间

675
00:24:58,266 --> 00:24:59,333
应该在另外一个地方

676
00:24:59,566 --> 00:25:00,266
原因是因为

677
00:25:00,266 --> 00:25:03,199
这个职责所需要的信息不在这

678
00:25:03,600 --> 00:25:04,733
而在别的地方

679
00:25:05,166 --> 00:25:07,499
所以职责应该跟信息在一起

680
00:25:07,500 --> 00:25:08,400
职责也就是

681
00:25:08,400 --> 00:25:13,266
我们写在类的方法里头的那些代码

682
00:25:13,600 --> 00:25:15,266
这就是我们所说的信息专家

683
00:25:15,800 --> 00:25:17,266
所以当我们做分解的时候

684
00:25:17,266 --> 00:25:19,933
我们基本上是基于这样的一个原则

685
00:25:20,066 --> 00:25:20,966
来做分解的

686
00:25:20,966 --> 00:25:23,533
从而实现了封装性

687
00:25:23,533 --> 00:25:27,466
就是不会去调那些类的get set的方法

688
00:25:27,466 --> 00:25:29,199
去拿到那个值去做处理

689
00:25:29,566 --> 00:25:31,933
调它的get set方法只有两个可能性

690
00:25:31,933 --> 00:25:32,699
一个是要显示

691
00:25:32,700 --> 00:25:33,733
一个是要修改它

692
00:25:34,000 --> 00:25:34,933
那就会去调

693
00:25:35,566 --> 00:25:36,966
如果不是这两个可能性的话

694
00:25:36,966 --> 00:25:40,399
我们就不会去直接调它的get set方法

695
00:25:40,400 --> 00:25:41,200
去完成它

696
00:25:41,966 --> 00:25:44,699
我们来看一下这个茶上级地区

697
00:25:51,600 --> 00:25:55,166
这是一个我们用的非常高频的API

698
00:25:55,166 --> 00:25:57,133
因为我们在算运费模板的时候

699
00:25:57,133 --> 00:25:58,966
运费模板其实不是定在什么的

700
00:25:58,966 --> 00:26:00,933
不是定在每一个指定区的

701
00:26:01,300 --> 00:26:02,800
我们的每一个订单下下来的时候

702
00:26:02,800 --> 00:26:04,366
都是在接到

703
00:26:04,566 --> 00:26:06,066
是吧每个顾客都在接到

704
00:26:06,066 --> 00:26:07,066
那个地区都是在

705
00:26:07,400 --> 00:26:08,866
但是运费模板不会定在接到

706
00:26:08,866 --> 00:26:10,799
运费模板会定在省市

707
00:26:11,166 --> 00:26:13,066
至少是省市啊

708
00:26:13,066 --> 00:26:15,099
至少是市一级去定这个运费模板

709
00:26:15,100 --> 00:26:16,933
更大的可能性是定在省一级

710
00:26:17,600 --> 00:26:18,466
所以这样的话

711
00:26:18,466 --> 00:26:19,866
当顾客下个订单的时候

712
00:26:19,866 --> 00:26:22,599
这个订单到底运费是多少

713
00:26:23,133 --> 00:26:24,333
要不要收他的运费

714
00:26:24,333 --> 00:26:25,666
收运费是多少钱

715
00:26:25,933 --> 00:26:27,266
这要去找他的运费模板

716
00:26:27,600 --> 00:26:29,700
那就需要从这个街道

717
00:26:30,100 --> 00:26:32,000
去看他所有的上级地区

718
00:26:32,000 --> 00:26:33,700
然后去看他那个哪个地区里

719
00:26:33,700 --> 00:26:34,766
有定营的运费模板

720
00:26:34,900 --> 00:26:35,533
然后才知道

721
00:26:35,533 --> 00:26:36,399
那个运费模板

722
00:26:37,200 --> 00:26:40,200
用的他这个订单的这个上头

723
00:26:40,600 --> 00:26:44,000
所以这是一个非常高频的API啊

724
00:26:44,000 --> 00:26:46,166
而且这个命名方式也顺便说一下

725
00:26:46,166 --> 00:26:46,766
大家注意看

726
00:26:46,766 --> 00:26:47,466
这个命名方式

727
00:26:47,466 --> 00:26:48,366
跟我们前面所讲的

728
00:26:48,366 --> 00:26:49,599
两种运营方式不一样

729
00:26:49,666 --> 00:26:50,566
我们前面运营方式

730
00:26:50,566 --> 00:26:52,733
一种告诉大家是有shops shop ID的

731
00:26:52,733 --> 00:26:53,499
那个是什么呢

732
00:26:53,500 --> 00:26:55,600
那个是后台管理员的APR

733
00:26:56,100 --> 00:26:57,000
一种是没有的

734
00:26:57,000 --> 00:27:00,866
那个就是前端顾客可以访问的API

735
00:27:01,400 --> 00:27:03,466
这是第三种

736
00:27:04,133 --> 00:27:04,999
internal

737
00:27:05,700 --> 00:27:08,166
这个就是既是后台也不能访问

738
00:27:08,200 --> 00:27:09,600
前台也不能访问

739
00:27:09,933 --> 00:27:13,133
只能在模块和模块之间调用的

740
00:27:13,166 --> 00:27:14,099
就是这个API

741
00:27:14,100 --> 00:27:16,966
并不会被我们所有的界面访问的

742
00:27:17,333 --> 00:27:20,466
这个API只能在模块和模块之间访问

743
00:27:20,500 --> 00:27:21,766
我们在限制的时候

744
00:27:21,766 --> 00:27:22,066
我们

745
00:27:22,066 --> 00:27:25,133
我们在之前讲过这个体系结构的里头

746
00:27:26,100 --> 00:27:27,800
把这个体系结构给大家打开

747
00:27:35,133 --> 00:27:36,366
我们讲过这个题结构

748
00:27:36,366 --> 00:27:37,499
的外头有个网关

749
00:27:38,566 --> 00:27:41,166
所有从外面过来的访问

750
00:27:41,466 --> 00:27:42,533
包括前台

751
00:27:42,533 --> 00:27:44,966
后台的顾客和或平台管理员的

752
00:27:45,166 --> 00:27:46,366
都是通过网关

753
00:27:46,533 --> 00:27:48,733
转发到这些API上头去的

754
00:27:48,966 --> 00:27:52,966
所以如果一个从前端过来的请求

755
00:27:53,566 --> 00:27:57,166
访问的是一个我们这里所看到的

756
00:27:59,500 --> 00:28:01,466
internal的这个请求的话

757
00:28:02,066 --> 00:28:03,899
网关会直接忽视

758
00:28:03,900 --> 00:28:06,300
他不会调用我们的模块

759
00:28:06,800 --> 00:28:08,900
所以这样的internal的URL

760
00:28:08,900 --> 00:28:11,100
只能在我们的网关里头

761
00:28:11,100 --> 00:28:14,533
的模块和模块之间相互调用

762
00:28:14,666 --> 00:28:16,466
所以就是我们一共有三种

763
00:28:16,733 --> 00:28:19,166
三种的API定义啊

764
00:28:19,166 --> 00:28:19,333
所以

765
00:28:19,333 --> 00:28:22,566
大家在下周讲塔伦克做作业时候

766
00:28:22,566 --> 00:28:24,299
注意我们一共有三种API定义

767
00:28:24,300 --> 00:28:25,766
一种是shop shop ID的

768
00:28:25,766 --> 00:28:27,699
那是后台用户所使用的

769
00:28:27,766 --> 00:28:30,999
那个是保证说当前登录用户的店铺

770
00:28:31,133 --> 00:28:32,133
和路径上

771
00:28:32,133 --> 00:28:33,599
那个店铺的ID是一致的

772
00:28:33,600 --> 00:28:35,133
不一致不会进来

773
00:28:35,300 --> 00:28:37,400
那个也是网关来管的

774
00:28:37,733 --> 00:28:40,066
第二这个就是没有XXXXXXXX ID的

775
00:28:40,066 --> 00:28:41,333
所以那个就不加控制

776
00:28:41,333 --> 00:28:42,566
直接可以进来了

777
00:28:42,900 --> 00:28:44,700
第三种就是这个internal的

778
00:28:44,700 --> 00:28:45,800
这个就是根本进不来

779
00:28:45,800 --> 00:28:47,600
从外面根本就进不来这个请求

780
00:28:47,866 --> 00:28:52,066
这些请求只能在模块和模块之间调用

781
00:28:52,266 --> 00:28:54,133
就是比如说这个模块调这个模块

782
00:28:54,733 --> 00:28:56,466
他们之间都在网关里头

783
00:28:56,466 --> 00:28:58,299
所以说他们之间就可以互相调用

784
00:28:58,366 --> 00:29:01,133
但是从外面来的请求

785
00:29:01,533 --> 00:29:04,166
是根本没办法透过网关

786
00:29:04,166 --> 00:29:06,933
把internal的请求发到这个里面来的啊

787
00:29:07,066 --> 00:29:08,566
所以是三种API

788
00:29:11,766 --> 00:29:12,966
这就是一个内部的

789
00:29:13,400 --> 00:29:17,766
因为其实对于界面上的所有的请求

790
00:29:17,766 --> 00:29:19,566
其实用不到这个API

791
00:29:19,933 --> 00:29:21,266
那内部的API呢

792
00:29:21,266 --> 00:29:23,133
通常我们没有去控制权限啊

793
00:29:23,133 --> 00:29:26,399
所以说他也没有去认证的部分

794
00:29:27,466 --> 00:29:29,333
呃我们看一下这个设

795
00:29:29,333 --> 00:29:30,199
计是怎么做的

796
00:29:30,766 --> 00:29:31,099
这个设计

797
00:29:31,100 --> 00:29:31,866
我们就没画

798
00:29:31,866 --> 00:29:33,933
那个没有营养的控制器层了

799
00:29:34,600 --> 00:29:36,666
对吧就没有画没有营养的控制系统

800
00:29:36,666 --> 00:29:38,266
还画了比较繁琐的

801
00:29:38,266 --> 00:29:40,266
这个对象内部怎么做的

802
00:29:40,266 --> 00:29:42,199
我们说其实针对面向对象来说

803
00:29:42,200 --> 00:29:45,200
这个图如果是在写代码之前啊

804
00:29:45,200 --> 00:29:48,533
这个图其实就画到这就完了就够了

805
00:29:49,200 --> 00:29:51,166
就是我我如果要写这个代码

806
00:29:51,766 --> 00:29:52,966
那我在写之前

807
00:29:52,966 --> 00:29:54,166
我其实就要想清楚

808
00:29:54,166 --> 00:29:56,133
这个代码到底写哪个部分

809
00:29:56,300 --> 00:29:58,000
这个代码的第一个部分是可以重用的

810
00:29:58,000 --> 00:30:00,066
因为瑞金大我们已经写好了是吧

811
00:30:00,333 --> 00:30:02,133
啊那个find吧ID已经写好了

812
00:30:02,133 --> 00:30:04,699
所以说瑞金到的范德巴ID

813
00:30:04,700 --> 00:30:06,400
把那个对象找回来

814
00:30:06,666 --> 00:30:06,933
第二个

815
00:30:06,933 --> 00:30:09,199
我们就会要在red中间写一个方法

816
00:30:09,366 --> 00:30:13,066
去得到他的上所有的上级地区啊

817
00:30:13,066 --> 00:30:15,199
这不是一个就他的省

818
00:30:15,200 --> 00:30:17,866
四四省国家啊

819
00:30:17,866 --> 00:30:19,666
这么16得上去

820
00:30:20,166 --> 00:30:21,499
这个里头画的

821
00:30:21,500 --> 00:30:21,933
其实是

822
00:30:21,933 --> 00:30:24,499
我们在这个代码里头怎么去实现的

823
00:30:24,766 --> 00:30:25,466
啊大家知道

824
00:30:25,466 --> 00:30:26,866
其实我们在做设计过程中间

825
00:30:26,866 --> 00:30:28,733
我们其实并不会涉及到代码里头去

826
00:30:28,733 --> 00:30:29,599
怎么去实现

827
00:30:30,000 --> 00:30:30,666
我一直在说

828
00:30:30,666 --> 00:30:31,399
我们在设计过程中间

829
00:30:31,400 --> 00:30:32,700
主要解决的问题就是

830
00:30:32,700 --> 00:30:33,733
这个事情怎么分解

831
00:30:34,000 --> 00:30:35,333
应该在什么地方写一个方法

832
00:30:35,333 --> 00:30:36,666
这个方法要做什么样的功能

833
00:30:36,666 --> 00:30:38,466
这是我们确定设计任务

834
00:30:38,900 --> 00:30:40,933
然后再去写里头的代码

835
00:30:41,300 --> 00:30:42,566
写好了里头的代码呢

836
00:30:42,566 --> 00:30:43,066
如果说

837
00:30:43,066 --> 00:30:45,599
你觉得我要在这图上的表现一下

838
00:30:45,600 --> 00:30:47,100
说这里头怎么去实现的

839
00:30:47,366 --> 00:30:48,499
就把这个部分画上去

840
00:30:48,500 --> 00:30:50,466
因为这都是我在写完以后才画的

841
00:30:50,700 --> 00:30:52,700
所以我就把里头怎么实现的

842
00:30:52,700 --> 00:30:53,533
把它画出来

843
00:30:54,366 --> 00:30:56,933
大部分设计图纸其实没必要画这个的

844
00:30:56,933 --> 00:30:57,866
我画这个的主要

845
00:30:57,866 --> 00:31:01,166
目的就是给大家看到不同的画法

846
00:31:01,700 --> 00:31:02,266
就是因为

847
00:31:02,266 --> 00:31:04,666
大家除了说掌握怎么去画以外

848
00:31:04,900 --> 00:31:05,866
也要多去看看

849
00:31:05,866 --> 00:31:07,366
比如说我要表达不同的意思

850
00:31:07,366 --> 00:31:10,266
怎么用这个时序图的符号去画

851
00:31:11,066 --> 00:31:12,533
这张图里头

852
00:31:12,600 --> 00:31:13,333
这个部分啊

853
00:31:13,333 --> 00:31:14,933
前面部分大家一眼应该能看懂了吧

854
00:31:14,933 --> 00:31:16,499
我们讲了这么多张图了是吧

855
00:31:16,700 --> 00:31:17,500
能看懂吗

856
00:31:17,666 --> 00:31:19,666
前面那张图前面是在干嘛

857
00:31:21,500 --> 00:31:23,900
第三点就是我的第二

858
00:31:23,900 --> 00:31:25,133
从第二点开始说起吧

859
00:31:25,466 --> 00:31:26,933
社会使城里头有一个方法

860
00:31:26,933 --> 00:31:30,166
叫做rechieve parents

861
00:31:30,166 --> 00:31:31,799
route parents

862
00:31:31,800 --> 00:31:32,766
regions by ID

863
00:31:32,766 --> 00:31:34,333
这个方法常见的参数是ID

864
00:31:34,600 --> 00:31:35,766
这是表示这个

865
00:31:35,966 --> 00:31:36,799
在这个方法中间

866
00:31:36,800 --> 00:31:38,533
其实有两两个事情要做

867
00:31:38,533 --> 00:31:39,666
它不是两行代码啊

868
00:31:39,666 --> 00:31:40,733
代码其实比较更多

869
00:31:40,766 --> 00:31:41,799
但主要做了两件事情

870
00:31:41,800 --> 00:31:43,600
第一件事情是把那个ID变成对象

871
00:31:44,000 --> 00:31:46,366
所以调regional的fundabalid

872
00:31:46,366 --> 00:31:47,666
返回了一个region对象

873
00:31:47,966 --> 00:31:49,499
拿到这个region对象以后呢

874
00:31:49,500 --> 00:31:50,100
我就去调

875
00:31:50,100 --> 00:31:52,333
这个region对象的get assessed的方法

876
00:31:52,333 --> 00:31:54,333
去得到它的所有的算景地区就好了

877
00:31:54,700 --> 00:31:58,966
因为这个region的返回值对

878
00:31:58,966 --> 00:32:00,899
到这个地方要这么看

879
00:32:01,000 --> 00:32:02,100
所以你看到这个对象

880
00:32:02,100 --> 00:32:03,400
这个对象不是有变样名吗

881
00:32:03,533 --> 00:32:05,166
这个变样名其实描述了这个东西

882
00:32:05,166 --> 00:32:06,366
就是他的返回值

883
00:32:06,733 --> 00:32:08,133
所以我实际上是

884
00:32:08,133 --> 00:32:09,999
拿到返回的这个reading对象

885
00:32:10,000 --> 00:32:12,066
去调他的get assessed的方法

886
00:32:12,733 --> 00:32:14,699
去拿到他所有的上级就完了

887
00:32:14,700 --> 00:32:15,800
然后这里头就是

888
00:32:15,800 --> 00:32:19,466
这个get as assessed是怎么做的

889
00:32:19,466 --> 00:32:20,366
这个是细节

890
00:32:20,900 --> 00:32:22,300
你如果在在设计的过程中间

891
00:32:22,300 --> 00:32:23,666
其实这个部分是不用画的

892
00:32:23,666 --> 00:32:24,566
画到这个部分

893
00:32:24,700 --> 00:32:26,966
你就知道说你的设计想怎么弄

894
00:32:26,966 --> 00:32:29,733
就是我要在reading中间加一个方法

895
00:32:29,733 --> 00:32:31,866
那个方法要取得到他的上级地区

896
00:32:32,200 --> 00:32:33,800
然后那个你就自己去写代码吧

897
00:32:34,500 --> 00:32:35,300
看懂了吗

898
00:32:41,700 --> 00:32:43,300
这个是为什么呢

899
00:32:43,300 --> 00:32:44,733
因为这里是一个循环

900
00:32:44,800 --> 00:32:48,100
这个循环大家知道会比较慢对吧

901
00:32:48,166 --> 00:32:50,333
所以我们做了一个限制

902
00:32:50,333 --> 00:32:52,933
就是怕万一里头的数据出了问题

903
00:32:52,933 --> 00:32:56,166
这个就会无限的循环过去啊

904
00:32:56,166 --> 00:32:57,999
就怕万一你的数据出了限制

905
00:32:58,000 --> 00:32:58,933
出了问题啊

906
00:32:58,933 --> 00:33:00,399
当然如果数据是好的

907
00:33:00,400 --> 00:33:01,600
是不会到这个的

908
00:33:01,600 --> 00:33:02,533
因为大家知道

909
00:33:03,466 --> 00:33:06,733
从我我们不是四级居民

910
00:33:06,733 --> 00:33:09,466
街道不是委员会

911
00:33:09,466 --> 00:33:10,466
这居委会

912
00:33:10,966 --> 00:33:11,766
街道

913
00:33:12,533 --> 00:33:13,333
区

914
00:33:13,900 --> 00:33:15,466
市省

915
00:33:15,533 --> 00:33:17,199
国家五级

916
00:33:18,300 --> 00:33:20,866
我们就是行政区划就是5级

917
00:33:21,266 --> 00:33:22,799
所以我们这里就就怕

918
00:33:22,800 --> 00:33:24,000
如果说他的这个数据

919
00:33:24,000 --> 00:33:25,266
以及级都是对的话

920
00:33:25,266 --> 00:33:26,666
那就应该就5级就到头了

921
00:33:26,666 --> 00:33:28,566
是一个数是吧

922
00:33:28,900 --> 00:33:31,266
但是怕你的数据万一出了bug呢

923
00:33:31,666 --> 00:33:32,966
出现了循环图呢

924
00:33:32,966 --> 00:33:34,066
就会抓抓抓抓抓

925
00:33:34,066 --> 00:33:35,399
所以这次我做了个保险

926
00:33:35,933 --> 00:33:38,499
如果说他小于10的话

927
00:33:38,500 --> 00:33:39,366
他才会做

928
00:33:39,700 --> 00:33:40,933
如果出现了循环的话

929
00:33:40,933 --> 00:33:41,566
数据就不对了

930
00:33:41,566 --> 00:33:43,599
但是整个程序不会陷入到死循环

931
00:33:43,600 --> 00:33:46,333
就是为了这样的一个保险的目的

932
00:33:46,866 --> 00:33:48,333
所以他里头的逻辑

933
00:33:48,366 --> 00:33:49,533
其实这里也能看得出来

934
00:33:49,533 --> 00:33:52,133
就是小于10

935
00:33:52,266 --> 00:33:55,333
而且他的上级不到了最后的一个

936
00:33:55,333 --> 00:33:57,399
就他最最后的一个复节点

937
00:33:57,400 --> 00:33:58,466
是那个invite的ID

938
00:33:58,466 --> 00:33:59,499
就没有复节点了

939
00:33:59,500 --> 00:34:00,566
就中华人民共和国

940
00:34:00,766 --> 00:34:03,166
他的PID是没有复节点的

941
00:34:03,200 --> 00:34:06,100
那就去得到他的上级的region

942
00:34:06,366 --> 00:34:09,566
然后把上级region放到这个region中间

943
00:34:11,766 --> 00:34:12,699
放到这个region中间

944
00:34:12,700 --> 00:34:13,933
region是这个对象看到没有

945
00:34:14,166 --> 00:34:15,266
然后再循环过来

946
00:34:15,266 --> 00:34:17,166
其实要掉这个region的get parent

947
00:34:17,466 --> 00:34:19,399
就这么一次次的掉下去啊

948
00:34:19,400 --> 00:34:20,566
一次次吊上去

949
00:34:20,700 --> 00:34:21,666
这个不是地规啊

950
00:34:21,666 --> 00:34:23,299
这是对象不同啊

951
00:34:23,666 --> 00:34:25,999
循环10次拿到了10个对象

952
00:34:26,000 --> 00:34:27,300
当然不会循环10次了

953
00:34:27,400 --> 00:34:29,333
一般是循环4次或者5次

954
00:34:29,333 --> 00:34:30,733
拿到4个或者5个对象

955
00:34:30,733 --> 00:34:33,866
然后不停的吊他的这个parent啊

956
00:34:33,866 --> 00:34:34,666
吊他parent

957
00:34:34,666 --> 00:34:35,699
然后把这个region

958
00:34:35,700 --> 00:34:37,066
其实要放到一个列表里头

959
00:34:37,066 --> 00:34:37,599
把它返回

960
00:34:37,600 --> 00:34:38,766
变成这个regions

961
00:34:39,533 --> 00:34:41,466
看这个regions这里头的部分

962
00:34:41,466 --> 00:34:43,099
就是这个regions和regions之间的关系

963
00:34:43,100 --> 00:34:44,800
在图上没有画出来啊

964
00:34:44,800 --> 00:34:46,466
其实regions是一个release的

965
00:34:46,466 --> 00:34:48,266
每次拿到的regen都放到这个release的

966
00:34:48,266 --> 00:34:51,199
然后把它把它返回回来了啊

967
00:34:52,500 --> 00:34:54,266
这个是这个图啊

968
00:34:54,266 --> 00:34:55,366
我们看一下代码

969
00:35:01,100 --> 00:35:02,300
大家慢慢的就

970
00:35:02,300 --> 00:35:03,966
我们在讲这个课的过程中间

971
00:35:03,966 --> 00:35:05,699
其实不断的给大家看图

972
00:35:05,800 --> 00:35:08,100
然后你首先要做到一点什么呢

973
00:35:08,100 --> 00:35:09,300
就是你能看懂图

974
00:35:09,800 --> 00:35:10,566
然后第二点呢

975
00:35:10,566 --> 00:35:11,799
你能学会画图

976
00:35:11,800 --> 00:35:12,900
第三点才能做到

977
00:35:12,900 --> 00:35:14,200
说把自己的设计思想

978
00:35:14,200 --> 00:35:15,666
用图正确的表达出来

979
00:35:15,766 --> 00:35:16,566
三步骤啊

980
00:35:16,566 --> 00:35:18,899
我们先从看懂图开始

981
00:35:30,466 --> 00:35:32,333
啊这个过程当然应该有预期啊

982
00:35:32,333 --> 00:35:33,999
前面用力其实比它简单

983
00:35:34,000 --> 00:35:35,400
所以大家在写用力的时候

984
00:35:35,500 --> 00:35:37,100
画图都觉得很纠结

985
00:35:37,100 --> 00:35:40,166
是吧这玩意可比用力要麻烦多了

986
00:35:40,166 --> 00:35:42,166
所以你现在看起来都觉得有难度

987
00:35:43,000 --> 00:35:45,066
你去画的话就会觉得更有难度啊

988
00:35:45,066 --> 00:35:46,666
然后你会更会觉得

989
00:35:46,666 --> 00:35:48,899
说你想表达的设计思想

990
00:35:48,900 --> 00:35:50,733
其实用图没办法表达出来

991
00:35:50,733 --> 00:35:51,933
这其实是三个层次

992
00:35:51,933 --> 00:35:52,599
大家逐步来

993
00:35:52,600 --> 00:35:53,533
不着急啊

994
00:35:54,000 --> 00:35:56,300
所以看的过程中有问题就直接问

995
00:35:56,300 --> 00:35:57,933
我就跟你慢慢的解释

996
00:35:58,666 --> 00:36:00,499
这个一口吃不成个胖子啊

997
00:36:00,500 --> 00:36:02,933
不可能说一天就就学会这个

998
00:36:03,866 --> 00:36:04,799
怎么学会画图

999
00:36:04,800 --> 00:36:06,200
怎么学会做设计

1000
00:36:35,500 --> 00:36:36,933
我们从seven开始看起

1001
00:36:36,933 --> 00:36:40,266
我们像画图就以seven为入口

1002
00:36:47,466 --> 00:36:48,266
不是这个

1003
00:36:49,333 --> 00:36:50,699
我是get parent

1004
00:36:55,066 --> 00:36:58,066
这个retrieve parents regions by ID

1005
00:36:58,066 --> 00:36:59,466
设备层有这么一个方法

1006
00:36:59,666 --> 00:37:00,299
大家可以看到

1007
00:37:00,300 --> 00:37:02,100
这设备层上的图就换了两个

1008
00:37:02,100 --> 00:37:03,200
一个是找来对象

1009
00:37:05,066 --> 00:37:06,133
一个是找到对象

1010
00:37:06,366 --> 00:37:07,166
找到对象以后

1011
00:37:07,166 --> 00:37:10,066
去找他的所有的主线就完了

1012
00:37:10,066 --> 00:37:11,966
是吧这是设计啊

1013
00:37:11,966 --> 00:37:13,133
但是你在写代码的时候

1014
00:37:13,133 --> 00:37:14,499
肯定比设计更复杂

1015
00:37:15,266 --> 00:37:16,799
写代码时候会有更多的细节

1016
00:37:17,300 --> 00:37:18,700
所以这些细节啊

1017
00:37:18,700 --> 00:37:20,933
比如说这个参数必须合法

1018
00:37:20,933 --> 00:37:22,133
如果ID是空的话

1019
00:37:22,133 --> 00:37:25,166
我们就通常会抛出一个illegal argument

1020
00:37:25,533 --> 00:37:26,166
这就会包错

1021
00:37:26,166 --> 00:37:27,299
这说明代码写错了啊

1022
00:37:27,300 --> 00:37:28,600
不是程序写错了

1023
00:37:28,866 --> 00:37:30,199
因为我们前面传过来那个路径

1024
00:37:30,200 --> 00:37:31,466
ID是不可能为空的

1025
00:37:31,533 --> 00:37:32,699
你如果调了这个方法

1026
00:37:32,700 --> 00:37:33,566
发现ID为空

1027
00:37:33,566 --> 00:37:34,666
那是你代码有问题

1028
00:37:34,666 --> 00:37:36,066
所以要抛这个错

1029
00:37:36,066 --> 00:37:39,133
这些调试的时候会会知道啊

1030
00:37:39,133 --> 00:37:40,133
如果代码没写错

1031
00:37:40,133 --> 00:37:41,766
其实这个ID是不可能为空的

1032
00:37:41,866 --> 00:37:43,266
现在这个才在图上画的

1033
00:37:43,266 --> 00:37:45,866
用ID找到对象对吧

1034
00:37:46,000 --> 00:37:47,300
然后后面那个在哪呢

1035
00:37:47,300 --> 00:37:48,100
在这

1036
00:37:48,866 --> 00:37:50,933
用这个对象去找到他的ancestor

1037
00:37:51,700 --> 00:37:52,900
中间这一堆干嘛呢

1038
00:37:54,266 --> 00:37:55,099
不是处理

1039
00:37:55,133 --> 00:37:57,333
因为我们有一部分内容在图上没画

1040
00:37:57,500 --> 00:37:59,200
就是所说的细节

1041
00:37:59,400 --> 00:38:00,600
这个细节是什么呢

1042
00:38:00,800 --> 00:38:02,866
大家知道这是个高频的应用

1043
00:38:03,200 --> 00:38:04,666
就是调的很频繁的

1044
00:38:04,666 --> 00:38:06,133
所以我们要做缓存

1045
00:38:06,366 --> 00:38:08,066
我们使用了Redis缓存

1046
00:38:08,700 --> 00:38:11,733
把查出来的数据放到缓存里

1047
00:38:11,866 --> 00:38:12,899
所以大家可以看到

1048
00:38:12,900 --> 00:38:14,533
中间这些没有画在图上的部分

1049
00:38:14,533 --> 00:38:16,199
其实跟我们的逻辑没有关系

1050
00:38:16,800 --> 00:38:18,366
这个是我们的技术实现细节

1051
00:38:18,366 --> 00:38:20,066
这就不需要把这么一行一行的代码

1052
00:38:20,066 --> 00:38:20,933
都画在图上

1053
00:38:21,000 --> 00:38:22,133
画到图上就会使你

1054
00:38:22,133 --> 00:38:26,266
要表达的你的设计意图就就模糊了

1055
00:38:26,566 --> 00:38:29,199
所以技术细节你是要写在代码里头的

1056
00:38:29,200 --> 00:38:30,400
不需要画到图上

1057
00:38:30,666 --> 00:38:31,666
这个就是技术细节

1058
00:38:31,666 --> 00:38:33,999
我们首先怎么产生这个key

1059
00:38:34,300 --> 00:38:34,700
然后呢

1060
00:38:34,700 --> 00:38:36,600
到Rey中间用这个key得到了这个东西

1061
00:38:36,600 --> 00:38:38,700
这个顺便说一下这个缓存的依据

1062
00:38:39,000 --> 00:38:39,966
缓存我们的交换

1063
00:38:39,966 --> 00:38:41,399
e的刻视频

1064
00:38:41,400 --> 00:38:42,300
应该这种是缓存

1065
00:38:42,300 --> 00:38:43,100
是吧

1066
00:38:43,466 --> 00:38:44,666
是吧这都是缓存吗

1067
00:38:45,466 --> 00:38:48,266
对啊所以大家应该明天就要讲了啊

1068
00:38:48,266 --> 00:38:49,133
应该能看到

1069
00:38:49,133 --> 00:38:50,766
我就顺便把这个缓存的

1070
00:38:51,266 --> 00:38:52,099
缓存怎么用啊

1071
00:38:52,100 --> 00:38:52,800
那个课里讲的

1072
00:38:52,800 --> 00:38:55,533
但这里其实讲到你知道怎么调他的API

1073
00:38:55,900 --> 00:38:57,966
然后你怎么去去使用

1074
00:38:58,366 --> 00:38:59,499
怎么去设计这个缓存

1075
00:38:59,500 --> 00:38:59,966
怎么用

1076
00:38:59,966 --> 00:39:02,966
这里其实是是是一个很好的例子

1077
00:39:03,200 --> 00:39:04,100
这个是要为什么

1078
00:39:04,100 --> 00:39:06,166
我们要把上级地区全部缓存起来

1079
00:39:06,300 --> 00:39:08,666
但是我们缓存是有原则的

1080
00:39:08,700 --> 00:39:11,866
我们绝不把同样的数据缓存两次

1081
00:39:12,600 --> 00:39:14,366
就绝不把同样的数据缓存两次

1082
00:39:14,366 --> 00:39:15,733
这是一个最基本的原则

1083
00:39:15,733 --> 00:39:18,299
因为你如果把同样数据缓存两次的话

1084
00:39:18,533 --> 00:39:20,133
如果这个数据发生改变了

1085
00:39:20,166 --> 00:39:21,533
那个缓存很难处理

1086
00:39:21,900 --> 00:39:25,066
所以我们任何一个数据只缓存一次

1087
00:39:25,366 --> 00:39:27,466
那我们知道要返回上级地区

1088
00:39:27,466 --> 00:39:29,533
是要返回有多少个地区

1089
00:39:29,533 --> 00:39:32,199
每个地区的名字是什么

1090
00:39:32,200 --> 00:39:34,100
要把它返回在缓存里头

1091
00:39:34,100 --> 00:39:36,133
它是分成两个部分去缓存的

1092
00:39:36,600 --> 00:39:37,900
这个部分所缓存的

1093
00:39:37,900 --> 00:39:40,600
只是说他的上级地区的关系

1094
00:39:40,600 --> 00:39:42,466
所以他只缓存了那个ID

1095
00:39:43,066 --> 00:39:43,866
看到没有

1096
00:39:43,866 --> 00:39:46,733
哪缓的是所有上级地区的region ID

1097
00:39:47,100 --> 00:39:48,133
他的地区ID

1098
00:39:48,700 --> 00:39:51,100
所以如果说这个地球ID是有的

1099
00:39:51,133 --> 00:39:52,299
如果这个在瑞迪斯

1100
00:39:52,300 --> 00:39:54,366
都是没有这个对象的啊

1101
00:39:54,366 --> 00:39:55,966
大家知道这个其

1102
00:39:55,966 --> 00:39:57,499
实是我们在视频中间已经讲过了

1103
00:39:57,500 --> 00:40:00,400
这个不是瑞迪斯的原声的那个API

1104
00:40:00,666 --> 00:40:02,166
这个是我们历年来我们发现

1105
00:40:02,166 --> 00:40:04,766
直接使用瑞德原声API是不能测试的

1106
00:40:04,766 --> 00:40:05,866
不是它不好用啊

1107
00:40:06,133 --> 00:40:07,366
是不能测试的

1108
00:40:07,900 --> 00:40:11,066
所以我们在上面包装了一个radiuseuter

1109
00:40:11,333 --> 00:40:11,899
这个代码

1110
00:40:11,900 --> 00:40:12,933
在括里头

1111
00:40:13,000 --> 00:40:14,700
我们通过radiuseuter

1112
00:40:14,700 --> 00:40:17,733
去调那个Redis template的原声API

1113
00:40:18,000 --> 00:40:18,500
这样的话

1114
00:40:18,500 --> 00:40:19,600
当我们在测试的时候

1115
00:40:19,600 --> 00:40:22,300
我们可以把Redis util给它直接model掉

1116
00:40:22,300 --> 00:40:23,733
把它直接把它隔离掉

1117
00:40:23,866 --> 00:40:26,499
所以我们都不是直接去用Redis的template

1118
00:40:26,500 --> 00:40:28,866
而是通过我们自己写的youtil去调

1119
00:40:28,866 --> 00:40:30,899
所以这就是从Redis中间拿到这个key

1120
00:40:31,100 --> 00:40:32,866
如果说这个存在的

1121
00:40:32,866 --> 00:40:33,533
它就会拿到

1122
00:40:33,533 --> 00:40:34,666
如果不存在就是空

1123
00:40:35,200 --> 00:40:36,666
所以当然了

1124
00:40:36,666 --> 00:40:38,499
我们今天的这个代码其实不太讲

1125
00:40:38,500 --> 00:40:39,866
就直接判空了啊

1126
00:40:39,866 --> 00:40:42,566
大家知道在加瓦8还是加瓦9里头

1127
00:40:42,566 --> 00:40:44,533
有一个新的结构叫什么

1128
00:40:44,800 --> 00:40:45,900
叫做ALP形容啊

1129
00:40:45,900 --> 00:40:49,000
当然这个因为很早之前同学们写的

1130
00:40:49,000 --> 00:40:50,200
所以还是用来判空

1131
00:40:50,200 --> 00:40:51,166
这不是好习惯啊

1132
00:40:51,166 --> 00:40:53,266
其实应该变成一个OPTIONAL的什么什么

1133
00:40:53,366 --> 00:40:55,866
然后去根据OPTIONAL来判得空

1134
00:40:55,866 --> 00:40:56,766
把它改一下吧

1135
00:40:56,766 --> 00:40:58,199
但这个因为改的太多

1136
00:40:58,200 --> 00:40:58,966
这个一动的话

1137
00:40:58,966 --> 00:40:59,799
所有的嘛都要动

1138
00:40:59,800 --> 00:41:01,000
所以我就不敢动这个

1139
00:41:01,600 --> 00:41:02,766
不敢动这个red ZUT

1140
00:41:02,766 --> 00:41:02,999
哦

1141
00:41:03,000 --> 00:41:06,133
所以就是这才看到这个古早的样子啊

1142
00:41:06,266 --> 00:41:07,099
老的样子

1143
00:41:07,566 --> 00:41:08,533
如果它为空的话

1144
00:41:08,533 --> 00:41:10,199
就说明这个red中间没有

1145
00:41:11,200 --> 00:41:12,533
那就到下面这个部分

1146
00:41:12,800 --> 00:41:14,366
下面就是我们说的去reading

1147
00:41:14,366 --> 00:41:16,766
中间真的去找到他的redister

1148
00:41:17,466 --> 00:41:18,799
找到他的redister以后

1149
00:41:18,800 --> 00:41:20,666
又把他的ID看到没有

1150
00:41:20,666 --> 00:41:23,266
用这个流式处理把

1151
00:41:23,266 --> 00:41:25,099
他的ID给他弄出来

1152
00:41:25,100 --> 00:41:28,600
然后把他ID存到了Redis中间去

1153
00:41:28,800 --> 00:41:29,766
然后结束了

1154
00:41:30,133 --> 00:41:31,799
那如果他第一次有查过了

1155
00:41:31,800 --> 00:41:33,133
这个地区的商业地区的话

1156
00:41:33,166 --> 00:41:34,166
red中间这个key

1157
00:41:34,166 --> 00:41:36,399
就会把他的ID全部存下来

1158
00:41:36,700 --> 00:41:37,500
存下来以后呢

1159
00:41:37,500 --> 00:41:39,066
我这个哎

1160
00:41:39,066 --> 00:41:41,399
这个方法执行的时候就第169行

1161
00:41:41,400 --> 00:41:43,400
执行的时候他就会拿到那个判的ID

1162
00:41:43,666 --> 00:41:44,966
所以就会进到这个地方了

1163
00:41:44,966 --> 00:41:45,199
就这样

1164
00:41:45,200 --> 00:41:47,766
又用流失处理把这个ID全部换成对象

1165
00:41:49,166 --> 00:41:50,999
啊这个应该大家自己去学习

1166
00:41:51,000 --> 00:41:53,066
这是Java吧里头的流失处理啊

1167
00:41:53,400 --> 00:41:54,300
把它换成对象

1168
00:41:54,300 --> 00:41:57,300
然后把它对象的列表给它丢回去

1169
00:41:57,666 --> 00:41:59,966
所以这里头是用到了Redis的缓存

1170
00:42:00,000 --> 00:42:00,700
但是这部分

1171
00:42:00,700 --> 00:42:01,800
我们是完全不需要

1172
00:42:01,800 --> 00:42:04,400
在设计图上头画出来的

1173
00:42:04,400 --> 00:42:05,966
因为这是技术细节

1174
00:42:06,200 --> 00:42:08,400
我们在设计图里头可以看到

1175
00:42:08,533 --> 00:42:10,099
选择画的部分

1176
00:42:10,300 --> 00:42:12,333
是我们关注于这部分功能

1177
00:42:12,333 --> 00:42:15,266
到底哪部分留在了设备室里头

1178
00:42:15,666 --> 00:42:18,166
哪部分被分配出去了

1179
00:42:18,200 --> 00:42:19,966
也就是我们说的职责分配

1180
00:42:19,966 --> 00:42:22,199
我们被分配出去的是这个部分的代码

1181
00:42:23,566 --> 00:42:26,333
这部分代码如果大家写评选模型的话

1182
00:42:26,700 --> 00:42:27,900
就是我不知道

1183
00:42:27,900 --> 00:42:29,500
大家以前有没有写过这种东西

1184
00:42:29,500 --> 00:42:30,700
你们就会把这部分代码

1185
00:42:30,700 --> 00:42:32,300
也写到这个收费室里头

1186
00:42:33,466 --> 00:42:36,199
就通常就唰唰唰直白的这么写下去

1187
00:42:36,533 --> 00:42:37,766
那我们现在可以看到

1188
00:42:37,766 --> 00:42:39,966
这部分代码就从设备师中间割出去了

1189
00:42:39,966 --> 00:42:43,099
这其实就是做了一次模块化的划分

1190
00:42:43,466 --> 00:42:44,266
就把一部分代码

1191
00:42:44,266 --> 00:42:45,699
给它切到另外一个地方去了

1192
00:42:45,800 --> 00:42:47,300
那切到这个部分里头的代码

1193
00:42:47,300 --> 00:42:48,266
是怎么写的呢

1194
00:42:52,600 --> 00:42:54,933
我们可以看到切的原则啊

1195
00:42:54,933 --> 00:42:57,166
就是因为如果我想知道

1196
00:42:57,166 --> 00:42:58,399
一个地区的上级

1197
00:42:58,400 --> 00:43:00,100
地区所依赖的信息是什么

1198
00:43:00,100 --> 00:43:02,300
是每个地区他的上级再上级再上级

1199
00:43:02,300 --> 00:43:04,100
这个信息只有Regin里头有

1200
00:43:04,366 --> 00:43:06,733
所以说我应该把这个职责分配给Regin

1201
00:43:06,966 --> 00:43:08,766
所以说就在region中间做了一个方法

1202
00:43:08,766 --> 00:43:11,266
叫做get an ancestor去获得它

1203
00:43:11,600 --> 00:43:14,066
那我们可以看一下在Bo对象中间的

1204
00:43:16,366 --> 00:43:18,133
region对象这部分是怎么做的

1205
00:43:33,466 --> 00:43:35,066
这部分其实就很

1206
00:43:35,066 --> 00:43:36,366
就跟图上看的是一样的

1207
00:43:36,366 --> 00:43:38,499
我们图上没有画这个bo list

1208
00:43:38,866 --> 00:43:39,666
这个没画

1209
00:43:40,066 --> 00:43:41,199
但这个画了

1210
00:43:41,200 --> 00:43:43,366
就是他掉region的gate part丢

1211
00:43:43,366 --> 00:43:44,466
然后得到了region对象

1212
00:43:44,466 --> 00:43:45,966
加到他的list区

1213
00:43:46,000 --> 00:43:47,800
然后这个循环又会再去得这个对象的

1214
00:43:47,800 --> 00:43:48,600
再上一级

1215
00:43:48,766 --> 00:43:49,699
然后再加进去

1216
00:43:49,700 --> 00:43:51,000
再上去再加进去

1217
00:43:51,100 --> 00:43:52,766
直到说那个上面没有了

1218
00:43:53,266 --> 00:43:54,599
或者说已经到10了

1219
00:43:54,733 --> 00:43:56,766
那他就退回去

1220
00:43:56,966 --> 00:43:57,199
所以

1221
00:43:57,200 --> 00:44:00,300
返回的就是这样的一个reading对象啊

1222
00:44:00,766 --> 00:44:01,866
这就是职责分配

1223
00:44:01,866 --> 00:44:02,733
这一段代码

1224
00:44:02,733 --> 00:44:05,066
被分配到了region图像中间了

1225
00:44:05,133 --> 00:44:09,366
如果如果说没有这么分配的话

1226
00:44:09,366 --> 00:44:11,933
这些代码就是在service里头

1227
00:44:12,000 --> 00:44:14,200
大家知道这里头的这个代码

1228
00:44:14,200 --> 00:44:15,733
get parents region

1229
00:44:15,733 --> 00:44:18,566
这个代码其实是有去调数据库

1230
00:44:18,566 --> 00:44:19,599
去做查询的

1231
00:44:20,733 --> 00:44:21,599
这个在上面

1232
00:44:25,200 --> 00:44:27,300
这个看到没有

1233
00:44:28,466 --> 00:44:28,766
这个在

1234
00:44:28,766 --> 00:44:31,766
这就是我们得祖先里头的这个

1235
00:44:31,766 --> 00:44:33,133
拿到所有祖先里的代码

1236
00:44:33,133 --> 00:44:34,499
我们又被切了一小块

1237
00:44:34,766 --> 00:44:36,666
放到了这个地方了

1238
00:44:36,766 --> 00:44:39,199
然后变成他的另外一个职责啊

1239
00:44:39,200 --> 00:44:40,766
然后去得到他

1240
00:44:40,900 --> 00:44:42,566
所以同样的一个事

1241
00:44:42,566 --> 00:44:44,733
这个事情我们不是写在身份证上面

1242
00:44:44,733 --> 00:44:46,133
平铺直叙地写下来

1243
00:44:46,466 --> 00:44:48,133
而是把它切成了两个

1244
00:44:48,133 --> 00:44:49,199
一个是找到对象

1245
00:44:49,333 --> 00:44:51,799
一个是去拿到他具体的值

1246
00:44:51,966 --> 00:44:52,799
拿到他具体的值呢

1247
00:44:52,800 --> 00:44:53,400
又把他再

1248
00:44:53,400 --> 00:44:54,066
切了一小半

1249
00:44:54,066 --> 00:44:57,199
变成拿到他直接上级和拿到他所有的

1250
00:44:57,366 --> 00:44:58,933
所以切了三块

1251
00:44:59,000 --> 00:45:00,133
最后变成了这个样子

1252
00:45:00,133 --> 00:45:01,266
这就是我们说的

1253
00:45:01,400 --> 00:45:03,900
软件设计的最主要的目标

1254
00:45:04,766 --> 00:45:05,566
模块化

1255
00:45:05,766 --> 00:45:07,866
当然我们现在没有考虑它的重用性

1256
00:45:07,900 --> 00:45:09,800
但是这么来分配的话

1257
00:45:09,966 --> 00:45:12,699
通常会提高它的重用性

1258
00:45:12,966 --> 00:45:14,533
从而要达成它的封装性

1259
00:45:14,533 --> 00:45:15,766
为什么大家会发现

1260
00:45:15,766 --> 00:45:17,733
这个PID其实根本不会在外头去得

1261
00:45:18,133 --> 00:45:21,366
所有在PID要去用的代码

1262
00:45:21,900 --> 00:45:24,666
全部在这个region类里头

1263
00:45:24,766 --> 00:45:25,699
不在别的地方

1264
00:45:25,700 --> 00:45:26,266
就是别的地方

1265
00:45:26,266 --> 00:45:27,366
不会去get一个PRD

1266
00:45:27,366 --> 00:45:29,066
然后就根据这个PRD去做判断

1267
00:45:29,133 --> 00:45:30,299
没有这种代码的

1268
00:45:30,300 --> 00:45:32,333
所有这些跟PRD有关的代码

1269
00:45:32,366 --> 00:45:33,499
都在这个类里头

1270
00:45:33,500 --> 00:45:34,900
这就是我们说的封装型

1271
00:45:35,133 --> 00:45:36,199
好先休息一会

1272
00:55:22,933 --> 00:55:23,733
好

1273
00:55:24,333 --> 00:55:27,533
呃所以这是我们的第一个设计啊

1274
00:55:28,333 --> 00:55:30,533
get上级地区

1275
00:55:30,533 --> 00:55:31,533
查询上级地区

1276
00:55:31,533 --> 00:55:32,366
我们可以看到

1277
00:55:32,366 --> 00:55:37,399
我们用职责分配的原则做了两次分配

1278
00:55:37,600 --> 00:55:39,133
第一次分配是收费时

1279
00:55:39,133 --> 00:55:42,766
中间把这个职责分给了Lancester

1280
00:55:43,166 --> 00:55:45,666
这个部分不是面向对象的啊

1281
00:55:45,666 --> 00:55:46,699
这是面向功能的

1282
00:55:47,133 --> 00:55:49,766
就是我们利用稻城所提供的功能

1283
00:55:49,766 --> 00:55:50,999
找到这个对象啊

1284
00:55:51,000 --> 00:55:53,100
这个不是面向对象的职责分配

1285
00:55:53,466 --> 00:55:55,799
这个是面向对象的信息专家

1286
00:55:56,133 --> 00:55:56,533
就是

1287
00:55:56,533 --> 00:55:58,799
因为我们要找到一个地区的上级地区

1288
00:55:58,800 --> 00:56:00,400
我们去看这些上级地区

1289
00:56:00,400 --> 00:56:01,966
他所一二的数据是什么

1290
00:56:02,400 --> 00:56:03,133
一定要的信息是什么

1291
00:56:03,133 --> 00:56:04,766
这些信息是在region对象中间的

1292
00:56:04,766 --> 00:56:05,666
他的PRD

1293
00:56:06,300 --> 00:56:07,266
你有这个PRD

1294
00:56:07,266 --> 00:56:08,933
才能找到他的所有的祖先

1295
00:56:09,000 --> 00:56:12,300
所以因为region对象具备这个信息

1296
00:56:12,366 --> 00:56:13,799
当然在这里我们是有点可笑

1297
00:56:13,800 --> 00:56:14,866
因为只有一个对象

1298
00:56:14,866 --> 00:56:15,899
其实你不找他也没有别

1299
00:56:15,900 --> 00:56:16,800
没有别的办法

1300
00:56:17,000 --> 00:56:19,700
但是在其他的模块中间

1301
00:56:19,700 --> 00:56:20,566
有多个对象的话

1302
00:56:20,566 --> 00:56:23,766
就是按照谁具备完成这个职责

1303
00:56:23,766 --> 00:56:26,666
所需要的信息就由他来承担

1304
00:56:26,766 --> 00:56:28,866
所以在word里面多了一个方法

1305
00:56:28,866 --> 00:56:30,166
叫做get an ancestor

1306
00:56:30,533 --> 00:56:31,733
在get an ancestor里头

1307
00:56:31,733 --> 00:56:34,366
你又会发现说他需要知道直接上级

1308
00:56:34,366 --> 00:56:35,899
然后把所有的直接上级拼起来

1309
00:56:35,900 --> 00:56:37,333
再变成所有的上级

1310
00:56:37,666 --> 00:56:39,133
所以这又把它切成了一个职责

1311
00:56:39,133 --> 00:56:40,733
当然这个职责又是自己承担的

1312
00:56:40,733 --> 00:56:41,933
所以他又多了个方法

1313
00:56:42,100 --> 00:56:42,600
这样的话

1314
00:56:42,600 --> 00:56:44,366
我们做这样的一个功能

1315
00:56:44,966 --> 00:56:46,333
就被切出来了

1316
00:56:46,333 --> 00:56:47,166
两个方法

1317
00:56:47,166 --> 00:56:48,399
假如你连切出两个方法

1318
00:56:48,400 --> 00:56:49,300
就这么出来的

1319
00:56:49,533 --> 00:56:51,366
这两个方法这么切的话

1320
00:56:51,766 --> 00:56:52,599
切成这么小的话

1321
00:56:52,600 --> 00:56:55,800
是因为这个方法是这么切的话

1322
00:56:55,800 --> 00:56:58,366
是有可能会被其他的地方重用的

1323
00:56:58,800 --> 00:57:00,500
对吧所以切成这个样子

1324
00:57:00,600 --> 00:57:02,066
那目前来说

1325
00:57:02,066 --> 00:57:03,866
我们的其他IPI好像没用到它

1326
00:57:03,866 --> 00:57:05,333
但是我们还是把它切开了

1327
00:57:05,466 --> 00:57:09,099
把它分开切成另外一个方法

1328
00:57:09,766 --> 00:57:11,499
这是信息专家的第一个

1329
00:57:11,900 --> 00:57:14,666
那第二个的例子我们可以看一下

1330
00:57:14,666 --> 00:57:17,099
这个我们有一组API

1331
00:57:17,100 --> 00:57:18,766
就是要停用一个地区

1332
00:57:18,766 --> 00:57:21,699
恢复一个地区和废弃一个地区

1333
00:57:22,100 --> 00:57:24,400
这个这一组API有一个共性

1334
00:57:24,400 --> 00:57:25,100
这个共性是什么呢

1335
00:57:25,100 --> 00:57:27,966
就是我们所有的停用恢复和废弃

1336
00:57:28,000 --> 00:57:29,400
不是一个地区

1337
00:57:29,733 --> 00:57:32,599
而是这个地区所有的夏季地区全部要

1338
00:57:32,766 --> 00:57:34,266
比如说我停用厦门市

1339
00:57:34,300 --> 00:57:35,900
那厦门的5区

1340
00:57:36,133 --> 00:57:37,966
区底下的这个街道

1341
00:57:37,966 --> 00:57:39,933
街道底下的居委会就都停用了

1342
00:57:40,000 --> 00:57:42,266
就所有的人在选择地区的时候

1343
00:57:42,500 --> 00:57:44,066
就不能再选这个东西了

1344
00:57:44,066 --> 00:57:46,133
是吧包括底下的地区和居委会

1345
00:57:46,466 --> 00:57:47,599
恢复也是一样的

1346
00:57:48,566 --> 00:57:50,066
然后废弃也是一样

1347
00:57:50,266 --> 00:57:51,566
不是独立的

1348
00:57:51,566 --> 00:57:53,166
只对一个地区来做这个

1349
00:57:53,166 --> 00:57:54,499
而是把它下级所有地区

1350
00:57:54,500 --> 00:57:55,666
全部给他干掉了

1351
00:58:01,266 --> 00:58:01,899
不不

1352
00:58:01,900 --> 00:58:03,200
那只恢复它一下

1353
00:58:04,066 --> 00:58:04,766
只恢复它一下

1354
00:58:04,766 --> 00:58:06,299
不恢复它的

1355
00:58:06,366 --> 00:58:07,766
这样你说的这个问题对

1356
00:58:07,766 --> 00:58:09,166
我没有考虑这个逻辑

1357
00:58:09,300 --> 00:58:10,500
恢复是要去做判断

1358
00:58:10,500 --> 00:58:11,500
它上级是不是停用了

1359
00:58:11,500 --> 00:58:12,066
上级停用了

1360
00:58:12,066 --> 00:58:13,199
下级是不能恢复的

1361
00:58:14,266 --> 00:58:14,933
是这个逻辑

1362
00:58:14,933 --> 00:58:15,566
是这样的

1363
00:58:15,566 --> 00:58:16,533
这个逻辑还没写

1364
00:58:16,533 --> 00:58:17,266
你说的有道理

1365
00:58:17,266 --> 00:58:18,333
我再把它改进去

1366
00:58:20,333 --> 00:58:21,133
对

1367
00:58:22,566 --> 00:58:24,066
不行了看不出来

1368
00:58:28,700 --> 00:58:29,766
就是福建省恢复了

1369
00:58:29,766 --> 00:58:30,666
下面是才能用

1370
00:58:34,800 --> 00:58:35,800
你说是什么

1371
00:58:38,600 --> 00:58:39,400
对

1372
00:58:40,133 --> 00:58:41,133
只有厦门市还活着

1373
00:58:41,133 --> 00:58:42,099
其他都死了

1374
00:58:42,166 --> 00:58:44,333
对那你就是把福建省禁了

1375
00:58:44,400 --> 00:58:45,466
把福建省恢复了

1376
00:58:45,466 --> 00:58:46,599
然后把厦门市

1377
00:58:46,600 --> 00:58:48,266
把除厦门以外的其他地区

1378
00:58:48,266 --> 00:58:49,399
都把它禁用掉

1379
00:58:49,400 --> 00:58:50,200
就这样

1380
00:58:51,100 --> 00:58:51,933
就是这个逻辑

1381
00:58:51,933 --> 00:58:52,799
就是这个

1382
00:58:52,800 --> 00:58:53,666
我还没写啊

1383
00:58:53,666 --> 00:58:56,966
禁用的部分来说是恢复的时候

1384
00:58:56,966 --> 00:58:58,066
请说的有道理啊

1385
00:58:58,066 --> 00:58:58,933
就是恢复的时候

1386
00:58:58,933 --> 00:59:00,699
其实是上级地区没有恢复

1387
00:59:00,700 --> 00:59:01,933
他是不能恢复的

1388
00:59:02,300 --> 00:59:04,100
停用的话是没有限制

1389
00:59:04,766 --> 00:59:06,266
对停用是没有限制

1390
00:59:06,300 --> 00:59:07,200
废气也没有限制

1391
00:59:07,200 --> 00:59:09,000
就是恢复是有个特殊逻辑

1392
00:59:09,000 --> 00:59:10,100
这个我再加进去

1393
00:59:10,300 --> 00:59:10,966
大家可以考虑下

1394
00:59:10,966 --> 00:59:12,199
这个逻辑加在什么地方

1395
00:59:14,566 --> 00:59:15,499
怎么做的呢

1396
00:59:16,466 --> 00:59:19,333
呃我们的这个

1397
00:59:21,000 --> 00:59:22,300
代码给大家看一下代码吧

1398
00:59:22,300 --> 00:59:23,266
我的图没画

1399
00:59:24,533 --> 00:59:28,799
就是在控制器层有若干个方法

1400
00:59:29,066 --> 00:59:32,533
那他就会在收位值层有对应的方法

1401
00:59:32,533 --> 00:59:34,066
所以我们控制器层就不去看了

1402
00:59:34,066 --> 00:59:34,266
就是

1403
00:59:34,266 --> 00:59:35,899
控制器层和收位值层是一一对应的

1404
00:59:36,500 --> 00:59:39,733
我们在收位值层是有若干的方法的

1405
00:59:40,333 --> 00:59:42,099
就是针对他的

1406
00:59:45,100 --> 00:59:46,366
这是暂停

1407
00:59:46,966 --> 00:59:48,999
这是取消遮挡版本

1408
00:59:49,566 --> 00:59:53,466
这是他的resume

1409
00:59:53,766 --> 00:59:55,999
所以他的图的话

1410
00:59:56,000 --> 00:59:56,933
我们就画了

1411
00:59:58,100 --> 00:59:59,466
我应该也画了一张

1412
01:00:03,333 --> 01:00:03,933
啊没有

1413
01:00:03,933 --> 01:00:05,299
没有画表面这一张啊

1414
01:00:05,800 --> 01:00:06,366
Swisse的图

1415
01:00:06,366 --> 01:00:07,966
我没画Swisse图的话

1416
01:00:07,966 --> 01:00:08,566
大家可以看到

1417
01:00:08,566 --> 01:00:10,899
其实它的职责非常的简单

1418
01:00:11,200 --> 01:00:13,300
就是因为我们常见的就是对象

1419
01:00:13,966 --> 01:00:15,199
常见的是这个ID

1420
01:00:15,400 --> 01:00:16,300
所以大家可以看到

1421
01:00:16,300 --> 01:00:17,900
收费层基本上有个共性

1422
01:00:17,900 --> 01:00:19,300
当我们要做任何事情的时候

1423
01:00:19,300 --> 01:00:20,733
首先要把ID变成对象

1424
01:00:21,200 --> 01:00:22,566
所以都会把它变成对象

1425
01:00:22,900 --> 01:00:24,300
为什么会做这个过程

1426
01:00:24,300 --> 01:00:26,366
就是实际上把ID变成对象的时候

1427
01:00:26,400 --> 01:00:27,900
不仅仅把ID变成了对象

1428
01:00:27,900 --> 01:00:29,200
如果大家去看你的大成代码

1429
01:00:29,200 --> 01:00:30,066
其实他有做的时候

1430
01:00:30,066 --> 01:00:30,933
这个ID不存在

1431
01:00:30,933 --> 01:00:31,733
他会怎么办

1432
01:00:32,166 --> 01:00:34,466
就是如果这个ID是瞎给的一个ID

1433
01:00:34,466 --> 01:00:35,733
所以这个ID不存在

1434
01:00:36,100 --> 01:00:37,666
他会怎么办啊

1435
01:00:37,966 --> 01:00:39,499
那拿到对象以后

1436
01:00:39,500 --> 01:00:44,733
我们知道这个无论是停用还是恢复

1437
01:00:44,733 --> 01:00:48,366
还是这个呃废弃

1438
01:00:48,466 --> 01:00:50,099
都是reading的职责

1439
01:00:50,800 --> 01:00:52,733
因为这个事情要干的事情

1440
01:00:52,733 --> 01:00:56,666
就是要改变他和他以下的地区的状态

1441
01:00:57,066 --> 01:00:58,533
无论是他自己的状态

1442
01:00:58,533 --> 01:01:00,066
还是他以下的地区

1443
01:01:00,166 --> 01:01:03,266
都是regions所具备的信息

1444
01:01:03,266 --> 01:01:04,299
他有这个信息

1445
01:01:04,600 --> 01:01:06,133
所以说你才能让

1446
01:01:07,733 --> 01:01:09,399
把这个职责分配给了他

1447
01:01:10,133 --> 01:01:12,733
那我们具体去看这个region里头的

1448
01:01:19,366 --> 01:01:20,766
这是regin里头的代码

1449
01:01:21,066 --> 01:01:21,566
regin代码

1450
01:01:21,566 --> 01:01:22,666
因为这里是有状态的

1451
01:01:22,666 --> 01:01:24,566
就是regin是个有状态的对象啊

1452
01:01:24,566 --> 01:01:25,533
我们把状态截图

1453
01:01:25,533 --> 01:01:26,699
把它给大家看一下

1454
01:02:11,566 --> 01:02:12,499
我们的这个文档

1455
01:02:12,500 --> 01:02:14,600
我在上课完了之后会更新的

1456
01:02:14,600 --> 01:02:16,733
因为PPT上完以后我就不会再更新了

1457
01:02:16,733 --> 01:02:18,966
但其实大家知道PPT其实是有问题的

1458
01:02:19,166 --> 01:02:21,533
所以但是这个文档我会持续的更新

1459
01:02:28,533 --> 01:02:29,533
这是我们的状态

1460
01:02:30,266 --> 01:02:33,266
就是我们刚才说了region这个东西

1461
01:02:33,266 --> 01:02:34,199
为什么是有状态

1462
01:02:34,200 --> 01:02:37,333
的是因为它在不同状态下

1463
01:02:37,333 --> 01:02:38,899
它的行为是不一样

1464
01:02:39,333 --> 01:02:42,166
比如说它在耳斑等的状态下头

1465
01:02:42,400 --> 01:02:45,900
那用户其实是不能选择这个耳斑等的

1466
01:02:45,966 --> 01:02:48,866
它甚至看都看不到所有被废弃的地区

1467
01:02:48,866 --> 01:02:50,399
它只能看到有效的地区

1468
01:02:51,166 --> 01:02:54,199
如果说他是在这个版本的状态的话

1469
01:02:54,200 --> 01:02:56,133
他也不能再去把它恢复

1470
01:02:56,133 --> 01:02:57,533
也不能再把它停用

1471
01:02:57,600 --> 01:02:59,133
他就是一个最终状态

1472
01:02:59,333 --> 01:03:01,299
所以状态不同

1473
01:03:01,500 --> 01:03:03,366
我们对他们施加的行为

1474
01:03:03,400 --> 01:03:04,600
就会有不同的结果

1475
01:03:04,600 --> 01:03:05,766
比如说你看的行为

1476
01:03:05,766 --> 01:03:07,099
就会得到不同的结果

1477
01:03:07,100 --> 01:03:09,333
你去做的行为也会有不同的结果啊

1478
01:03:09,333 --> 01:03:11,299
所以这是在对于状态的定义

1479
01:03:11,500 --> 01:03:13,166
那这套状态去图画出来以后

1480
01:03:13,166 --> 01:03:15,066
是要在代码中间去实现的

1481
01:03:15,666 --> 01:03:18,499
那我们在这里头其实是有一套

1482
01:03:20,066 --> 01:03:23,166
固定的代码去实现这个所有的状态

1483
01:03:23,200 --> 01:03:24,300
也就是我们把状态截图

1484
01:03:24,300 --> 01:03:25,333
把它写成了代码

1485
01:03:25,966 --> 01:03:27,466
这个顺便给大家说一下

1486
01:03:27,466 --> 01:03:28,666
因为所有的状态机

1487
01:03:28,666 --> 01:03:30,566
所有有状态对象都是这么来实现的

1488
01:03:31,200 --> 01:03:33,600
在region的这个对象里头啊

1489
01:03:33,600 --> 01:03:36,600
因为这个相对比较简单

1490
01:03:36,700 --> 01:03:37,500
大家可以看到

1491
01:03:37,500 --> 01:03:40,466
在这里头我们一共会写了三种状态

1492
01:03:40,933 --> 01:03:42,266
我们在代码中心

1493
01:03:42,266 --> 01:03:42,666
大家知道

1494
01:03:42,666 --> 01:03:44,133
有个最基本的常识

1495
01:03:44,133 --> 01:03:45,866
是不能直接写常量的

1496
01:03:46,100 --> 01:03:50,733
一定要用这个大写字母去替代它

1497
01:03:50,800 --> 01:03:53,200
所以我们把跟region有关的

1498
01:03:53,200 --> 01:03:55,466
所有的常量都定义在region里头

1499
01:03:56,000 --> 01:03:57,466
跟整个系统有关的常量

1500
01:03:57,466 --> 01:03:59,666
是定义在我们的mole里头啊

1501
01:03:59,666 --> 01:04:00,533
括里头的

1502
01:04:00,766 --> 01:04:02,199
所以这里定义了三个常量

1503
01:04:02,200 --> 01:04:06,100
是对应着它的三个状态啊这一些的

1504
01:04:06,100 --> 01:04:06,866
这个注解

1505
01:04:06,866 --> 01:04:08,866
就这些注解的主要的目的就是

1506
01:04:08,900 --> 01:04:12,566
因为这些东西是会调试的时候

1507
01:04:12,566 --> 01:04:13,499
会把它打印出来

1508
01:04:13,500 --> 01:04:14,366
就他会有图示

1509
01:04:14,366 --> 01:04:14,899
俊的方法

1510
01:04:14,900 --> 01:04:16,533
我们用南book的图示

1511
01:04:16,533 --> 01:04:17,333
俊的方法

1512
01:04:18,700 --> 01:04:21,300
呃定义了说怎么把它变成Steam

1513
01:04:21,300 --> 01:04:22,500
这样调试好看

1514
01:04:22,500 --> 01:04:25,200
但是这些东西我们是不不输出的

1515
01:04:25,200 --> 01:04:26,900
所以to Steam的eclude

1516
01:04:27,066 --> 01:04:27,899
所以在to Steam时候

1517
01:04:27,900 --> 01:04:29,766
它是不输出这些内容的

1518
01:04:29,966 --> 01:04:31,133
在节省的时候

1519
01:04:31,133 --> 01:04:31,933
把它节省化的时候

1520
01:04:31,933 --> 01:04:33,133
这部分也不输出的啊

1521
01:04:33,133 --> 01:04:34,099
所以这两个标记

1522
01:04:34,100 --> 01:04:35,866
就起了这样的一个作用

1523
01:04:36,400 --> 01:04:37,733
那三个状态

1524
01:04:37,733 --> 01:04:39,533
然后我们还定义了一个map

1525
01:04:39,533 --> 01:04:42,199
这个map主要是状态是有中文名称的

1526
01:04:42,533 --> 01:04:44,399
对吧前端要显示状态时候

1527
01:04:44,400 --> 01:04:45,700
是要看到中文名称

1528
01:04:45,800 --> 01:04:47,933
我们如果要抛错的话

1529
01:04:47,933 --> 01:04:49,866
其实也要看到它对应的名称

1530
01:04:49,866 --> 01:04:51,699
而不是看一个状态码

1531
01:04:52,100 --> 01:04:53,800
那这个东西我们时间定的代码中

1532
01:04:53,800 --> 01:04:55,266
就像这种城市化的方式

1533
01:04:55,266 --> 01:04:56,199
都要一个map

1534
01:04:56,466 --> 01:05:00,066
我们在所有的模块里头都有一组API

1535
01:05:00,066 --> 01:05:01,866
去获得当前这些状态的

1536
01:05:01,866 --> 01:05:03,066
所有的中文提示

1537
01:05:03,066 --> 01:05:04,333
和状态码的对应关系

1538
01:05:04,400 --> 01:05:05,200
那个是干嘛的

1539
01:05:05,200 --> 01:05:06,600
那个是丢给前端的

1540
01:05:06,733 --> 01:05:07,933
就是前端启动的时候

1541
01:05:07,933 --> 01:05:09,699
他会把所有的状态和状态码

1542
01:05:09,700 --> 01:05:10,933
全部缓存在前端

1543
01:05:11,333 --> 01:05:13,366
我们所有的API都只返回状态码

1544
01:05:13,366 --> 01:05:15,966
不会返回这个状态码对应的关系

1545
01:05:15,966 --> 01:05:18,166
那是由前端去做对应的

1546
01:05:18,166 --> 01:05:20,533
所以我们给前端提供了一组的API

1547
01:05:20,866 --> 01:05:23,533
去获得那个状态和对应的这个关系

1548
01:05:23,533 --> 01:05:23,766
啊

1549
01:05:23,766 --> 01:05:25,666
那个东西读的时候就是读了这个字

1550
01:05:25,866 --> 01:05:27,333
那个不是这种单

1551
01:05:27,333 --> 01:05:28,733
不是随便写的

1552
01:05:28,733 --> 01:05:30,499
是读了这个里头的这个字

1553
01:05:31,366 --> 01:05:32,266
那第三个

1554
01:05:32,266 --> 01:05:32,899
我们在状态之间

1555
01:05:32,900 --> 01:05:34,366
我们会写一个状态迁移

1556
01:05:34,366 --> 01:05:35,066
这个是什么呢

1557
01:05:35,066 --> 01:05:36,066
这个就是这张图

1558
01:05:38,733 --> 01:05:39,699
就从这张图

1559
01:05:40,000 --> 01:05:42,666
我们这个描述的是当前是什么状态

1560
01:05:42,666 --> 01:05:44,199
它可以迁移到什

1561
01:05:44,200 --> 01:05:46,066
么状态比如说wallet状态

1562
01:05:46,066 --> 01:05:48,299
它可以迁移到suspend和abandon

1563
01:05:48,700 --> 01:05:51,866
suspend可以迁移到wallet和abandon

1564
01:05:51,866 --> 01:05:53,399
abandon什么都不能迁

1565
01:05:54,200 --> 01:05:55,400
这三个状态的迁移关系

1566
01:05:55,400 --> 01:05:56,466
是这样的一个关系

1567
01:05:56,700 --> 01:05:59,100
所以在代码中间就是这么写的

1568
01:05:59,566 --> 01:06:00,766
我们定义了一个map

1569
01:06:00,766 --> 01:06:02,966
map key代表当前的状态

1570
01:06:03,300 --> 01:06:06,866
所以value状态它的值是一个什么呢

1571
01:06:06,866 --> 01:06:07,899
是一个site

1572
01:06:07,900 --> 01:06:09,466
就是它可以签到SUS

1573
01:06:09,466 --> 01:06:11,266
suspend和abandon

1574
01:06:11,566 --> 01:06:12,533
如果说suspend的话

1575
01:06:12,533 --> 01:06:13,933
可以签到valet和abandon

1576
01:06:13,933 --> 01:06:15,066
abandon什么都不能签

1577
01:06:15,066 --> 01:06:16,133
abandon这里头没有

1578
01:06:16,700 --> 01:06:17,500
直接没有

1579
01:06:17,566 --> 01:06:18,399
这玩意怎么用的呢

1580
01:06:18,400 --> 01:06:19,700
我们下面定义了一个方法

1581
01:06:19,700 --> 01:06:21,333
叫做allow status

1582
01:06:21,533 --> 01:06:23,399
allow status是根据当

1583
01:06:24,000 --> 01:06:27,366
这是因为定在这对象里头的方法

1584
01:06:27,600 --> 01:06:30,300
所以allow status是当前这个对象的状态

1585
01:06:30,300 --> 01:06:32,133
可以迁到哪个状态上去

1586
01:06:32,133 --> 01:06:33,299
就我们状态去图说

1587
01:06:33,366 --> 01:06:35,099
当前这个状态可以迁到哪个状态

1588
01:06:35,200 --> 01:06:36,566
allow status才会返回去

1589
01:06:36,566 --> 01:06:37,699
要不就是false

1590
01:06:37,866 --> 01:06:40,099
所以allow status所做的这个判断

1591
01:06:40,100 --> 01:06:41,100
大家可以看到

1592
01:06:41,600 --> 01:06:42,800
他其实就是去

1593
01:06:42,800 --> 01:06:45,200
在这个allows data的set中间

1594
01:06:45,200 --> 01:06:46,500
拿到对应状态

1595
01:06:46,500 --> 01:06:48,066
可以签到的状态级

1596
01:06:48,133 --> 01:06:49,599
然后如果这个是没有的

1597
01:06:49,600 --> 01:06:50,133
那就说明

1598
01:06:50,133 --> 01:06:51,566
这个状态就根本就是个死状态

1599
01:06:51,566 --> 01:06:52,366
签不出去的

1600
01:06:52,400 --> 01:06:53,200
如果他有的话

1601
01:06:53,200 --> 01:06:56,166
要看这个当前的就是要迁去的

1602
01:06:56,166 --> 01:06:58,766
这个目标的状态是不是在这个集合里

1603
01:06:58,766 --> 01:07:00,366
如果在的话才会返回去

1604
01:07:00,700 --> 01:07:01,933
这就是一个固定的写法

1605
01:07:02,400 --> 01:07:05,766
所有在我们的代码中间有状态的对象

1606
01:07:06,133 --> 01:07:07,066
状态的定义

1607
01:07:07,066 --> 01:07:08,166
状态的名称

1608
01:07:08,466 --> 01:07:09,899
状态的状态截图

1609
01:07:10,000 --> 01:07:12,300
还有这个方法是一模一样的

1610
01:07:12,733 --> 01:07:13,733
copy过去了

1611
01:07:14,166 --> 01:07:17,099
呃当然如果状态的对象很多的

1612
01:07:17,100 --> 01:07:17,900
话大家会觉得

1613
01:07:17,900 --> 01:07:19,800
特别是这些这个方法

1614
01:07:20,466 --> 01:07:23,666
觉得都重复的country c看球v挺辛苦的

1615
01:07:24,166 --> 01:07:26,066
但是我们所有的对象

1616
01:07:26,066 --> 01:07:28,199
很多对象是已经有继承了一个积累

1617
01:07:28,200 --> 01:07:30,400
已经继承了一个o o more up的积累

1618
01:07:30,566 --> 01:07:32,266
它没办法继承第二个积累

1619
01:07:32,800 --> 01:07:34,000
所以这个怎么办

1620
01:07:35,933 --> 01:07:38,333
我们也不能把它写到OMO的Optic里头

1621
01:07:38,333 --> 01:07:40,333
因为有状态的无状态对象

1622
01:07:40,333 --> 01:07:41,166
都继承那个积累

1623
01:07:41,166 --> 01:07:42,333
不是所有的

1624
01:07:42,533 --> 01:07:44,733
不是所有的对象都是有状态的

1625
01:07:44,733 --> 01:07:46,899
只有一少部分对象是有状态的

1626
01:07:47,100 --> 01:07:47,666
所以这部分

1627
01:07:47,666 --> 01:07:49,866
我们就是在每一个有状态代码中间

1628
01:07:49,866 --> 01:07:51,899
重新country c country v的一把

1629
01:07:52,366 --> 01:07:54,333
大家觉得也没办法把这个问题解决掉

1630
01:07:56,400 --> 01:07:58,200
因为面向对象只能单继承

1631
01:07:58,500 --> 01:08:01,400
但是我们确实又有一些东西是需要的

1632
01:08:01,800 --> 01:08:02,600
其实

1633
01:08:04,733 --> 01:08:05,533
加法可以单击时

1634
01:08:05,533 --> 01:08:06,266
代表别的办法

1635
01:08:06,266 --> 01:08:07,666
可以用instrumentation

1636
01:08:07,866 --> 01:08:09,166
大家知道instrumentation吗

1637
01:08:09,766 --> 01:08:11,966
啊那有兴趣大家可以去看一看

1638
01:08:11,966 --> 01:08:12,566
instrumentation

1639
01:08:12,566 --> 01:08:14,899
可以做到对于已有的一个对象

1640
01:08:14,900 --> 01:08:17,066
去装饰他的新的东西

1641
01:08:17,166 --> 01:08:19,099
那今年我们在后面吧

1642
01:08:19,100 --> 01:08:21,900
打算看大家有兴趣去搞搞这个把

1643
01:08:21,900 --> 01:08:22,300
这个东西

1644
01:08:22,300 --> 01:08:24,333
因为有一部分对象是有这个东西的

1645
01:08:24,333 --> 01:08:26,366
这种代码就这个allowstate

1646
01:08:26,366 --> 01:08:29,699
这个方法是目前是被country Ctrl v的啊

1647
01:08:29,766 --> 01:08:30,166
大家知道

1648
01:08:30,166 --> 01:08:33,699
country Ctrl v是写代码的大忌啊

1649
01:08:33,733 --> 01:08:34,266
通常来说

1650
01:08:34,266 --> 01:08:35,166
同样代码被看球

1651
01:08:35,166 --> 01:08:36,533
是一看就围到多个地方

1652
01:08:36,800 --> 01:08:37,966
万一要改的话

1653
01:08:38,166 --> 01:08:39,933
当然我们这个现在是没有改的需求了

1654
01:08:39,933 --> 01:08:40,699
万一要改的话

1655
01:08:40,700 --> 01:08:42,800
这个就累死了是吧

1656
01:08:42,800 --> 01:08:45,533
就会改改不全

1657
01:08:45,900 --> 01:08:49,166
这个也是可以去去去做的一个

1658
01:08:49,166 --> 01:08:50,999
所以我们里头是有些自由任务的

1659
01:08:51,000 --> 01:08:51,900
我把这些自由任

1660
01:08:51,900 --> 01:08:52,600
务提出来啊

1661
01:08:52,600 --> 01:08:55,366
看有同学们有兴趣去做这些自由任务

1662
01:08:56,700 --> 01:08:58,166
当然你们可以自己提出来这些自由

1663
01:08:58,166 --> 01:08:58,899
因为代码中间

1664
01:08:58,900 --> 01:09:00,133
肯定是有各种各样的问题

1665
01:09:00,133 --> 01:09:01,166
可以去提高的

1666
01:09:03,100 --> 01:09:05,000
所以有了这样的一个逻辑啊

1667
01:09:05,000 --> 01:09:07,066
所以我们看一下这个东西是怎么做的

1668
01:09:07,300 --> 01:09:08,300
我们现在这个做法

1669
01:09:08,300 --> 01:09:09,333
就在reading中间

1670
01:09:09,566 --> 01:09:11,399
我们写了对应的方法

1671
01:09:11,600 --> 01:09:14,100
因为这个职责是交给了reading是吧

1672
01:09:14,200 --> 01:09:14,900
所以reading呢

1673
01:09:14,900 --> 01:09:16,166
大家就有这个

1674
01:09:16,566 --> 01:09:21,199
大家可以看到有suspend的方法啊

1675
01:09:21,200 --> 01:09:23,200
word的方法reshoot

1676
01:09:23,200 --> 01:09:24,400
呃reshoot方法

1677
01:09:24,400 --> 01:09:25,366
abound的方法

1678
01:09:25,466 --> 01:09:26,799
但实际这些所有的方法

1679
01:09:26,800 --> 01:09:28,300
其实归根结底就是一件事情

1680
01:09:28,300 --> 01:09:29,166
要去改状态

1681
01:09:29,500 --> 01:09:30,200
当然这改状态

1682
01:09:30,200 --> 01:09:32,133
不是简单的去改动它的状态值啊

1683
01:09:32,133 --> 01:09:33,733
所以我们独立写了一个方法

1684
01:09:34,066 --> 01:09:35,666
这个方法叫做改状态

1685
01:09:35,766 --> 01:09:37,066
这是在reading中间的

1686
01:09:44,933 --> 01:09:46,299
这个图还画错了

1687
01:09:46,500 --> 01:09:47,600
那我们就直接看吧

1688
01:09:47,700 --> 01:09:48,800
这个图画的不对

1689
01:09:49,400 --> 01:09:50,700
这是改状态的这个

1690
01:09:50,933 --> 01:09:52,266
所以在改状态的过程中间

1691
01:09:52,266 --> 01:09:52,899
大家可以看到

1692
01:09:52,900 --> 01:09:55,466
首先用我们刚才写好的那个allow states

1693
01:09:55,466 --> 01:09:57,566
去判断当前这个状态是不是可以改

1694
01:09:57,800 --> 01:09:59,266
如果是suspend的话啊

1695
01:09:59,266 --> 01:09:59,733
Abound的话

1696
01:09:59,733 --> 01:10:01,899
就是要把这个状态改成Abound是吧

1697
01:10:02,066 --> 01:10:04,733
所以说他会去判断说他允不允许修改

1698
01:10:04,933 --> 01:10:06,699
如果允许修改的话

1699
01:10:06,766 --> 01:10:07,999
那他就会去修改

1700
01:10:08,000 --> 01:10:10,466
他如果不允许修改的话

1701
01:10:10,466 --> 01:10:11,366
他就不能修改

1702
01:10:11,600 --> 01:10:14,166
所以不仅仅是修改当前这个东西状态

1703
01:10:14,166 --> 01:10:14,966
他还要修改

1704
01:10:14,966 --> 01:10:17,399
他底下所有的指定区的状态

1705
01:10:17,700 --> 01:10:18,666
所以这里你可以看到

1706
01:10:18,666 --> 01:10:20,466
他调了一个方法去获得他的指定区

1707
01:10:20,466 --> 01:10:21,166
这是个常量

1708
01:10:21,166 --> 01:10:22,299
这个常量是1,000

1709
01:10:22,466 --> 01:10:24,699
因为通常来说我们认为这是他的

1710
01:10:24,700 --> 01:10:25,500
直接的

1711
01:10:26,166 --> 01:10:27,099
这是他的

1712
01:10:27,100 --> 01:10:29,933
这个直接的指定区啊

1713
01:10:32,066 --> 01:10:33,099
一是第一页

1714
01:10:33,900 --> 01:10:34,700
因为他有待分页

1715
01:10:34,700 --> 01:10:35,566
就所有的查询

1716
01:10:35,566 --> 01:10:36,799
因为这会返回很多

1717
01:10:37,133 --> 01:10:40,466
所以说我们都有做了这个分页的啊

1718
01:10:40,466 --> 01:10:41,266
都有做了分页的

1719
01:10:41,266 --> 01:10:42,666
就是即算是你要获得所有的

1720
01:10:42,666 --> 01:10:43,666
也是有个上限

1721
01:10:43,700 --> 01:10:44,933
现在上限就是1,000

1722
01:10:45,133 --> 01:10:46,399
要不然怕这笔头太多

1723
01:10:46,400 --> 01:10:47,666
一下子把数据货给

1724
01:10:47,733 --> 01:10:49,499
把整个服务器给搞崩了

1725
01:10:49,866 --> 01:10:51,066
所以获得他的子弟区

1726
01:10:51,066 --> 01:10:52,699
再把他的所有的子弟区

1727
01:10:53,400 --> 01:10:55,133
去修改它的状态

1728
01:10:55,566 --> 01:10:57,799
这个就是它的直接指地区啊

1729
01:10:57,800 --> 01:10:59,266
不是下面所有的指地区

1730
01:10:59,266 --> 01:11:01,133
就是如果说这个是福建省的话

1731
01:11:01,133 --> 01:11:03,533
这就是福建省的七个地市啊

1732
01:11:03,533 --> 01:11:05,733
所以这个MAX1000的话应该是够了

1733
01:11:05,733 --> 01:11:06,899
因为所有的直接指地区

1734
01:11:06,900 --> 01:11:08,466
应该不会超过1,000

1735
01:11:09,533 --> 01:11:11,799
就他直接在下一集就是福

1736
01:11:11,800 --> 01:11:12,466
如果福建省的话

1737
01:11:12,466 --> 01:11:13,899
就是福建省的八个地市

1738
01:11:15,600 --> 01:11:17,466
对这不定下帝国在哪做的呢

1739
01:11:17,533 --> 01:11:18,466
帝国在这做的

1740
01:11:19,466 --> 01:11:20,766
就是我拿到他的子弟区

1741
01:11:20,766 --> 01:11:21,699
这不叫地规啊

1742
01:11:21,700 --> 01:11:22,566
这个纠正下

1743
01:11:22,566 --> 01:11:23,399
这不叫地规

1744
01:11:23,600 --> 01:11:25,966
这个叫做我拿到他的这个子弟区以后

1745
01:11:25,966 --> 01:11:28,466
然后追着他子弟区里头的每一个对象

1746
01:11:29,166 --> 01:11:30,333
去干了嘛了

1747
01:11:30,333 --> 01:11:31,866
去把他再去调

1748
01:11:31,866 --> 01:11:33,299
他的前期对的是什么

1749
01:11:33,300 --> 01:11:34,100
就这个方法

1750
01:11:34,900 --> 01:11:36,266
学好自己加这个方法

1751
01:11:36,266 --> 01:11:36,933
这个不是地规

1752
01:11:36,933 --> 01:11:38,466
因为这是对象不同了

1753
01:11:38,766 --> 01:11:40,066
不是方法

1754
01:11:40,166 --> 01:11:41,099
同一个方法

1755
01:11:41,200 --> 01:11:42,933
我们的面相对象中间没有地规

1756
01:11:43,466 --> 01:11:44,499
这是不同的对象

1757
01:11:44,500 --> 01:11:45,666
调不同对象的间接时刻

1758
01:11:45,666 --> 01:11:47,266
是去改他的这个东西

1759
01:11:47,300 --> 01:11:47,733
大家知道

1760
01:11:47,733 --> 01:11:48,466
调那个对象的时候

1761
01:11:48,466 --> 01:11:50,566
同样这个过程又回来要去查他指定区

1762
01:11:50,566 --> 01:11:52,933
再去调他的东西

1763
01:11:52,933 --> 01:11:54,199
再去完成啊

1764
01:11:54,200 --> 01:11:55,333
再去完成这个过程

1765
01:11:55,500 --> 01:11:58,066
这里头用到了流边程的一些东西

1766
01:11:58,066 --> 01:11:59,733
就是焦瓦巴里头的流边程

1767
01:11:59,733 --> 01:12:01,533
你们在焦瓦课里头

1768
01:12:01,533 --> 01:12:02,599
学过这个东西对吧

1769
01:12:04,600 --> 01:12:05,200
计划不是不修

1770
01:12:05,200 --> 01:12:06,766
那你必须要要干

1771
01:12:06,766 --> 01:12:07,166
我这个课

1772
01:12:07,166 --> 01:12:08,133
必须要把计划修完啊

1773
01:12:08,133 --> 01:12:09,899
不修完你怎么干干这个

1774
01:12:13,100 --> 01:12:14,100
呃我问过美化老师

1775
01:12:14,100 --> 01:12:15,133
说他教过这个

1776
01:12:16,166 --> 01:12:17,666
对这个是干嘛的

1777
01:12:19,333 --> 01:12:20,133
这个不知道

1778
01:12:20,566 --> 01:12:21,866
所以我们这里头

1779
01:12:21,866 --> 01:12:22,366
你可以看到

1780
01:12:22,366 --> 01:12:25,133
大量代码使用了牛编程的方式

1781
01:12:25,300 --> 01:12:28,133
这就是我们在这个里头

1782
01:12:28,133 --> 01:12:31,399
其实有融合了三种写程序的方式

1783
01:12:31,400 --> 01:12:32,266
面向功能的

1784
01:12:32,266 --> 01:12:33,333
面向对象的

1785
01:12:33,666 --> 01:12:34,866
面向AOP的

1786
01:12:34,966 --> 01:12:36,599
还有面向函数的

1787
01:12:36,600 --> 01:12:38,166
有边程序都是面向函数的

1788
01:12:38,300 --> 01:12:39,466
真正在写代码的时候

1789
01:12:39,466 --> 01:12:41,399
其实不是单纯的在使用面向功能

1790
01:12:41,400 --> 01:12:42,200
面向对象

1791
01:12:42,333 --> 01:12:43,299
或者面向AOP

1792
01:12:43,300 --> 01:12:44,133
或者是面向函数

1793
01:12:44,133 --> 01:12:46,766
而是所有的东西都得要用

1794
01:12:47,300 --> 01:12:49,400
因为你要解决的是问题

1795
01:12:49,533 --> 01:12:51,166
你现在手上有这么多武器

1796
01:12:51,366 --> 01:12:53,599
你当然要把你的武器用到极致

1797
01:12:53,733 --> 01:12:55,133
用最少的代价

1798
01:12:55,133 --> 01:12:57,466
最优雅的方式把这个问题给解决了

1799
01:12:57,733 --> 01:12:57,966
对吧

1800
01:12:57,966 --> 01:13:00,799
你不能说你不会这个留编程的方式

1801
01:13:00,800 --> 01:13:02,766
你就完全就逃避他啊

1802
01:13:02,766 --> 01:13:03,999
所以大家可以看到

1803
01:13:04,100 --> 01:13:05,500
我们其实近三年来

1804
01:13:05,500 --> 01:13:06,800
已经把里头代码中间

1805
01:13:06,800 --> 01:13:08,800
但凡能用函数编程的

1806
01:13:09,300 --> 01:13:11,300
全部改成了函数式编程

1807
01:13:11,466 --> 01:13:13,166
那当然这里有个极端的案例

1808
01:13:13,166 --> 01:13:14,799
就是我们现在还是基于Stack的

1809
01:13:14,800 --> 01:13:17,000
那个several Stack的架构来写的

1810
01:13:17,133 --> 01:13:18,999
severed是severed Stack的架构

1811
01:13:19,000 --> 01:13:20,200
还是命令式编程

1812
01:13:20,200 --> 01:13:22,566
就是我们这种一行行写的

1813
01:13:22,566 --> 01:13:24,766
但是如果改成反应式机制的话

1814
01:13:24,766 --> 01:13:26,899
它就是全部翻天覆地的

1815
01:13:26,900 --> 01:13:28,100
都是函数式编程

1816
01:13:28,300 --> 01:13:29,266
从头到尾

1817
01:13:29,266 --> 01:13:31,366
从入口就是流

1818
01:13:31,466 --> 01:13:32,466
出口也是流

1819
01:13:32,466 --> 01:13:34,066
所以里头每一行代码

1820
01:13:34,700 --> 01:13:36,133
都是留编程的啊

1821
01:13:36,133 --> 01:13:36,766
都是留编程的

1822
01:13:36,766 --> 01:13:39,066
因为我们今天打算是在娇娃一那边

1823
01:13:39,066 --> 01:13:40,133
去讲这个部分

1824
01:13:40,466 --> 01:13:41,799
其实我们已经准备了好多年了

1825
01:13:41,800 --> 01:13:42,766
都没讲到这个部分

1826
01:13:42,766 --> 01:13:44,333
但是我们把代码已经慢慢的

1827
01:13:44,666 --> 01:13:45,933
尽量能做流编程的

1828
01:13:45,933 --> 01:13:48,266
全部改成留编程的这个方式

1829
01:13:48,933 --> 01:13:49,899
这个有好处

1830
01:13:50,166 --> 01:13:53,533
好处在于说他其实代码写的更少

1831
01:13:53,966 --> 01:13:54,966
写出来更优雅

1832
01:13:54,966 --> 01:13:56,666
就是他这边人处理这种东西的话

1833
01:13:56,666 --> 01:13:57,599
写出来更优雅

1834
01:13:58,066 --> 01:13:59,199
坏处是什么呢

1835
01:13:59,533 --> 01:14:00,699
你们知道坏处是什么

1836
01:14:01,666 --> 01:14:02,866
话术不是看不懂

1837
01:14:03,566 --> 01:14:04,533
不好调试

1838
01:14:04,933 --> 01:14:06,566
写错了就不知道错在哪

1839
01:14:07,000 --> 01:14:10,066
所以要写这个玩意你就最好心里有数

1840
01:14:10,066 --> 01:14:11,199
写好就不要错

1841
01:14:11,800 --> 01:14:12,300
错了以后

1842
01:14:12,300 --> 01:14:15,800
真的是不知道在什么地方会会出问题

1843
01:14:16,100 --> 01:14:16,500
所以他

1844
01:14:16,500 --> 01:14:18,966
特别是你如果没有自己写日志的话

1845
01:14:18,966 --> 01:14:20,533
他如果他自己抛一个产品的话

1846
01:14:20,533 --> 01:14:21,933
你完全不知道他在哪个地方抛出的

1847
01:14:21,933 --> 01:14:22,733
一个产品

1848
01:14:22,966 --> 01:14:24,599
这么长一滴6

1849
01:14:24,766 --> 01:14:26,566
中间每个地方都会出一个商品

1850
01:14:26,700 --> 01:14:28,100
他不知道是在具体什么地方

1851
01:14:28,100 --> 01:14:29,533
所以只能一点点的去

1852
01:14:29,700 --> 01:14:31,066
一点点的去找

1853
01:14:31,166 --> 01:14:33,266
靠手工一点点去找啊

1854
01:14:33,266 --> 01:14:35,366
当然如果写熟的话啊

1855
01:14:35,366 --> 01:14:37,299
其实他出错的概率是挺小的

1856
01:14:37,800 --> 01:14:39,400
就是如果你熟悉他的话

1857
01:14:39,500 --> 01:14:41,000
他出错的概率会更少

1858
01:14:41,100 --> 01:14:42,966
代码写起来是更加优雅一些

1859
01:14:46,200 --> 01:14:48,800
这个学期看我们县城的代码

1860
01:14:48,800 --> 01:14:49,933
应该大家会慢慢熟悉

1861
01:14:49,933 --> 01:14:50,566
因为我们县城代码

1862
01:14:50,566 --> 01:14:52,533
中间但凡就没有分循环

1863
01:14:53,333 --> 01:14:55,499
基本上是没有分循环的

1864
01:14:55,666 --> 01:14:56,866
只要是处理集合对象

1865
01:14:56,866 --> 01:14:58,666
就不会用分循环和外循环去做

1866
01:14:58,666 --> 01:15:00,333
一定是用流去处理的

1867
01:15:01,666 --> 01:15:04,999
这就是我们的这个啊引巴里头巴

1868
01:15:05,366 --> 01:15:06,199
血管斑等

1869
01:15:06,333 --> 01:15:07,366
所以在这个过程中间

1870
01:15:07,366 --> 01:15:08,466
大家可以看到

1871
01:15:09,533 --> 01:15:12,566
我们计算在内部的代码里头

1872
01:15:12,566 --> 01:15:13,733
是一个方法

1873
01:15:13,866 --> 01:15:15,099
就是我们在这里头写的

1874
01:15:15,100 --> 01:15:16,600
是一个change status的方法

1875
01:15:16,800 --> 01:15:19,333
但是我们在面向对象的角度给暴

1876
01:15:19,333 --> 01:15:21,299
露出来的还是什么呢

1877
01:15:21,533 --> 01:15:23,066
还是三个不同的方法

1878
01:15:24,266 --> 01:15:25,266
为什么想这么做

1879
01:15:25,266 --> 01:15:27,966
就是我们称之为这是领域模型

1880
01:15:28,333 --> 01:15:30,566
当使用这个对象的时候

1881
01:15:30,566 --> 01:15:33,499
并不是说我们自己写这个三个方法

1882
01:15:33,500 --> 01:15:35,166
大家会觉得写这个三个方法很可笑

1883
01:15:35,166 --> 01:15:37,766
是吧你为什么不直接把这个change sense

1884
01:15:37,766 --> 01:15:38,099
暴露出来

1885
01:15:38,100 --> 01:15:39,400
让他们直接这么掉呢

1886
01:15:40,166 --> 01:15:42,866
对吧而要用这三个方法来来包一下

1887
01:15:43,666 --> 01:15:44,999
而且这方法其实也没干啥

1888
01:15:45,000 --> 01:15:46,700
其实就进来就是去钓他

1889
01:15:46,900 --> 01:15:47,666
这个主要的目的

1890
01:15:47,666 --> 01:15:50,699
就是让使用这个reading对象的人

1891
01:15:50,700 --> 01:15:52,300
会觉得更加的轻松

1892
01:15:52,400 --> 01:15:54,366
他知道说red像是可以挂气

1893
01:15:54,366 --> 01:15:55,133
可以废气

1894
01:15:55,133 --> 01:15:56,466
可以恢复的

1895
01:15:56,566 --> 01:15:57,699
但他其实并不需要知道

1896
01:15:57,700 --> 01:15:59,500
他里头是怎么去做的

1897
01:15:59,666 --> 01:16:01,333
所以我们并没有把里头的

1898
01:16:01,333 --> 01:16:02,499
修改状态的这个方法

1899
01:16:02,500 --> 01:16:03,100
把他抱出去

1900
01:16:03,100 --> 01:16:04,533
而且呢是个private的

1901
01:16:05,700 --> 01:16:06,300
看到没有

1902
01:16:06,300 --> 01:16:07,366
这个是个private的

1903
01:16:07,366 --> 01:16:08,399
这个方法啊

1904
01:16:08,500 --> 01:16:12,133
这个就是我们这个部分的这个设计

1905
01:16:12,133 --> 01:16:12,999
这张图画错了

1906
01:16:13,000 --> 01:16:14,300
我之后再把它改过来

1907
01:16:15,666 --> 01:16:18,099
那这是整体的这个类图

1908
01:16:18,100 --> 01:16:20,100
这个类图里头既包含了兵对象

1909
01:16:20,100 --> 01:16:23,333
也包含了我们的领域模型对象啊

1910
01:16:23,333 --> 01:16:24,766
总体上来说

1911
01:16:24,766 --> 01:16:25,533
大家可以看到

1912
01:16:25,533 --> 01:16:26,599
在这个设计中间

1913
01:16:26,733 --> 01:16:29,299
我们已经尽量的把一些方法

1914
01:16:29,366 --> 01:16:31,866
充实到我们的Bo对象中间

1915
01:16:32,666 --> 01:16:34,266
我们这里不是get c的方法

1916
01:16:34,266 --> 01:16:36,133
这就是我们现在做完了以后

1917
01:16:36,166 --> 01:16:37,666
所有c进去的方法

1918
01:16:37,800 --> 01:16:40,600
但是在稻城还有一些方法

1919
01:16:40,600 --> 01:16:41,966
这些方法就是正常改查

1920
01:16:42,366 --> 01:16:43,399
在收费层的方法

1921
01:16:43,400 --> 01:16:44,866
跟上面的方法一一对应

1922
01:16:45,300 --> 01:16:45,966
然后收费层

1923
01:16:45,966 --> 01:16:47,299
虽然大家看起来有这么多方法

1924
01:16:47,300 --> 01:16:48,600
因为跟上面是一一对应的嘛

1925
01:16:48,733 --> 01:16:50,466
每个方法中间的代码非常少

1926
01:16:51,066 --> 01:16:51,266
就是

1927
01:16:51,266 --> 01:16:53,533
很多代码中间就只有一行两行啊

1928
01:16:53,533 --> 01:16:55,933
所以主要的内容在这

1929
01:16:56,466 --> 01:16:58,099
跟纯数据库

1930
01:16:58,100 --> 01:16:59,933
读写数据库有关的内容在这

1931
01:17:00,266 --> 01:17:01,499
就是代码就变成了这个

1932
01:17:01,500 --> 01:17:03,666
这个这个是面向功能的

1933
01:17:03,666 --> 01:17:05,733
但是这个是面向对象的

1934
01:17:05,733 --> 01:17:07,566
这就是我们在面向对象的

1935
01:17:07,566 --> 01:17:08,733
这个设计的方式的

1936
01:17:08,733 --> 01:17:11,066
这个努力的方向啊

1937
01:17:11,066 --> 01:17:12,133
就是这样一个方向

1938
01:17:12,533 --> 01:17:14,199
这个代码写完了以后啊

1939
01:17:14,200 --> 01:17:15,166
作为程序员来说

1940
01:17:15,166 --> 01:17:17,566
你要把你写好的代码都要是正确的

1941
01:17:17,700 --> 01:17:18,166
是吧

1942
01:17:18,166 --> 01:17:21,333
你怎么保证你写好代码是正确的啊

1943
01:17:21,333 --> 01:17:23,366
你们怎么保证写好的码是正确的

1944
01:17:24,100 --> 01:17:25,100
嘴巴说没用

1945
01:17:25,266 --> 01:17:26,699
要拉出实证来

1946
01:17:28,333 --> 01:17:30,933
这个代码我们在教育已经讲过

1947
01:17:30,933 --> 01:17:32,466
是需要写测试的

1948
01:17:32,800 --> 01:17:36,100
所以所有的测试都有在这里都写了

1949
01:17:38,133 --> 01:17:39,899
那怎么写的话我就不讲了

1950
01:17:39,900 --> 01:17:40,800
但你怎么知道

1951
01:17:40,800 --> 01:17:43,766
你这个测试写的是满足我的要求的

1952
01:17:43,966 --> 01:17:45,333
这就要看另外个东西

1953
01:17:45,566 --> 01:17:47,566
就这个东西加Coco

1954
01:17:48,600 --> 01:17:50,266
就是跑完测试以后

1955
01:17:50,266 --> 01:17:51,799
我们里头是有一个插件

1956
01:17:51,800 --> 01:17:54,000
会生成一个htm的报表

1957
01:17:54,133 --> 01:17:54,899
这个htm的报表

1958
01:17:54,900 --> 01:17:56,966
可以非常直观的告诉你一件事情

1959
01:17:56,966 --> 01:17:59,866
你到底哪些代码被覆盖了

1960
01:17:59,900 --> 01:18:00,500
我们知道

1961
01:18:00,500 --> 01:18:02,000
在测试中间其实有两个概念啊

1962
01:18:02,000 --> 01:18:03,066
因为大家软光还没讲到

1963
01:18:03,066 --> 01:18:06,699
这个部分叫做白核测试和黑核测试

1964
01:18:11,000 --> 01:18:11,966
他讲了是吧

1965
01:18:12,800 --> 01:18:13,600
啊

1966
01:18:23,600 --> 01:18:26,366
白盒测试是我们程序员要做的事情

1967
01:18:26,366 --> 01:18:28,199
黑盒测试是测试部做的事情

1968
01:18:28,466 --> 01:18:29,699
白盒测试做的是什么

1969
01:18:29,700 --> 01:18:31,066
就是代码的覆盖率

1970
01:18:31,600 --> 01:18:33,000
就是我要写的测试

1971
01:18:33,000 --> 01:18:33,366
用力

1972
01:18:33,366 --> 01:18:36,066
都要把我的每一行代码都有测到了

1973
01:18:36,500 --> 01:18:37,300
测到以后

1974
01:18:37,300 --> 01:18:38,700
然后你这个代码的输出

1975
01:18:38,700 --> 01:18:40,900
和我预想的值是一致的

1976
01:18:40,966 --> 01:18:42,366
那能保证一点什么呢

1977
01:18:42,933 --> 01:18:45,499
能保证我写的代码都是正确的

1978
01:18:45,766 --> 01:18:46,799
对吧但能

1979
01:18:46,800 --> 01:18:48,500
保证这个程序是正确的吗

1980
01:18:49,166 --> 01:18:50,899
对为什么不能保证程序是正确的

1981
01:18:52,266 --> 01:18:53,166
比如说你刚才说的那个问题

1982
01:18:53,166 --> 01:18:53,399
就是

1983
01:18:53,400 --> 01:18:55,333
我现在车子已经覆盖到了从未代码

1984
01:18:55,500 --> 01:18:56,500
但是我就没有做

1985
01:18:56,500 --> 01:18:59,766
说当我要恢复一个地区的时候

1986
01:19:00,866 --> 01:19:02,599
就说当我要恢复个地区的时候

1987
01:19:02,600 --> 01:19:03,800
他上级地区被停用了

1988
01:19:03,800 --> 01:19:04,800
他是不能恢复的

1989
01:19:05,100 --> 01:19:06,333
这行代码我没有写

1990
01:19:07,133 --> 01:19:08,999
我没有写就不可能被撤到

1991
01:19:09,366 --> 01:19:10,099
所以他就不

1992
01:19:10,100 --> 01:19:11,266
他就是不对的

1993
01:19:11,333 --> 01:19:13,733
对吧当我试图去恢复一个

1994
01:19:14,200 --> 01:19:15,700
恢复一个已有的地区的时候

1995
01:19:15,700 --> 01:19:16,733
虽然他上几句停用了

1996
01:19:16,733 --> 01:19:17,766
他也会被恢复起来

1997
01:19:17,766 --> 01:19:18,899
现在代码就这个样子

1998
01:19:18,900 --> 01:19:20,000
他就会被恢复起来

1999
01:19:20,133 --> 01:19:22,133
这就是你作为程序员来说

2000
01:19:22,133 --> 01:19:23,933
你所有写出去的代码

2001
01:19:24,466 --> 01:19:26,699
你要保证你写出去的代码是正确的

2002
01:19:27,066 --> 01:19:30,066
我们需要用这个就就是我们测试代码

2003
01:19:30,066 --> 01:19:31,133
测试完了以后

2004
01:19:31,300 --> 01:19:33,800
所有的输出和预期的输出是一致的

2005
01:19:34,166 --> 01:19:36,966
所有的代码行都有覆盖到了

2006
01:19:37,133 --> 01:19:38,766
那程序员的本分就做完了

2007
01:19:38,766 --> 01:19:40,066
比如说刚才他提的那个问题

2008
01:19:40,066 --> 01:19:41,199
那就不是我的问题

2009
01:19:41,466 --> 01:19:44,199
那就是因为我对于需求的理解有偏差

2010
01:19:46,066 --> 01:19:47,499
不是也不是设计的问题

2011
01:19:47,500 --> 01:19:48,533
这都不是谁的问题

2012
01:19:48,533 --> 01:19:50,666
就是因为你肯定知道你在做的时候

2013
01:19:50,666 --> 01:19:53,799
你跟你的需求是有不全面或者片面

2014
01:19:53,800 --> 01:19:56,066
漏掉的地方或者理解错误的地方

2015
01:19:56,166 --> 01:19:57,899
都会造成你最后的程序出错

2016
01:19:57,966 --> 01:19:59,266
但这个事情你在程序员这里

2017
01:19:59,266 --> 01:20:00,366
你就已经找不出来了

2018
01:20:00,366 --> 01:20:01,733
因为我的理解

2019
01:20:02,266 --> 01:20:03,099
我的理解

2020
01:20:03,100 --> 01:20:04,400
我已经全部写成代码了

2021
01:20:04,400 --> 01:20:06,266
然后我的每一行代码都按照我的理解

2022
01:20:06,266 --> 01:20:07,199
已经测试正确了

2023
01:20:07,200 --> 01:20:08,133
都覆盖到了

2024
01:20:08,500 --> 01:20:10,400
这个事情是由测试部的人去做的

2025
01:20:10,400 --> 01:20:11,500
他靠的是什么呢

2026
01:20:11,866 --> 01:20:12,766
配合测试

2027
01:20:13,266 --> 01:20:15,366
所以对于我们的同学来说

2028
01:20:15,366 --> 01:20:16,766
如果你想做程序员的话

2029
01:20:16,766 --> 01:20:18,733
白盒测试是一定要会的

2030
01:20:18,733 --> 01:20:20,099
这是你自己的事情

2031
01:20:20,366 --> 01:20:21,133
黑盒测试嘛

2032
01:20:21,133 --> 01:20:22,166
如果你不想做测试

2033
01:20:22,166 --> 01:20:23,666
就做测试的人员的话

2034
01:20:23,666 --> 01:20:25,266
你其实是不用管黑盒测试的

2035
01:20:25,300 --> 01:20:28,000
我们在软宫里头所讲的

2036
01:20:28,000 --> 01:20:29,566
所有的测试方法

2037
01:20:29,566 --> 01:20:30,899
都是黑盒测试

2038
01:20:31,466 --> 01:20:32,899
就他会讲等价类

2039
01:20:32,900 --> 01:20:33,900
等价类的划分

2040
01:20:33,900 --> 01:20:35,666
那些东西其实都是黑盒测试

2041
01:20:35,900 --> 01:20:37,200
白盒测试其实很简单

2042
01:20:37,200 --> 01:20:38,500
就是依赖于工具

2043
01:20:38,800 --> 01:20:39,500
依赖于工具

2044
01:20:39,500 --> 01:20:41,166
你看你代码盖到没有

2045
01:20:41,333 --> 01:20:42,366
没盖到再写个

2046
01:20:42,366 --> 01:20:45,466
用力去把它盖到就完了啊

2047
01:20:45,466 --> 01:20:47,066
所以你的目标是把代码都盖到

2048
01:20:47,066 --> 01:20:47,999
但是这是不可能的

2049
01:20:48,000 --> 01:20:48,566
大家可以看到

2050
01:20:48,566 --> 01:20:49,966
为什么我不能都盖到

2051
01:20:51,800 --> 01:20:53,400
比如说Bo的这个里头

2052
01:20:53,400 --> 01:20:54,466
为什么没盖到

2053
01:20:56,400 --> 01:20:57,100
不是条件

2054
01:20:57,100 --> 01:21:00,333
我这里写了一个带全参的构造函数

2055
01:21:00,900 --> 01:21:02,733
但其实带全参的构造函数

2056
01:21:02,733 --> 01:21:05,466
在整个代码中间从来没有用到过

2057
01:21:06,766 --> 01:21:08,499
所以当我看到这个覆盖率的时候

2058
01:21:08,500 --> 01:21:09,333
我就会做一个决定

2059
01:21:09,333 --> 01:21:10,466
我这决定是什么呢

2060
01:21:11,466 --> 01:21:12,499
我把这个删了

2061
01:21:13,533 --> 01:21:14,566
对从来没用到过嘛

2062
01:21:14,566 --> 01:21:15,799
他也没从来没测到过

2063
01:21:15,800 --> 01:21:17,300
那我不把他删了不就完了嘛

2064
01:21:17,500 --> 01:21:18,600
所以我就把他删了啊

2065
01:21:18,600 --> 01:21:20,400
这这个这个是一个啊

2066
01:21:22,600 --> 01:21:24,466
对他这不会就不会有被分

2067
01:21:24,466 --> 01:21:25,466
我说没我没有了

2068
01:21:25,466 --> 01:21:26,699
当然就覆盖就提高了

2069
01:21:27,733 --> 01:21:29,166
对吧然后我们再看一下

2070
01:21:32,200 --> 01:21:35,133
对但是这个会在测试部那边会找到

2071
01:21:38,700 --> 01:21:39,500
这个覆盖地

2072
01:21:42,166 --> 01:21:44,766
比如说比如说这个

2073
01:21:47,100 --> 01:21:47,966
比如说这些

2074
01:21:48,000 --> 01:21:48,866
这些东西啊

2075
01:21:48,866 --> 01:21:49,199
这些东西

2076
01:21:49,200 --> 01:21:50,666
就是因为它在分支里头

2077
01:21:50,666 --> 01:21:52,966
没有触发到这些条件

2078
01:21:53,200 --> 01:21:55,600
所以说它的分支就没有测到

2079
01:21:55,766 --> 01:21:58,666
这个就需要去完善测试数据

2080
01:21:58,866 --> 01:21:59,866
这个不是代码的问题

2081
01:21:59,866 --> 01:22:01,733
因为我测数据它没有这种不合法的数

2082
01:22:01,733 --> 01:22:04,133
据所以这部分代码就没有去掉

2083
01:22:04,133 --> 01:22:04,733
没有测到

2084
01:22:04,733 --> 01:22:06,966
那就需要去完善测试数据

2085
01:22:06,966 --> 01:22:08,133
然后完善你的测试

2086
01:22:08,133 --> 01:22:09,866
用力才能测到

2087
01:22:12,100 --> 01:22:14,400
然后我们再看一下region中间的

2088
01:22:17,800 --> 01:22:19,666
好我们find的里头词比较多

2089
01:22:19,933 --> 01:22:21,466
在稻城里头比较多

2090
01:22:25,333 --> 01:22:26,866
啊滤镜到里头的

2091
01:22:27,800 --> 01:22:29,066
比如save的方法

2092
01:22:29,466 --> 01:22:30,499
比如说你看这个

2093
01:22:30,566 --> 01:22:32,166
这个红色部分就是没有测到

2094
01:22:33,066 --> 01:22:35,099
没有测到的原因是因为这个异常

2095
01:22:35,100 --> 01:22:37,666
没有没有没有产生

2096
01:22:37,966 --> 01:22:39,199
所以这就需要完善测试

2097
01:22:39,200 --> 01:22:42,466
用力去把这些异常给他抛出来

2098
01:22:42,800 --> 01:22:43,966
才会知道

2099
01:22:44,366 --> 01:22:45,766
所以作为程序员来说

2100
01:22:45,766 --> 01:22:47,099
你其实要依赖于这个东西

2101
01:22:47,100 --> 01:22:49,400
去看说你还需要写什么样的测试

2102
01:22:49,400 --> 01:22:50,400
用力去

2103
01:22:50,400 --> 01:22:54,700
尽量把所有的你写出来的代码都测到

2104
01:22:54,700 --> 01:22:56,366
和你的预期是一致的

2105
01:22:56,466 --> 01:22:57,699
程序员的事情就完成了

2106
01:22:57,700 --> 01:22:59,100
后面交给测试部门

2107
01:22:59,366 --> 01:23:02,166
去做相应的这个测试啊

2108
01:23:03,000 --> 01:23:05,066
所以这是必须要学会做的事情

2109
01:23:05,066 --> 01:23:06,733
就是大家应该知道

2110
01:23:06,733 --> 01:23:08,666
你们如果想以写代码为生的话

2111
01:23:08,666 --> 01:23:10,399
你不会干这个事情

2112
01:23:10,400 --> 01:23:11,600
你写的代码就是垃圾

2113
01:23:11,800 --> 01:23:13,533
谁也不能保证那代码是正确的

2114
01:23:13,966 --> 01:23:14,899
对吧所以

2115
01:23:14,900 --> 01:23:15,900
你至少自己保证

2116
01:23:15,900 --> 01:23:18,000
自己写的代码是跟你的想法是一致的

2117
01:23:18,000 --> 01:23:18,866
我们说正确的啊

2118
01:23:18,866 --> 01:23:21,366
自己写的代码跟自己的想法是一致的

2119
01:23:21,366 --> 01:23:22,699
然后再由别人去教练

2120
01:23:22,700 --> 01:23:24,366
说你的这个东西是不是正确的

2121
01:23:25,166 --> 01:23:25,999
这是可能

2122
01:23:26,000 --> 01:23:30,600
这是大家从刚刚学会写代码到学会说

2123
01:23:30,600 --> 01:23:33,900
用写代码去维生这个过程的变化

2124
01:23:33,900 --> 01:23:36,066
一定要跨过这一步啊啊

2125
01:23:36,066 --> 01:23:37,266
不能说就满足于说

2126
01:23:37,266 --> 01:23:38,666
把东西写出来就完事

2127
01:23:40,333 --> 01:23:44,166
这是我们的这个地区模块啊

2128
01:23:44,266 --> 01:23:47,333
那我们还得花些时间来讲一下

2129
01:23:47,533 --> 01:23:48,466
支付模块

2130
01:23:49,133 --> 01:23:51,899
呃我们看一下这个

2131
01:23:52,900 --> 01:23:54,066
看一下这个

2132
01:23:57,133 --> 01:23:57,933
模块图

2133
01:24:05,800 --> 01:24:06,533
从这个模块图上

2134
01:24:06,533 --> 01:24:08,166
大家应该能够看到一个特点

2135
01:24:08,266 --> 01:24:09,599
地区模块是最简单的

2136
01:24:09,600 --> 01:24:10,600
不但最简单

2137
01:24:10,600 --> 01:24:12,566
而且吊在最尾巴上的

2138
01:24:12,966 --> 01:24:14,866
就是他不调用任何其他的模块

2139
01:24:14,866 --> 01:24:16,866
他被所有的其他模块去调用

2140
01:24:17,466 --> 01:24:18,399
对他只被调用

2141
01:24:18,400 --> 01:24:20,466
所以他是一个相对比较简单的模块啊

2142
01:24:20,466 --> 01:24:22,133
这个模块我完全做完了

2143
01:24:22,266 --> 01:24:24,066
然后测试也基本上写完了

2144
01:24:24,066 --> 01:24:24,799
当然里头有bug

2145
01:24:24,800 --> 01:24:26,500
刚才大家上课就应该发现

2146
01:24:26,700 --> 01:24:27,666
所以bug嘛

2147
01:24:27,666 --> 01:24:28,599
留给同学们去改

2148
01:24:28,600 --> 01:24:30,200
我不改这个东西了啊

2149
01:24:30,533 --> 01:24:33,533
所以我们的后三轮的必做任务

2150
01:24:33,533 --> 01:24:34,499
就是后面的必做任务

2151
01:24:34,500 --> 01:24:36,333
里面其实有一个自由轮的必做任务

2152
01:24:36,500 --> 01:24:38,666
那个自由任务中主要是两类

2153
01:24:38,666 --> 01:24:40,199
一类就是同学们自己提出来

2154
01:24:40,200 --> 01:24:41,733
说我想做一个什么样的功能

2155
01:24:41,966 --> 01:24:43,699
比如说我们这里看到的copy from

2156
01:24:43,700 --> 01:24:45,266
就是提出来

2157
01:24:45,266 --> 01:24:47,133
同学们自己提出来想做的

2158
01:24:47,266 --> 01:24:48,733
比如说我们的GPA的改动

2159
01:24:48,733 --> 01:24:50,133
这都同学们自己提出来的

2160
01:24:50,300 --> 01:24:51,000
还有一类呢

2161
01:24:51,000 --> 01:24:53,700
就是我们会把你改的bug累加起来

2162
01:24:53,700 --> 01:24:55,200
变成一个自由轮的任务

2163
01:24:55,666 --> 01:24:57,366
我还没想好改多少个

2164
01:24:57,366 --> 01:24:58,966
改10个还是改20个

2165
01:24:59,966 --> 01:25:02,499
你如果改到10个或者改到多少个

2166
01:25:02,500 --> 01:25:03,966
我就给你算一个

2167
01:25:03,966 --> 01:25:06,399
这样的一个一个自由人的任务啊

2168
01:25:06,400 --> 01:25:07,733
这个错误就不论大小

2169
01:25:07,733 --> 01:25:08,466
有大有小

2170
01:25:08,466 --> 01:25:10,133
这就不好不好说了啊

2171
01:25:10,133 --> 01:25:11,899
所以说啊

2172
01:25:12,400 --> 01:25:14,766
我们的这个呃

2173
01:25:15,533 --> 01:25:17,499
reading部分就是这个样子

2174
01:25:17,500 --> 01:25:19,266
所以我不会再去改这个代码了

2175
01:25:19,266 --> 01:25:20,666
大家如果觉得他有问题

2176
01:25:20,766 --> 01:25:21,733
比如说你觉得有问题

2177
01:25:21,733 --> 01:25:22,899
你就去改那个代码

2178
01:25:22,966 --> 01:25:25,066
然后提一个一求出来

2179
01:25:25,066 --> 01:25:26,399
然后提一个墨迹合并出来

2180
01:25:26,400 --> 01:25:27,800
然后我觉得对

2181
01:25:28,166 --> 01:25:29,566
然后就把它改进去啊

2182
01:25:29,566 --> 01:25:31,566
对应的测试也要去写这个

2183
01:25:31,566 --> 01:25:33,999
是这个呃

2184
01:25:34,000 --> 01:25:34,600
这个模块

2185
01:25:34,600 --> 01:25:36,600
所以这个模块是我把它写完了

2186
01:25:36,600 --> 01:25:37,266
测试完了

2187
01:25:37,266 --> 01:25:39,199
然后有问题大家自己去发现

2188
01:25:39,200 --> 01:25:40,000
自己去改

2189
01:25:40,500 --> 01:25:41,966
剩下的几个模块呢

2190
01:25:41,966 --> 01:25:43,299
这个模块和这个模块

2191
01:25:43,300 --> 01:25:46,000
我打算我把所有现有代码全部整理完

2192
01:25:46,700 --> 01:25:48,766
做到编译可以通过

2193
01:25:48,900 --> 01:25:50,533
但是我不写任何测试

2194
01:25:51,166 --> 01:25:52,799
由把它分成必做任务

2195
01:25:52,800 --> 01:25:54,200
分给同学们去写

2196
01:25:54,200 --> 01:25:56,566
测试和调试里头把它调通

2197
01:25:56,733 --> 01:25:57,866
所以这两个模块

2198
01:25:57,866 --> 01:26:00,399
会完整的把设计和代码全部实现出来

2199
01:26:01,166 --> 01:26:02,699
但是做到可以编译

2200
01:26:02,800 --> 01:26:03,533
编译通过啊

2201
01:26:03,533 --> 01:26:04,666
我的事情就完成了

2202
01:26:04,666 --> 01:26:06,099
剩下事情交给同学去做

2203
01:26:06,500 --> 01:26:07,533
这两个模块呢

2204
01:26:07,533 --> 01:26:08,699
打算今年重写

2205
01:26:09,533 --> 01:26:10,766
所以从0开始写

2206
01:26:11,000 --> 01:26:12,600
所以这是我们5个闭轴模块

2207
01:26:12,600 --> 01:26:13,900
采用三种方式来完成

2208
01:26:13,900 --> 01:26:14,866
一个完整写完

2209
01:26:14,866 --> 01:26:15,999
一个我写一半

2210
01:26:16,533 --> 01:26:18,766
一个是交给同学们去

2211
01:26:18,766 --> 01:26:19,966
自己去写啊

2212
01:26:19,966 --> 01:26:21,899
自己去写这样的一种方式

2213
01:26:21,900 --> 01:26:23,166
为什么要用这种方式来写

2214
01:26:23,166 --> 01:26:24,666
大家应该有意识到说

2215
01:26:24,866 --> 01:26:27,899
其实学会写代码或者学会写设计

2216
01:26:28,066 --> 01:26:29,466
不是一个简单的

2217
01:26:29,466 --> 01:26:31,899
靠自学过程能够完成的事情

2218
01:26:33,466 --> 01:26:34,866
写代码相对比较简单点

2219
01:26:34,866 --> 01:26:35,666
要学会写代码

2220
01:26:35,666 --> 01:26:38,166
其实你要首先要去多看

2221
01:26:38,866 --> 01:26:39,899
看的代码多

2222
01:26:39,933 --> 01:26:41,399
你才能写出好代码来

2223
01:26:41,466 --> 01:26:43,399
如果说你就是闷头去写

2224
01:26:43,400 --> 01:26:45,766
代码水平是很难提高的

2225
01:26:45,766 --> 01:26:47,299
所以一定要去看代码

2226
01:26:47,500 --> 01:26:50,333
那我们现在的这三个这些必中模块

2227
01:26:50,333 --> 01:26:52,666
其实就是让大家有一些代码

2228
01:26:52,666 --> 01:26:53,566
可以去参考

2229
01:26:53,600 --> 01:26:55,700
比如说最简单的region和这两个模块

2230
01:26:55,866 --> 01:26:58,133
是让大家有一些代码去参考

2231
01:26:58,133 --> 01:27:00,533
说这个玩意怎么去做设计

2232
01:27:00,533 --> 01:27:01,933
其实比写代码更难

2233
01:27:02,366 --> 01:27:02,866
就大家知道

2234
01:27:02,866 --> 01:27:04,099
你要提升你的设计能力

2235
01:27:04,100 --> 01:27:05,933
其实比提升写代码能力更难

2236
01:27:06,066 --> 01:27:07,099
因为写代码的能力

2237
01:27:07,100 --> 01:27:09,933
除了你操控大型的这些很多

2238
01:27:09,933 --> 01:27:12,466
代码以及你对技术的熟悉性以外

2239
01:27:12,466 --> 01:27:14,466
其实靠时间是可以磨出来的

2240
01:27:14,800 --> 01:27:17,266
但是设计靠时间磨不出来

2241
01:27:17,366 --> 01:27:18,533
大家应该已经意识到了

2242
01:27:18,533 --> 01:27:19,533
靠设计是磨不出来的

2243
01:27:19,533 --> 01:27:20,333
为什么呢

2244
01:27:20,466 --> 01:27:23,533
因为设计是要多看多想多讨论

2245
01:27:23,533 --> 01:27:25,799
多做多反复才能来

2246
01:27:26,133 --> 01:27:27,933
所以如果你闷头一个人去做

2247
01:27:28,700 --> 01:27:29,766
没有人讨论

2248
01:27:29,766 --> 01:27:31,866
也没有人去跟你跟你验证

2249
01:27:32,333 --> 01:27:34,733
你也不知道你的设计好还是不好

2250
01:27:34,966 --> 01:27:38,099
对吧所以这个过程就必须一样的

2251
01:27:38,100 --> 01:27:42,933
要多看多讨论多想多自己做

2252
01:27:43,066 --> 01:27:45,266
然后自己不断的反复自己

2253
01:27:45,266 --> 01:27:46,399
大家可以看到我的上课程

2254
01:27:46,400 --> 01:27:47,266
所有讲的设计

2255
01:27:47,266 --> 01:27:49,066
基本上我的课间都去不停的改

2256
01:27:49,300 --> 01:27:51,166
为啥因为讲的过程就发现他有问题

2257
01:27:51,266 --> 01:27:52,066
所以每一堂课

2258
01:27:52,066 --> 01:27:54,799
每一堂课都在不停的改这些设计

2259
01:27:55,000 --> 01:27:56,366
同学们做更是这样

2260
01:27:56,366 --> 01:27:57,133
因为这个设计

2261
01:27:57,133 --> 01:27:58,499
其实我们已经做了3年了

2262
01:27:58,900 --> 01:28:00,100
每堂课还是这个状态

2263
01:28:00,100 --> 01:28:02,166
其实三年来上这个课都这个状态

2264
01:28:02,166 --> 01:28:04,666
就是上课工程间不断的在改这个设计

2265
01:28:04,933 --> 01:28:10,666
所以设计一定要多看多讲多做多改

2266
01:28:10,900 --> 01:28:12,166
才能做的出来

2267
01:28:12,766 --> 01:28:13,533
这个避震模块

2268
01:28:13,533 --> 01:28:13,999
就是实际上

2269
01:28:14,000 --> 01:28:14,400
带大家

2270
01:28:14,400 --> 01:28:16,400
学会怎么去写这个个人设计的代码

2271
01:28:16,400 --> 01:28:18,666
以及学会怎么去做这个设计的过程啊

2272
01:28:18,666 --> 01:28:21,466
如果大家觉得这个不重要

2273
01:28:21,466 --> 01:28:22,933
到最后可以去冲一下

2274
01:28:23,866 --> 01:28:24,566
冲不出来的啊

2275
01:28:24,566 --> 01:28:25,466
我告诉大家

2276
01:28:25,700 --> 01:28:27,000
大家应该能够意识到

2277
01:28:27,000 --> 01:28:29,500
说你如果是靠最后一个月去冲一下

2278
01:28:29,700 --> 01:28:31,600
是完全不知道这玩意怎么写

2279
01:28:31,600 --> 01:28:32,600
和怎么做的

2280
01:28:32,700 --> 01:28:33,800
这里头有太多的东西

2281
01:28:33,800 --> 01:28:36,700
不是靠短时间能够能够那个的

2282
01:28:36,766 --> 01:28:37,966
所以从现在开始

2283
01:28:37,966 --> 01:28:39,799
11月份开始还不晚啊

2284
01:28:40,100 --> 01:28:41,133
把前面的东西补上

2285
01:28:41,133 --> 01:28:43,299
然后跟着这个过程慢慢的来

2286
01:28:43,333 --> 01:28:44,666
就会慢慢的学会怎么

2287
01:28:44,666 --> 01:28:47,333
去写你们上面的选做部分

2288
01:28:47,766 --> 01:28:48,699
因为上面这些就是文字

2289
01:28:48,700 --> 01:28:50,133
完全靠你们自己去完成

2290
01:28:50,533 --> 01:28:51,899
这个部分我给大家写好了

2291
01:28:51,900 --> 01:28:53,200
这个部分我大家写了个模板

2292
01:28:53,200 --> 01:28:53,866
大家去改

2293
01:28:53,866 --> 01:28:55,466
这部分我会去指导大家写

2294
01:28:55,733 --> 01:28:58,366
但这部分就是全靠大家自己去写了啊

2295
01:28:58,366 --> 01:29:01,133
所以这次我们把整个部分这么去分成

2296
01:29:02,766 --> 01:29:04,366
啊那我们来讲一下支付模块

2297
01:29:04,366 --> 01:29:08,799
支付模块比呃地区模块要复杂很多

2298
01:29:09,700 --> 01:29:11,400
但是相对于其他几个模块来说

2299
01:29:11,400 --> 01:29:12,366
还是简单的

2300
01:29:12,733 --> 01:29:15,599
为啥呢是因为它在最底下

2301
01:29:15,800 --> 01:29:18,566
它其实除了掉支付平台以外

2302
01:29:18,566 --> 01:29:20,699
没有再掉任何其他的东西

2303
01:29:21,133 --> 01:29:22,666
它的这个包图

2304
01:29:22,666 --> 01:29:24,099
也就是它的这个层次结构

2305
01:29:24,100 --> 01:29:26,666
其实跟前面的reaching不太一样

2306
01:29:27,500 --> 01:29:28,566
在这个层次结构中

2307
01:29:28,566 --> 01:29:29,966
大家看到这个结构的时候

2308
01:29:29,966 --> 01:29:31,599
我们的逻辑是一样的啊

2309
01:29:31,600 --> 01:29:32,866
就最上面是控制器层

2310
01:29:32,866 --> 01:29:33,599
最下面是my本层

2311
01:29:33,600 --> 01:29:35,933
这两层是6平结构的最外圈

2312
01:29:36,466 --> 01:29:38,266
对吧我们要设计的重点是

2313
01:29:38,266 --> 01:29:39,966
中间的收尾层和稻层

2314
01:29:39,966 --> 01:29:40,966
对吧这个大家知道

2315
01:29:40,966 --> 01:29:42,499
稻层里面有一大部分是增山改

2316
01:29:42,500 --> 01:29:44,066
茶就增山改

2317
01:29:44,200 --> 01:29:44,966
这是固定的

2318
01:29:44,966 --> 01:29:45,599
然后茶嘛

2319
01:29:45,600 --> 01:29:48,400
根据你的这个Bo的需求不同

2320
01:29:48,400 --> 01:29:50,800
然后会做各种各样不同的茶的方法

2321
01:29:51,000 --> 01:29:52,333
收尾层主要是做分解

2322
01:29:52,333 --> 01:29:54,399
然后大量的代码就不大量代码

2323
01:29:54,400 --> 01:29:55,866
我们尽量先把代码放到这个

2324
01:29:56,333 --> 01:29:56,999
放这里头了

2325
01:29:57,000 --> 01:29:58,133
这个逻辑是一样的

2326
01:29:58,133 --> 01:30:00,499
但是跟瑞景城不同的地方在于

2327
01:30:00,500 --> 01:30:02,300
开朗他这里多出这么多东西来

2328
01:30:02,766 --> 01:30:03,566
这些东西是干嘛的

2329
01:30:03,566 --> 01:30:06,266
这些东西就是访问支付宝和微信的

2330
01:30:06,733 --> 01:30:09,333
我们把访问支付宝和微信的这些代码

2331
01:30:09,333 --> 01:30:10,533
放到了map层

2332
01:30:10,800 --> 01:30:11,933
它的定义是什么

2333
01:30:11,933 --> 01:30:14,599
定义呢就是六边形结构中间的最

2334
01:30:14,600 --> 01:30:18,800
外圈我们最外圈既有跟前端交交互的

2335
01:30:19,100 --> 01:30:20,133
跟数据库

2336
01:30:20,133 --> 01:30:21,766
我们自己的数据库交互的

2337
01:30:21,766 --> 01:30:22,466
就是这个部分

2338
01:30:22,466 --> 01:30:24,266
因为这个只有MYBET写的

2339
01:30:25,100 --> 01:30:26,200
这是生成代码啊

2340
01:30:26,200 --> 01:30:28,400
my body是写的generate生成代码

2341
01:30:28,566 --> 01:30:31,799
还有跟支付宝和微信的API

2342
01:30:31,800 --> 01:30:33,066
去交互的代码

2343
01:30:33,300 --> 01:30:34,733
这些代码就放到这个地方

2344
01:30:36,666 --> 01:30:38,999
所以这就是我们在六边形结构中间

2345
01:30:39,000 --> 01:30:39,800
所说的最外圈

2346
01:30:39,800 --> 01:30:40,933
我们一直不是一直在说

2347
01:30:40,933 --> 01:30:43,199
我们是混合了不同的结构吗

2348
01:30:43,266 --> 01:30:45,266
就是什么代码放在什么层

2349
01:30:45,666 --> 01:30:46,799
其实是有讲究的

2350
01:30:46,800 --> 01:30:49,066
我们现在最外头这一圈的代码里头

2351
01:30:49,466 --> 01:30:52,299
其实放的是控制器层和map层

2352
01:30:52,900 --> 01:30:55,300
控制器层是跟前端打交道的

2353
01:30:55,700 --> 01:30:57,533
map层里头放开了两部分

2354
01:30:57,533 --> 01:30:59,799
一部分是存自己的数据库的

2355
01:30:59,900 --> 01:31:02,466
还有一部分是跟外围的系统打交道的

2356
01:31:02,466 --> 01:31:04,766
也放到这个map层了啊

2357
01:31:04,766 --> 01:31:06,199
也在这个外头这一圈

2358
01:31:06,366 --> 01:31:07,399
所以这个层次结构

2359
01:31:07,400 --> 01:31:08,900
就是我们这里看到的这个

2360
01:31:08,900 --> 01:31:09,866
这样的一个结构

2361
01:31:11,766 --> 01:31:13,199
map城会比较多

2362
01:31:13,200 --> 01:31:15,700
因为他多了跟外面的支付宝

2363
01:31:15,700 --> 01:31:17,366
微信通讯的部分

2364
01:31:17,533 --> 01:31:18,699
去沟通的部分

2365
01:31:20,133 --> 01:31:22,299
啊对象模型也比较复杂

2366
01:31:22,366 --> 01:31:24,533
是吧刚才reading只有一个

2367
01:31:24,533 --> 01:31:29,899
这里就有12345678个吧 9个

2368
01:31:33,100 --> 01:31:34,733
如果你一个人做这个系统

2369
01:31:35,466 --> 01:31:36,866
你们想从哪开始做起

2370
01:31:39,266 --> 01:31:40,066
啊

2371
01:31:42,933 --> 01:31:43,766
你只有一个

2372
01:31:43,766 --> 01:31:44,599
其实没什么好说的

2373
01:31:44,600 --> 01:31:45,566
像reading就一个嘛

2374
01:31:45,566 --> 01:31:47,466
那就没什么从哪做起的问题

2375
01:31:47,700 --> 01:31:49,966
当你看到一个模块有这么多的话

2376
01:31:49,966 --> 01:31:51,333
你就会想从哪做起

2377
01:31:51,700 --> 01:31:53,500
因为假如说你一个人做的话

2378
01:31:53,600 --> 01:31:55,166
你肯定要从头开始做

2379
01:31:55,333 --> 01:31:56,866
如果说你是一个人设计的话

2380
01:31:56,866 --> 01:31:58,499
你也要从一个地方开始设计起

2381
01:31:58,500 --> 01:31:59,866
才慢慢的衍生出去

2382
01:32:00,100 --> 01:32:00,666
这个其实是

2383
01:32:00,666 --> 01:32:01,733
有讲究的啊

2384
01:32:02,166 --> 01:32:02,999
通常来说

2385
01:32:03,000 --> 01:32:04,133
他的做法是这样

2386
01:32:04,366 --> 01:32:05,199
从这开始

2387
01:32:07,733 --> 01:32:09,699
因为它是最简单最靠边的

2388
01:32:11,500 --> 01:32:12,300
哪个

2389
01:32:13,133 --> 01:32:13,933
这个

2390
01:32:14,900 --> 01:32:16,066
这个不是核心业务

2391
01:32:16,066 --> 01:32:16,899
这个是对账

2392
01:32:16,900 --> 01:32:17,900
对出来就是

2393
01:32:17,900 --> 01:32:19,066
这个对象是什么呢

2394
01:32:19,066 --> 01:32:21,333
这个对象是对账对出来的

2395
01:32:21,333 --> 01:32:22,866
在我们平台里没有的

2396
01:32:22,866 --> 01:32:25,399
记录在支付宝微信里头有的东西

2397
01:32:26,200 --> 01:32:27,566
这个太靠边了啊

2398
01:32:27,566 --> 01:32:29,399
这个这太靠边了

2399
01:32:29,600 --> 01:32:31,266
所以支付渠道

2400
01:32:31,466 --> 01:32:34,099
商铺的支付渠道交易

2401
01:32:35,200 --> 01:32:36,966
交易里头的支付交易

2402
01:32:37,200 --> 01:32:38,300
退款交易

2403
01:32:38,600 --> 01:32:40,200
然后支付的分账

2404
01:32:40,466 --> 01:32:41,499
退款的分账

2405
01:32:42,100 --> 01:32:43,066
最后是对账

2406
01:32:43,333 --> 01:32:44,399
按照这个顺序做

2407
01:32:44,400 --> 01:32:45,100
我整理的时候

2408
01:32:45,100 --> 01:32:46,166
也是按照这个顺序整理的

2409
01:32:46,166 --> 01:32:48,299
就连这个代码去年同学有都写完

2410
01:32:48,300 --> 01:32:49,866
那里头有很多很多的问题

2411
01:32:50,000 --> 01:32:51,333
所以我再逐一的整理

2412
01:32:51,333 --> 01:32:53,666
这个代码我也按照这个顺序整的

2413
01:32:53,733 --> 01:32:54,933
我现在整理完了

2414
01:32:54,933 --> 01:32:56,199
整到整到这个地方

2415
01:32:57,733 --> 01:32:59,933
支付交易推广交易还没有整理

2416
01:32:59,933 --> 01:33:01,666
然后这些还没有整理完

2417
01:33:01,700 --> 01:33:03,400
但是这部分整理完了啊

2418
01:33:03,666 --> 01:33:04,699
所以现在传上去的代码

2419
01:33:04,700 --> 01:33:05,566
是有编译错误的

2420
01:33:05,566 --> 01:33:08,133
但是我传上去给大家看一下啊

2421
01:33:08,133 --> 01:33:09,166
争取在这个星期之内

2422
01:33:09,166 --> 01:33:11,799
把这一个模块的代码全部整理完

2423
01:33:12,266 --> 01:33:13,266
我整理完的目的就是

2424
01:33:13,266 --> 01:33:16,899
我把设计的想法全部用代码写出来

2425
01:33:16,900 --> 01:33:19,500
然后把这些代码做到编译无措

2426
01:33:20,133 --> 01:33:22,533
但是这个离他真正能够工作

2427
01:33:22,600 --> 01:33:24,300
还有很长的路要走啊

2428
01:33:24,566 --> 01:33:26,399
这个过程中间会你都要去

2429
01:33:26,400 --> 01:33:28,733
就是大家去做这部分的必做任务

2430
01:33:28,733 --> 01:33:30,533
的时候会要去理解现有的设计

2431
01:33:30,533 --> 01:33:32,866
然后用测试证明这个设计是可行的

2432
01:33:33,100 --> 01:33:35,000
如果测试证明这个设计是不可行的

2433
01:33:35,000 --> 01:33:36,066
那就没办法

2434
01:33:36,066 --> 01:33:38,466
要去改现有的这个设计啊

2435
01:33:38,466 --> 01:33:40,933
所以设计是一定想的

2436
01:33:40,933 --> 01:33:42,699
过程中在不断的动写的过程中间

2437
01:33:42,700 --> 01:33:43,066
写好了

2438
01:33:43,066 --> 01:33:45,566
也会在不断的去修正自己的这个设计

2439
01:33:45,900 --> 01:33:48,166
所以我们用这个半拉子的工程

2440
01:33:48,266 --> 01:33:48,799
就这个模块

2441
01:33:48,800 --> 01:33:50,000
是个半拉子的工程

2442
01:33:50,400 --> 01:33:52,966
带大家去慢慢的去去去

2443
01:33:52,966 --> 01:33:54,499
动手来做这个东西

2444
01:33:56,300 --> 01:33:57,800
呃这是他的数据库表

2445
01:33:57,966 --> 01:33:59,199
我为什么要花点时间

2446
01:33:59,200 --> 01:34:00,266
来讲一下数据库表呢

2447
01:34:00,266 --> 01:34:02,333
因为这个星期包括下个星期

2448
01:34:02,333 --> 01:34:03,966
大家都会在做数据库表的设计

2449
01:34:03,966 --> 01:34:05,099
和对象模型的设计

2450
01:34:05,366 --> 01:34:07,099
所以有同学会在问一个问题

2451
01:34:07,400 --> 01:34:10,100
我在对象模型中间要不要写ID

2452
01:34:12,533 --> 01:34:13,399
要不要写ID

2453
01:34:15,000 --> 01:34:16,366
我这里其实有写了

2454
01:34:16,366 --> 01:34:17,799
但其实是不要写的

2455
01:34:18,466 --> 01:34:21,266
所有的ID都不出现在对象模型里头

2456
01:34:21,533 --> 01:34:22,399
因为第一啊

2457
01:34:22,400 --> 01:34:24,366
我们知道所有对象都是有ID的

2458
01:34:24,466 --> 01:34:25,699
这个是前提对吧

2459
01:34:25,700 --> 01:34:26,933
每个对象都有一个ID

2460
01:34:27,200 --> 01:34:28,600
这个ID就不需要写了

2461
01:34:28,966 --> 01:34:31,699
因为这个ID就是用来标识这个对象的

2462
01:34:31,866 --> 01:34:32,466
这些相当于

2463
01:34:32,466 --> 01:34:34,566
我们对象在内存中间的地址

2464
01:34:34,800 --> 01:34:36,066
只不过是这个ID标识

2465
01:34:36,066 --> 01:34:37,999
在数据库里头的一条记录而已

2466
01:34:38,000 --> 01:34:39,300
所以我们在对象中间

2467
01:34:39,300 --> 01:34:40,533
其实是不需要写ID的

2468
01:34:40,666 --> 01:34:42,866
所以之后我会把这几个ID给它删掉啊

2469
01:34:42,866 --> 01:34:44,266
这是不需要写ID的

2470
01:34:44,900 --> 01:34:46,300
包括这些什么秀华ID

2471
01:34:46,300 --> 01:34:47,133
这些都不要写

2472
01:34:47,133 --> 01:34:48,133
但这个是有的啊

2473
01:34:48,133 --> 01:34:50,366
这是它有意义的纸商户号

2474
01:34:50,366 --> 01:34:51,299
这是有意义的

2475
01:34:51,400 --> 01:34:53,900
但是其他这些ID其实在对名都不用写

2476
01:34:54,166 --> 01:34:55,766
对象模型中间描述的是什么呢

2477
01:34:55,766 --> 01:34:58,199
描述的是对象和对象之间的关系

2478
01:34:59,066 --> 01:35:01,199
所以比如说像这个

2479
01:35:01,366 --> 01:35:02,599
我们以这个来说啊

2480
01:35:02,600 --> 01:35:04,466
这样以支付交易来说

2481
01:35:04,733 --> 01:35:08,399
它里头是有多个退款交易的

2482
01:35:08,866 --> 01:35:10,966
它描述的是它会有一个list

2483
01:35:10,966 --> 01:35:15,066
每个对象是refund transaction描述的

2484
01:35:15,066 --> 01:35:15,866
是这个东西

2485
01:35:16,133 --> 01:35:18,066
但是你在数据表里头

2486
01:35:18,933 --> 01:35:22,133
你的支付交易和退款交易的表里头

2487
01:35:22,133 --> 01:35:23,533
是需要写ID的

2488
01:35:23,766 --> 01:35:24,699
我们刚才说了

2489
01:35:24,700 --> 01:35:28,066
一个支付交易是有多个退款交易的

2490
01:35:28,333 --> 01:35:29,166
这个东西总要存在

2491
01:35:29,166 --> 01:35:30,799
哪他怎么存的呢

2492
01:35:30,966 --> 01:35:33,333
他存的是把这个全三个形的ID

2493
01:35:33,333 --> 01:35:35,266
存到了这个里头了

2494
01:35:35,533 --> 01:35:36,299
存到这个里头了

2495
01:35:36,300 --> 01:35:37,800
所以这里有一个拍

2496
01:35:37,800 --> 01:35:39,766
全三个形的ID是写在这个地方

2497
01:35:39,766 --> 01:35:41,699
这个东西是他的一个字段

2498
01:35:41,966 --> 01:35:43,666
这个字段名是写在这里了

2499
01:35:44,500 --> 01:35:49,366
所以我们的对数据库里头是要设计说

2500
01:35:49,366 --> 01:35:51,333
你刚才我们的对象门联说

2501
01:35:51,333 --> 01:35:52,966
表述的这样一个关系

2502
01:35:53,366 --> 01:35:55,266
在数据库里头是怎么存储的

2503
01:35:55,266 --> 01:35:56,466
所以这需要写ID

2504
01:35:56,966 --> 01:35:58,166
所以这是两

2505
01:35:58,166 --> 01:35:59,766
为什么要做两个模型

2506
01:35:59,933 --> 01:36:02,466
虽然这个模型看起来是很像的

2507
01:36:02,566 --> 01:36:05,399
但是我们其实每一个模型在做的时候

2508
01:36:05,766 --> 01:36:07,733
他所描述的内容是不一样的

2509
01:36:07,933 --> 01:36:10,733
这个不仅仅说这个描述的人不一样

2510
01:36:10,733 --> 01:36:12,499
我们会发现在代码中间啊

2511
01:36:12,500 --> 01:36:15,566
虽然这些ID在对象里头都有

2512
01:36:16,000 --> 01:36:18,166
比如说这个page section ID

2513
01:36:19,400 --> 01:36:21,766
在refund这个里头是有的

2514
01:36:21,966 --> 01:36:24,133
但是我们的代码中间从来不用它

2515
01:36:24,666 --> 01:36:27,933
我们从来用的都是这个对象

2516
01:36:28,533 --> 01:36:31,399
而不会直接去使用那个ID

2517
01:36:32,000 --> 01:36:33,366
我们那个ID的作用

2518
01:36:33,366 --> 01:36:36,066
就是为了产生这个对象

2519
01:36:36,066 --> 01:36:37,666
所以那个ID被什么样呢

2520
01:36:37,666 --> 01:36:40,699
被封装在这个对象里面了

2521
01:36:41,066 --> 01:36:42,466
我们暴露出来的

2522
01:36:42,466 --> 01:36:42,699
就是

2523
01:36:42,700 --> 01:36:44,533
我们在对象门里面所看到这个东西

2524
01:36:44,600 --> 01:36:45,733
这也就是为什么在对象门里面

2525
01:36:45,733 --> 01:36:48,566
不但去写被封装在里面

2526
01:36:48,766 --> 01:36:50,766
无论在界面上也看不到

2527
01:36:50,900 --> 01:36:52,800
也不能去直接去set

2528
01:36:52,800 --> 01:36:55,733
修改的的这些属性

2529
01:36:56,266 --> 01:36:57,566
就是那些ID啊

2530
01:36:57,566 --> 01:36:58,166
所以对面是

2531
01:36:58,166 --> 01:36:59,333
完全不会看到的

2532
01:37:00,900 --> 01:37:02,933
我们从还是一样的

2533
01:37:02,933 --> 01:37:04,266
用一个个的例子来讲

2534
01:37:04,266 --> 01:37:06,966
我们主要的创建者的设计方法

2535
01:37:06,966 --> 01:37:08,733
和信息专家的设计方法

2536
01:37:09,300 --> 01:37:10,700
创建者的这个设计方法呢

2537
01:37:10,700 --> 01:37:13,066
我们是以这样的一个功能呢来讲的

2538
01:37:13,066 --> 01:37:15,199
叫做签约支付渠道

2539
01:37:15,933 --> 01:37:16,866
这个我顺便说一下

2540
01:37:16,866 --> 01:37:17,166
我

2541
01:37:17,166 --> 01:37:19,999
我看到今年支付宝的API全部都改了

2542
01:37:20,000 --> 01:37:21,800
他已经支持了restful API

2543
01:37:22,000 --> 01:37:23,400
原来是很恶心的啊

2544
01:37:23,533 --> 01:37:25,733
今年他已经全面支持rest API了

2545
01:37:25,866 --> 01:37:27,166
所以我们今年把所有的代码

2546
01:37:27,166 --> 01:37:28,933
都改到他的新的API上头啊

2547
01:37:28,933 --> 01:37:31,466
rest API做起来会比较轻松一点

2548
01:37:32,133 --> 01:37:34,699
那这个签约支付渠道是什么呢

2549
01:37:34,700 --> 01:37:35,900
它的功能是这样的

2550
01:37:36,400 --> 01:37:37,900
就是我们的商户

2551
01:37:37,900 --> 01:37:39,300
先到微信或者支付宝上去

2552
01:37:39,300 --> 01:37:40,333
申请了一个账号

2553
01:37:41,066 --> 01:37:41,899
申请账号以后呢

2554
01:37:41,900 --> 01:37:44,066
他需要在我们的平台上头去签约

2555
01:37:44,466 --> 01:37:45,499
签约的意思就是

2556
01:37:45,500 --> 01:37:46,666
他要在我们这里去

2557
01:37:47,133 --> 01:37:51,399
把这个账号跟我们平台的那个账号

2558
01:37:51,400 --> 01:37:53,533
去建立一个分账关系

2559
01:37:54,066 --> 01:37:55,466
这个关系建立了以后

2560
01:37:55,466 --> 01:37:56,533
我们的平台账号

2561
01:37:56,533 --> 01:37:59,933
就能去操作他账号里头的分账动作

2562
01:38:00,100 --> 01:38:00,866
其他的不能做啊

2563
01:38:00,866 --> 01:38:02,866
可以查然后可以分账

2564
01:38:02,900 --> 01:38:04,866
但是你不能从他里头把钱转出来

2565
01:38:04,900 --> 01:38:05,133
所以

2566
01:38:05,133 --> 01:38:07,366
分账只能分到固定的我们的平台上头

2567
01:38:07,366 --> 01:38:08,933
查是可以任意去查的

2568
01:38:12,600 --> 01:38:13,600
不是这不是预留金

2569
01:38:13,600 --> 01:38:15,966
就是你在支付宝里头开了一个账号嘛

2570
01:38:16,100 --> 01:38:17,900
然后你在这个平台上所有卖的钱

2571
01:38:17,900 --> 01:38:19,800
都会打到你的支付宝的账号上头去

2572
01:38:22,566 --> 01:38:23,399
那是另外一个地方

2573
01:38:23,400 --> 01:38:24,200
那是另外一回事

2574
01:38:24,200 --> 01:38:26,733
这个就是单纯只在交易的过程中间

2575
01:38:26,733 --> 01:38:28,199
所有的顾客付给你的钱

2576
01:38:28,200 --> 01:38:29,166
都在你的账号上

2577
01:38:29,333 --> 01:38:31,899
但是你跟我签了这个签约了以后

2578
01:38:32,600 --> 01:38:34,466
我的平台可以去查你的账

2579
01:38:34,466 --> 01:38:36,066
要正常是不能查你的账的

2580
01:38:36,133 --> 01:38:37,933
我就可以查你的那个账号

2581
01:38:37,933 --> 01:38:39,966
里头的钱有多少

2582
01:38:40,366 --> 01:38:41,666
第二是我可以调查

2583
01:38:41,666 --> 01:38:42,799
分账只能做两件事情

2584
01:38:42,800 --> 01:38:43,300
一个是查

2585
01:38:43,300 --> 01:38:44,100
一个是分账

2586
01:38:44,533 --> 01:38:45,666
分账也是按照固定的

2587
01:38:45,666 --> 01:38:47,366
这个只能分给我

2588
01:38:47,366 --> 01:38:48,733
不能去分给别人

2589
01:38:48,766 --> 01:38:51,899
然后这么多是你可以说分多少

2590
01:38:51,900 --> 01:38:52,366
这个是可以

2591
01:38:52,366 --> 01:38:54,133
但你只能分给平台

2592
01:38:54,133 --> 01:38:56,266
不能分给任何其他的东西

2593
01:38:56,533 --> 01:38:58,299
所以这是我们说签约

2594
01:38:58,300 --> 01:39:00,466
这个支付的这个功能

2595
01:39:00,466 --> 01:39:01,866
就是建立这样的一个事情

2596
01:39:02,400 --> 01:39:03,966
这个实际做的过程

2597
01:39:03,966 --> 01:39:06,166
中间其实是有很多的内容要填进来的

2598
01:39:06,166 --> 01:39:07,733
但是我们做了一个简化

2599
01:39:08,066 --> 01:39:10,299
就是我们只填了一个这个纸

2600
01:39:10,300 --> 01:39:11,133
商务号啊

2601
01:39:11,133 --> 01:39:13,366
我们下个星期再说吧

