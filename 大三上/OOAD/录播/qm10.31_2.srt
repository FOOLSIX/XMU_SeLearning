1
00:00:26,200 --> 00:00:28,533
我们今天两个事情

2
00:00:29,066 --> 00:00:32,566
一节课把对象模型呃

3
00:00:32,566 --> 00:00:34,466
还没有讲完的部分讲一下

4
00:00:34,466 --> 00:00:36,699
然后之前讲过的部分

5
00:00:36,700 --> 00:00:38,366
其实我们有一点小小的修改

6
00:00:38,500 --> 00:00:40,800
所以把修改的部分再梳理一下

7
00:00:41,100 --> 00:00:43,500
第二部分我们开始讲呃

8
00:00:43,500 --> 00:00:45,500
地区那个模块的设计啊

9
00:00:45,500 --> 00:00:47,100
就结合我们grass的方法

10
00:00:47,300 --> 00:00:49,466
讲地区那个模块是怎么设计的

11
00:00:49,533 --> 00:00:51,866
那第二部分刚才应该讲不完

12
00:00:51,866 --> 00:00:56,333
所以会延续到星期三再来讲啊

13
00:00:56,700 --> 00:00:57,933
这个部分的设计

14
00:00:57,933 --> 00:00:58,699
我们可以看到

15
00:00:58,700 --> 00:00:59,866
前面的领域模型

16
00:00:59,866 --> 00:01:02,666
经过我们上周三的讲了一遍以后

17
00:01:02,666 --> 00:01:04,199
其实有一点小小的修改

18
00:01:04,400 --> 00:01:05,666
就是在产品这边

19
00:01:05,666 --> 00:01:07,299
我们增加了一个新的概念

20
00:01:07,300 --> 00:01:09,966
叫做草稿产品

21
00:01:09,966 --> 00:01:11,599
这个原因就是因为我们知道

22
00:01:11,600 --> 00:01:13,900
产品的修改是需要经过审核的

23
00:01:14,300 --> 00:01:16,800
所以当商铺要去修改一个商品的时候

24
00:01:16,800 --> 00:01:18,933
他不能立马去修改

25
00:01:19,600 --> 00:01:21,133
还是要把它修改的东西

26
00:01:21,133 --> 00:01:21,999
交给平台管理员

27
00:01:22,000 --> 00:01:23,066
审核通过了以后

28
00:01:23,066 --> 00:01:25,066
才会改到具体的商品上

29
00:01:25,366 --> 00:01:25,599
所以

30
00:01:25,600 --> 00:01:28,933
这就有了一个草稿商品的这个概念

31
00:01:29,100 --> 00:01:30,733
当然因为这个概念的存在

32
00:01:30,733 --> 00:01:33,166
所以我们给他赋予了更多的内涵

33
00:01:33,166 --> 00:01:36,399
他不仅仅用于修改商品的时候

34
00:01:36,900 --> 00:01:39,400
当商铺要新增一个商品的时候

35
00:01:39,400 --> 00:01:43,133
其实他也是建立了一个草稿商品的

36
00:01:43,366 --> 00:01:44,933
这个外延实力

37
00:01:45,133 --> 00:01:46,999
然后由平台管理员审核通过以后

38
00:01:47,000 --> 00:01:49,966
再由草稿商品变成正式商品啊

39
00:01:49,966 --> 00:01:52,133
所以这边的领域模型

40
00:01:52,133 --> 00:01:55,066
对象模型都增加了一个新的呃

41
00:01:55,300 --> 00:01:57,166
概念和对象数据护理

42
00:01:57,166 --> 00:01:58,399
其实它本来就有

43
00:01:58,933 --> 00:02:00,366
第二个部分来说

44
00:02:00,366 --> 00:02:02,699
我们把所有的状态截图重新画了一下

45
00:02:02,733 --> 00:02:04,699
也就是我们原来没有去描述

46
00:02:04,700 --> 00:02:06,933
它的第一个呃

47
00:02:06,933 --> 00:02:10,666
第一个初始的状态是怎么来的所

48
00:02:10,666 --> 00:02:11,333
以我们可以看到

49
00:02:11,333 --> 00:02:12,299
在初始状态

50
00:02:12,300 --> 00:02:14,300
就是这个初始状态的这个线上呢

51
00:02:14,300 --> 00:02:15,766
我们都标注了事件

52
00:02:16,166 --> 00:02:17,766
标示这个事件的作用就是

53
00:02:17,766 --> 00:02:20,099
我们会知道这个对象是怎么来的

54
00:02:20,400 --> 00:02:21,266
比如说活动

55
00:02:21,266 --> 00:02:23,466
会知道是因为新建而来的

56
00:02:23,533 --> 00:02:26,699
然后呃产品是因为审核了以后

57
00:02:26,700 --> 00:02:27,766
他就会变成下架

58
00:02:27,900 --> 00:02:29,766
然后所有的事件啊

59
00:02:31,266 --> 00:02:34,366
其实都有啊等一下

60
00:03:44,300 --> 00:03:46,366
啊我们在这个文档中间可以看到

61
00:03:46,366 --> 00:03:47,533
我们有产生了

62
00:03:47,533 --> 00:03:49,933
第二阶段所要写的很多的文档

63
00:03:49,933 --> 00:03:51,566
就是设计文档

64
00:03:52,000 --> 00:03:53,866
然后在这份文档中间呢

65
00:03:54,300 --> 00:03:56,066
所有的状态图啊

66
00:03:56,066 --> 00:03:57,933
我刚才有感觉状态图还没更新

67
00:03:57,933 --> 00:04:01,099
所有的状态图的事件下面都需要标识

68
00:04:01,100 --> 00:04:05,066
说UIL就是它的API是什么

69
00:04:05,466 --> 00:04:07,366
所以比如说以

70
00:04:09,933 --> 00:04:12,066
这个商品来说

71
00:04:12,133 --> 00:04:14,733
那审核的API是什么

72
00:04:15,166 --> 00:04:16,333
进售的API是什么

73
00:04:16,333 --> 00:04:17,533
减禁的API是什么

74
00:04:17,533 --> 00:04:18,599
都需要标注出来

75
00:04:18,866 --> 00:04:21,899
所以啊第二阶段的这个作业

76
00:04:21,900 --> 00:04:23,933
其实大家就按照这个格式来写

77
00:04:24,366 --> 00:04:24,899
这个文档

78
00:04:24,900 --> 00:04:26,400
我们会作为第二阶段

79
00:04:26,400 --> 00:04:28,866
和第三阶段的作业啊

80
00:04:28,866 --> 00:04:33,533
因为前半部分是我们的这个对象模型

81
00:04:33,533 --> 00:04:34,799
数据库的设计

82
00:04:35,200 --> 00:04:36,733
状态截图啊

83
00:04:36,900 --> 00:04:39,600
这个部分我们有一个写完了

84
00:04:39,700 --> 00:04:41,933
后半部分是我们的详细设计

85
00:04:42,900 --> 00:04:44,333
比如说地区啊

86
00:04:44,333 --> 00:04:47,766
地区我把代码和不是地区

87
00:04:47,766 --> 00:04:50,599
我把代码和这个全部都写完了

88
00:04:52,666 --> 00:04:54,966
代码文档和测试全部都写完了

89
00:04:56,700 --> 00:04:58,933
所以这个就后半段会有他的设计

90
00:05:00,466 --> 00:05:03,699
就是我们的第二个和第三个

91
00:05:03,733 --> 00:05:05,099
就是完整的

92
00:05:05,100 --> 00:05:08,466
在这里这个是因为合起来会太多啊

93
00:05:08,466 --> 00:05:10,666
所以我们虽然是分模块来写的

94
00:05:14,466 --> 00:05:15,499
所以在这啊

95
00:05:15,533 --> 00:05:18,566
状态地图的起始状态我们都标了世界

96
00:05:22,300 --> 00:05:23,800
商铺的部分啊

97
00:05:23,800 --> 00:05:25,266
这个我们没什么改动

98
00:05:25,266 --> 00:05:27,266
支付的部分没有什么改动啊

99
00:05:27,266 --> 00:05:28,399
支付门讲完了

100
00:05:29,000 --> 00:05:30,733
然后物流的部分

101
00:05:31,066 --> 00:05:31,799
物流的部分

102
00:05:31,800 --> 00:05:34,000
我们的呃

103
00:05:34,466 --> 00:05:36,266
第二阶段的必做任务的

104
00:05:36,266 --> 00:05:39,533
前面三个任务都是跟物流有关的

105
00:05:39,533 --> 00:05:40,466
他的对象模型

106
00:05:40,466 --> 00:05:42,099
他的数据库和他的API

107
00:05:42,400 --> 00:05:43,066
然后昨天晚上

108
00:05:43,066 --> 00:05:45,299
我看完了对象模型和数据库

109
00:05:45,600 --> 00:05:47,400
然后数据库的发现

110
00:05:48,100 --> 00:05:49,933
我们之前是有一个数据库设计的啊

111
00:05:49,933 --> 00:05:51,266
就目前大家设计的

112
00:05:51,266 --> 00:05:53,066
没有比之前的设计的更好

113
00:05:53,100 --> 00:05:55,133
所以我就把这个b座任务给取消了啊

114
00:05:55,133 --> 00:05:56,399
你要比之前设计的

115
00:05:56,400 --> 00:05:57,866
让我觉得更加有道理

116
00:05:57,933 --> 00:05:59,966
我才会选用它作为b座任务

117
00:05:59,966 --> 00:06:02,133
所以我们现在用的是之前的那个

118
00:06:02,133 --> 00:06:02,733
数据库设计

119
00:06:02,733 --> 00:06:04,199
就去年的数据库设计

120
00:06:05,900 --> 00:06:06,500
对象模型

121
00:06:06,500 --> 00:06:08,333
我选用了一位同学对象模型

122
00:06:09,400 --> 00:06:12,700
这个对象模型为什么会这样来设计啊

123
00:06:12,700 --> 00:06:14,533
其实跟我们的领域模型有关的

124
00:06:14,733 --> 00:06:15,699
在领域模型中间

125
00:06:15,700 --> 00:06:19,166
我们会发现所有的关系全是双向的

126
00:06:19,466 --> 00:06:20,533
所以对象模型中间

127
00:06:20,533 --> 00:06:21,866
首先第一件事情要明确

128
00:06:21,866 --> 00:06:23,699
双向的是不是依然保留

129
00:06:24,000 --> 00:06:25,266
就是在我们对象模型中间

130
00:06:25,266 --> 00:06:27,799
我们到底是需要双向的还是单向的

131
00:06:27,900 --> 00:06:29,500
那到底是双向还是单向的

132
00:06:29,500 --> 00:06:30,666
是跟着API来的

133
00:06:30,933 --> 00:06:32,333
所以这是有一定的关系的

134
00:06:32,333 --> 00:06:34,966
你看到API上的可能需要知道双向的

135
00:06:34,966 --> 00:06:37,599
那就可能需要双向的啊

136
00:06:37,600 --> 00:06:39,933
不你看到API上的可能需要装双向的

137
00:06:39,933 --> 00:06:41,199
然后你会去做一个判断

138
00:06:41,200 --> 00:06:41,966
说这个双向的

139
00:06:41,966 --> 00:06:43,899
哪些是由对象模型来实现的

140
00:06:44,133 --> 00:06:46,166
哪些是由面向功能的去实现的

141
00:06:46,166 --> 00:06:48,466
然后最后决定对象模型是什么

142
00:06:48,666 --> 00:06:49,866
所以这里头呢

143
00:06:49,866 --> 00:06:51,599
倒不是设施最后的版本

144
00:06:51,933 --> 00:06:52,599
这里头是

145
00:06:52,600 --> 00:06:54,333
我们根据API来说啊

146
00:06:54,333 --> 00:06:55,666
定的一些方向

147
00:06:55,666 --> 00:07:01,333
这些方向比如说呃商铺和仓库

148
00:07:01,400 --> 00:07:05,600
我们把它方向从商仓库指向商铺

149
00:07:06,000 --> 00:07:06,966
然后物流呢

150
00:07:06,966 --> 00:07:09,666
我们是从物流呃

151
00:07:10,400 --> 00:07:11,666
在这个模块中间

152
00:07:11,666 --> 00:07:14,866
物流模块中间是有物流指向商铺的啊

153
00:07:14,866 --> 00:07:19,199
那在商铺模块中间是由设呃对

154
00:07:19,200 --> 00:07:19,600
在这里的

155
00:07:19,600 --> 00:07:21,566
我们对象模型是用物流来指向商铺的

156
00:07:21,566 --> 00:07:22,399
但是API上的

157
00:07:22,400 --> 00:07:24,000
其实是需要从商铺知道

158
00:07:24,000 --> 00:07:25,133
它有多少物流的

159
00:07:25,166 --> 00:07:25,199
那

160
00:07:25,200 --> 00:07:28,866
那个就会有面向功能的方式去实现

161
00:07:29,166 --> 00:07:31,499
这里头最麻烦的就是我们这个三角

162
00:07:31,766 --> 00:07:34,966
这个三角的这三个关系是多对多的

163
00:07:36,300 --> 00:07:37,000
多对多的

164
00:07:37,000 --> 00:07:38,300
你就会有一个抉择

165
00:07:38,300 --> 00:07:39,166
第一是方向

166
00:07:39,166 --> 00:07:42,199
是不是两方向的多对多都需要保留

167
00:07:42,866 --> 00:07:44,299
第二是多对多的

168
00:07:44,300 --> 00:07:46,700
到底是在对象模型中间进行多对多的

169
00:07:46,733 --> 00:07:48,366
还是把它拆解

170
00:07:48,566 --> 00:07:50,133
我们知道拆解的原因

171
00:07:50,133 --> 00:07:51,899
是因为我们可能在这里头

172
00:07:51,900 --> 00:07:53,900
需要加入新的属性

173
00:07:53,900 --> 00:07:54,733
就是在关系上呢

174
00:07:54,733 --> 00:07:55,799
是有新的属性

175
00:07:56,000 --> 00:07:56,900
我们在对象模型上呢

176
00:07:56,900 --> 00:07:58,133
就会把它进行拆解

177
00:07:58,400 --> 00:07:59,333
在这里我们可以看到

178
00:07:59,333 --> 00:08:01,666
这位同学做的选择是把它拆解了

179
00:08:02,000 --> 00:08:03,600
就是这三角关系啊

180
00:08:03,600 --> 00:08:04,466
这个这个

181
00:08:04,466 --> 00:08:08,333
和这个本来是多对多的一个三角关系

182
00:08:08,400 --> 00:08:09,366
那做的选择

183
00:08:09,366 --> 00:08:12,533
是把它全部拆解成了中间的

184
00:08:12,566 --> 00:08:13,399
这个东西

185
00:08:13,866 --> 00:08:15,933
拆解的主要的原因呢

186
00:08:15,933 --> 00:08:19,299
其实是因为它有属性

187
00:08:19,566 --> 00:08:22,799
比如说我们说仓库和地区来说

188
00:08:22,800 --> 00:08:24,133
我们其实要描述说

189
00:08:24,133 --> 00:08:24,766
这个仓库

190
00:08:24,766 --> 00:08:28,199
在哪段时间会要配送这个地区

191
00:08:28,533 --> 00:08:30,999
所以它会有一个begin time和an time

192
00:08:31,400 --> 00:08:32,400
仓库和物流来说

193
00:08:32,400 --> 00:08:33,533
因为这是签的合同

194
00:08:33,533 --> 00:08:36,266
所以这个仓库用这个物流

195
00:08:36,266 --> 00:08:38,566
肯定是有一个开始时间和结束时间的

196
00:08:38,800 --> 00:08:39,733
同样的这个

197
00:08:39,733 --> 00:08:40,466
物流不配送

198
00:08:40,466 --> 00:08:41,999
这个地区不是永久不配送

199
00:08:42,000 --> 00:08:44,933
所以说他也有一个这个属性

200
00:08:44,933 --> 00:08:46,666
就是从这段时间到这段时间

201
00:08:46,666 --> 00:08:47,933
我这个物流公司

202
00:08:47,933 --> 00:08:51,166
不配送这一地区的快件

203
00:08:51,600 --> 00:08:54,133
那这因为有一系列的属性

204
00:08:54,133 --> 00:08:55,566
所以需要把它拆解

205
00:08:55,566 --> 00:08:58,699
成为中间的带属性的对象啊

206
00:08:58,700 --> 00:09:01,866
这个就是会拆的主要的原因

207
00:09:01,866 --> 00:09:03,133
那第二个原因就第二个

208
00:09:03,133 --> 00:09:04,366
就是他的方向

209
00:09:04,366 --> 00:09:06,866
或者他多对多的关系是否都要保留

210
00:09:07,133 --> 00:09:09,133
大家可以看到这一个关系

211
00:09:09,133 --> 00:09:11,399
上面这个仓库和地区的关系

212
00:09:11,800 --> 00:09:14,733
剩下来的是一个一对多的关系

213
00:09:14,733 --> 00:09:18,933
这个一对多的方向是从1到多啊

214
00:09:18,933 --> 00:09:20,666
这边是一个一对一的

215
00:09:20,700 --> 00:09:22,966
好把多对多的关系的

216
00:09:23,066 --> 00:09:25,933
从这边到这边的多的关系给它去掉

217
00:09:26,733 --> 00:09:28,666
啊这就是因为我们从API上的

218
00:09:28,666 --> 00:09:30,466
其实并不需要从地区看到

219
00:09:30,466 --> 00:09:32,533
这个地区有多少仓库

220
00:09:32,566 --> 00:09:34,999
我们只需要知道这个仓库有多少地区

221
00:09:35,100 --> 00:09:36,266
不是说这个需求没有

222
00:09:36,266 --> 00:09:37,999
是因为API上没有这个需求

223
00:09:38,000 --> 00:09:39,800
没有这个API啊

224
00:09:39,800 --> 00:09:40,266
所以说

225
00:09:40,266 --> 00:09:42,666
我们就没有做这个方向到这个方向

226
00:09:42,666 --> 00:09:45,266
而是只做了这个方向到这个方向的啊

227
00:09:45,266 --> 00:09:46,866
就是我们从平台的角度上呢

228
00:09:46,866 --> 00:09:47,666
并没有去看

229
00:09:47,666 --> 00:09:49,799
说所有的商户

230
00:09:49,800 --> 00:09:52,333
在每个地区到底有多少的仓库

231
00:09:52,333 --> 00:09:54,499
并没有去做这个部分的API

232
00:09:54,800 --> 00:09:56,600
所以只有这个方向的啊

233
00:09:57,566 --> 00:09:58,466
啊这个方向呢

234
00:09:58,466 --> 00:09:59,133
大家可以看到

235
00:09:59,133 --> 00:10:02,266
他留下了仓库到物流的啊

236
00:10:02,266 --> 00:10:03,933
没有物流到仓库的

237
00:10:04,066 --> 00:10:05,099
这个道理也是一样的

238
00:10:05,100 --> 00:10:07,600
API上头应该是没有这个方向的啊

239
00:10:07,600 --> 00:10:08,933
只有这个方向的API

240
00:10:09,600 --> 00:10:10,300
那还有一个呢

241
00:10:10,300 --> 00:10:11,366
是这个方向

242
00:10:11,366 --> 00:10:14,766
他留下的这个方向就是从物流到这个

243
00:10:14,800 --> 00:10:16,600
所以总的来说

244
00:10:16,600 --> 00:10:18,366
你可以看到我们在这

245
00:10:18,366 --> 00:10:19,066
个部分的

246
00:10:19,066 --> 00:10:23,366
核心的概念其实是仓库物流模块啊

247
00:10:23,366 --> 00:10:25,599
仓库和物流这是两个核心的模块

248
00:10:25,600 --> 00:10:27,100
其实在仓库和物流中间

249
00:10:27,100 --> 00:10:28,366
最核心的其实是仓库

250
00:10:28,366 --> 00:10:30,199
因为这是物流的起点

251
00:10:30,533 --> 00:10:32,199
对吧另外一个是运单啊是

252
00:10:32,200 --> 00:10:34,566
这两个是他最核心的模块

253
00:10:34,700 --> 00:10:37,733
所以保留的方向就是从核心模块

254
00:10:37,900 --> 00:10:40,466
核心的概念朝外的方向

255
00:10:40,600 --> 00:10:42,933
大家可以看到仓库到商铺

256
00:10:43,166 --> 00:10:44,499
仓库到地区

257
00:10:44,866 --> 00:10:47,966
仓库到物流啊这样的一个方向

258
00:10:48,200 --> 00:10:50,866
然后这个也是订单到物流

259
00:10:51,000 --> 00:10:54,100
保留都是这个从核心的概念

260
00:10:54,100 --> 00:10:56,333
核心的对象朝外的这个

261
00:10:56,400 --> 00:10:58,500
当然这个不见得合理啊

262
00:10:58,500 --> 00:10:59,666
但是我们在做之前

263
00:10:59,666 --> 00:11:01,899
至少有一个第一版本的方案

264
00:11:02,166 --> 00:11:03,499
然后在后面设计过程中间

265
00:11:03,500 --> 00:11:06,166
这个方案会根据我们的设计过程

266
00:11:06,166 --> 00:11:07,466
中间所遇到的问题啊

267
00:11:07,466 --> 00:11:08,966
再去做不断的修改

268
00:11:09,333 --> 00:11:11,999
这是物流的这个

269
00:11:12,000 --> 00:11:14,500
这用的是那个徐生斌的方案啊

270
00:11:15,966 --> 00:11:16,799
那数据库

271
00:11:16,800 --> 00:11:21,100
我就没有觉得比这个更好点的方案

272
00:11:21,200 --> 00:11:22,366
有同学提出来说

273
00:11:22,366 --> 00:11:25,533
他想存不同的顺丰快递

274
00:11:25,533 --> 00:11:27,333
就是包括对象模型和数据库模型

275
00:11:27,533 --> 00:11:28,466
是想针动

276
00:11:28,900 --> 00:11:30,866
针对极兔中通和顺丰

277
00:11:30,866 --> 00:11:32,866
去做不同的设计啊

278
00:11:32,866 --> 00:11:35,266
但是我的基本的思想来说

279
00:11:35,266 --> 00:11:37,566
我们并不想在数据和对象

280
00:11:37,566 --> 00:11:39,166
特别是数据库的设计上头

281
00:11:39,400 --> 00:11:41,666
去体现不同的物流公司啊

282
00:11:41,666 --> 00:11:42,066
这样的话

283
00:11:42,066 --> 00:11:43,566
每家物流公司都要去动数据库

284
00:11:43,566 --> 00:11:44,599
这个太痛苦了

285
00:11:44,900 --> 00:11:45,333
所以我们希望

286
00:11:45,333 --> 00:11:47,933
把所有的物流公司里的相关信息

287
00:11:47,933 --> 00:11:50,133
全部建立在同样的一个模型里头啊

288
00:11:50,133 --> 00:11:52,899
这是这个建模的一个基本的想法

289
00:11:54,500 --> 00:11:55,933
地区我们之前讲过了

290
00:11:55,933 --> 00:11:57,133
这个很简单啊

291
00:11:57,133 --> 00:11:58,499
这个我们就不说了

292
00:11:58,600 --> 00:12:00,133
那我们来讲订单

293
00:12:06,333 --> 00:12:07,366
订单的领域模型

294
00:12:07,366 --> 00:12:08,199
最核心的概念

295
00:12:08,200 --> 00:12:08,900
就是订单

296
00:12:08,900 --> 00:12:11,666
这个大家应该没有什么问题啊

297
00:12:11,900 --> 00:12:14,600
那再有一个则是这个订单的明细

298
00:12:14,600 --> 00:12:16,266
就是订单里头的东西

299
00:12:16,333 --> 00:12:19,099
我们对于订单的内涵的定义是什么

300
00:12:19,100 --> 00:12:21,533
定义领域模型一定要明确这一点

301
00:12:21,966 --> 00:12:24,299
我们对于订单的内涵的定义

302
00:12:24,300 --> 00:12:25,933
其实从这张图上能看得出来

303
00:12:26,300 --> 00:12:28,500
它跟商铺是一个一对多的关系

304
00:12:29,200 --> 00:12:31,666
这个其实就定义了它的内涵是什么

305
00:12:32,733 --> 00:12:36,166
它内涵是这个订单里头的所有东西

306
00:12:36,166 --> 00:12:37,466
都是同一个商铺的

307
00:12:38,100 --> 00:12:41,100
就是如果说在购物车里头

308
00:12:41,566 --> 00:12:44,099
顾客选了很多的东西同时下单

309
00:12:44,800 --> 00:12:45,900
在我们的系统中间

310
00:12:45,900 --> 00:12:47,733
我们现在这个领域模型做出来的结果

311
00:12:47,733 --> 00:12:48,366
就是

312
00:12:48,366 --> 00:12:52,299
它会根据商铺不同变成不同的订单

313
00:12:53,066 --> 00:12:54,799
然后下一步支付会是什么样子

314
00:12:54,800 --> 00:12:55,800
我们这个领域模型呢

315
00:12:55,800 --> 00:12:56,666
其实讲了

316
00:12:56,900 --> 00:12:58,400
针对每一个订单来说

317
00:12:58,400 --> 00:13:01,566
它是有对应的支付以及之后的退款的

318
00:13:01,933 --> 00:13:03,699
所以如果说按照这个领域模型

319
00:13:03,700 --> 00:13:05,100
定义出来的需求

320
00:13:05,100 --> 00:13:05,400
就是

321
00:13:05,400 --> 00:13:08,766
如果顾客在购物车里选了一堆的商品

322
00:13:08,966 --> 00:13:10,266
去购买的话

323
00:13:10,400 --> 00:13:13,400
会根据这些商品归属于不同的商铺

324
00:13:13,400 --> 00:13:15,766
变成若干个不同的订单

325
00:13:15,966 --> 00:13:19,299
然后每一个订单去单独付款

326
00:13:19,900 --> 00:13:20,900
这个柠檬就这样

327
00:13:21,566 --> 00:13:23,599
这个柠檬所描述的需求就是这个样子

328
00:13:23,600 --> 00:13:24,600
啊大家知道

329
00:13:24,600 --> 00:13:27,566
像淘宝是可以做到合并付款了

330
00:13:27,666 --> 00:13:29,866
就是我选了很多的不同的商铺

331
00:13:30,100 --> 00:13:32,500
他会变成很多个订单没问题

332
00:13:32,500 --> 00:13:34,500
但是付款的时候可以一笔付出去

333
00:13:34,533 --> 00:13:37,299
然后他再把它解成不同的东西

334
00:13:37,500 --> 00:13:39,600
我们现在这个是不行的啊

335
00:13:39,600 --> 00:13:42,566
这是领域模型描述的概念

336
00:13:42,566 --> 00:13:43,733
决定了你的需求

337
00:13:43,733 --> 00:13:44,733
就是这样一个需求

338
00:13:44,733 --> 00:13:47,466
如果同时把很多商品一起买

339
00:13:47,700 --> 00:13:50,100
分不同的店铺变成不同的

340
00:13:50,100 --> 00:13:54,533
订单然后这些订单是分别付款的啊

341
00:13:54,533 --> 00:13:56,599
这是我们这个领域模型所描述的

342
00:13:56,733 --> 00:13:57,699
这块有问题吗

343
00:13:58,500 --> 00:13:59,933
这就是领域模型决定的

344
00:13:59,933 --> 00:14:01,566
决定的需求就是这个样子

345
00:14:02,800 --> 00:14:05,200
然后退款的这部分是一个一对多的啊

346
00:14:05,200 --> 00:14:06,400
这个大家应该知道

347
00:14:06,566 --> 00:14:08,533
我们其实订单里头是有多个商品的

348
00:14:08,533 --> 00:14:10,666
所以会产生多次退款

349
00:14:11,000 --> 00:14:13,300
这就是任何一个订单

350
00:14:13,300 --> 00:14:16,300
是归属于一个顾客的啊

351
00:14:16,300 --> 00:14:18,166
所以一个顾客会有多个订单啊

352
00:14:18,333 --> 00:14:20,266
他是创建订单的人

353
00:14:21,300 --> 00:14:22,666
订单里头啊

354
00:14:22,666 --> 00:14:25,366
我们注意到其中有最后两个属性

355
00:14:25,366 --> 00:14:26,799
我们中间加了一个斜杠

356
00:14:28,333 --> 00:14:31,266
就是这个和这个这两个

357
00:14:31,266 --> 00:14:33,733
加斜杠的原因是因为这两个东西

358
00:14:33,733 --> 00:14:35,366
其实我们在做需求分析的时候

359
00:14:35,366 --> 00:14:37,866
我们觉得他可以从后面东西算出来

360
00:14:38,533 --> 00:14:40,366
就是后面到底有多少东西

361
00:14:40,733 --> 00:14:42,799
它的价格加起来就是它的折扣

362
00:14:42,800 --> 00:14:43,666
钱的价格

363
00:14:44,133 --> 00:14:47,399
它的呃这个折扣价格

364
00:14:47,400 --> 00:14:51,333
折扣点加起来就是它的这个折让价格

365
00:14:51,900 --> 00:14:52,700
对吧

366
00:14:52,866 --> 00:14:55,933
然后其实祭典支付的话也能算出来

367
00:14:55,933 --> 00:14:57,799
就是他这个啊

368
00:14:57,800 --> 00:14:58,466
不这个不能算

369
00:14:58,466 --> 00:14:59,199
算不出来啊

370
00:14:59,200 --> 00:15:00,366
就后面两个是可以

371
00:15:00,366 --> 00:15:01,399
是可以算出来

372
00:15:01,533 --> 00:15:05,266
所以这个我们称之为derived attribution

373
00:15:05,400 --> 00:15:08,300
叫做可推算的属性

374
00:15:08,700 --> 00:15:09,500
可推算的属性

375
00:15:09,500 --> 00:15:11,600
会不会真正变成对象的属性

376
00:15:11,600 --> 00:15:12,766
变成数据库里的字段

377
00:15:12,800 --> 00:15:14,566
这个你自己去考量

378
00:15:14,700 --> 00:15:15,933
但是我们在领域模型中间

379
00:15:15,933 --> 00:15:17,066
其实要把它描述出来

380
00:15:17,066 --> 00:15:19,099
说这些属性其实是可以算出来的

381
00:15:19,333 --> 00:15:20,933
那后面怎么去处理啊

382
00:15:20,933 --> 00:15:22,666
这个就是后面的事情

383
00:15:23,600 --> 00:15:24,533
在明细里头

384
00:15:24,533 --> 00:15:26,999
其实我们应该记的进度更多的东西啊

385
00:15:27,000 --> 00:15:27,900
从需求上来说

386
00:15:27,900 --> 00:15:29,266
不仅仅要记数量

387
00:15:29,600 --> 00:15:31,400
要记折扣的

388
00:15:32,133 --> 00:15:33,399
这个祭典

389
00:15:33,666 --> 00:15:35,699
因为我们可以用祭典来支付祭典相

390
00:15:35,700 --> 00:15:37,166
当于那个京豆啊

391
00:15:37,166 --> 00:15:38,399
京东的京豆应该大家知道

392
00:15:38,400 --> 00:15:39,100
你买了东西

393
00:15:39,100 --> 00:15:41,400
买了以后他都可以返京豆是吧

394
00:15:41,400 --> 00:15:42,800
好像买1,000多块钱返

395
00:15:43,166 --> 00:15:44,099
买100块钱返一个吧

396
00:15:44,100 --> 00:15:45,200
好像是这样

397
00:15:45,466 --> 00:15:47,133
那个金豆是可以用来支付的

398
00:15:47,133 --> 00:15:48,566
所以我们的祭典就是金豆啊

399
00:15:48,566 --> 00:15:49,766
就是那同样的东西

400
00:15:50,066 --> 00:15:51,533
那如果顾客在支付的时候

401
00:15:51,533 --> 00:15:53,566
他用祭典去支付了

402
00:15:54,366 --> 00:15:57,266
这个祭典是要积点啊

403
00:15:57,266 --> 00:16:00,399
是要折算到每一个订单上的

404
00:16:00,400 --> 00:16:01,500
每一个订单明细上的

405
00:16:01,500 --> 00:16:03,733
为啥呢因为会退款

406
00:16:04,466 --> 00:16:05,566
会退款的话

407
00:16:06,466 --> 00:16:07,799
到底退多少钱

408
00:16:07,800 --> 00:16:09,100
退多少积点

409
00:16:09,766 --> 00:16:11,899
那你要看每一个东西来定

410
00:16:11,900 --> 00:16:13,900
所以要按照他那个价格的比例

411
00:16:13,900 --> 00:16:17,866
去折算到每一个订单明细上头

412
00:16:18,133 --> 00:16:20,399
那单价也是一样的

413
00:16:20,600 --> 00:16:24,100
因为我们会有多个商品的优惠活动

414
00:16:24,333 --> 00:16:25,666
比如说三个商品

415
00:16:26,266 --> 00:16:28,599
第三件半价

416
00:16:29,333 --> 00:16:30,166
那第三件就折了

417
00:16:30,166 --> 00:16:31,299
半价是吧

418
00:16:31,733 --> 00:16:34,499
呃那退款怎么办

419
00:16:35,700 --> 00:16:36,500
退款的话

420
00:16:36,500 --> 00:16:39,500
我们是要把三件的折让的价钱

421
00:16:39,500 --> 00:16:42,200
平分到每一个商品上

422
00:16:42,533 --> 00:16:43,933
因为避免什么呢

423
00:16:43,933 --> 00:16:47,466
避免用户把前面的全价商品退掉

424
00:16:47,866 --> 00:16:49,766
留下后面那个半价的商品

425
00:16:49,766 --> 00:16:51,899
对吧这个是明显不合理的

426
00:16:52,066 --> 00:16:54,566
所以退款的方面啊

427
00:16:54,566 --> 00:16:55,533
有两种做法

428
00:16:55,533 --> 00:16:56,299
一种做法是

429
00:16:56,300 --> 00:16:57,100
你记住

430
00:16:57,466 --> 00:17:00,499
所有的东西他是捆绑在一起买的

431
00:17:00,500 --> 00:17:01,333
所以要退

432
00:17:01,333 --> 00:17:02,133
全退

433
00:17:02,366 --> 00:17:04,566
我们像这个领域模型是不支持的

434
00:17:05,366 --> 00:17:05,899
大家注意看

435
00:17:05,900 --> 00:17:08,966
我们现在领模型是不支持把所有

436
00:17:08,966 --> 00:17:10,266
比如说我买三件

437
00:17:10,266 --> 00:17:11,266
第三件半价

438
00:17:11,266 --> 00:17:12,799
那要正常一种做法

439
00:17:12,800 --> 00:17:14,966
就是把三件东西做成一个整体

440
00:17:15,066 --> 00:17:15,799
你退一件

441
00:17:15,800 --> 00:17:17,766
都要把另外两件一起退掉才行

442
00:17:17,766 --> 00:17:19,299
对吧我们现在这个领模型

443
00:17:19,300 --> 00:17:20,366
是不支持这样子的

444
00:17:20,566 --> 00:17:21,899
我们现在这个领域模型支持什么呢

445
00:17:21,900 --> 00:17:23,300
支持说一件件退

446
00:17:23,300 --> 00:17:23,966
但是他实际上

447
00:17:23,966 --> 00:17:27,799
把折扣价格折到了每一件的上面

448
00:17:28,400 --> 00:17:30,000
这个就是领域模型

449
00:17:30,066 --> 00:17:31,933
决定了你的需求做成什么样

450
00:17:32,300 --> 00:17:33,533
你如果说要做成

451
00:17:33,533 --> 00:17:35,933
说要知道三个东西是绑在一起的

452
00:17:36,100 --> 00:17:37,766
要退这三个东西必须一起退

453
00:17:38,266 --> 00:17:41,299
那这个还得要做新的概念出来

454
00:17:41,933 --> 00:17:43,766
现在这个领域模型就只能做到

455
00:17:44,166 --> 00:17:46,366
我会把价格算到每一个上头

456
00:17:46,366 --> 00:17:48,333
所以每一个的折扣单价是多少

457
00:17:48,333 --> 00:17:50,133
退的时候就只退那一个东西

458
00:17:50,966 --> 00:17:52,766
所以这是那个discount price

459
00:17:53,300 --> 00:17:55,133
那其实除了这个以外还需要别的啊

460
00:17:55,133 --> 00:17:56,933
我之后在客户再把它补上来

461
00:17:57,100 --> 00:17:57,933
还需要知道什么呢

462
00:17:57,933 --> 00:17:59,866
还需要知道它的分账的

463
00:17:59,966 --> 00:18:01,133
分账的金额

464
00:18:01,300 --> 00:18:03,100
因为每一个商品的分账比例

465
00:18:03,100 --> 00:18:03,900
是不一样的

466
00:18:04,166 --> 00:18:05,466
所以当时支付的时候

467
00:18:05,466 --> 00:18:07,399
多少钱多少钱会分给平台

468
00:18:07,533 --> 00:18:09,066
需要在这里把它记录下来

469
00:18:09,166 --> 00:18:10,299
为什么要这里记录下来

470
00:18:10,300 --> 00:18:11,366
因为你在退款的时候

471
00:18:11,366 --> 00:18:12,899
先要用平台退给商户

472
00:18:12,900 --> 00:18:14,000
商户推给顾客

473
00:18:14,200 --> 00:18:15,466
所以这里不记的话

474
00:18:15,600 --> 00:18:16,866
退款商就没有办法

475
00:18:17,166 --> 00:18:18,733
所以这样的一个订单明细啊

476
00:18:18,733 --> 00:18:19,699
不是大家想象的

477
00:18:19,700 --> 00:18:20,666
那么就放一个东西

478
00:18:20,666 --> 00:18:21,266
放一个数量

479
00:18:21,266 --> 00:18:22,299
放一个价格就完了

480
00:18:22,300 --> 00:18:23,766
他其实还要放很多

481
00:18:24,166 --> 00:18:26,899
为了退款所需要放的属性啊

482
00:18:26,900 --> 00:18:28,100
放到这个明细里头

483
00:18:28,200 --> 00:18:29,600
而这些很多的属性

484
00:18:29,600 --> 00:18:32,200
其实对于普通顾客来说是看不到的

485
00:18:32,466 --> 00:18:34,666
他是为了商户来服务的

486
00:18:34,666 --> 00:18:37,766
为了商户来退款来计算的啊

487
00:18:38,066 --> 00:18:39,533
这是明细

488
00:18:40,400 --> 00:18:41,566
那商品来说啊

489
00:18:41,566 --> 00:18:43,699
我们这里的从订单领域来说

490
00:18:43,700 --> 00:18:45,733
他看到的商品都是有价格的对吧

491
00:18:45,733 --> 00:18:47,566
你放到订单里的商品如果没有价格

492
00:18:47,566 --> 00:18:48,866
那怎么买的是吧

493
00:18:49,000 --> 00:18:51,000
所以我们这里应该知道一点

494
00:18:51,000 --> 00:18:53,866
就是我们这里所看到的商品和商品

495
00:18:53,866 --> 00:18:54,933
产品模块中间

496
00:18:54,933 --> 00:18:57,799
所看到的商品不是同一个东西

497
00:18:58,666 --> 00:18:59,466
不是同一个东西

498
00:18:59,466 --> 00:19:01,699
因为在产品中间的那个商品

499
00:19:01,800 --> 00:19:03,133
是没有价格的

500
00:19:03,133 --> 00:19:04,866
他是在销售上有价格

501
00:19:04,933 --> 00:19:05,533
但在我们这里

502
00:19:05,533 --> 00:19:07,599
看到的是一个有价格的东西

503
00:19:07,866 --> 00:19:08,366
所以

504
00:19:08,366 --> 00:19:11,099
这就是我们在分子领域建模的时候

505
00:19:11,100 --> 00:19:13,166
我们可以在每一个子领域中间

506
00:19:13,166 --> 00:19:16,166
对于同一个东西是有不同的认识的

507
00:19:16,500 --> 00:19:17,600
但这个东西从哪来

508
00:19:17,666 --> 00:19:20,866
这个东西就是从产品之领域来的

509
00:19:20,866 --> 00:19:21,933
所以产品之领域

510
00:19:21,933 --> 00:19:23,666
必须得要为订单之领域

511
00:19:23,666 --> 00:19:25,599
提供这样的一个东西

512
00:19:25,600 --> 00:19:26,766
至于他怎么提供

513
00:19:27,200 --> 00:19:28,666
那是产品这领域的问题

514
00:19:28,666 --> 00:19:30,133
我只管我订单这领域

515
00:19:30,133 --> 00:19:30,899
所要看的商品

516
00:19:30,900 --> 00:19:32,700
就是一个有名字有价格的东西

517
00:19:32,900 --> 00:19:33,700
当然我们知道

518
00:19:33,700 --> 00:19:36,966
这个价格不是现在销售的价格是什么

519
00:19:37,733 --> 00:19:40,099
是下订单当时的价格

520
00:19:40,400 --> 00:19:41,933
对吧我这个订单里的明细

521
00:19:41,933 --> 00:19:42,066
就是

522
00:19:42,066 --> 00:19:44,566
我把它放到这个订单明细里头的时候

523
00:19:45,100 --> 00:19:46,933
这个订单成交的时候啊

524
00:19:46,933 --> 00:19:48,599
其实这个订单成交的时候

525
00:19:48,600 --> 00:19:49,900
这个东西的价格是多少

526
00:19:49,900 --> 00:19:51,166
那就一直会这样

527
00:19:51,566 --> 00:19:54,533
这是我们的订单指领域的模型

528
00:19:59,266 --> 00:20:00,099
顾客顾客

529
00:20:00,100 --> 00:20:01,300
我们知道主要是三个事情

530
00:20:01,300 --> 00:20:05,000
顾客购物券和地址啊

531
00:20:05,100 --> 00:20:07,733
还有还有一个购物车啊

532
00:20:08,266 --> 00:20:10,066
这个地址

533
00:20:10,066 --> 00:20:12,466
购物车顾客这个应该没什么好说的

534
00:20:12,800 --> 00:20:15,200
呃我们这里可能要跟大家解释一下

535
00:20:15,200 --> 00:20:18,200
我们对于优惠券的这个内涵的定义

536
00:20:18,200 --> 00:20:19,000
是什么

537
00:20:19,933 --> 00:20:20,799
优惠券啊

538
00:20:20,800 --> 00:20:24,366
我们这里内涵定义就是指优惠的券

539
00:20:24,866 --> 00:20:26,666
把优惠两个字去掉啊

540
00:20:26,666 --> 00:20:27,766
就是指券

541
00:20:28,200 --> 00:20:30,600
什么呢它就是实际上是一张券

542
00:20:30,600 --> 00:20:31,900
这张券可以打折

543
00:20:31,900 --> 00:20:33,100
但这个折呢

544
00:20:33,200 --> 00:20:36,466
优惠呢这个定义并不在优惠券里头

545
00:20:36,800 --> 00:20:37,666
优惠定义在哪呢

546
00:20:37,666 --> 00:20:38,866
在优惠活动里头

547
00:20:39,333 --> 00:20:43,499
所以我们对于优惠券的定义是定

548
00:20:43,500 --> 00:20:45,133
它的内涵的定义是这样的

549
00:20:45,166 --> 00:20:48,733
是针对优惠活动的数量控制

550
00:20:49,066 --> 00:20:50,866
不是这个优惠活动是要有数量的

551
00:20:50,866 --> 00:20:52,866
我比如这个优惠活动做的最多做100份

552
00:20:52,866 --> 00:20:53,933
或者做200份

553
00:20:54,600 --> 00:20:57,966
那我就只能发出100张或者200张优惠券

554
00:20:58,200 --> 00:20:59,666
谁有这个优惠券

555
00:20:59,900 --> 00:21:01,600
才能参与这个优惠活动

556
00:21:01,700 --> 00:21:02,666
没有这个优惠券

557
00:21:02,666 --> 00:21:04,199
就不能参与这个优惠活动

558
00:21:04,200 --> 00:21:05,466
就起个这样作用啊

559
00:21:05,466 --> 00:21:06,299
所以我们的优惠券

560
00:21:06,300 --> 00:21:07,100
其实这这个

561
00:21:07,100 --> 00:21:09,500
这个内涵的定义是这样的一个定义

562
00:21:09,700 --> 00:21:12,300
当然我说的这个内涵的定义是什么呢

563
00:21:12,300 --> 00:21:14,733
是我们在领域模型中间

564
00:21:14,733 --> 00:21:15,533
内涵定义

565
00:21:15,766 --> 00:21:18,133
你给顾客看起来

566
00:21:18,133 --> 00:21:19,466
给他的主参与者

567
00:21:19,466 --> 00:21:21,733
顾客看起来优惠券就是可以打折的

568
00:21:21,733 --> 00:21:23,766
我有这个优惠券才是可以打折

569
00:21:23,933 --> 00:21:25,899
但是在我们的领域模型中间

570
00:21:25,900 --> 00:21:29,133
我把我们把顾客眼中的那个优惠券

571
00:21:29,600 --> 00:21:31,200
把它切成了两个概念

572
00:21:31,200 --> 00:21:33,133
一个是优惠券就是券

573
00:21:33,466 --> 00:21:34,733
一个是优惠

574
00:21:34,866 --> 00:21:36,199
那是优惠活动啊

575
00:21:36,200 --> 00:21:37,400
把它切成两个概念

576
00:21:37,533 --> 00:21:41,499
所以一个优惠券一定是属于啊

577
00:21:41,500 --> 00:21:42,466
这个写反了

578
00:21:42,600 --> 00:21:43,466
这个写反了啊

579
00:21:43,466 --> 00:21:45,066
这个看这关系应该在下面

580
00:21:45,566 --> 00:21:46,699
一个优惠券一

581
00:21:46,700 --> 00:21:48,800
一定是属于一个优惠活动的

582
00:21:48,800 --> 00:21:50,766
所以他这个一对多的关系啊

583
00:21:50,766 --> 00:21:53,933
所以是从优惠活动是整体

584
00:21:54,200 --> 00:21:56,066
优惠券是局部

585
00:21:56,066 --> 00:21:58,699
是这样的一个关系啊

586
00:21:58,800 --> 00:22:00,100
那同样我们也记住了

587
00:22:00,100 --> 00:22:03,800
一个优惠券是某一个商铺来发的

588
00:22:03,900 --> 00:22:05,766
这个其实在领域目前中间

589
00:22:06,400 --> 00:22:09,400
你应该知道优惠活动是某一个商铺的

590
00:22:09,600 --> 00:22:12,266
所以当然优惠活动所发出来的优惠券

591
00:22:12,266 --> 00:22:13,299
当然是某个商铺的

592
00:22:13,300 --> 00:22:14,266
但是我们在柠檬中间

593
00:22:14,266 --> 00:22:17,066
我们把它直接做了这样的一个记录啊

594
00:22:17,066 --> 00:22:17,999
做了这样记录

595
00:22:18,200 --> 00:22:19,533
其他的应该没啥

596
00:22:20,500 --> 00:22:23,400
其他的概念应该没有什么特别可以讲

597
00:22:23,800 --> 00:22:24,666
一眼就能看出来

598
00:22:24,666 --> 00:22:25,799
所以这里一定知道

599
00:22:25,800 --> 00:22:27,200
我们在定义领域模型的时候

600
00:22:27,200 --> 00:22:29,066
他的概念的内涵

601
00:22:29,700 --> 00:22:30,966
要把它明确下来啊

602
00:22:30,966 --> 00:22:32,066
要把它明确下来

603
00:22:33,566 --> 00:22:35,599
呃大家在交作业的时候

604
00:22:35,600 --> 00:22:36,366
因为我在上课时候

605
00:22:36,366 --> 00:22:38,666
我们并没有在礼仪蒙下面写文字解释

606
00:22:38,666 --> 00:22:40,266
啊大家在交作业的时候

607
00:22:40,266 --> 00:22:43,066
最好在下面去写他的文字解释

608
00:22:47,933 --> 00:22:49,066
呃售后

609
00:22:50,533 --> 00:22:54,733
售后的部分最核心的是售后和仲裁

610
00:22:54,733 --> 00:22:57,166
就是我们说的这两个东西啊

611
00:22:57,166 --> 00:22:59,399
这里头要解释的是什么呢

612
00:22:59,400 --> 00:23:03,200
就是售后和product之间的关系

613
00:23:03,533 --> 00:23:06,066
我们知道售后是因为一个订单而起的

614
00:23:06,066 --> 00:23:08,499
就上面那个订单的明细

615
00:23:08,666 --> 00:23:09,933
里头的一项东西

616
00:23:10,366 --> 00:23:11,799
就会产生一个售后

617
00:23:11,800 --> 00:23:12,666
所以你需要知道

618
00:23:12,666 --> 00:23:15,099
这个订单明细的这个东西是产生售后

619
00:23:15,600 --> 00:23:18,100
但是当售后做的过程中间

620
00:23:18,100 --> 00:23:21,766
它其实是跟我们具体的商品有关

621
00:23:21,766 --> 00:23:23,866
和具体的串号有关

622
00:23:23,866 --> 00:23:24,299
我们首先说

623
00:23:24,300 --> 00:23:26,133
为什么说它跟具体的商品有关

624
00:23:26,466 --> 00:23:29,799
因为如果这个售后是需要做服务的

625
00:23:30,133 --> 00:23:32,999
所以他要从这个售后所关联的商品

626
00:23:33,000 --> 00:23:34,200
去找到这个商品

627
00:23:34,200 --> 00:23:36,666
提在这个地区提供的服务商是谁

628
00:23:36,800 --> 00:23:39,566
然后由这个服务商去完成这个服务

629
00:23:39,933 --> 00:23:42,899
所以我们当从一个order item

630
00:23:42,900 --> 00:23:46,000
产生一个售后以后

631
00:23:46,366 --> 00:23:48,099
当啊

632
00:23:48,100 --> 00:23:50,133
商铺的管理员批准了这样的一个售后

633
00:23:50,133 --> 00:23:52,199
以后这个售后就必须要建立

634
00:23:52,200 --> 00:23:54,800
这个售后到底是服务什么商品的

635
00:23:55,100 --> 00:23:56,266
所以我们会建立一个

636
00:23:56,266 --> 00:23:58,333
售后和商品之间的关系

637
00:23:58,500 --> 00:23:59,400
这个应该没问题吧

638
00:23:59,400 --> 00:24:01,300
这个关系并不是一开始建立的

639
00:24:01,300 --> 00:24:03,266
而是平台啊

640
00:24:03,266 --> 00:24:03,866
店铺管理员

641
00:24:03,866 --> 00:24:06,066
在审核这个售后是OK的情况下头

642
00:24:06,300 --> 00:24:07,166
然后去建

643
00:24:07,166 --> 00:24:08,733
立的这样的一个关系

644
00:24:09,566 --> 00:24:11,566
那为什么上面还有一个product item

645
00:24:12,133 --> 00:24:12,866
这个关系

646
00:24:12,866 --> 00:24:15,299
就上面那个product item那个概念的内涵

647
00:24:15,300 --> 00:24:17,700
是一个具体的东西

648
00:24:18,000 --> 00:24:19,166
每一件啊

649
00:24:19,166 --> 00:24:20,166
具体的东西

650
00:24:20,500 --> 00:24:20,900
为什么

651
00:24:20,900 --> 00:24:23,866
我们会需要定义这样的一个概念

652
00:24:23,866 --> 00:24:26,333
原因是因为我们有一些的这个售后

653
00:24:26,333 --> 00:24:27,399
比如手机啊

654
00:24:27,900 --> 00:24:31,900
手机你说你要这个保保修啊

655
00:24:31,900 --> 00:24:33,933
寄回来寄回来以后呢

656
00:24:34,266 --> 00:24:38,366
售后的人验了货说可以这个保修

657
00:24:39,100 --> 00:24:41,900
那可以保修的话怎么办

658
00:24:42,300 --> 00:24:44,800
要需要把这个东西的串号给记上了

659
00:24:44,900 --> 00:24:46,200
因为他要去修

660
00:24:46,600 --> 00:24:47,266
修完了以后

661
00:24:47,266 --> 00:24:49,699
你要把这个东西再还给顾客

662
00:24:49,700 --> 00:24:51,333
你不能记错了是吧

663
00:24:51,700 --> 00:24:55,500
所以说我们需要在验货以后

664
00:24:55,766 --> 00:24:58,199
把这个商品的串号

665
00:24:59,766 --> 00:25:01,533
在这个系统中间去记录下来

666
00:25:01,700 --> 00:25:02,600
那这个串号是什么

667
00:25:02,600 --> 00:25:03,600
这个串号实际上是

668
00:25:03,600 --> 00:25:05,500
每一个商品是不同的

669
00:25:05,566 --> 00:25:07,166
所以下面这个商品的内涵

670
00:25:07,166 --> 00:25:08,533
是指我们说的

671
00:25:09,900 --> 00:25:11,733
店铺卖的一个商品

672
00:25:12,166 --> 00:25:13,933
上面那个product it呢

673
00:25:13,933 --> 00:25:17,066
则是一个具体的东西啊

674
00:25:17,066 --> 00:25:18,766
则是一个具体的东西

675
00:25:20,133 --> 00:25:21,299
啊所以验货了以后

676
00:25:21,300 --> 00:25:23,966
我们需要把具体拿到的这个商品

677
00:25:23,966 --> 00:25:25,599
到底他的串号是什么

678
00:25:26,300 --> 00:25:28,566
把他跟我们的这个售后单啊

679
00:25:28,566 --> 00:25:29,699
给他建立一个关系

680
00:25:29,700 --> 00:25:30,666
知道我们这个售后单

681
00:25:30,666 --> 00:25:32,599
最后服务的这个商品的串号

682
00:25:32,866 --> 00:25:34,699
是这样的一个东西

683
00:25:34,700 --> 00:25:37,200
这样避免说最后再寄回给顾客的时候

684
00:25:37,200 --> 00:25:38,933
会产生错误

685
00:25:40,366 --> 00:25:42,899
啊这是服务单啊

686
00:25:42,900 --> 00:25:43,766
售售后单

687
00:25:43,766 --> 00:25:45,866
然后售后单跟店铺啊

688
00:25:45,866 --> 00:25:48,333
售后单跟顾客之间的关系

689
00:25:48,500 --> 00:25:50,733
包括仲裁跟顾客

690
00:25:50,733 --> 00:25:52,333
仲裁跟店铺之间的关系啊

691
00:25:52,333 --> 00:25:54,666
这个应该没有什么特别多的

692
00:25:54,666 --> 00:25:55,933
要去解释的

693
00:25:57,166 --> 00:25:58,066
最后是服务

694
00:25:59,200 --> 00:26:00,133
服务的部分来说

695
00:26:00,133 --> 00:26:03,066
我们知道我们其实主要是两个内容

696
00:26:03,066 --> 00:26:03,966
一个是服务

697
00:26:03,966 --> 00:26:05,199
一个是服务单

698
00:26:07,800 --> 00:26:08,666
呃三个内容啊

699
00:26:08,666 --> 00:26:09,533
一个是服务商

700
00:26:09,533 --> 00:26:10,266
一个是服务

701
00:26:10,266 --> 00:26:11,266
一个是服务单

702
00:26:12,200 --> 00:26:14,800
我们首先对于这个啊

703
00:26:14,800 --> 00:26:15,800
服务商的内涵

704
00:26:15,800 --> 00:26:18,066
就是在平台上并不是卖东西

705
00:26:18,166 --> 00:26:21,299
而是提供售前和售后服务的

706
00:26:21,300 --> 00:26:22,333
这是他的内涵

707
00:26:22,866 --> 00:26:25,066
对于服务的这个内涵的定义是

708
00:26:25,133 --> 00:26:26,899
服务商在某一个地区

709
00:26:26,900 --> 00:26:28,800
他要提供什么样的服务

710
00:26:29,500 --> 00:26:32,333
所以服务商会建立在

711
00:26:32,333 --> 00:26:35,666
针对在某个地区去建立一个服务

712
00:26:35,666 --> 00:26:37,333
在服务里头去描述说他想干嘛

713
00:26:37,333 --> 00:26:38,166
在这个地区

714
00:26:39,066 --> 00:26:41,966
那服务是怎么跟商品关联起来的

715
00:26:41,966 --> 00:26:47,333
是因为商铺在这个地区他有商品

716
00:26:47,333 --> 00:26:48,333
他有商品要卖

717
00:26:48,333 --> 00:26:49,599
所以他在这个地区去探索

718
00:26:49,600 --> 00:26:51,500
这个地区到底提供了些什么样的服务

719
00:26:51,800 --> 00:26:52,933
所以他看到这个服务

720
00:26:52,933 --> 00:26:54,766
觉得这个服务适合他的商品

721
00:26:55,166 --> 00:26:56,499
所以他就会选择说

722
00:26:56,500 --> 00:26:59,466
把这个服务和他的商品关联起来

723
00:26:59,466 --> 00:27:01,133
建立一个关系

724
00:27:01,133 --> 00:27:03,533
说我这个商品用它来服务

725
00:27:04,000 --> 00:27:05,666
而且我们可以看到

726
00:27:06,266 --> 00:27:07,733
我们建立了一个

727
00:27:08,333 --> 00:27:11,333
这个店铺和服务之间的关系

728
00:27:12,700 --> 00:27:15,466
呃这个主要是我们想要知道

729
00:27:15,466 --> 00:27:17,599
说一个店铺到底到每个地区

730
00:27:17,600 --> 00:27:19,200
选择了什么样的服务

731
00:27:19,200 --> 00:27:21,533
而不是要通过一个店铺

732
00:27:21,600 --> 00:27:23,300
他所关联的商品

733
00:27:23,466 --> 00:27:25,199
然后再去看到他的服务

734
00:27:25,200 --> 00:27:26,300
所以这个关系呢

735
00:27:26,300 --> 00:27:27,966
建立还是不建立

736
00:27:27,966 --> 00:27:29,066
这个大家可以考虑

737
00:27:29,066 --> 00:27:31,299
我们现在是有划了这样的一个关系

738
00:27:31,600 --> 00:27:32,300
在之后做的时候

739
00:27:32,300 --> 00:27:34,466
再看这个关系有没有必要啊

740
00:27:34,466 --> 00:27:37,933
这个其实是可以从商铺和商品的关系

741
00:27:37,933 --> 00:27:39,066
推演出来

742
00:27:39,066 --> 00:27:39,766
在这个地区

743
00:27:39,766 --> 00:27:40,899
但是大家知道

744
00:27:40,900 --> 00:27:42,700
如果从商铺的商品

745
00:27:42,700 --> 00:27:44,166
在这个地区的所有的服务

746
00:27:44,166 --> 00:27:44,866
把它推演出来

747
00:27:44,866 --> 00:27:47,333
这个关系有点绕啊

748
00:27:47,333 --> 00:27:48,733
他推出来比较麻烦所

749
00:27:48,733 --> 00:27:48,766
以

750
00:27:48,766 --> 00:27:51,133
我们就直接把这个关系给他建立出来

751
00:27:51,166 --> 00:27:54,933
也就是当这个商铺选定这个商品

752
00:27:55,066 --> 00:27:57,666
在这个地区有这个服务来提供的时候

753
00:27:57,666 --> 00:27:58,499
我们同样也建立

754
00:27:58,500 --> 00:28:00,400
这个服务和商铺之间的关系

755
00:28:01,200 --> 00:28:03,900
这是上半段啊

756
00:28:03,900 --> 00:28:05,100
那下半段的话

757
00:28:05,100 --> 00:28:07,066
主要是他的服务单

758
00:28:07,566 --> 00:28:10,599
所以如果说这个商品是在这个地区

759
00:28:10,600 --> 00:28:13,733
由这个服务商的服务来提供的话

760
00:28:15,600 --> 00:28:18,400
那就会产生一个服务单啊

761
00:28:18,400 --> 00:28:18,966
就会产生一个

762
00:28:18,966 --> 00:28:20,333
我们现在并没有建立

763
00:28:20,333 --> 00:28:24,066
这个服务单和服务之间的关系

764
00:28:24,466 --> 00:28:25,666
这个要不要建立呢

765
00:28:26,000 --> 00:28:28,166
其实要建立也可以啊

766
00:28:28,200 --> 00:28:29,133
要建立也可以

767
00:28:29,133 --> 00:28:31,066
我们现在没有没有划这个关系

768
00:28:31,933 --> 00:28:32,899
这个服务单

769
00:28:33,966 --> 00:28:38,366
他如果说被某一个商铺接单了

770
00:28:38,466 --> 00:28:40,099
我们选择的方式是

771
00:28:40,100 --> 00:28:45,100
并不是由这个让他跟服务建立关系

772
00:28:45,100 --> 00:28:46,366
而是让他直接跟

773
00:28:47,733 --> 00:28:48,899
服务商建立关系

774
00:28:49,133 --> 00:28:50,966
好像还是要跟服务建立关系

775
00:28:50,966 --> 00:28:53,799
要不然这个服务商是不知道说

776
00:28:53,800 --> 00:28:54,933
他有哪一些

777
00:28:55,666 --> 00:28:57,799
哪一些服务单是可以接的

778
00:28:57,800 --> 00:29:00,466
是吧因为服务单是由商铺产生的

779
00:29:00,800 --> 00:29:02,666
但是服务商其实并不知道说

780
00:29:02,666 --> 00:29:04,766
这个服务单是哪些

781
00:29:04,766 --> 00:29:05,766
服务单是可以接的

782
00:29:05,766 --> 00:29:06,066
所以

783
00:29:06,066 --> 00:29:08,499
要建立这个服务单和服务之间的关系

784
00:29:08,900 --> 00:29:10,933
然后服务商如果决定之后

785
00:29:10,933 --> 00:29:12,266
他可以接这个单

786
00:29:12,300 --> 00:29:15,366
他再建立他跟服务单之间的关系

787
00:29:15,466 --> 00:29:16,899
后面的同学有问题吗

788
00:29:17,566 --> 00:29:18,533
啊没问题啊

789
00:29:19,100 --> 00:29:21,266
所以这样的话啊

790
00:29:21,333 --> 00:29:22,366
才会建立说

791
00:29:22,366 --> 00:29:25,566
服务单和服务商之间的关系

792
00:29:25,666 --> 00:29:28,166
那服务单是服务顾客的

793
00:29:28,333 --> 00:29:30,566
那服务单如果涉及到送修的话

794
00:29:30,566 --> 00:29:34,299
就会有这个快递单啊

795
00:29:34,300 --> 00:29:37,166
如果说这个服务是要记录串号的

796
00:29:37,266 --> 00:29:39,499
那这个服务单上的其实要有串号

797
00:29:40,133 --> 00:29:42,533
也就是比如说维修一个手机或者维修

798
00:29:42,533 --> 00:29:43,399
一个空调

799
00:29:43,533 --> 00:29:43,799
其实

800
00:29:43,800 --> 00:29:47,366
都需要把串号记录在这个服务单上面

801
00:29:47,600 --> 00:29:49,866
这个是这个

802
00:29:49,933 --> 00:29:52,966
呃服务子女啊

803
00:29:52,966 --> 00:29:53,699
领域模型里头

804
00:29:53,700 --> 00:29:56,733
可能还是会有若干不合理的地方

805
00:29:56,733 --> 00:29:56,899
那

806
00:29:56,900 --> 00:30:00,766
大家在第二阶段的这个对象模型中间

807
00:30:00,766 --> 00:30:01,966
去改正吧

808
00:30:02,133 --> 00:30:04,066
然后提说

809
00:30:04,066 --> 00:30:06,799
这个领域模型还有什么想动的地方

810
00:30:06,800 --> 00:30:08,366
然后我就把领域模型

811
00:30:08,366 --> 00:30:10,899
去同步的去改过来

812
00:30:11,366 --> 00:30:12,766
只是给大家一个参考

813
00:30:12,766 --> 00:30:15,266
让大家以此为基准去做

814
00:30:15,366 --> 00:30:17,499
对象模型和数据库的设计

815
00:30:17,900 --> 00:30:18,766
这块有问题吗

816
00:30:18,766 --> 00:30:18,999
因为

817
00:30:19,000 --> 00:30:22,700
这跟大家的第二阶段的作业有关系

818
00:30:24,200 --> 00:30:25,066
所以下一周

819
00:30:25,066 --> 00:30:25,666
这个周末

820
00:30:25,666 --> 00:30:29,333
应该想发言的小组要教你们的

821
00:30:29,333 --> 00:30:30,099
对象模型

822
00:30:30,100 --> 00:30:32,066
状态设计和数据库的设计了

823
00:30:32,066 --> 00:30:33,533
还有API四个东西

824
00:30:34,300 --> 00:30:36,266
API对象模型

825
00:30:36,866 --> 00:30:37,666
状态设计

826
00:30:37,666 --> 00:30:39,066
还有数据库设计了

827
00:30:39,366 --> 00:30:42,166
那主要就是两个

828
00:30:42,333 --> 00:30:46,133
指领域的两个选做的部分啊

829
00:30:46,900 --> 00:30:49,400
软工那边是要交需求分析作业了是吧

830
00:30:49,400 --> 00:30:50,900
美工老师的要求是什么

831
00:30:51,666 --> 00:30:52,466
还没讲

832
00:31:01,200 --> 00:31:02,466
然后你们就选择说

833
00:31:02,466 --> 00:31:05,733
你们是做的订单顾客的

834
00:31:06,166 --> 00:31:07,766
还是啊

835
00:31:07,766 --> 00:31:09,199
你可以按照你们之前那个选项

836
00:31:09,200 --> 00:31:11,100
也可以按照你们现在新的选项写

837
00:31:11,100 --> 00:31:12,200
也可以都可以

838
00:31:12,266 --> 00:31:14,499
就在你们之前选择是订单物流的

839
00:31:14,900 --> 00:31:15,733
然后

840
00:31:18,133 --> 00:31:19,366
对我说的是内容

841
00:31:19,366 --> 00:31:19,999
我说的是

842
00:31:20,000 --> 00:31:21,966
你们在需求规格说明书里写的内容

843
00:31:21,966 --> 00:31:22,866
写的是什么

844
00:31:24,566 --> 00:31:25,899
对啊我现在正在跟你说啊

845
00:31:25,966 --> 00:31:28,133
他告诉你说要交需求规格说明说明书

846
00:31:28,133 --> 00:31:30,399
我告诉你那里头要写的内容是写什么

847
00:31:30,533 --> 00:31:32,999
按照面向对象的这个选题

848
00:31:33,466 --> 00:31:34,899
你们自己选择哪个模块

849
00:31:34,900 --> 00:31:37,000
去写对应模块的需求规格说明书

850
00:31:37,000 --> 00:31:39,966
所以你们的选项可以选这个

851
00:31:40,000 --> 00:31:42,066
订单和物流

852
00:31:42,800 --> 00:31:44,600
顾客售后和服务

853
00:31:44,600 --> 00:31:45,966
或者按照新的选题写也可

854
00:31:45,966 --> 00:31:49,533
以新的就应该是订单和顾客

855
00:31:50,166 --> 00:31:53,066
售后和服务

856
00:31:53,166 --> 00:31:56,266
对我建议大家按照新的划分去写

857
00:31:56,933 --> 00:31:58,699
因为我跟我待会跟三位

858
00:31:58,733 --> 00:32:00,166
两位老师都讲一下

859
00:32:00,400 --> 00:32:01,933
就是内容

860
00:32:02,100 --> 00:32:04,200
就是按照你们新的那个选题去写

861
00:32:04,200 --> 00:32:05,933
需求个人说明书啊

862
00:32:05,933 --> 00:32:08,733
所以虽然这个b座任务我有发出去了

863
00:32:08,733 --> 00:32:09,933
我有在上面说了

864
00:32:09,933 --> 00:32:13,399
所以所有的同学在软工作业交完以后

865
00:32:13,466 --> 00:32:15,666
再把那个b座的任务

866
00:32:15,666 --> 00:32:17,299
更新到VT文档上去

867
00:32:17,566 --> 00:32:19,099
要不然大家交给软工的

868
00:32:19,100 --> 00:32:20,933
就变成一模一样的了

869
00:32:20,933 --> 00:32:21,733
是吧

870
00:32:21,800 --> 00:32:25,066
所以等软工的作业提交完了以后啊

871
00:32:25,066 --> 00:32:26,366
然后最后一轮的

872
00:32:26,366 --> 00:32:28,566
这个第一轮的必做的任务

873
00:32:28,566 --> 00:32:30,299
再更新到viki上

874
00:32:30,933 --> 00:32:31,966
这块有问题吗

875
00:32:34,166 --> 00:32:34,966
OK

876
00:32:37,600 --> 00:32:38,566
啊所以

877
00:32:41,733 --> 00:32:42,599
领域模型啊

878
00:32:42,600 --> 00:32:43,866
在交给软工的作业中间

879
00:32:43,866 --> 00:32:45,499
如果大家觉得还有改动的话

880
00:32:45,500 --> 00:32:46,766
可以继续去改

881
00:32:46,766 --> 00:32:47,933
但是需求的话

882
00:32:47,933 --> 00:32:50,299
就按照你们的领域模型所描述的

883
00:32:50,533 --> 00:32:51,466
这个能力

884
00:32:51,700 --> 00:32:53,500
去写他的需求啊

885
00:32:53,500 --> 00:32:54,933
领序模型做不到的

886
00:32:54,933 --> 00:32:58,466
这个部分就不要在需求里去说了啊

887
00:34:09,400 --> 00:34:11,333
好我们来说详细设计

888
00:34:16,900 --> 00:34:19,300
详细设计的前面一部分我们讲完了

889
00:34:19,300 --> 00:34:20,400
图怎么画啊

890
00:34:20,400 --> 00:34:22,400
所以大家应该针对图怎么画

891
00:34:22,400 --> 00:34:23,466
都比较清楚了

892
00:34:23,533 --> 00:34:25,799
我们下面开始讲它的实质的部分

893
00:34:25,800 --> 00:34:27,566
就怎么来做这个设计

894
00:34:27,666 --> 00:34:31,666
我们以地区这个模块为例啊

895
00:34:31,666 --> 00:34:33,066
因为地区模块最简单

896
00:34:33,066 --> 00:34:37,333
大家可以看到就一个对象一张表啊

897
00:34:37,566 --> 00:34:39,499
那这个部分来说

898
00:34:39,500 --> 00:34:41,866
怎么去做它直折驱动的设计

899
00:34:46,966 --> 00:34:47,199
首先

900
00:34:47,200 --> 00:34:49,700
我们要讲什么叫做职责驱动的设计啊

901
00:34:50,066 --> 00:34:52,566
我们知道在写面向对象的设计的时候

902
00:34:52,600 --> 00:34:54,800
代码的最基本的单位是什么

903
00:34:54,800 --> 00:34:56,266
是类和接口

904
00:34:56,733 --> 00:34:57,766
这是我们在面

905
00:34:57,766 --> 00:34:59,899
向对象之间最基本的设计单位

906
00:35:07,466 --> 00:35:09,166
类刚才在对象模型已经看到

907
00:35:09,166 --> 00:35:12,766
我们基本上给代码中间会有多少个类

908
00:35:13,133 --> 00:35:15,266
通过对象模型有做了一个设计啊

909
00:35:15,266 --> 00:35:16,866
这当然这不一定是最后的版本

910
00:35:17,066 --> 00:35:18,066
在对象模型设计中间

911
00:35:18,066 --> 00:35:20,666
我们基本上给这些类定义了它的属性

912
00:35:21,266 --> 00:35:22,899
对吧定义了它的关系

913
00:35:23,133 --> 00:35:25,566
那这是它的一个部分

914
00:35:25,733 --> 00:35:26,399
在命下对象中

915
00:35:26,400 --> 00:35:27,800
中间更重要的部分是

916
00:35:27,800 --> 00:35:29,866
这个类的职责是什么

917
00:35:29,866 --> 00:35:31,666
就是我们说的responsibility

918
00:35:32,066 --> 00:35:33,299
什么叫类的职责

919
00:35:33,500 --> 00:35:35,366
你直观的理解就是

920
00:35:35,366 --> 00:35:37,566
那个类除了属性以外

921
00:35:37,900 --> 00:35:39,166
它还要有方法

922
00:35:39,733 --> 00:35:42,199
我们说get say的方法并不算方法

923
00:35:42,200 --> 00:35:43,800
那是针对它属性的访问

924
00:35:43,800 --> 00:35:45,466
我们所说的职责

925
00:35:45,733 --> 00:35:47,799
是指除了get say的方法以外

926
00:35:47,800 --> 00:35:49,966
你还需要在这个类里头

927
00:35:50,166 --> 00:35:52,266
去写一些什么样的方法

928
00:35:52,600 --> 00:35:54,066
这个就是我们说的职责

929
00:35:54,266 --> 00:35:55,599
在面向对象设计过程中间

930
00:35:55,600 --> 00:35:56,766
我们其实知道

931
00:35:56,766 --> 00:36:01,499
我们设计的目标的最终的结果是功能

932
00:36:02,166 --> 00:36:04,666
就是不管是什么样的软件设计

933
00:36:04,666 --> 00:36:06,166
最终表现出来就是功能

934
00:36:06,366 --> 00:36:08,366
所以面向对象首先做的第一件事情

935
00:36:08,366 --> 00:36:10,199
就是把功能

936
00:36:14,566 --> 00:36:15,866
分解成为职责

937
00:36:20,866 --> 00:36:23,666
这个分解过程基本上会像什么呢

938
00:36:23,666 --> 00:36:25,299
会像我们传统的面相

939
00:36:25,300 --> 00:36:26,166
功能的分解

940
00:36:26,566 --> 00:36:28,966
就是把一个功能分成6个部分

941
00:36:29,066 --> 00:36:31,599
但是它分的方式不太一样

942
00:36:31,600 --> 00:36:33,333
就是它分的标准不太一样

943
00:36:33,333 --> 00:36:34,766
我们的目标叫做职责

944
00:36:35,066 --> 00:36:36,999
是因为分的这些东西

945
00:36:37,400 --> 00:36:39,666
是由每一个类来承担的

946
00:36:40,166 --> 00:36:41,333
所以我们在分的时候

947
00:36:41,333 --> 00:36:44,199
我们会说这个类它的属性是什么

948
00:36:44,200 --> 00:36:46,066
它就能够承担什么样的职责

949
00:36:46,066 --> 00:36:48,566
然后把这个职责变成这个类

950
00:36:48,666 --> 00:36:50,733
或者这个对象的方法

951
00:36:50,866 --> 00:36:52,666
这就是我们所说的第一个概念

952
00:36:52,666 --> 00:36:55,133
职责那什么叫做角色

953
00:36:55,266 --> 00:36:57,766
角色其实是我们所说的接口

954
00:36:58,166 --> 00:36:58,566
我们知道

955
00:36:58,566 --> 00:37:00,566
在一个接口里头所表现出来的是什么

956
00:37:00,566 --> 00:37:02,199
它会定义好多个方法

957
00:37:02,666 --> 00:37:05,099
所以为什么会要定义一个接口

958
00:37:05,100 --> 00:37:06,900
这就大家去考虑的问题

959
00:37:07,000 --> 00:37:09,600
为什么我不直接写一个类

960
00:37:09,733 --> 00:37:10,966
这个类有多个方法

961
00:37:10,966 --> 00:37:13,966
直接去调这个类的方法就完了

962
00:37:13,966 --> 00:37:15,366
还要去写一个接口

963
00:37:15,900 --> 00:37:17,866
原因是因为我们会发现一个类

964
00:37:17,866 --> 00:37:20,533
其实它的职责是它

965
00:37:20,533 --> 00:37:22,299
虽然它会承担很多的职责

966
00:37:22,300 --> 00:37:23,566
但它的职责是

967
00:37:24,900 --> 00:37:24,966
会会

968
00:37:24,966 --> 00:37:25,966
会有什么呢

969
00:37:25,966 --> 00:37:27,899
会有这种一组一组的感觉

970
00:37:28,200 --> 00:37:30,300
就是他会在某些时候

971
00:37:30,300 --> 00:37:33,066
把他的某一些职责拉出来

972
00:37:33,200 --> 00:37:34,100
变成一个

973
00:37:34,100 --> 00:37:35,500
我们称之为角色

974
00:37:35,900 --> 00:37:36,933
这个表现出来就是

975
00:37:36,933 --> 00:37:38,166
我们会定义一个接口

976
00:37:38,166 --> 00:37:39,766
接口里定义了若干个方法

977
00:37:39,866 --> 00:37:42,199
这个方法会被这个类去实现

978
00:37:42,333 --> 00:37:42,533
当然

979
00:37:42,533 --> 00:37:44,666
我们知道这个类都还会写更多的方法

980
00:37:44,966 --> 00:37:47,299
但是他实现了这个

981
00:37:47,733 --> 00:37:49,899
他实现了这个接口的这些方法

982
00:37:49,933 --> 00:37:52,366
我们则称之为他是一个角色

983
00:37:52,933 --> 00:37:54,299
那这个角色意味着什么

984
00:37:54,300 --> 00:37:55,366
这个角色意味着

985
00:37:55,366 --> 00:37:57,966
我们在很多时候

986
00:37:57,966 --> 00:37:59,199
会把接口

987
00:37:59,200 --> 00:38:02,766
也作为我们设计的一个最主要的单位

988
00:38:02,766 --> 00:38:04,866
就是我们用的时候是用的是一个接口

989
00:38:05,000 --> 00:38:07,333
而不是去用那个具体的类

990
00:38:07,733 --> 00:38:08,699
那大家知道啊

991
00:38:08,700 --> 00:38:09,666
这样的一种方式

992
00:38:09,666 --> 00:38:12,466
会使得说这个接口有多个实现的话

993
00:38:12,600 --> 00:38:14,166
你是可以去替换的

994
00:38:14,366 --> 00:38:15,866
所以有必要说

995
00:38:16,000 --> 00:38:19,266
把若干个职责合起来

996
00:38:19,733 --> 00:38:22,599
所形成的一个定义叫做一个角色

997
00:38:22,766 --> 00:38:26,066
而这个角色在我们的代码实现的时候

998
00:38:26,266 --> 00:38:28,533
其实就是用接口来实现的

999
00:38:29,133 --> 00:38:31,266
职责在类中间

1000
00:38:31,600 --> 00:38:35,300
若干个职责合起来就形成了一个角色

1001
00:38:35,600 --> 00:38:38,166
这个角色是定义在接口里头的

1002
00:38:38,466 --> 00:38:40,933
那我们的功能最后是怎么做的呢

1003
00:38:40,933 --> 00:38:41,766
我们的功能

1004
00:38:41,766 --> 00:38:44,866
其实就是靠着若干个类和接口

1005
00:38:45,133 --> 00:38:46,399
协作来完成的

1006
00:38:46,800 --> 00:38:46,966
也就是

1007
00:38:46,966 --> 00:38:50,599
我们会把功能分解成为若干个部分

1008
00:38:50,766 --> 00:38:52,799
把它交给不同的类

1009
00:38:52,900 --> 00:38:55,800
或者不同的接口去实现

1010
00:38:55,800 --> 00:38:58,566
最后是有一个协调者把它合起来

1011
00:38:58,566 --> 00:39:01,299
最后变成我们最后所要的功能

1012
00:39:01,700 --> 00:39:03,200
说起来有点抽象啊

1013
00:39:03,800 --> 00:39:08,766
我们以呃地区这个模块的例子来说

1014
00:39:08,933 --> 00:39:11,166
那整个这个设计的方法

1015
00:39:11,166 --> 00:39:12,966
就是这样的一个思路啊

1016
00:39:12,966 --> 00:39:15,199
是面向对象设计的一个最基本的思路

1017
00:39:15,266 --> 00:39:17,366
当然这个思路底下设计的方法

1018
00:39:17,366 --> 00:39:18,766
其实是有很多的

1019
00:39:18,800 --> 00:39:20,100
我们在这门课中间

1020
00:39:20,100 --> 00:39:21,866
主要我们不知道

1021
00:39:21,866 --> 00:39:24,299
我们这门课讲的就是他的一种

1022
00:39:24,300 --> 00:39:25,933
大家目前主流使用的方法

1023
00:39:25,933 --> 00:39:28,066
叫做grasp方法啊

1024
00:39:28,066 --> 00:39:31,099
它全称叫做general responsibility assignment

1025
00:39:31,100 --> 00:39:32,166
software Pitus

1026
00:39:32,166 --> 00:39:34,899
首字母提出来就是grasp

1027
00:39:34,966 --> 00:39:39,399
GRS g r a s p啊

1028
00:39:39,500 --> 00:39:42,333
GRASP这个单词Glasgow

1029
00:39:42,333 --> 00:39:44,299
一共有9种不同的方法

1030
00:39:44,300 --> 00:39:45,066
但是

1031
00:39:45,066 --> 00:39:48,766
我们其实到学了这么多年的淘汰啊

1032
00:39:49,000 --> 00:39:50,466
大家可能用的比较多的

1033
00:39:50,466 --> 00:39:52,866
是其中的6种方法啊

1034
00:39:52,866 --> 00:39:54,766
因为剩下三种方法

1035
00:39:54,766 --> 00:39:56,799
一个是控制器

1036
00:39:56,800 --> 00:39:58,200
那个其实是体系结构

1037
00:39:58,200 --> 00:39:59,700
而不是具体的设计方法

1038
00:40:00,066 --> 00:40:02,399
另外一个是PV啊

1039
00:40:02,400 --> 00:40:03,800
protected variation

1040
00:40:03,866 --> 00:40:04,699
保护变化

1041
00:40:04,700 --> 00:40:06,966
那个其实太广泛了

1042
00:40:06,966 --> 00:40:09,066
其实不太好具体的实用

1043
00:40:09,333 --> 00:40:11,966
还有一个是虚拟啊

1044
00:40:12,266 --> 00:40:14,699
虚拟的话就就比较难

1045
00:40:15,100 --> 00:40:17,200
难说那种方法怎么去弄啊

1046
00:40:17,200 --> 00:40:18,566
所以他不太好实操

1047
00:40:18,866 --> 00:40:20,333
那剩下的36种呢

1048
00:40:20,333 --> 00:40:21,199
我们都把它列在这

1049
00:40:21,200 --> 00:40:22,133
我们在这门课里头

1050
00:40:22,133 --> 00:40:23,533
其实主要讲的这6种

1051
00:40:23,533 --> 00:40:25,766
还不会去讲剩下的那个

1052
00:40:26,300 --> 00:40:27,533
剩下的那个3种

1053
00:40:28,600 --> 00:40:29,800
第一种和第二种

1054
00:40:29,800 --> 00:40:32,666
是百分之七八十的设计都会

1055
00:40:32,666 --> 00:40:33,199
用到的

1056
00:40:33,200 --> 00:40:35,533
就是大部分的简单的面向对象设计

1057
00:40:35,533 --> 00:40:37,666
没有太多的花头的

1058
00:40:37,700 --> 00:40:41,566
就会用到创建者creater和information expert

1059
00:40:41,966 --> 00:40:43,566
信息专家啊这两种

1060
00:40:43,933 --> 00:40:47,533
中间两种低类低欧和高类距啊

1061
00:40:47,533 --> 00:40:49,399
low Carpen和high Cohension

1062
00:40:49,766 --> 00:40:51,799
它其实是一种价值观啊

1063
00:40:51,800 --> 00:40:53,333
不是一种具体的设计方法

1064
00:40:53,466 --> 00:40:56,099
就是当我有a方法也可以做出来

1065
00:40:56,100 --> 00:40:57,466
b方法也可以做出来

1066
00:40:57,466 --> 00:40:59,066
我到底选择哪一种

1067
00:40:59,566 --> 00:41:02,933
就是我会用no copy和high cohension

1068
00:41:02,933 --> 00:41:04,099
这样的一个价值观

1069
00:41:04,266 --> 00:41:06,466
去选择a方案还是b方案

1070
00:41:06,933 --> 00:41:08,066
那最后两种

1071
00:41:08,066 --> 00:41:09,766
多态啊polymorphism

1072
00:41:10,000 --> 00:41:12,333
这个就是继承来的啊

1073
00:41:12,333 --> 00:41:13,799
和间接interaction

1074
00:41:13,800 --> 00:41:15,600
这就两种比较高级的方法了

1075
00:41:15,600 --> 00:41:16,000
也就是

1076
00:41:16,000 --> 00:41:19,100
当我们去面对一些比较复杂的问题

1077
00:41:19,100 --> 00:41:23,533
我们就会用啊多态和间接去完成

1078
00:41:24,066 --> 00:41:26,099
那我们今天开个头啊

1079
00:41:26,100 --> 00:41:29,600
主要讲创建者方法和信息专家的方法

1080
00:41:29,966 --> 00:41:33,066
那我们以reading中间的例子来说

1081
00:41:33,166 --> 00:41:34,899
首先说创建者的方法

1082
00:41:35,466 --> 00:41:36,499
创建者方法是要干嘛

1083
00:41:36,500 --> 00:41:38,100
是说对象的创建问题

1084
00:41:38,800 --> 00:41:39,400
大家知道啊

1085
00:41:39,400 --> 00:41:40,366
面向对象嘛

1086
00:41:40,366 --> 00:41:42,166
肯定是对象

1087
00:41:42,466 --> 00:41:45,099
对象是从内中间创建出来的

1088
00:41:45,333 --> 00:41:47,966
那如果说要从内中间创建对象

1089
00:41:48,066 --> 00:41:49,299
就有一个问题

1090
00:41:49,400 --> 00:41:50,300
怎么创建

1091
00:41:50,733 --> 00:41:52,366
如果在spin的框架中间

1092
00:41:52,366 --> 00:41:55,733
很多的对象都是由框架创建出来的

1093
00:41:56,466 --> 00:41:58,066
所以我们在很多情况下

1094
00:41:58,066 --> 00:42:00,899
都不需要去烦恼说对象从何而来

1095
00:42:01,166 --> 00:42:03,266
对象是由框架创建出来的

1096
00:42:03,666 --> 00:42:05,299
但是某些情况下

1097
00:42:05,300 --> 00:42:06,900
都是需要我们自己创建对象的

1098
00:42:06,900 --> 00:42:08,800
就是你不可能100%的情况下

1099
00:42:08,800 --> 00:42:10,333
都是由框架创建对象

1100
00:42:10,600 --> 00:42:11,500
在某些情况下

1101
00:42:11,500 --> 00:42:13,000
你需要用代码创建对象

1102
00:42:13,100 --> 00:42:14,966
那如果要用代码创建对象的话

1103
00:42:14,966 --> 00:42:16,733
你就要解决一个问题

1104
00:42:16,733 --> 00:42:17,899
这个对象怎么创建

1105
00:42:18,600 --> 00:42:20,000
如果不做任何设计的话

1106
00:42:20,000 --> 00:42:22,000
这个代码就在进来的这个地方

1107
00:42:22,000 --> 00:42:23,133
给他创建出来

1108
00:42:23,200 --> 00:42:24,766
全部创建出来就好了

1109
00:42:24,866 --> 00:42:27,266
这其实是没有做设计的这个做法

1110
00:42:27,366 --> 00:42:28,866
如果要做设计的话

1111
00:42:28,866 --> 00:42:31,466
我们会用创建者的方式

1112
00:42:31,666 --> 00:42:33,899
来让这些对象并不是平面的

1113
00:42:33,900 --> 00:42:34,933
在入口的地方

1114
00:42:34,933 --> 00:42:37,299
或者在某个地方平面的全部创建出来

1115
00:42:37,566 --> 00:42:40,099
而是让他有逻辑的逐步的创建出来

1116
00:42:40,166 --> 00:42:42,366
那怎样有逻辑的逐步创建出来呢

1117
00:42:42,966 --> 00:42:44,299
以下的四个标准

1118
00:42:44,333 --> 00:42:46,266
会是我们创建的依据啊

1119
00:42:46,266 --> 00:42:47,666
如果说有两个对象

1120
00:42:48,366 --> 00:42:49,766
如果说是有两个对象

1121
00:42:49,766 --> 00:42:54,933
如果说b对象是a对象的整体

1122
00:42:54,933 --> 00:42:56,966
就是b对象包含a对象

1123
00:42:57,200 --> 00:42:59,400
那我由整体来创建局部

1124
00:42:59,400 --> 00:43:00,200
就换句话说

1125
00:43:00,200 --> 00:43:02,700
如果说我有order和order item

1126
00:43:02,700 --> 00:43:03,966
我们在创建一个订单的时候

1127
00:43:03,966 --> 00:43:06,066
order和order item都是要需要创建的

1128
00:43:06,533 --> 00:43:08,366
那order item就是由order创建的

1129
00:43:08,366 --> 00:43:09,933
而不是我创建一个order

1130
00:43:09,933 --> 00:43:10,899
创建一个order item

1131
00:43:10,900 --> 00:43:13,066
然后把order item和order关联起来

1132
00:43:13,066 --> 00:43:13,933
不是这么做的

1133
00:43:14,000 --> 00:43:15,166
而是创建一个order

1134
00:43:15,166 --> 00:43:17,399
由order去创建里头所有的order item啊

1135
00:43:17,400 --> 00:43:19,200
这是整体和局部的关系

1136
00:43:19,366 --> 00:43:20,999
那还有一个就是b

1137
00:43:21,000 --> 00:43:24,000
记录a b用到a和b

1138
00:43:24,000 --> 00:43:25,366
有a的初始化数据

1139
00:43:25,366 --> 00:43:26,599
但后三种啊

1140
00:43:26,600 --> 00:43:28,300
相对来说比较灵活一点

1141
00:43:28,300 --> 00:43:30,700
并不是必然会做的一个选择

1142
00:43:30,700 --> 00:43:31,800
我们先休息会儿

1143
00:53:43,466 --> 00:53:44,266
好

1144
00:53:45,666 --> 00:53:46,466
那

1145
00:53:47,666 --> 00:53:48,866
创建的过程啊

1146
00:53:48,866 --> 00:53:51,266
我们以region来说

1147
00:53:51,566 --> 00:53:53,733
因为地区这个模块比较简单

1148
00:53:53,733 --> 00:53:55,899
其实就只有一个对象

1149
00:53:55,933 --> 00:53:57,099
就是一个类啊

1150
00:53:57,100 --> 00:53:58,700
就是region类

1151
00:53:58,966 --> 00:54:00,266
然后它只有一个关系

1152
00:54:00,266 --> 00:54:02,566
就是它的上级关系

1153
00:54:02,900 --> 00:54:04,733
我们现在定义的这个方式呢

1154
00:54:04,733 --> 00:54:09,266
方向是从呃region指向它的上级地区

1155
00:54:09,266 --> 00:54:10,799
所以它是个一对多的关系

1156
00:54:10,800 --> 00:54:11,900
但是在对向模型中间

1157
00:54:11,900 --> 00:54:13,566
只建了一个一对一的关系

1158
00:54:13,566 --> 00:54:14,799
指向它上级地区

1159
00:54:15,000 --> 00:54:17,333
但是依然我们把这个一对一的关系

1160
00:54:17,366 --> 00:54:19,733
也把它的卡普申请关系表现出来

1161
00:54:19,933 --> 00:54:21,333
这个就是意思是说

1162
00:54:22,500 --> 00:54:24,966
任何一个地区是不可能孤立存在的

1163
00:54:24,966 --> 00:54:25,999
比如说厦门市

1164
00:54:26,066 --> 00:54:27,299
它不可能没有上级地区

1165
00:54:27,300 --> 00:54:29,700
它一定有上面的福建省

1166
00:54:30,000 --> 00:54:34,300
所以它一定是福建省的一个局部

1167
00:54:34,366 --> 00:54:35,466
虽然我们这时候建的

1168
00:54:35,466 --> 00:54:37,599
并不是一个从福建省到厦门市的

1169
00:54:37,600 --> 00:54:38,966
这样的一个一对多的关系

1170
00:54:38,966 --> 00:54:40,933
而是从厦门市到福建省的

1171
00:54:40,933 --> 00:54:42,166
一个一对一的关系

1172
00:54:42,500 --> 00:54:43,766
最后我们能这么来建呢

1173
00:54:43,766 --> 00:54:45,499
只建了一个方向啊

1174
00:54:46,200 --> 00:54:48,933
但是我们依然要把这个company关键

1175
00:54:48,933 --> 00:54:50,399
把它表示出来啊

1176
00:54:50,400 --> 00:54:52,266
对象模型中心只见的这一个方向

1177
00:54:52,266 --> 00:54:54,599
并不是说我们在用的时候

1178
00:54:54,600 --> 00:54:56,800
并不需要从福建省到厦门市啊

1179
00:54:57,066 --> 00:54:57,733
是需要的

1180
00:54:57,733 --> 00:54:59,899
只是说他不会用对象模型去实现

1181
00:55:00,100 --> 00:55:02,766
而是用面向功能的方式去做实现

1182
00:55:03,666 --> 00:55:05,466
这是我们的对象模型

1183
00:55:06,000 --> 00:55:06,533
我们说

1184
00:55:06,533 --> 00:55:09,266
对象模型里头已经有了很多的属性

1185
00:55:09,266 --> 00:55:10,133
我们现在要做的事情

1186
00:55:10,133 --> 00:55:11,799
是把职责给它设塞进去

1187
00:55:11,800 --> 00:55:12,666
就这个对象模型中

1188
00:55:12,666 --> 00:55:14,366
到底有些什么样的方法

1189
00:55:14,533 --> 00:55:16,066
它的职责是什么

1190
00:55:16,500 --> 00:55:17,400
那职责从哪来

1191
00:55:17,400 --> 00:55:19,200
职责是从我们的功能来的

1192
00:55:19,300 --> 00:55:20,133
我们的功能

1193
00:55:20,133 --> 00:55:21,566
对于我们后端来说

1194
00:55:21,566 --> 00:55:23,766
我们的功能就是我们的一个个的API

1195
00:55:24,133 --> 00:55:26,733
每一个API就是我们要实现的功能

1196
00:55:26,800 --> 00:55:27,733
我们现在看

1197
00:55:27,733 --> 00:55:30,299
我们现在这个创建地区的这个功能

1198
00:55:30,800 --> 00:55:31,933
我们有一个API

1199
00:55:31,966 --> 00:55:32,999
这个API呢

1200
00:55:33,000 --> 00:55:33,733
描述了说

1201
00:55:33,733 --> 00:55:35,599
我们如何创建地区

1202
00:55:35,866 --> 00:55:37,599
这个API我顺便多说几句啊

1203
00:55:37,600 --> 00:55:39,600
就是我们的整个后台的API

1204
00:55:39,600 --> 00:55:41,200
是有一定的规范的

1205
00:55:41,266 --> 00:55:44,666
我们的API里头其实分为两类API

1206
00:55:45,000 --> 00:55:45,733
一类API

1207
00:55:45,733 --> 00:55:48,199
叫做后台管理人员可以用到的API

1208
00:55:48,766 --> 00:55:49,599
另外一类API呢

1209
00:55:49,600 --> 00:55:50,866
是前端用户

1210
00:55:50,866 --> 00:55:53,166
就是我们的顾客可以用到的API

1211
00:55:53,533 --> 00:55:56,099
后端人员所管理人员所用到的API

1212
00:55:56,100 --> 00:55:56,733
有一个特征

1213
00:55:56,733 --> 00:55:59,899
就是它前面会带Sharps和Sharps ID

1214
00:56:00,166 --> 00:56:02,399
在我们这里写的是Sharps did

1215
00:56:02,400 --> 00:56:04,600
那个did就是Sharps ID

1216
00:56:05,000 --> 00:56:07,333
为什么会带这样的一个链接

1217
00:56:07,333 --> 00:56:10,133
是因为我们在API上头

1218
00:56:10,133 --> 00:56:12,566
是有一个AOP去截的

1219
00:56:12,800 --> 00:56:16,566
就是我们要要求所有带shops ID的API

1220
00:56:16,866 --> 00:56:18,766
必须要登陆才能访问

1221
00:56:18,766 --> 00:56:19,566
这是第一

1222
00:56:19,800 --> 00:56:21,366
不但登陆去访问

1223
00:56:21,366 --> 00:56:22,499
而且我们会验证

1224
00:56:22,500 --> 00:56:25,733
登陆用户里头所带的他的商铺的ID

1225
00:56:26,133 --> 00:56:28,966
必须跟这个sharp的ID是一致的

1226
00:56:29,400 --> 00:56:32,333
如果说这个上面写的这个sharp的ID

1227
00:56:32,533 --> 00:56:34,666
就是URL上这个sharp的ID

1228
00:56:34,866 --> 00:56:36,966
和登陆用户所带的那个标记里头

1229
00:56:36,966 --> 00:56:38,333
所标的那个sharp ID

1230
00:56:38,333 --> 00:56:40,366
因为登录用户带的标记是一个TOKEN

1231
00:56:40,600 --> 00:56:41,866
这个j w的TOKEN

1232
00:56:41,866 --> 00:56:44,933
TOKEN里头有记录了他的super ID是什么

1233
00:56:45,000 --> 00:56:47,566
两者不一致是不允许他访问的

1234
00:56:47,566 --> 00:56:49,933
当我们在代码中间不需要写AOP的

1235
00:56:49,933 --> 00:56:51,133
把它截掉了

1236
00:56:51,466 --> 00:56:53,733
所以如果说调到我们的代码里头来

1237
00:56:53,733 --> 00:56:56,733
我们应该知道这个用户是登录了的

1238
00:56:56,966 --> 00:56:58,466
这个用户登录的那个

1239
00:56:58,466 --> 00:56:59,966
他的店铺的ID

1240
00:57:00,133 --> 00:57:02,599
和上面的那个sharp链接里头

1241
00:57:02,600 --> 00:57:04,800
那个sharp的那个ID是一模一样的

1242
00:57:05,266 --> 00:57:06,799
才可以调到我们代码里头来啊

1243
00:57:06,800 --> 00:57:08,066
这是用AOP去做的

1244
00:57:08,066 --> 00:57:10,266
所以代码中间并看不到这个部分

1245
00:57:10,533 --> 00:57:12,066
那代码中间要做什么部分

1246
00:57:12,066 --> 00:57:13,333
关于这一个部分来说

1247
00:57:13,333 --> 00:57:14,366
我们有一个逻辑

1248
00:57:14,500 --> 00:57:16,266
就是普通的商铺管理员

1249
00:57:16,266 --> 00:57:18,199
是不能建地区的

1250
00:57:18,600 --> 00:57:20,800
只有平台的管理员才可以建对吧

1251
00:57:20,800 --> 00:57:21,966
不能任何一个商户

1252
00:57:22,200 --> 00:57:24,466
任意的去在某个底下建个新的地区

1253
00:57:24,466 --> 00:57:25,399
这是不允许的

1254
00:57:25,500 --> 00:57:27,100
那我们怎么做到这一点呢

1255
00:57:27,100 --> 00:57:29,266
我们其实靠的就是这个shop ID

1256
00:57:29,366 --> 00:57:33,499
shop ID为0代表说它是平台级的管理员

1257
00:57:34,266 --> 00:57:36,966
shop ID不为0就是每一个店铺的

1258
00:57:36,966 --> 00:57:39,299
因为每个店铺它都有会有店铺的ID

1259
00:57:39,666 --> 00:57:41,599
所以我们这里会要做一个判断

1260
00:57:41,700 --> 00:57:44,933
如果说shop ID为0的话

1261
00:57:45,100 --> 00:57:47,500
才可以在底下建此地区

1262
00:57:47,500 --> 00:57:50,266
修牌ID不为0的话是不能建此地区的

1263
00:57:50,666 --> 00:57:52,766
前面的判断有a IP去做了

1264
00:57:52,766 --> 00:57:53,666
登录的用户

1265
00:57:53,666 --> 00:57:54,533
他已经保证了

1266
00:57:54,533 --> 00:57:58,366
他的ID和链接上面的这个是一致的

1267
00:57:58,466 --> 00:57:59,733
那第二件事情

1268
00:57:59,733 --> 00:58:01,133
需要我们的代码中间去写

1269
00:58:01,133 --> 00:58:02,599
就是这个链接里头带过来的

1270
00:58:02,600 --> 00:58:05,066
这个shop did必须为0

1271
00:58:05,866 --> 00:58:08,333
如果为0的话才可以建指店铺

1272
00:58:08,333 --> 00:58:09,933
如果不为0的话

1273
00:58:09,933 --> 00:58:12,899
就不能去建指定指地区啊

1274
00:58:12,900 --> 00:58:16,266
这是我们关于这个链接说一下

1275
00:58:16,266 --> 00:58:17,766
所有的链接都这个规矩

1276
00:58:17,766 --> 00:58:19,699
就是后台的所有链接

1277
00:58:19,700 --> 00:58:21,800
全部带了shops和did

1278
00:58:21,800 --> 00:58:23,300
那个会保证说

1279
00:58:23,366 --> 00:58:27,366
当前登录的用户的ID和的shop ID

1280
00:58:27,366 --> 00:58:29,933
和这个链接里头这个ID是一致的

1281
00:58:30,166 --> 00:58:31,666
然后其他逻辑自己去做

1282
00:58:32,066 --> 00:58:33,699
这个API里头大家可以看到

1283
00:58:33,700 --> 00:58:36,000
它其实在pass上头指定的

1284
00:58:36,000 --> 00:58:39,766
说在哪一个地区底下去建一个指地

1285
00:58:39,766 --> 00:58:41,666
区在八底

1286
00:58:41,666 --> 00:58:44,266
中间描述了这个地区

1287
00:58:44,400 --> 00:58:46,166
给的一些最基本信息

1288
00:58:46,533 --> 00:58:48,199
就是我们所说的名字啊

1289
00:58:48,533 --> 00:58:50,099
简称啊合并名字啊

1290
00:58:50,100 --> 00:58:51,600
拼音啊经纬度啊

1291
00:58:52,200 --> 00:58:53,066
地区码啊

1292
00:58:53,333 --> 00:58:57,133
zip码啊城市码啊等等啊一系列的

1293
00:58:57,133 --> 00:58:59,699
这个然后返回值呢

1294
00:58:59,700 --> 00:59:00,600
其实就是

1295
00:59:00,866 --> 00:59:02,533
因为我们会创建一个新的地区

1296
00:59:02,533 --> 00:59:05,099
所以这个新的地区的ID会返回

1297
00:59:05,100 --> 00:59:05,900
主要是为了这个

1298
00:59:05,900 --> 00:59:08,400
但我们顺便把他的名字一起返回了啊

1299
00:59:08,566 --> 00:59:11,299
就是创建的新的那个地区的ID

1300
00:59:11,300 --> 00:59:13,133
和他传过来这个名字啊

1301
00:59:13,133 --> 00:59:14,133
会一并返回

1302
00:59:14,500 --> 00:59:16,533
这里头还有一个判断

1303
00:59:17,300 --> 00:59:20,400
就是我在一个地区底下去建一个地区

1304
00:59:20,733 --> 00:59:22,899
比如说我们知道啊

1305
00:59:22,900 --> 00:59:23,766
以厦门来说

1306
00:59:23,766 --> 00:59:25,666
地区区划会发生变化的

1307
00:59:25,666 --> 00:59:27,499
我们以前的市民区叫做什么

1308
00:59:27,500 --> 00:59:28,333
大家知道吗

1309
00:59:29,100 --> 00:59:32,700
叫做开元区和鼓浪屿区

1310
00:59:33,866 --> 00:59:35,733
然后好像还有一个区啊

1311
00:59:35,933 --> 00:59:38,299
是三个是三个区合并出来

1312
00:59:38,300 --> 00:59:40,133
变成我们的市民区的

1313
00:59:40,700 --> 00:59:41,533
那开源区

1314
00:59:41,533 --> 00:59:43,133
就是一直会存在

1315
00:59:43,133 --> 00:59:44,699
我们数据库里头的一个数据

1316
00:59:44,700 --> 00:59:47,266
为啥假如说我们的系统运行了20年

1317
00:59:47,266 --> 00:59:48,966
30年 30年前

1318
00:59:48,966 --> 00:59:50,733
有人在开源区下了个订单

1319
00:59:50,800 --> 00:59:52,900
那个订单里的地址就写着开源区

1320
00:59:52,900 --> 00:59:54,066
什么什么什么街道

1321
00:59:54,200 --> 00:59:56,500
对吧虽然开源区不存在了

1322
00:59:56,533 --> 00:59:58,733
但是我们的数据库里开源区依然要在

1323
00:59:58,733 --> 01:00:00,099
但是他是什么状态呢

1324
01:00:00,300 --> 01:00:01,800
他是一个废弃的状态

1325
01:00:02,400 --> 01:00:05,500
就是他是不能再去被选了

1326
01:00:05,700 --> 01:00:07,766
用户去选择这个地区去下单的

1327
01:00:07,933 --> 01:00:09,566
但是以前下过的订单

1328
01:00:09,566 --> 01:00:11,566
你依然还能看到开元区的订单

1329
01:00:11,566 --> 01:00:12,899
这个是不可以去

1330
01:00:13,133 --> 01:00:14,499
不会去修改的

1331
01:00:15,000 --> 01:00:17,733
那在废弃的地区底下去建此地区

1332
01:00:17,733 --> 01:00:18,533
可以吗

1333
01:00:19,266 --> 01:00:19,999
肯定是不可以

1334
01:00:20,000 --> 01:00:20,933
那地方都废弃了

1335
01:00:20,933 --> 01:00:22,366
你还要去建此地区什么

1336
01:00:22,366 --> 01:00:22,966
所以我们这里还有

1337
01:00:22,966 --> 01:00:23,733
一个逻辑就是

1338
01:00:23,733 --> 01:00:25,599
他如果这个地区已经废弃了

1339
01:00:25,900 --> 01:00:28,766
他是不能去建此订单的这些东西啊

1340
01:00:28,766 --> 01:00:31,133
我所有说的这些东西都是功能

1341
01:00:31,366 --> 01:00:34,499
我们的功能包括说要去判断用户

1342
01:00:34,666 --> 01:00:37,266
必须是平台级的用户才能建止地区

1343
01:00:37,533 --> 01:00:38,199
这个地区

1344
01:00:38,200 --> 01:00:40,266
必须建在一个现有的地区底下

1345
01:00:40,333 --> 01:00:43,399
这个地区不能是已经废弃的地区

1346
01:00:44,200 --> 01:00:46,800
他才可以建这个此地区啊

1347
01:00:46,966 --> 01:00:47,899
这个顺便说一下

1348
01:00:47,900 --> 01:00:48,800
大家应该记得

1349
01:00:48,800 --> 01:00:51,500
我们在地区里头的三个状态

1350
01:00:51,500 --> 01:00:52,766
一个是有效状态

1351
01:00:52,766 --> 01:00:55,599
一个是这个暂停状态

1352
01:00:55,766 --> 01:00:57,166
一个是废弃状态

1353
01:00:57,166 --> 01:00:59,333
我们现在讲的废弃状态有效状态

1354
01:00:59,333 --> 01:01:00,466
应该没什么好问题的

1355
01:01:00,466 --> 01:01:02,266
暂停状态大家可能不太了解

1356
01:01:02,266 --> 01:01:03,266
那是干嘛用的

1357
01:01:03,366 --> 01:01:04,933
那是假如说啊

1358
01:01:04,933 --> 01:01:06,766
我正在这个前夕

1359
01:01:06,933 --> 01:01:08,266
我要把失明

1360
01:01:08,266 --> 01:01:10,933
要把开元区和鼓浪屿区合并

1361
01:01:10,933 --> 01:01:11,966
成为失明区

1362
01:01:11,966 --> 01:01:13,899
从某月某日开始

1363
01:01:14,300 --> 01:01:16,466
所以我的系统就要把市民区建进去

1364
01:01:16,466 --> 01:01:17,499
但市民区现在还不能选

1365
01:01:17,500 --> 01:01:20,000
我还没有没有完成这个区划

1366
01:01:20,333 --> 01:01:22,699
市民区底下的子弟区也会都建出来

1367
01:01:22,800 --> 01:01:24,666
然后从几月几号开始

1368
01:01:24,666 --> 01:01:26,899
这个东西就会变成正式的啊

1369
01:01:26,900 --> 01:01:31,100
开元区和鼓浪屿区就会变成废弃的

1370
01:01:31,166 --> 01:01:32,699
所以这个时候的失明区

1371
01:01:32,700 --> 01:01:33,533
就是一个什么呢

1372
01:01:33,533 --> 01:01:35,133
就是一个suspend状态

1373
01:01:35,200 --> 01:01:37,133
就是一个它不能被选择

1374
01:01:37,333 --> 01:01:39,699
但是它可以去做维护

1375
01:01:39,966 --> 01:01:40,966
但某一时刻

1376
01:01:40,966 --> 01:01:43,466
它就会把它从suspend变成varity的状态

1377
01:01:43,466 --> 01:01:44,666
的这样一个东西啊

1378
01:01:44,733 --> 01:01:45,866
所以suspend这个状态

1379
01:01:45,866 --> 01:01:46,866
其实主要用在

1380
01:01:46,866 --> 01:01:49,533
那些会有新的地区出来

1381
01:01:49,533 --> 01:01:51,599
会要做区划规整的时候

1382
01:01:51,800 --> 01:01:53,966
把那些要出来的新的区表达

1383
01:01:53,966 --> 01:01:55,066
变成失败状态

1384
01:01:55,600 --> 01:01:57,666
那所以说我们现在这个逻辑

1385
01:01:57,666 --> 01:02:00,333
就是在wire的状态和测试ban的状

1386
01:02:00,333 --> 01:02:02,166
态是可以加指定区的

1387
01:02:02,166 --> 01:02:03,299
就是现在是有效的地区

1388
01:02:03,300 --> 01:02:04,900
或者未来会出现的新的地区

1389
01:02:05,066 --> 01:02:06,499
都可以在底下去加指定区

1390
01:02:06,500 --> 01:02:09,100
但是abound的状态是不能加的啊

1391
01:02:09,566 --> 01:02:11,866
花点时间把这个功能给讲清楚

1392
01:02:11,866 --> 01:02:14,099
所以大家看到这个API里头

1393
01:02:14,100 --> 01:02:16,766
其实描述的就是我们要做的这个功能

1394
01:02:17,500 --> 01:02:19,933
这个功能在面向对象的领域中间

1395
01:02:19,933 --> 01:02:21,766
是要把它分成职责的

1396
01:02:21,866 --> 01:02:23,699
是要把它分成若干个职责

1397
01:02:23,866 --> 01:02:26,799
然后把这些职责分到不同的类上面去

1398
01:02:26,800 --> 01:02:28,800
然后变成这些类的方法

1399
01:02:30,166 --> 01:02:30,999
怎么分呢

1400
01:02:31,900 --> 01:02:33,533
我们首先看一下

1401
01:02:33,533 --> 01:02:35,933
我们到底有多少类和多少接口

1402
01:02:36,566 --> 01:02:38,699
这是region里头所有的类

1403
01:02:39,266 --> 01:02:40,299
还有所有的包

1404
01:02:40,466 --> 01:02:43,733
因为这个这个模块特别简单

1405
01:02:43,733 --> 01:02:47,066
就一个对象一张表是吧

1406
01:02:47,166 --> 01:02:48,599
然后只有一个关系

1407
01:02:48,600 --> 01:02:50,400
一个对象一个关系一张表

1408
01:02:50,400 --> 01:02:52,366
所以它是我们所有模块中间

1409
01:02:52,366 --> 01:02:54,499
9个模块中间最简单的一个模块

1410
01:02:55,000 --> 01:02:56,366
这个模块就不劳大家动手了

1411
01:02:56,366 --> 01:02:57,299
我把它做完了啊

1412
01:02:57,300 --> 01:02:58,666
我花了6个小时

1413
01:02:58,666 --> 01:03:02,599
连代码代文档代这个注测试啊

1414
01:03:02,600 --> 01:03:04,066
全部写完了啊

1415
01:03:04,100 --> 01:03:05,066
当然里头还有bug

1416
01:03:05,066 --> 01:03:06,766
有bug大家自己去自己去找

1417
01:03:07,100 --> 01:03:10,500
但是这个模块啊

1418
01:03:11,500 --> 01:03:13,400
整体的结构就是这样的一个结构

1419
01:03:14,866 --> 01:03:16,733
呃这边这个结构大家应该已经看到

1420
01:03:16,733 --> 01:03:18,866
我们是一个分层式体系结构是吧

1421
01:03:19,366 --> 01:03:22,066
但是我们其实并不完全是一个

1422
01:03:22,066 --> 01:03:22,966
分层式体系结构

1423
01:03:22,966 --> 01:03:26,499
其实我们融合了DD的六边形的结构

1424
01:03:26,700 --> 01:03:27,500
大家应该记得

1425
01:03:27,500 --> 01:03:28,933
我们六边形结构里头

1426
01:03:28,933 --> 01:03:30,566
最上面这个Controller

1427
01:03:30,800 --> 01:03:31,866
其实在六边形结构中间

1428
01:03:31,866 --> 01:03:34,666
相当于rest的adapter啊

1429
01:03:34,666 --> 01:03:36,466
这个大家还记得六边形结构吗

1430
01:03:36,966 --> 01:03:38,699
我把那那个PPT打开

1431
01:03:39,766 --> 01:03:40,866
是不是有点忘了

1432
01:03:52,966 --> 01:03:56,099
这个我们的体系结构

1433
01:03:56,100 --> 01:04:00,866
其实并不是完全的层次体系结构

1434
01:04:01,266 --> 01:04:02,733
其实是层次体系结构

1435
01:04:02,733 --> 01:04:04,333
和六边形结构的混合体

1436
01:04:04,333 --> 01:04:06,599
为啥呢因为我们上面的Controller

1437
01:04:06,600 --> 01:04:08,300
其实是restful Adapter

1438
01:04:09,333 --> 01:04:12,599
下面的那个map和稻层合起来

1439
01:04:12,600 --> 01:04:14,366
其实是ORM Adapter

1440
01:04:14,566 --> 01:04:18,766
然后我们中间的service层是应用层

1441
01:04:19,100 --> 01:04:20,100
是这个应用

1442
01:04:20,400 --> 01:04:24,066
Bo的那个包是我们的领域模型

1443
01:04:24,600 --> 01:04:27,200
其实是这样的一个结构啊

1444
01:04:27,200 --> 01:04:30,133
所以我们对着这个类图来看

1445
01:04:30,133 --> 01:04:31,866
其实就是这样的一个结构

1446
01:04:32,100 --> 01:04:34,466
上面这个control层主要是做rest API的

1447
01:04:34,466 --> 01:04:36,399
所以是rest API的Adapter

1448
01:04:36,600 --> 01:04:38,466
下面的这个稻层和map层

1449
01:04:38,466 --> 01:04:39,999
主要是做数据库访问的

1450
01:04:40,100 --> 01:04:42,766
所以这一层其实是我们的Adapter

1451
01:04:42,766 --> 01:04:43,499
但这个Adapter

1452
01:04:43,500 --> 01:04:45,533
其实我们并不仅仅是什么呢

1453
01:04:45,700 --> 01:04:48,800
并不仅仅是在呃DDE结构

1454
01:04:48,800 --> 01:04:50,866
中间的ORM Adapter

1455
01:04:50,866 --> 01:04:53,666
其实我们这个道的作用可更强大

1456
01:04:53,666 --> 01:04:55,266
它不仅仅存了数据库

1457
01:04:55,266 --> 01:04:56,533
还操作了缓存

1458
01:04:56,733 --> 01:05:00,533
那不管操作数据库还是操作缓存

1459
01:05:00,600 --> 01:05:02,566
我们稻城最终的目的

1460
01:05:02,566 --> 01:05:04,733
就是要跟我们搞出这个bo出来

1461
01:05:04,966 --> 01:05:05,999
我们的read对象

1462
01:05:06,000 --> 01:05:07,866
这个对象可能是来自于数据库的

1463
01:05:07,866 --> 01:05:09,699
可能是来自于缓存的

1464
01:05:09,700 --> 01:05:11,366
但是我们通过了稻城以后

1465
01:05:11,366 --> 01:05:13,933
我们并不关心他到底从何而来

1466
01:05:14,066 --> 01:05:17,166
那收费市城和Bo这两个东西

1467
01:05:17,166 --> 01:05:19,766
就是我们所说的核心逻辑所在

1468
01:05:19,866 --> 01:05:21,266
身份层是应用逻辑

1469
01:05:21,366 --> 01:05:23,166
Bo层是我们的领域逻辑

1470
01:05:23,166 --> 01:05:24,166
领域对象啊

1471
01:05:24,166 --> 01:05:25,366
Bo对象所以

1472
01:05:25,366 --> 01:05:27,533
我们这里看似是一个分层的体系结构

1473
01:05:27,533 --> 01:05:30,666
其实它是跟DD的结构是可以对过去的

1474
01:05:30,700 --> 01:05:32,933
是两种结构的混杂体

1475
01:05:33,266 --> 01:05:34,966
就实际上我们在做一个体系

1476
01:05:34,966 --> 01:05:35,566
结构的时候

1477
01:05:35,566 --> 01:05:37,799
并不是单纯的我们说用a体系结构

1478
01:05:37,800 --> 01:05:39,000
或者用b体系结构

1479
01:05:39,100 --> 01:05:41,566
我们是可以把不同的体系结构的

1480
01:05:42,400 --> 01:05:44,466
觉得适用于自己的这个部分

1481
01:05:44,466 --> 01:05:45,499
把它抽出来啊

1482
01:05:45,500 --> 01:05:47,700
做到这个里头来的啊

1483
01:05:47,700 --> 01:05:48,900
所以这个结构中心

1484
01:05:48,900 --> 01:05:49,366
大家可以看到

1485
01:05:49,366 --> 01:05:52,599
在Controller层里头有三个Controller

1486
01:05:52,600 --> 01:05:53,766
有一个VO

1487
01:05:53,766 --> 01:05:54,699
一个DTO

1488
01:05:55,500 --> 01:05:56,366
呃switch程

1489
01:05:56,366 --> 01:05:57,933
只有一个switch的方法

1490
01:05:58,000 --> 01:06:00,366
稻城的话有呃region道

1491
01:06:00,366 --> 01:06:01,533
因为只有一个bo对象

1492
01:06:01,533 --> 01:06:01,733
所以

1493
01:06:01,733 --> 01:06:04,799
它主要为了产生这个region的region对象

1494
01:06:04,866 --> 01:06:05,599
然后Maps呢

1495
01:06:05,600 --> 01:06:08,500
是负责把这个Bo对象变成数据库

1496
01:06:08,500 --> 01:06:09,200
存进去哈

1497
01:06:09,200 --> 01:06:09,933
所以它有数据库

1498
01:06:09,933 --> 01:06:10,733
因为这一张表

1499
01:06:10,733 --> 01:06:12,499
所以对应的是region Po对象

1500
01:06:12,500 --> 01:06:13,166
然后这个Maps

1501
01:06:13,166 --> 01:06:15,066
负责把数据库给它存进去

1502
01:06:15,066 --> 01:06:16,566
就这么一个很简单的结构

1503
01:06:16,900 --> 01:06:17,366
在这节奏上

1504
01:06:17,366 --> 01:06:18,199
我们怎么做

1505
01:06:18,400 --> 01:06:20,800
创建指地区

1506
01:06:20,800 --> 01:06:21,800
就前面那个API

1507
01:06:22,166 --> 01:06:23,199
他怎么做的啊

1508
01:06:23,333 --> 01:06:23,766
这张图

1509
01:06:23,766 --> 01:06:27,766
我完整地从控制器层划到了稻城

1510
01:06:28,300 --> 01:06:29,200
没有画map

1511
01:06:29,700 --> 01:06:32,666
就是我们这里所看到的控制器层

1512
01:06:32,666 --> 01:06:33,366
收尾时层

1513
01:06:33,366 --> 01:06:34,866
稻城map城

1514
01:06:34,866 --> 01:06:36,933
我从控制器城划到了稻城

1515
01:06:37,500 --> 01:06:38,366
没有画map成

1516
01:06:38,366 --> 01:06:40,666
但之后的图我们都不会画这么完整

1517
01:06:40,800 --> 01:06:43,066
为啥呢我给大家讲一下它的道理啊

1518
01:06:43,400 --> 01:06:44,933
这张图描述的是

1519
01:06:44,933 --> 01:06:46,533
当我去从前端

1520
01:06:46,533 --> 01:06:49,099
发一个restful的API的请求

1521
01:06:49,100 --> 01:06:50,200
去创建一个

1522
01:06:51,600 --> 01:06:52,600
指地区的时候

1523
01:06:52,600 --> 01:06:53,666
我们在控制器层

1524
01:06:53,666 --> 01:06:56,399
有一个叫做create subrageans的方法

1525
01:06:56,400 --> 01:06:57,500
它的四个参数

1526
01:06:57,500 --> 01:06:59,466
其实是对应着我们在呃

1527
01:06:59,466 --> 01:07:00,766
API上面的那个东西

1528
01:07:00,766 --> 01:07:01,799
一个是消防ID

1529
01:07:01,800 --> 01:07:04,166
就对应着它的第二个did

1530
01:07:04,700 --> 01:07:05,666
第二个是ID

1531
01:07:05,666 --> 01:07:07,199
这个是其实region的ID

1532
01:07:07,466 --> 01:07:07,766
然后

1533
01:07:07,766 --> 01:07:09,533
他的body里头传过来的值

1534
01:07:09,533 --> 01:07:10,766
放到了VO里头

1535
01:07:11,000 --> 01:07:14,000
然后他的当前登陆用户

1536
01:07:14,000 --> 01:07:15,766
我们其实是从top中间截出来

1537
01:07:15,766 --> 01:07:17,799
因为AOP放到它第四个参数中间

1538
01:07:17,900 --> 01:07:18,533
usually到啊

1539
01:07:18,533 --> 01:07:19,799
这是用AOP做的

1540
01:07:20,100 --> 01:07:21,300
所以这个AOP的过程

1541
01:07:21,300 --> 01:07:23,966
不仅仅会把当前登陆用户截出来

1542
01:07:23,966 --> 01:07:24,766
也会判定

1543
01:07:24,800 --> 01:07:27,100
判定当前登陆用户的shopar ID

1544
01:07:27,333 --> 01:07:30,533
一定跟路径上那个shopar ID是一样的

1545
01:07:30,733 --> 01:07:33,866
能保证这个事情进来以后

1546
01:07:34,100 --> 01:07:35,766
我们所做的第一件事情

1547
01:07:35,766 --> 01:07:37,066
我们没在图上没画

1548
01:07:37,166 --> 01:07:37,599
这件事情

1549
01:07:37,600 --> 01:07:38,166
是要判断

1550
01:07:38,166 --> 01:07:40,699
当前登陆用户是平台级的用户

1551
01:07:40,733 --> 01:07:42,266
才能做后面的事情

1552
01:07:42,466 --> 01:07:45,066
这个事情是在Controller上做的

1553
01:07:45,300 --> 01:07:46,800
这个其实也涉及到职责划分

1554
01:07:46,800 --> 01:07:49,066
就是我们不说具体的

1555
01:07:49,066 --> 01:07:51,333
这个类的对象的职责划分

1556
01:07:51,333 --> 01:07:55,266
我们首先要确定说每一层干什么

1557
01:07:55,266 --> 01:07:57,199
这是一个最大的职责划分啊

1558
01:07:57,533 --> 01:07:58,933
所以进来以后

1559
01:07:58,933 --> 01:08:00,499
首先这个用户能不能干三样事情

1560
01:08:00,500 --> 01:08:02,266
第一判断他是不是平台级用户

1561
01:08:02,300 --> 01:08:04,733
这个判断就是在control成完成的

1562
01:08:04,800 --> 01:08:05,566
代码中间有

1563
01:08:05,566 --> 01:08:06,866
但我们在图上没有画

1564
01:08:06,966 --> 01:08:09,666
如果判断说他是一个平台级的用户

1565
01:08:09,666 --> 01:08:11,166
那做的事情大家可以看

1566
01:08:11,166 --> 01:08:12,733
control成在第二和第8

1567
01:08:13,466 --> 01:08:14,299
一上一下

1568
01:08:14,766 --> 01:08:15,933
上面这件事情是干嘛呢

1569
01:08:15,933 --> 01:08:18,333
是把当前传过来的那个Bo对象

1570
01:08:18,333 --> 01:08:20,499
把它变成一个我们的Bo对象

1571
01:08:20,700 --> 01:08:24,133
所以我们有一个climate factory的类

1572
01:08:24,300 --> 01:08:25,566
这个类是一个静态类

1573
01:08:25,566 --> 01:08:27,799
这个类其实我们不是用代码写出来的

1574
01:08:28,000 --> 01:08:30,133
这个类是用

1575
01:08:30,600 --> 01:08:33,200
就是陈一鸣同学去年自动生成出来的

1576
01:08:33,533 --> 01:08:34,933
啊我们代码中间其实没有这个部分

1577
01:08:34,933 --> 01:08:36,566
但是我害怕把这个类画出来了啊

1578
01:08:36,566 --> 01:08:37,133
待会可以给

1579
01:08:37,133 --> 01:08:38,933
大家看一下代码中间啊

1580
01:08:38,933 --> 01:08:40,266
我们现在这个代码中间

1581
01:08:40,700 --> 01:08:42,133
服务器的代码中间也没有这个部分

1582
01:08:42,133 --> 01:08:42,799
看不到

1583
01:08:42,800 --> 01:08:46,366
要在你本地编译的时候才能看得到

1584
01:08:46,733 --> 01:08:48,599
所以生产出来的这个类里头

1585
01:08:48,600 --> 01:08:50,000
有个copy方法把

1586
01:08:51,466 --> 01:08:53,566
VO就是我们常见的那个值

1587
01:08:53,566 --> 01:08:55,099
把它变成对向

1588
01:08:55,400 --> 01:08:57,733
因为从控制器层以后

1589
01:08:57,800 --> 01:08:59,166
就是我们的收费值层

1590
01:08:59,166 --> 01:09:00,866
就是开始到面向对向

1591
01:09:01,000 --> 01:09:03,366
然后倒层也是面向对向的

1592
01:09:03,366 --> 01:09:05,966
到PU层又把它变成非面向对向的

1593
01:09:05,966 --> 01:09:07,299
所以上下两层

1594
01:09:07,300 --> 01:09:10,166
就是上面是一个restful的Adapter

1595
01:09:10,200 --> 01:09:12,600
下面是一个ORM的Adapter

1596
01:09:12,600 --> 01:09:14,266
这两层不是面向对象的

1597
01:09:14,266 --> 01:09:15,566
中间全是面向对象

1598
01:09:15,800 --> 01:09:16,966
所以进来以后我们可以看到

1599
01:09:16,966 --> 01:09:17,333
第一件事情

1600
01:09:17,333 --> 01:09:19,666
就是我们把我们的呃

1601
01:09:19,666 --> 01:09:20,266
常见的值

1602
01:09:20,266 --> 01:09:22,933
和对象模型的里头的领域

1603
01:09:22,933 --> 01:09:23,866
对象中间的reading

1604
01:09:23,866 --> 01:09:25,266
做了一个对考

1605
01:09:25,266 --> 01:09:26,866
当然我们现在这个很简单

1606
01:09:27,333 --> 01:09:28,266
就是一对一的

1607
01:09:28,266 --> 01:09:30,166
并没有什么特别大的复杂的地方

1608
01:09:30,166 --> 01:09:32,366
其实复杂的还会更复杂啊

1609
01:09:32,366 --> 01:09:34,199
这里就直接把它对考过来了

1610
01:09:34,733 --> 01:09:35,533
对卡过来以后

1611
01:09:35,533 --> 01:09:36,099
大家可以看到

1612
01:09:36,100 --> 01:09:38,200
我们调收费层其实还是功能

1613
01:09:38,200 --> 01:09:39,533
这个部分还是功能

1614
01:09:39,600 --> 01:09:40,366
这个功能就是说

1615
01:09:40,366 --> 01:09:41,499
我们在收费层做了一个方法

1616
01:09:41,500 --> 01:09:43,000
这个方法的体现的功能

1617
01:09:43,000 --> 01:09:45,366
就是创建值地区

1618
01:09:45,600 --> 01:09:48,300
所以我们去调创建此地区这个方法

1619
01:09:48,533 --> 01:09:51,799
把我们的当前地区的ID传过来

1620
01:09:51,800 --> 01:09:53,133
就是我们要建在哪个地区

1621
01:09:53,133 --> 01:09:54,799
底下的这底ID传过来

1622
01:09:54,933 --> 01:09:56,999
然后要建一个什么样的地区传过去

1623
01:09:57,000 --> 01:09:59,800
还把是谁建的传过去啊

1624
01:09:59,800 --> 01:10:01,700
所以这个部分到收费层这部分

1625
01:10:01,700 --> 01:10:02,900
还是面向功能的

1626
01:10:03,066 --> 01:10:04,333
并没有到面向对象

1627
01:10:04,566 --> 01:10:06,699
面向对象从这开始

1628
01:10:06,966 --> 01:10:09,966
从收费层以下到这个

1629
01:10:10,200 --> 01:10:11,866
Bo才是面向对象

1630
01:10:12,100 --> 01:10:13,533
但是怎么面向对象法

1631
01:10:13,600 --> 01:10:14,500
我们知道

1632
01:10:14,500 --> 01:10:15,766
当我们做一个功能的时候

1633
01:10:15,766 --> 01:10:18,766
我们首先做的是要把功能变成职责

1634
01:10:19,666 --> 01:10:21,133
当我们要创建一个地区的时候

1635
01:10:21,133 --> 01:10:22,299
他有什么职责呢

1636
01:10:23,900 --> 01:10:24,766
第一个职责啊

1637
01:10:24,766 --> 01:10:25,333
大家可以看到

1638
01:10:25,333 --> 01:10:26,266
我们做的第一个职责

1639
01:10:26,266 --> 01:10:27,799
就是这个地区要在

1640
01:10:28,700 --> 01:10:30,600
是吧我这个地区就是平白无故的

1641
01:10:30,600 --> 01:10:31,900
没有的地区

1642
01:10:32,066 --> 01:10:33,599
这个肯定是不可能的

1643
01:10:33,600 --> 01:10:35,000
是吧所以第一

1644
01:10:35,000 --> 01:10:36,000
这个地区要在

1645
01:10:36,300 --> 01:10:37,333
这是第一个指责

1646
01:10:37,600 --> 01:10:38,600
这个地区要在

1647
01:10:39,066 --> 01:10:40,599
第二这个地区状态要对

1648
01:10:41,100 --> 01:10:42,500
他必须是一个valet

1649
01:10:42,500 --> 01:10:43,733
或者说是测试办的状态

1650
01:10:43,733 --> 01:10:45,866
才可以在底下去建是地区

1651
01:10:46,000 --> 01:10:47,733
第三就是把这个地区建出来

1652
01:10:48,133 --> 01:10:49,799
所以他实际上有三个职责

1653
01:10:50,133 --> 01:10:52,166
但是我们可以看到这三个职责

1654
01:10:52,166 --> 01:10:55,299
我们把第一个职责交给道去做

1655
01:10:55,300 --> 01:10:56,600
因为这个东西在不在

1656
01:10:56,600 --> 01:10:57,400
这个事情

1657
01:10:57,400 --> 01:11:00,100
我们不是自己能判断出来的

1658
01:11:00,100 --> 01:11:01,666
我们必须要依赖于稻城

1659
01:11:01,666 --> 01:11:03,366
map城到数据库里去查出来

1660
01:11:03,533 --> 01:11:04,866
看这个东西在不在

1661
01:11:04,966 --> 01:11:06,466
所以稻城做了一个方法

1662
01:11:06,466 --> 01:11:08,966
find吧ID这个不是面向对象的啊

1663
01:11:08,966 --> 01:11:10,999
这个职责的分配并不是面向对象

1664
01:11:11,266 --> 01:11:12,099
这个职责的分配

1665
01:11:12,100 --> 01:11:13,733
就纯粹是因为体系结构的原因

1666
01:11:13,733 --> 01:11:15,199
我们做了功能的分解

1667
01:11:15,566 --> 01:11:16,499
把查询

1668
01:11:16,500 --> 01:11:20,100
这个是个功能交给了稻城的一个方法

1669
01:11:20,333 --> 01:11:21,533
find把ID

1670
01:11:21,533 --> 01:11:22,399
把ID传过去

1671
01:11:22,400 --> 01:11:24,000
把这个对象拿回来

1672
01:11:24,300 --> 01:11:26,166
那拿回来这个对象以后

1673
01:11:26,166 --> 01:11:28,466
这时候就是一个bo对象

1674
01:11:28,900 --> 01:11:31,333
就是我们说的或者叫do对象了

1675
01:11:31,333 --> 01:11:33,166
叫做领域模型region对象了

1676
01:11:33,200 --> 01:11:34,933
这时候我们才能做对象

1677
01:11:35,000 --> 01:11:36,133
面向对象的事情

1678
01:11:36,300 --> 01:11:37,766
那剩下的事情就有两件事情

1679
01:11:37,766 --> 01:11:39,466
第一这个对象的状态对不

1680
01:11:39,466 --> 01:11:40,566
对第二

1681
01:11:40,566 --> 01:11:42,499
这个对象状态对了

1682
01:11:42,500 --> 01:11:44,933
可以在底下圈指对象

1683
01:11:45,166 --> 01:11:46,466
但是我们会发现说

1684
01:11:46,466 --> 01:11:47,466
我们把这两个知识

1685
01:11:47,466 --> 01:11:50,066
通通都交给了reading去做

1686
01:11:50,266 --> 01:11:54,133
而不是在server层去写方法

1687
01:11:54,766 --> 01:11:57,399
这个就是我们说的这个

1688
01:11:57,600 --> 01:11:59,733
后面的信息专家和创建者

1689
01:11:59,733 --> 01:12:01,166
两个合到一起去了啊

1690
01:12:01,500 --> 01:12:03,200
那我们这里首先讲创建者

1691
01:12:03,966 --> 01:12:05,799
创建一个新的瑞景对象

1692
01:12:05,966 --> 01:12:07,266
我们不是在身份证上

1693
01:12:07,266 --> 01:12:08,466
写了一个6的方法

1694
01:12:08,466 --> 01:12:09,466
把它创建出来

1695
01:12:09,466 --> 01:12:11,799
然后再到个稻城去把它存下去

1696
01:12:12,100 --> 01:12:14,333
大家市面上看到的大部分的代码

1697
01:12:14,333 --> 01:12:15,399
应该都这么写的

1698
01:12:16,400 --> 01:12:19,166
我们裁卷的方式是做冲血模型

1699
01:12:19,533 --> 01:12:21,133
就是把这些职责

1700
01:12:21,133 --> 01:12:23,466
交给了我们的领域对象

1701
01:12:23,866 --> 01:12:25,866
就是我们的reaching对象去完成

1702
01:12:26,300 --> 01:12:28,100
为什么会交给他去完成

1703
01:12:28,100 --> 01:12:30,166
因为我们在对象模型中间可以看到

1704
01:12:32,000 --> 01:12:32,900
这个过程

1705
01:12:32,966 --> 01:12:34,999
是因为每一个子对象

1706
01:12:35,000 --> 01:12:37,500
都是他副对象的局部

1707
01:12:38,666 --> 01:12:40,299
也就是我们在这个对象模型中间

1708
01:12:40,300 --> 01:12:44,166
是不允许出现说我建出一个子对象

1709
01:12:44,666 --> 01:12:47,066
它是没有一个副对象

1710
01:12:47,066 --> 01:12:49,133
或者他的副对象的状态是不对的

1711
01:12:49,400 --> 01:12:51,766
是不应该出现这样的一种状况的

1712
01:12:51,800 --> 01:12:53,133
那你怎么样保证

1713
01:12:53,133 --> 01:12:54,766
不出现这样的一个状况呢

1714
01:12:54,900 --> 01:12:56,500
就是我压根就不允许

1715
01:12:56,500 --> 01:12:58,266
孤立的去建一个子对象

1716
01:12:58,266 --> 01:12:59,699
代码中间没有这种代码

1717
01:13:00,133 --> 01:13:01,299
就没有任何一行代码

1718
01:13:01,300 --> 01:13:03,400
是可以孤立的去建一个子对象的

1719
01:13:03,400 --> 01:13:05,900
我必须在一个副对象底下

1720
01:13:05,900 --> 01:13:07,933
才能建出这个子对象的

1721
01:13:08,200 --> 01:13:09,566
从代码上就这么做的

1722
01:13:09,700 --> 01:13:10,533
所以大家可以看到

1723
01:13:10,533 --> 01:13:11,933
我们整个方法中间

1724
01:13:11,933 --> 01:13:13,866
就没有任何一行代码

1725
01:13:14,066 --> 01:13:15,999
是可以去孤立的建出一个对象

1726
01:13:16,000 --> 01:13:16,866
然后把这个对象

1727
01:13:16,866 --> 01:13:18,299
加到一个副对象底下的

1728
01:13:18,300 --> 01:13:19,266
没有这种代码

1729
01:13:20,100 --> 01:13:21,600
见对象就必须在

1730
01:13:21,600 --> 01:13:24,300
副对象底下去见子对象

1731
01:13:24,800 --> 01:13:26,766
从代码的设计角度

1732
01:13:26,966 --> 01:13:29,533
保证我们在逻辑角度上

1733
01:13:29,533 --> 01:13:32,499
都不会出现孤立的子对象

1734
01:13:32,500 --> 01:13:33,933
所以我们可以看到

1735
01:13:34,900 --> 01:13:37,266
这个见指对象的这个事情

1736
01:13:37,266 --> 01:13:38,899
我们用创建者的方式

1737
01:13:38,900 --> 01:13:41,366
把它交给了region对象去完成

1738
01:13:41,700 --> 01:13:43,700
啊这个parent这个画错了

1739
01:13:43,700 --> 01:13:46,000
parent其实是一个region的对象

1740
01:13:46,566 --> 01:13:49,333
那交给了这个region对象去完成以后

1741
01:13:49,366 --> 01:13:50,933
那region对象里头的方法

1742
01:13:51,866 --> 01:13:53,299
我们里头是有一个判断

1743
01:13:53,333 --> 01:13:56,333
判断当前的状态是不是合理的

1744
01:13:56,533 --> 01:13:57,733
如果是合理的

1745
01:13:57,733 --> 01:14:00,699
他再去调约景道去完成

1746
01:14:01,133 --> 01:14:02,366
如果大家以前有写过

1747
01:14:02,366 --> 01:14:03,899
我估计小区大家是不是有写过

1748
01:14:03,900 --> 01:14:06,100
这个spring boot的应用

1749
01:14:07,066 --> 01:14:09,133
写过吗如果有写过的话

1750
01:14:09,133 --> 01:14:09,933
应该知道

1751
01:14:10,266 --> 01:14:11,999
目前市面上大部分的代码

1752
01:14:12,000 --> 01:14:12,933
不是这么写的

1753
01:14:13,466 --> 01:14:15,899
这是我们从去年开始

1754
01:14:16,733 --> 01:14:19,399
引入了这个DD的设计的方式

1755
01:14:19,600 --> 01:14:23,333
把我们的Bo对象变成了一个肥的对象

1756
01:14:23,600 --> 01:14:25,366
变成了一个胖的对象

1757
01:14:25,366 --> 01:14:26,299
是这么干的

1758
01:14:26,666 --> 01:14:27,666
这种做法就是

1759
01:14:27,666 --> 01:14:29,333
Bo对象中间其实是有道的

1760
01:14:29,766 --> 01:14:32,699
然后调到的方法去把它存下来

1761
01:14:32,766 --> 01:14:36,199
那这样做的最终的目的就是service

1762
01:14:36,200 --> 01:14:37,966
成的这个reading

1763
01:14:37,966 --> 01:14:41,099
service成了我们的对象的协调者

1764
01:14:41,133 --> 01:14:43,699
而不是对象职责的承担者

1765
01:14:44,200 --> 01:14:45,800
这个这个想法

1766
01:14:45,800 --> 01:14:47,800
跟目前滴滴滴的这个做法

1767
01:14:47,800 --> 01:14:48,800
都是不一样的

1768
01:14:48,900 --> 01:14:51,133
因为滴滴滴的做法里头还有说

1769
01:14:51,133 --> 01:14:51,799
吃不吃对象

1770
01:14:51,800 --> 01:14:53,600
他是要承担一定的职责的

1771
01:14:53,666 --> 01:14:55,466
我们现在完全把吃不吃对象

1772
01:14:55,466 --> 01:14:56,266
变成一个瘦子

1773
01:14:56,266 --> 01:14:58,399
这个瘦子就是他不做任何的职责

1774
01:14:58,966 --> 01:15:00,499
他如果可以不做职责啊

1775
01:15:00,500 --> 01:15:01,966
他就完全不做职责

1776
01:15:02,300 --> 01:15:04,000
单纯成为协调者

1777
01:15:04,166 --> 01:15:08,499
把所有的职责分给我们的领域对象

1778
01:15:08,500 --> 01:15:10,166
或者Bo对象去完成

1779
01:15:10,400 --> 01:15:11,466
所以大家可以看到

1780
01:15:11,466 --> 01:15:14,066
最后包括纯数据库的这样一个过程

1781
01:15:14,333 --> 01:15:16,166
都是在Bo对象里头完成的

1782
01:15:16,766 --> 01:15:18,466
那如果状态是对的

1783
01:15:18,466 --> 01:15:20,333
他就把这个对象做出来

1784
01:15:20,333 --> 01:15:21,666
然后把它存进去

1785
01:15:21,766 --> 01:15:23,266
如果状态是不对的

1786
01:15:23,266 --> 01:15:24,499
他会抛出一个exception

1787
01:15:24,500 --> 01:15:26,900
说当前这个区域是一个abandon的区域

1788
01:15:27,200 --> 01:15:28,566
然后如果存下去的话

1789
01:15:28,566 --> 01:15:30,133
会把新的对象返回回来

1790
01:15:30,300 --> 01:15:32,000
you region一路带回来

1791
01:15:32,000 --> 01:15:34,133
带到第三句然后

1792
01:15:35,800 --> 01:15:37,466
在第8句的时候

1793
01:15:38,166 --> 01:15:41,399
去把这个lyric景变成一个DTO的对象

1794
01:15:41,500 --> 01:15:42,700
返回给前端

1795
01:15:42,900 --> 01:15:46,266
这就是我们的创建者的设计模式

1796
01:15:47,000 --> 01:15:48,933
我们大家看一下这个代码是怎么写的

1797
01:15:53,333 --> 01:15:56,066
代码我好像新的代码还没有更新上去

1798
01:15:56,066 --> 01:15:56,866
这个

1799
01:15:58,400 --> 01:15:59,366
代码还有

1800
01:16:01,066 --> 01:16:02,099
看一下吧

1801
01:16:21,500 --> 01:16:23,166
因为刚才一二节课讲的时候

1802
01:16:23,166 --> 01:16:24,466
我就发现代码中有bug

1803
01:16:24,466 --> 01:16:25,866
所以我刚刚改了下bug

1804
01:16:27,066 --> 01:16:29,766
但是因为刚才还没有提交上去

1805
01:16:36,366 --> 01:16:37,933
我们从control层方法看一下啊

1806
01:16:37,933 --> 01:16:40,799
这个在admin control里头

1807
01:16:41,533 --> 01:16:46,166
所以在admin control里头它其实是有一个

1808
01:16:50,100 --> 01:16:51,800
这个create submarine

1809
01:16:51,866 --> 01:16:53,533
水景是跟对着我们图看

1810
01:16:53,533 --> 01:16:54,399
就这个方法

1811
01:16:54,766 --> 01:16:55,899
这个方法中间大家可以看到

1812
01:16:55,900 --> 01:16:57,333
我在图里头没有画的时候

1813
01:16:57,333 --> 01:16:58,599
我竟然有判断了

1814
01:16:58,600 --> 01:17:02,666
他的这个did是不是platform

1815
01:17:02,666 --> 01:17:03,699
我们在代码中应该知道

1816
01:17:03,700 --> 01:17:04,733
一个最基本的原则

1817
01:17:04,733 --> 01:17:06,566
就是不能写常量是吧

1818
01:17:06,566 --> 01:17:08,166
所以platform是定义在CONS中间的

1819
01:17:08,166 --> 01:17:08,666
一个常量

1820
01:17:08,666 --> 01:17:09,466
其实就是0

1821
01:17:09,966 --> 01:17:12,366
如果它不等的话

1822
01:17:12,800 --> 01:17:14,466
那这时候他其实是不能操作的

1823
01:17:14,466 --> 01:17:15,133
因为我们设定了

1824
01:17:15,133 --> 01:17:17,533
这个功能只能由平台管理员来操作

1825
01:17:17,866 --> 01:17:19,466
然后除了这个判断以外

1826
01:17:19,600 --> 01:17:21,133
在control上就做了两件

1827
01:17:21,133 --> 01:17:23,733
事情一件事情是把VO变成region

1828
01:17:23,800 --> 01:17:26,900
一件事情是把传回来的这个region

1829
01:17:26,966 --> 01:17:30,999
new region再把它变成一个这个我们的要

1830
01:17:31,000 --> 01:17:33,200
或者只有ID和name的一个对象

1831
01:17:33,200 --> 01:17:34,066
DTO对象

1832
01:17:34,466 --> 01:17:36,733
这就是我们说的control层的职责

1833
01:17:37,000 --> 01:17:38,966
干嘛呢负责接收数据

1834
01:17:39,366 --> 01:17:41,133
数据从接收的数据

1835
01:17:41,133 --> 01:17:43,399
变成我们的对象模型

1836
01:17:43,866 --> 01:17:46,133
然后把结果再从对象模型

1837
01:17:46,200 --> 01:17:50,700
变回我们的要传过去的数据

1838
01:17:51,500 --> 01:17:53,333
这就是乘和乘的职责

1839
01:17:53,466 --> 01:17:56,499
所有的逻辑都不在controller层里头

1840
01:17:56,733 --> 01:17:57,566
逻辑在哪呢

1841
01:17:57,566 --> 01:17:59,133
逻辑在收费层里头

1842
01:17:59,600 --> 01:18:00,766
你收费层以下啊

1843
01:18:00,766 --> 01:18:01,799
不是收费层里头

1844
01:18:01,900 --> 01:18:02,866
所以你可以看到

1845
01:18:02,866 --> 01:18:04,466
当我把传说的数据

1846
01:18:04,466 --> 01:18:06,499
变成我们所要的reading对象以后

1847
01:18:06,566 --> 01:18:09,299
我们其实往后走的

1848
01:18:09,300 --> 01:18:10,700
都是我们的对象模型

1849
01:18:10,733 --> 01:18:12,099
都是我们的领域对象

1850
01:18:12,366 --> 01:18:15,933
那我们调这个service的create sub region啊

1851
01:18:15,933 --> 01:18:17,933
去看它是怎么来完成的

1852
01:18:31,933 --> 01:18:33,733
Chris Abrision其实非常的简单

1853
01:18:33,733 --> 01:18:35,066
就我说的两件事情

1854
01:18:35,200 --> 01:18:35,733
第一件事情

1855
01:18:35,733 --> 01:18:37,266
去找一下这个对象在不在

1856
01:18:38,166 --> 01:18:39,766
是吧第二件事情呢

1857
01:18:40,000 --> 01:18:40,966
找到以后

1858
01:18:41,533 --> 01:18:43,199
在这个对象底下去创建此对象

1859
01:18:43,200 --> 01:18:44,900
这就是创建者的模式

1860
01:18:44,900 --> 01:18:47,766
起的作用就是创建这个新的对象

1861
01:18:47,766 --> 01:18:48,499
这段逻辑

1862
01:18:48,500 --> 01:18:49,666
并不是写在

1863
01:18:50,133 --> 01:18:51,599
收费市场的这个代码中间的

1864
01:18:51,900 --> 01:18:53,300
如果大家之前有写过这个代码

1865
01:18:53,300 --> 01:18:55,700
或者是在网上看到的现有代码

1866
01:18:55,933 --> 01:18:58,599
一般就是在社会层直接把它写下去了

1867
01:18:58,966 --> 01:19:00,333
但是我们的做法来说

1868
01:19:00,333 --> 01:19:02,299
我们并不是在社会层去写这些代码

1869
01:19:02,533 --> 01:19:06,133
而是在社会层成为了一个协调者

1870
01:19:06,766 --> 01:19:08,866
他把职责分配给了这个

1871
01:19:08,866 --> 01:19:10,533
稻城的rejects道

1872
01:19:10,533 --> 01:19:10,866
当然

1873
01:19:10,866 --> 01:19:13,333
这个分配并不是基于面向对象的考虑

1874
01:19:13,333 --> 01:19:13,999
这是基于什么

1875
01:19:14,000 --> 01:19:14,800
呢

1876
01:19:15,100 --> 01:19:16,966
这是具面向功能的考虑

1877
01:19:17,266 --> 01:19:21,199
就是因为自己有稻城那个去查对象

1878
01:19:21,200 --> 01:19:22,666
因为查对象这个过程

1879
01:19:22,666 --> 01:19:23,699
大家如果去看里头代码

1880
01:19:23,700 --> 01:19:25,266
我没有给大家画出来

1881
01:19:25,400 --> 01:19:26,800
他其实帮了两部分

1882
01:19:26,800 --> 01:19:28,166
一部分是如果缓存率有

1883
01:19:28,166 --> 01:19:29,366
直接从缓存率拿

1884
01:19:29,566 --> 01:19:30,866
如果缓存率没有

1885
01:19:30,866 --> 01:19:32,799
他就是到数据库里去查

1886
01:19:32,800 --> 01:19:33,900
好给大家看一下吧

1887
01:19:34,533 --> 01:19:35,699
这部分代码是没有

1888
01:19:36,066 --> 01:19:37,899
没有把它画在图上啊

1889
01:19:38,100 --> 01:19:39,000
因为其实画图

1890
01:19:39,000 --> 01:19:41,500
是不需要把所有的细节都画在图上的

1891
01:19:41,766 --> 01:19:43,599
它其实只需要描述说

1892
01:19:43,600 --> 01:19:46,166
你的一个大的思路和分工

1893
01:19:46,166 --> 01:19:47,999
设计的是idea是什么

1894
01:19:48,766 --> 01:19:50,399
这就是我们的find the 8ID

1895
01:19:51,500 --> 01:19:52,166
find my ID

1896
01:19:52,166 --> 01:19:55,066
里头其实就是分为了两个部分啊

1897
01:19:55,333 --> 01:19:56,466
一个部分是

1898
01:19:57,933 --> 01:19:59,799
什么呢一个部分是从raise啦

1899
01:20:00,600 --> 01:20:01,900
我们用了一个瑞兹缓存

1900
01:20:01,900 --> 01:20:02,733
为了提速

1901
01:20:03,566 --> 01:20:06,199
所以如果说缓存里是有这个数据的

1902
01:20:06,200 --> 01:20:08,266
那他就把这个数据直接拿出来

1903
01:20:08,533 --> 01:20:10,333
如果缓存里没有这个数据

1904
01:20:10,333 --> 01:20:12,399
这就是直接到数据库里去找了

1905
01:20:12,566 --> 01:20:14,399
那数据库里把它找出来

1906
01:20:14,400 --> 01:20:16,366
然后再把它放到缓存里去

1907
01:20:16,700 --> 01:20:18,666
这个其实是把它放到缓存里去

1908
01:20:18,666 --> 01:20:20,566
我们不仅仅把它放到缓存里去

1909
01:20:20,566 --> 01:20:23,466
而且我们把它变成一个胖的Bo对象

1910
01:20:23,466 --> 01:20:24,533
为什么叫胖的Bo对象

1911
01:20:24,533 --> 01:20:27,499
大家可以看到上面的这个get bo的方法

1912
01:20:28,333 --> 01:20:29,933
啊他把p o变成了b o

1913
01:20:30,400 --> 01:20:34,300
然后呢还把b o里头的这个

1914
01:20:34,533 --> 01:20:36,533
设了一个我们的倒对象在里头

1915
01:20:36,533 --> 01:20:38,733
为啥因为我们的b o对象里头

1916
01:20:38,733 --> 01:20:40,533
是会去访问倒对象

1917
01:20:40,533 --> 01:20:41,599
去做操作的

1918
01:20:41,966 --> 01:20:43,766
这个做法来说啊

1919
01:20:43,766 --> 01:20:44,966
应该是大家在市面上的

1920
01:20:44,966 --> 01:20:46,266
应该是没有看到过的

1921
01:20:46,366 --> 01:20:49,966
这是我们在这几年的这个

1922
01:20:50,133 --> 01:20:51,399
领域模型的改变时候

1923
01:20:51,400 --> 01:20:54,533
我们是试图把领域模型做的更加的胖

1924
01:20:54,766 --> 01:20:57,466
就是原来只是一个充血模型

1925
01:20:57,466 --> 01:20:59,699
我们试图把它做成一个满血模型

1926
01:20:59,700 --> 01:21:01,700
比DED还要激进一点啊

1927
01:21:01,700 --> 01:21:02,733
还要激进一点

1928
01:21:02,933 --> 01:21:03,166
所以

1929
01:21:03,166 --> 01:21:05,399
把倒对象也放到了这个reading里头

1930
01:21:05,600 --> 01:21:07,933
这样的话有逻辑

1931
01:21:07,933 --> 01:21:11,533
由这个Bo对象来操作数据库

1932
01:21:11,533 --> 01:21:15,066
而不是由身份证对象去操作盗对象啊

1933
01:21:15,566 --> 01:21:16,733
这个做法啊

1934
01:21:17,000 --> 01:21:19,400
会使得我们可以把更多的职责

1935
01:21:19,400 --> 01:21:20,900
分配给了Bo对象

1936
01:21:20,966 --> 01:21:22,699
分配给了我们的do对象

1937
01:21:26,300 --> 01:21:28,933
所以如果说他在数据库里把它找到了

1938
01:21:28,933 --> 01:21:30,866
然后把它变成一个肥胖的

1939
01:21:30,866 --> 01:21:31,766
这个get b o时间

1940
01:21:31,766 --> 01:21:34,766
把它变成一个肥胖的b o对象啊

1941
01:21:34,766 --> 01:21:36,366
给他返回回去了

1942
01:21:37,100 --> 01:21:39,400
这是这个到的方法

1943
01:21:45,200 --> 01:21:45,966
那我们看一下

1944
01:21:45,966 --> 01:21:48,466
他的这个reading的方法做了啥

1945
01:21:52,200 --> 01:21:54,733
我们在图上呢看到这个region的方法

1946
01:21:55,333 --> 01:21:58,533
调了它的create region去构造了这个对象

1947
01:22:31,566 --> 01:22:35,299
这个这个代码还有一个bug

1948
01:22:35,300 --> 01:22:37,133
就是他没有判断状态

1949
01:22:37,266 --> 01:22:38,666
我只好把它加上去了啊

1950
01:22:38,666 --> 01:22:39,799
还没有上传上来

1951
01:22:40,000 --> 01:22:41,000
所以他应该判断一下

1952
01:22:41,000 --> 01:22:41,733
当前这个状态

1953
01:22:41,733 --> 01:22:44,533
是不是能create这个指路径

1954
01:22:44,800 --> 01:22:46,333
指的地区啊

1955
01:22:46,333 --> 01:22:48,933
我们说只有word和suspend状态是可以的

1956
01:22:48,933 --> 01:22:51,299
而band状态是不能在创建指地区的

1957
01:22:51,500 --> 01:22:52,733
但如果可以的话

1958
01:22:52,733 --> 01:22:54,099
它就会创建指地区

1959
01:22:54,266 --> 01:22:57,799
所以大家可以看到它把这个ID

1960
01:22:57,933 --> 01:23:00,366
把这个reaching的该的属性啊

1961
01:23:00,366 --> 01:23:01,599
给它set了一下

1962
01:23:01,700 --> 01:23:04,266
然后它就调稻城的音色的方法

1963
01:23:04,300 --> 01:23:05,666
把它存进去了

1964
01:23:05,800 --> 01:23:08,100
那我们看一下稻城的音色的方法

1965
01:23:16,766 --> 01:23:18,266
这就是稻城的一设的方法

1966
01:23:18,366 --> 01:23:18,999
稻城的一套方法

1967
01:23:19,000 --> 01:23:19,866
再进一步的

1968
01:23:19,866 --> 01:23:22,799
把这个创建的用户和创建的时间

1969
01:23:22,933 --> 01:23:23,933
给它设一下

1970
01:23:24,166 --> 01:23:25,966
然后再把它考成PO对象

1971
01:23:27,466 --> 01:23:31,466
然后调map层的safe方法把它存进去了

1972
01:23:31,700 --> 01:23:32,900
然后我们可以看一下

1973
01:23:32,900 --> 01:23:34,600
map层到底是什么

1974
01:23:35,366 --> 01:23:38,466
我们的这个设计的map层用的是JPA的

1975
01:23:40,466 --> 01:23:41,499
spin data GPA

1976
01:23:41,500 --> 01:23:42,666
而不是用的my batist

1977
01:23:42,900 --> 01:23:44,333
为啥用spinta GPA呢

1978
01:23:44,333 --> 01:23:45,933
就为什么大家都爱用这个

1979
01:23:46,766 --> 01:23:48,899
因为map城的代码真的很简单

1980
01:23:48,933 --> 01:23:50,533
就这么两行就完了

1981
01:23:50,533 --> 01:23:51,899
一行代码都没写

1982
01:23:52,533 --> 01:23:54,399
而且我们要调的那个方法

1983
01:23:54,400 --> 01:23:55,366
这里还没看到

1984
01:23:55,366 --> 01:23:57,133
为啥因为他默认实现了

1985
01:23:57,333 --> 01:23:58,733
直接调就可以啊

1986
01:23:58,733 --> 01:24:00,966
我们这里写的是他默认没有实现的

1987
01:24:01,300 --> 01:24:02,733
所以这么写两句

1988
01:24:02,900 --> 01:24:04,733
所以大家如果使用过Maps的话

1989
01:24:04,733 --> 01:24:06,399
Maps会生成一大堆的东西

1990
01:24:06,866 --> 01:24:08,933
但是如果使用spindatajpa的话

1991
01:24:08,933 --> 01:24:09,999
啥东西都没有

1992
01:24:10,533 --> 01:24:13,133
全部都在不言中啊

1993
01:24:13,133 --> 01:24:14,066
全部都在不言中

1994
01:24:14,166 --> 01:24:17,366
所以我们除了支付那个模块

1995
01:24:17,533 --> 01:24:19,999
我们还是会用一个模块用mypades来写

1996
01:24:20,366 --> 01:24:21,333
其他的模块

1997
01:24:21,766 --> 01:24:22,699
必做的部分

1998
01:24:22,700 --> 01:24:24,400
同学们都自主地选择了

1999
01:24:24,400 --> 01:24:27,866
使用这个GPA来做啊

2000
01:24:27,866 --> 01:24:29,166
spring data GPA来做

2001
01:24:29,266 --> 01:24:31,799
而且它的效率不会差于my betes

2002
01:24:31,800 --> 01:24:32,333
为什么呢

2003
01:24:32,333 --> 01:24:33,666
是因为我们的同学

2004
01:24:33,666 --> 01:24:35,699
去年同学又把这个GPA改造了一下

2005
01:24:35,700 --> 01:24:37,066
默认还是挺慢的

2006
01:24:37,200 --> 01:24:37,466
但是

2007
01:24:37,466 --> 01:24:39,866
他把这个GPA的reporter也重新改了一下

2008
01:24:40,266 --> 01:24:41,166
改了一些方法

2009
01:24:41,166 --> 01:24:43,933
所以说他目前的效率还是不错的啊

2010
01:24:43,933 --> 01:24:45,066
可以去做一下对比

2011
01:24:45,066 --> 01:24:47,999
其实不差于那个my Belis的这个效率

2012
01:24:48,300 --> 01:24:50,933
这个为什么在目前业内用的比较少

2013
01:24:51,100 --> 01:24:54,066
就是因为这个推出的时间晚

2014
01:24:54,400 --> 01:24:55,166
很多的系统

2015
01:24:55,166 --> 01:24:56,133
比如说我

2016
01:24:56,133 --> 01:24:58,399
们现在之前的支付是用Mypad写的

2017
01:24:58,566 --> 01:24:59,766
也没人想把它改过来

2018
01:24:59,766 --> 01:25:01,499
所以他就一直用Mypad写下来

2019
01:25:01,666 --> 01:25:03,799
但是如果新的项目的话啊

2020
01:25:03,800 --> 01:25:04,666
用这个来写的话

2021
01:25:04,666 --> 01:25:06,866
他的代码会少更多啊

2022
01:25:06,866 --> 01:25:07,699
会少更多

2023
01:25:08,700 --> 01:25:09,466
新的东西啊

2024
01:25:09,466 --> 01:25:12,266
总是会比旧的东西要往前走一步

2025
01:25:12,333 --> 01:25:14,166
不可能说比旧的东西更差

2026
01:25:14,166 --> 01:25:16,733
但是因为很多的项目是有传承的

2027
01:25:16,733 --> 01:25:18,366
所以就没办法用新的东西

2028
01:25:20,666 --> 01:25:21,499
那我们的课呢

2029
01:25:21,500 --> 01:25:22,800
新的东西也讲对吧

2030
01:25:22,800 --> 01:25:24,133
旧的东西也讲

2031
01:25:24,300 --> 01:25:25,800
但是同学们自己选择

2032
01:25:25,800 --> 01:25:26,200
就是你们

2033
01:25:26,200 --> 01:25:27,333
特别是你们的选中模块

2034
01:25:27,333 --> 01:25:28,733
你们自己选择用什么

2035
01:25:28,933 --> 01:25:31,699
这个就是用的实名的JPA

2036
01:25:31,900 --> 01:25:32,533
但其实

2037
01:25:32,533 --> 01:25:36,166
因为我们做成了独立的稻城和map城

2038
01:25:37,066 --> 01:25:39,666
我们在用my Betis还是用JPI的时候

2039
01:25:39,666 --> 01:25:41,966
其实稻城是完全没有感觉的

2040
01:25:42,266 --> 01:25:43,699
就是我们在做这个

2041
01:25:43,966 --> 01:25:44,533
大家可以看到

2042
01:25:44,533 --> 01:25:45,966
我们在做这个视频的JPI的时候

2043
01:25:45,966 --> 01:25:47,933
我们也尽量把它模仿成为

2044
01:25:47,933 --> 01:25:49,499
用my Betis生成的东西

2045
01:25:49,866 --> 01:25:51,699
尽量把它模仿成一模一样啊

2046
01:25:51,700 --> 01:25:52,500
所以说

2047
01:25:53,000 --> 01:25:55,733
其实是可以在map程去给它替换掉

2048
01:25:55,900 --> 01:25:57,800
这就是我们为什么会用分层体系结构

2049
01:25:57,800 --> 01:25:59,100
这个原因

2050
01:26:00,666 --> 01:26:01,733
啊这是

2051
01:26:06,366 --> 01:26:07,399
我们的这个代码

2052
01:26:07,766 --> 01:26:08,866
大家可以看到啊

2053
01:26:08,866 --> 01:26:10,599
当我把这张图画出来的时候

2054
01:26:10,600 --> 01:26:14,666
基本上代码的7成都有能够看出来了

2055
01:26:14,933 --> 01:26:17,366
当然在实际设计的时候

2056
01:26:17,366 --> 01:26:19,333
其实是不需要画的这么复杂的

2057
01:26:19,733 --> 01:26:21,333
我们在实际设计的时候啊

2058
01:26:21,333 --> 01:26:23,999
单纯从面向对象的设计的角度来说

2059
01:26:24,333 --> 01:26:26,499
画到第五步就够了

2060
01:26:27,500 --> 01:26:29,133
这一块其实是不需要画的

2061
01:26:29,466 --> 01:26:31,366
这一块的逻辑其实可以看到

2062
01:26:31,366 --> 01:26:33,966
它并不涉及到面向对象的一个内容

2063
01:26:33,966 --> 01:26:37,733
它是面向对象的方法里头的实现

2064
01:26:37,733 --> 01:26:38,999
逻辑就是

2065
01:26:39,000 --> 01:26:40,600
我们在做面向对象设计的时候

2066
01:26:40,600 --> 01:26:44,300
其实我们更关注的是职责怎么分配

2067
01:26:44,300 --> 01:26:46,066
法职责分配完了

2068
01:26:46,066 --> 01:26:47,933
至于这个职责怎么去做

2069
01:26:48,466 --> 01:26:49,333
这个部分

2070
01:26:49,333 --> 01:26:52,699
其实不太需要在这个顺序图里头

2071
01:26:52,700 --> 01:26:53,700
去把它描述出来

2072
01:26:53,700 --> 01:26:55,200
所以顺序图大家要关注说

2073
01:26:55,200 --> 01:26:56,166
我们在画的时候

2074
01:26:56,166 --> 01:26:58,866
其实更多的关注是这个职责怎么分配

2075
01:26:59,333 --> 01:27:01,499
职责分配好了以后怎么去做

2076
01:27:01,500 --> 01:27:03,566
其实是不需要在顺序图里画出来的啊

2077
01:27:03,966 --> 01:27:07,333
这是我们的创建者的模式

2078
01:27:08,666 --> 01:27:09,733
那信息专家的模式

2079
01:27:09,733 --> 01:27:11,966
我们放到下次课再讲吧

2080
01:27:11,966 --> 01:27:13,666
我们顺便讲一下最后这张图

2081
01:27:13,666 --> 01:27:14,599
给大家看一下

2082
01:27:14,933 --> 01:27:18,933
我把这张整个reaching的这个内图啊

2083
01:27:18,933 --> 01:27:20,533
把它完整的画在这了

2084
01:27:20,533 --> 01:27:22,399
我把它放大一点给大家看一下

2085
01:27:40,566 --> 01:27:41,499
这张图上头啊

2086
01:27:41,500 --> 01:27:43,466
大家就能看到我们的体系结构

2087
01:27:43,466 --> 01:27:46,366
它从上往下其实是控制器层

2088
01:27:46,700 --> 01:27:49,500
service层盗层和map层

2089
01:27:49,800 --> 01:27:51,066
大家的感觉是什么

2090
01:27:53,600 --> 01:27:55,533
越来越瘦是吧

2091
01:27:55,766 --> 01:27:58,966
方法的个数看起来越来越少对吧

2092
01:27:59,333 --> 01:28:01,166
因为我们每一个方法里头的代码量

2093
01:28:01,166 --> 01:28:01,933
其实差不多的

2094
01:28:01,933 --> 01:28:03,066
都不都不太多

2095
01:28:03,466 --> 01:28:05,466
多的话大概6行7行

2096
01:28:05,500 --> 01:28:07,333
少的话一行两行

2097
01:28:07,866 --> 01:28:10,366
所以从方法的个数上头

2098
01:28:10,366 --> 01:28:12,966
大家能够看到一个趋势是什么

2099
01:28:13,366 --> 01:28:14,499
代码的从用

2100
01:28:14,933 --> 01:28:16,766
因为最终的每一行代码

2101
01:28:16,766 --> 01:28:17,999
肯定就是每一个功能

2102
01:28:18,000 --> 01:28:20,300
肯定是从上面一直穿透到最下面的

2103
01:28:20,666 --> 01:28:21,733
一定是这么穿透的

2104
01:28:21,733 --> 01:28:24,199
他不可能说到中间除了是异常以外啊

2105
01:28:24,366 --> 01:28:25,399
除了是异常以外

2106
01:28:25,400 --> 01:28:26,700
真正拿到数据的东西

2107
01:28:26,700 --> 01:28:28,733
一定是从上到下全部穿透的

2108
01:28:29,166 --> 01:28:30,566
所以你从这张图上

2109
01:28:30,566 --> 01:28:33,966
你大家就能看出来说从上往下

2110
01:28:34,066 --> 01:28:35,566
越往下面代码越少

2111
01:28:35,900 --> 01:28:38,933
他是因为有做了从用的那每一层

2112
01:28:38,933 --> 01:28:39,266
上面

2113
01:28:39,266 --> 01:28:42,999
因为map层我们使用了speed data的GPA

2114
01:28:43,066 --> 01:28:44,299
所以它基本上没代码

2115
01:28:44,300 --> 01:28:45,000
0代码啊

2116
01:28:45,000 --> 01:28:46,733
就写了两个方法的定义

2117
01:28:46,766 --> 01:28:48,999
方法定义的代码都不用写啊

2118
01:28:49,000 --> 01:28:51,400
这是因为技术的进步给我们带来的

2119
01:28:51,733 --> 01:28:53,166
那稻城的部分来说

2120
01:28:53,166 --> 01:28:54,299
就是真三改查

2121
01:28:55,700 --> 01:28:57,933
真三啊

2122
01:28:57,933 --> 01:28:59,199
我们这里没有改啊

2123
01:28:59,200 --> 01:29:00,400
就是针3

2124
01:29:00,500 --> 01:29:01,400
然后查呢

2125
01:29:01,400 --> 01:29:03,400
他会有多种的需求

2126
01:29:03,400 --> 01:29:04,566
比如说find吧ID

2127
01:29:05,000 --> 01:29:08,400
然后找到指的路径

2128
01:29:08,400 --> 01:29:10,866
所以他查会因为API的不同

2129
01:29:10,866 --> 01:29:12,199
会有不同的要求

2130
01:29:12,333 --> 01:29:14,699
但是针和3我们这里没有改

2131
01:29:14,700 --> 01:29:16,466
因为地区不能改啊

2132
01:29:16,466 --> 01:29:18,966
所以针和3这两个部分来说

2133
01:29:18,966 --> 01:29:20,199
其实就是固定的

2134
01:29:20,600 --> 01:29:22,600
那真正的业务在哪呢

2135
01:29:22,600 --> 01:29:25,400
业务在这里和这里

2136
01:29:25,800 --> 01:29:26,766
在这两个东西当中

2137
01:29:26,766 --> 01:29:28,666
因为我们只有一个对象

2138
01:29:28,666 --> 01:29:29,966
只有一个reading对象

2139
01:29:30,133 --> 01:29:32,699
所以就在这个和这个里头

2140
01:29:32,866 --> 01:29:34,166
我们现在把职责

2141
01:29:34,166 --> 01:29:35,499
尽量的分配到了reading对象

2142
01:29:35,500 --> 01:29:36,266
中间所以大家看到

2143
01:29:36,266 --> 01:29:37,666
reading对象有好几个方法

2144
01:29:38,900 --> 01:29:40,666
那收费时的方法也有很多

2145
01:29:40,666 --> 01:29:42,366
但收费时方法的每一个里头

2146
01:29:42,366 --> 01:29:43,199
代码都很少

2147
01:29:43,200 --> 01:29:45,166
因为收费时的方法就干一件事情

2148
01:29:45,400 --> 01:29:46,733
把职责分给别人去干

2149
01:29:47,300 --> 01:29:48,200
所以我们可以看到

2150
01:29:48,200 --> 01:29:49,966
当我们要去建一个指定区的时候

2151
01:29:50,000 --> 01:29:52,366
我们首先调稻城的话去找到他

2152
01:29:52,366 --> 01:29:54,366
然后调他去把它建出来就好了

2153
01:29:54,366 --> 01:29:55,999
他所以他是个协调者

2154
01:29:56,100 --> 01:29:57,566
就是我们说的协作者

2155
01:29:57,733 --> 01:29:58,966
是由他来完成的

2156
01:29:58,966 --> 01:29:59,866
那控制器层呢

2157
01:29:59,866 --> 01:30:01,199
我们把它分成了三个

2158
01:30:01,200 --> 01:30:02,933
是因为我们有多少个API

2159
01:30:03,400 --> 01:30:04,866
上面就有多少个方法

2160
01:30:04,900 --> 01:30:06,500
所以你看你的API有多少

2161
01:30:06,700 --> 01:30:08,066
上面就有多少个方法

2162
01:30:08,166 --> 01:30:10,333
当然上面我们可以看到我们有一个VO

2163
01:30:10,333 --> 01:30:12,999
是用来接收数据的一个DTO

2164
01:30:13,000 --> 01:30:14,533
呢是用来往回传数据的

2165
01:30:14,533 --> 01:30:16,699
然后我们还有一个从括来的那个ID

2166
01:30:16,700 --> 01:30:17,700
name type

2167
01:30:17,700 --> 01:30:19,566
那个就是因为很多地方都会用到

2168
01:30:19,566 --> 01:30:20,966
只要传ID和name

2169
01:30:21,266 --> 01:30:24,133
所以我们从括里头做了一个DTO啊

2170
01:30:24,133 --> 01:30:26,066
严格来说是一个DTO

2171
01:30:26,466 --> 01:30:29,266
用来去往回去丢数据的啊

2172
01:30:29,266 --> 01:30:33,266
所以这是控制系统的三个方法啊

2173
01:30:33,733 --> 01:30:37,533
这些方法之间就是VO会变成region

2174
01:30:37,533 --> 01:30:38,499
region会变成PU

2175
01:30:38,666 --> 01:30:39,766
靠的都是这个

2176
01:30:40,066 --> 01:30:41,999
而这个代码其实是没有的

2177
01:30:42,000 --> 01:30:43,133
这是自动生成的

2178
01:30:43,300 --> 01:30:44,466
现在我们根据它的注解

2179
01:30:44,466 --> 01:30:45,666
生成的4个方法

2180
01:30:45,800 --> 01:30:48,066
所以负责把这些东西来做

2181
01:30:48,100 --> 01:30:50,933
拷贝进来的VO考成reading

2182
01:30:50,933 --> 01:30:53,466
reading传给service来做操作

2183
01:30:53,466 --> 01:30:55,733
service分配给reading去做

2184
01:30:55,966 --> 01:30:58,466
然后或者说分给到去做

2185
01:30:58,466 --> 01:30:59,366
去操作数据库

2186
01:30:59,366 --> 01:31:00,566
或者操作Redis

2187
01:31:00,700 --> 01:31:01,500
拿回来以后

2188
01:31:01,500 --> 01:31:02,800
最后再把它变成

2189
01:31:02,800 --> 01:31:04,133
再用它把它变成DTO

2190
01:31:04,133 --> 01:31:05,066
给它丢回去

2191
01:31:05,100 --> 01:31:07,333
就是这样的一个逻辑

2192
01:31:09,166 --> 01:31:14,499
啊这就是我们的最简单的一个模块

2193
01:31:14,500 --> 01:31:16,600
给大家讲一下它的体系结构

2194
01:31:16,900 --> 01:31:19,666
和我们的大概的这个设计的思路

2195
01:31:19,666 --> 01:31:21,066
是这样的一个思路

2196
01:31:21,333 --> 01:31:22,533
那里头的一个个的方法

2197
01:31:22,533 --> 01:31:24,199
我们放到下次课去讲吧

2198
01:31:24,200 --> 01:31:25,066
因为信息专家

2199
01:31:25,066 --> 01:31:27,299
我们还会用到若干个方法

2200
01:31:28,566 --> 01:31:29,399
有什么问题吗

2201
01:31:30,666 --> 01:31:33,099
大家之前有写过这个screen book代码嘛

2202
01:31:33,100 --> 01:31:34,366
或者网上看到screen book代码

2203
01:31:34,366 --> 01:31:36,066
应该是没有看到像我们这么写的

2204
01:31:36,900 --> 01:31:39,600
我们是试图去创造一种新的

2205
01:31:40,266 --> 01:31:43,099
更胖的领域模型啊

2206
01:31:43,100 --> 01:31:45,200
因为在学校里头的好处在于说

2207
01:31:45,333 --> 01:31:47,166
你在去做的时候

2208
01:31:47,900 --> 01:31:50,166
你的目的不是说去墨守成规啊

2209
01:31:50,166 --> 01:31:52,533
因为传统的方法写评选模型

2210
01:31:52,533 --> 01:31:53,366
大家都会写

2211
01:31:53,533 --> 01:31:54,999
那个只是工作量的问题

2212
01:31:55,300 --> 01:31:56,100
冲选模型呢

2213
01:31:56,100 --> 01:31:57,766
其实不能改变它的

2214
01:31:58,266 --> 01:32:00,599
这个根本性的改变

2215
01:32:00,600 --> 01:32:01,466
因为冲血模型

2216
01:32:01,466 --> 01:32:02,399
其实是把一部分逻辑

2217
01:32:02,400 --> 01:32:03,533
放到了reading中间

2218
01:32:03,700 --> 01:32:06,300
但是如果他不能操作底下的数据的话

2219
01:32:06,300 --> 01:32:08,100
就不能操作底下的稻城的话

2220
01:32:08,266 --> 01:32:09,866
你会非常受限

2221
01:32:09,866 --> 01:32:11,066
说哪些东西能放进去呢

2222
01:32:11,066 --> 01:32:12,099
肯定不能放进去

2223
01:32:12,133 --> 01:32:13,099
我们现在是

2224
01:32:13,100 --> 01:32:16,566
给了领域模型完全的自由

2225
01:32:17,000 --> 01:32:18,266
这个自由靠什么来的

2226
01:32:18,266 --> 01:32:21,733
就是领域模型中间是有这个倒对象

2227
01:32:22,400 --> 01:32:23,600
靠这个东西来

2228
01:32:23,600 --> 01:32:25,600
使得领域模型有了完全的自由

2229
01:32:25,866 --> 01:32:26,666
所以

2230
01:32:26,733 --> 01:32:29,466
只要能够分配给领域模型对象的职责

2231
01:32:29,466 --> 01:32:31,499
我们都会分配给分配出去

2232
01:32:31,733 --> 01:32:33,999
使得收费值成的代码变得极少

2233
01:32:34,066 --> 01:32:35,766
造成只负责正常改查

2234
01:32:36,900 --> 01:32:38,933
主要代码全部在领域模型中间

2235
01:32:38,933 --> 01:32:40,533
这就是我们说的胖模型

2236
01:32:40,666 --> 01:32:43,166
这个胖模型主要是指领域模型很胖

2237
01:32:43,466 --> 01:32:47,566
所以在5层的这个结构中间

2238
01:32:47,933 --> 01:32:49,766
其实应该把中间的领域模型

2239
01:32:49,766 --> 01:32:51,066
画得非常的胖

2240
01:32:51,466 --> 01:32:53,899
把UPDK型变得非常的窄

2241
01:32:54,000 --> 01:32:55,166
然后最外头两层

2242
01:32:55,166 --> 01:32:58,366
其实就是负责往回传数据

2243
01:32:58,366 --> 01:33:00,166
和往底下去拿数据库的

2244
01:33:00,166 --> 01:33:03,533
这就是滴滴模型的这个精髓啊

2245
01:33:03,533 --> 01:33:04,933
其实就这个这个意思

2246
01:33:04,933 --> 01:33:05,999
但是我们从技术上走

2247
01:33:06,000 --> 01:33:07,866
让他的领域模型变得更加的胖

2248
01:33:08,133 --> 01:33:10,299
所以我们把它的名字不叫做充血模型

2249
01:33:10,300 --> 01:33:11,500
叫做满血模型

2250
01:33:11,733 --> 01:33:12,766
就里头那个是血

2251
01:33:12,766 --> 01:33:14,899
是心脏我们把里头这个领域模型

2252
01:33:14,900 --> 01:33:15,966
把它变得更胖

2253
01:33:16,000 --> 01:33:18,333
压缩周边的这个范围

2254
01:33:20,333 --> 01:33:21,266
有什么问题吗

2255
01:33:22,133 --> 01:33:23,666
好没什么问题我们就下课了

