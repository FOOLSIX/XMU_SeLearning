1
00:00:16,200 --> 00:00:19,133
好商铺这个模块来说

2
00:00:19,133 --> 00:00:21,933
它整体的结构还是相对比较简单的

3
00:00:21,933 --> 00:00:24,999
那我们从上往下给大家介绍一下

4
00:00:25,466 --> 00:00:26,099
控制器层

5
00:00:26,100 --> 00:00:27,400
跟其他的模块一样

6
00:00:27,400 --> 00:00:28,066
因为控制器层

7
00:00:28,066 --> 00:00:29,766
其实因为它职责比较简单

8
00:00:29,766 --> 00:00:32,699
就是用来做输入数据的检查

9
00:00:32,766 --> 00:00:34,266
输出数据的转换

10
00:00:34,800 --> 00:00:36,333
我已经说了n多遍了啊

11
00:00:37,000 --> 00:00:40,500
所以底头只有DTO和VOVO用来接数据

12
00:00:40,500 --> 00:00:42,166
DTO用来往回传数据

13
00:00:42,166 --> 00:00:42,933
这个基本上

14
00:00:42,933 --> 00:00:44,366
我们所有的存在control的程序

15
00:00:44,366 --> 00:00:45,199
不会做啥

16
00:00:45,366 --> 00:00:46,533
所以结构都是一样

17
00:00:47,200 --> 00:00:48,400
社会层大家会发现

18
00:00:48,400 --> 00:00:51,100
比我们之前的支付的模块

19
00:00:51,266 --> 00:00:54,799
和那个地区的模块都多了一点

20
00:00:54,800 --> 00:00:58,000
为啥呢因为这一个模块里头

21
00:00:58,000 --> 00:00:59,400
有用到了Rocky number

22
00:00:59,800 --> 00:01:02,466
有用到了消息服务啊

23
00:01:02,466 --> 00:01:06,166
所以我们把跟消息服务有关的代码

24
00:01:06,166 --> 00:01:07,399
放到listen里头

25
00:01:07,500 --> 00:01:09,766
但是我们不打算在今天来讲

26
00:01:09,766 --> 00:01:12,166
里头跟消息服务有关的东西

27
00:01:12,366 --> 00:01:16,566
这个放到加瓦伊伊的课的下一周啊

28
00:01:17,366 --> 00:01:18,566
还是下下一种

29
00:01:18,566 --> 00:01:20,099
我们讲到消息服务器

30
00:01:20,100 --> 00:01:21,800
Rocking q的那个部分来说

31
00:01:22,000 --> 00:01:25,666
将会讲到说在商铺模块中间

32
00:01:25,666 --> 00:01:27,766
我们这个部分的消息服务器

33
00:01:27,766 --> 00:01:28,266
是怎么用的

34
00:01:28,266 --> 00:01:31,333
我们会把这个模块和产品模块里头的

35
00:01:31,500 --> 00:01:33,600
用到消息服务器里头的所有的代码

36
00:01:33,600 --> 00:01:36,533
在加瓦一的内测课里头一次性的讲完

37
00:01:36,533 --> 00:01:37,766
所以会放的稍微厚一点

38
00:01:37,766 --> 00:01:40,333
但产品模块讲完以后啊

39
00:01:40,333 --> 00:01:42,566
才会他把所有的消息服务的代码

40
00:01:42,566 --> 00:01:43,399
放到一起讲

41
00:01:43,466 --> 00:01:44,366
我们今天不会讲

42
00:01:44,366 --> 00:01:46,066
这个listen里头做了啥啊

43
00:01:48,200 --> 00:01:49,300
但在包结构中间

44
00:01:49,300 --> 00:01:50,166
大家可能看到说

45
00:01:50,166 --> 00:01:53,299
它其实多了一个消息服务器的代码

46
00:01:54,300 --> 00:01:58,800
稻城来说大家可以看到复杂很多是吧

47
00:01:58,900 --> 00:02:01,100
一个是这个

48
00:02:02,300 --> 00:02:02,966
呃这个

49
00:02:02,966 --> 00:02:07,333
模块比虽然类没有支付模块那么多

50
00:02:08,400 --> 00:02:11,766
但是它的代码量是大很多

51
00:02:12,333 --> 00:02:13,799
虽然数据表没有那么多啊

52
00:02:13,800 --> 00:02:15,400
但是它的类多了很多

53
00:02:15,866 --> 00:02:16,133
所以

54
00:02:16,133 --> 00:02:18,466
这样会使得我们在Bo的这个部分来说

55
00:02:18,466 --> 00:02:21,733
我们把它的这些所有的Bo对象

56
00:02:22,300 --> 00:02:22,766
做了一个分

57
00:02:22,766 --> 00:02:25,599
分别类没有直接放到它的根目底下

58
00:02:25,800 --> 00:02:27,933
我们把两类的Bo对象

59
00:02:27,933 --> 00:02:29,366
给它单放了两个包啊

60
00:02:29,366 --> 00:02:30,866
因为通常在一个bo底下

61
00:02:30,866 --> 00:02:33,199
放了十几个或者20个类的话

62
00:02:33,200 --> 00:02:34,500
就会觉得太多啊

63
00:02:34,566 --> 00:02:36,966
这就是因为我们把它分了下类

64
00:02:37,100 --> 00:02:38,100
怎么分的呢

65
00:02:38,700 --> 00:02:39,966
就这里大家可以看到

66
00:02:40,366 --> 00:02:42,166
白色的部分在根目录底下

67
00:02:42,600 --> 00:02:44,600
黄色的部分在template底下

68
00:02:44,600 --> 00:02:46,733
黄色的部分包括那个白色的reading

69
00:02:46,733 --> 00:02:48,866
template在template底下

70
00:02:49,100 --> 00:02:51,366
绿色的部分在dewite底下

71
00:02:52,066 --> 00:02:55,766
所以上面的两个这个这个

72
00:02:55,766 --> 00:02:57,099
这个就是白色的

73
00:02:57,100 --> 00:02:58,400
蓝色的在根部底下

74
00:02:58,700 --> 00:03:00,400
这个在tempered底下

75
00:03:00,666 --> 00:03:04,999
绿色的所谓的东西在divide底下啊

76
00:03:05,000 --> 00:03:07,166
所以做了一个这个分类

77
00:03:07,366 --> 00:03:09,666
那到的话也做了一个分类

78
00:03:09,666 --> 00:03:13,166
就是跟那个Mango有关的部分

79
00:03:13,166 --> 00:03:14,699
把它放到了temper的底下

80
00:03:14,700 --> 00:03:16,900
跟Mango没关的放到了根目底下

81
00:03:17,166 --> 00:03:19,199
然后我们可以看到多了一个open Fi

82
00:03:19,500 --> 00:03:20,866
为什么多了一个open Fi

83
00:03:21,000 --> 00:03:23,133
我们看到Mac层多了一个open Fi

84
00:03:23,166 --> 00:03:24,933
所以稻城也多了一个open Fi

85
00:03:25,333 --> 00:03:25,799
这个原因

86
00:03:25,800 --> 00:03:29,266
就是因为这个模块又掉了region模块

87
00:03:29,900 --> 00:03:32,266
所以吊region模块的这个代码

88
00:03:32,266 --> 00:03:35,133
我们写到了Mapper层里头

89
00:03:35,400 --> 00:03:39,066
所以有一个吊region模块的open bend包

90
00:03:39,066 --> 00:03:40,733
里头是一个region的

91
00:03:40,733 --> 00:03:43,099
Mapper是去吊region模块

92
00:03:43,100 --> 00:03:45,500
我们用微服务的方式去

93
00:03:45,600 --> 00:03:47,600
raise rapi的方式啊去吊它

94
00:03:48,000 --> 00:03:49,866
但是那个返回来的那个值呢

95
00:03:49,866 --> 00:03:51,866
并不能满足我们最终的要求

96
00:03:51,866 --> 00:03:52,133
所以

97
00:03:52,133 --> 00:03:55,766
我们的在稻城又写了一个regional啊

98
00:03:55,766 --> 00:03:58,499
然后把调微服务的这个过程

99
00:03:58,500 --> 00:04:00,800
把它变成好像是个本地过程一样

100
00:04:00,900 --> 00:04:04,000
所以这一个东西也放到这个open里头

101
00:04:04,266 --> 00:04:09,166
这就是这个包结构的总体的内容啊

102
00:04:09,166 --> 00:04:12,466
所以大家可以看到说我们在模块

103
00:04:12,466 --> 00:04:13,799
一个模块一个模块

104
00:04:13,800 --> 00:04:15,266
随着他的内容越复杂

105
00:04:15,266 --> 00:04:17,199
技术越来越多啊

106
00:04:17,200 --> 00:04:19,533
他的这个包的结构啊

107
00:04:19,533 --> 00:04:21,966
也会变得越来越丰富啊

108
00:04:21,966 --> 00:04:22,666
不能说复杂

109
00:04:22,666 --> 00:04:24,466
但总体来说还是

110
00:04:25,066 --> 00:04:26,499
我们的分层体系结构

111
00:04:26,533 --> 00:04:29,599
就是Controller层service层倒层和map层

112
00:04:29,900 --> 00:04:33,266
每一层的职责大家一定要牢记在心

113
00:04:33,266 --> 00:04:34,899
因为这里头的每一行代码

114
00:04:34,900 --> 00:04:37,566
都是按照这个职责来写的

115
00:04:37,900 --> 00:04:39,366
control层负责输出输入

116
00:04:39,600 --> 00:04:41,466
Server层负责分配职责

117
00:04:41,566 --> 00:04:43,866
所以Server层相当于总控

118
00:04:43,966 --> 00:04:46,366
也是我们的所有的事物的切入点

119
00:04:46,566 --> 00:04:47,699
切在这个地方

120
00:04:48,000 --> 00:04:51,000
除了一些极少数的API的事物

121
00:04:51,000 --> 00:04:54,666
体现到了Controller层80%以上的

122
00:04:54,733 --> 00:04:57,999
特别是增伤感这一类的事物的

123
00:04:58,566 --> 00:05:00,166
这个边界

124
00:05:00,166 --> 00:05:00,866
都切断了

125
00:05:00,866 --> 00:05:03,266
service层稻城的主要的任务

126
00:05:03,266 --> 00:05:05,766
就是形成我们的Bo对象

127
00:05:05,900 --> 00:05:07,400
而Bo对象的主要的任务

128
00:05:07,400 --> 00:05:10,733
是承接从service层分配来的业务

129
00:05:11,300 --> 00:05:11,766
然后

130
00:05:11,766 --> 00:05:14,733
Mappeter是真正去访问具体的数据的

131
00:05:14,800 --> 00:05:19,066
无论这个数据是在啊Mac里头

132
00:05:19,066 --> 00:05:20,366
是在Mango里头

133
00:05:20,366 --> 00:05:23,099
还是在另外一个模块里头

134
00:05:23,100 --> 00:05:25,133
我们都是在marker层

135
00:05:25,200 --> 00:05:26,966
去完成这样的一个访问的

136
00:05:26,966 --> 00:05:29,466
所以每一层会写什么样的代码

137
00:05:29,500 --> 00:05:32,700
我们是有明确的这个定义的

138
00:05:33,933 --> 00:05:35,766
呃这是它的包结

139
00:05:35,766 --> 00:05:37,799
构那对象模型

140
00:05:37,800 --> 00:05:39,333
我们在之前有讲到过

141
00:05:39,333 --> 00:05:40,899
这一个部分的对象模型

142
00:05:40,900 --> 00:05:41,466
可以看到

143
00:05:41,466 --> 00:05:44,066
随着我们的一个一个的模块来讲

144
00:05:44,366 --> 00:05:46,399
变得五颜六色了啊

145
00:05:46,400 --> 00:05:47,533
变得五颜六色了

146
00:05:47,533 --> 00:05:48,099
就意味着说

147
00:05:48,100 --> 00:05:49,533
我们会用不同的技术

148
00:05:49,800 --> 00:05:52,000
来产生这些对象模型

149
00:05:52,366 --> 00:05:53,899
其中在这个模块中间

150
00:05:53,966 --> 00:05:55,899
白色的这些对象模型

151
00:05:55,900 --> 00:05:57,966
是会存在Mycpo数据库里的

152
00:05:58,133 --> 00:05:59,399
主要是商铺

153
00:05:59,933 --> 00:06:01,399
商铺的模板

154
00:06:01,533 --> 00:06:04,333
商铺和模板是一个一对多的关系啊

155
00:06:04,333 --> 00:06:05,599
这个要再改一下

156
00:06:05,933 --> 00:06:07,533
是一个一对多的关系

157
00:06:07,966 --> 00:06:08,966
但是我们在这里

158
00:06:08,966 --> 00:06:11,533
现在目前只记了一个一对一的关系

159
00:06:11,533 --> 00:06:13,333
因为我们认为一对多的关系

160
00:06:13,333 --> 00:06:15,066
其实在业务上没有意义

161
00:06:15,266 --> 00:06:16,466
一对一的关系

162
00:06:16,600 --> 00:06:17,566
一对多的关系

163
00:06:17,566 --> 00:06:18,966
只是为了查看的时候

164
00:06:18,966 --> 00:06:21,366
要看一个商铺有多少模板要查看

165
00:06:21,533 --> 00:06:22,533
所以对象模型中间

166
00:06:22,533 --> 00:06:24,333
没有记那个一对多的关系

167
00:06:25,500 --> 00:06:26,866
那查看的时候

168
00:06:26,866 --> 00:06:28,599
就用面相功能的方式去做

169
00:06:29,566 --> 00:06:30,666
在对象模型中间

170
00:06:30,666 --> 00:06:31,999
记了一个一对一的关系

171
00:06:32,000 --> 00:06:33,400
是它的default template的

172
00:06:33,400 --> 00:06:35,900
为什么是因为业务上面有这个需求

173
00:06:36,333 --> 00:06:39,766
就是当这个商铺的商品

174
00:06:39,766 --> 00:06:42,299
没有定义运费模板时候

175
00:06:42,566 --> 00:06:45,066
就会使用默认的运费模板

176
00:06:45,066 --> 00:06:46,933
去计算它的运费价格

177
00:06:47,466 --> 00:06:49,399
所以因为这个默认的运费模板

178
00:06:49,400 --> 00:06:50,800
是有业务意义的

179
00:06:50,800 --> 00:06:52,066
所以我们可以看到

180
00:06:52,366 --> 00:06:53,666
在对象模型中间

181
00:06:53,666 --> 00:06:55,199
我们并没有真实的记录

182
00:06:55,200 --> 00:06:56,700
它是一个一对多的关系

183
00:06:56,733 --> 00:06:58,133
而仅仅记录了

184
00:06:58,133 --> 00:07:01,666
我们有业务的default template啊

185
00:07:01,666 --> 00:07:03,566
所以这个是一个简化

186
00:07:03,566 --> 00:07:04,899
这个简化就是那个一对多的

187
00:07:04,900 --> 00:07:05,566
我们没记

188
00:07:05,566 --> 00:07:07,599
没记就只能靠面相功能的方式去实现

189
00:07:07,600 --> 00:07:09,366
而且业务上是用不到那个东西的

190
00:07:09,533 --> 00:07:10,899
只是为了看一下而已

191
00:07:14,166 --> 00:07:16,999
这个我再说这上面白色的

192
00:07:18,133 --> 00:07:18,933
嗯

193
00:07:21,133 --> 00:07:23,466
我那个那个那个纸张画一下

194
00:07:23,466 --> 00:07:24,566
可能这个图太复杂了

195
00:07:24,566 --> 00:07:26,899
大家已经看看不太清楚了啊

196
00:07:30,966 --> 00:07:32,566
这个地方啊

197
00:07:32,566 --> 00:07:33,533
他画不了吗

198
00:07:35,500 --> 00:07:36,300
为啥

199
00:07:41,100 --> 00:07:41,900
啊

200
00:07:43,800 --> 00:07:44,933
就就就晃晃吧

201
00:07:44,933 --> 00:07:45,733
这个地方

202
00:07:47,466 --> 00:07:48,266
啊

203
00:07:48,700 --> 00:07:50,333
这个本身是一个一对多的关系

204
00:07:50,333 --> 00:07:52,299
一个商铺是有多个运费模板

205
00:07:52,533 --> 00:07:54,366
但是我们在对讲模型里

206
00:07:54,366 --> 00:07:55,766
只记得一个一对一的关系

207
00:07:55,766 --> 00:07:57,766
因为这个一对一的关系是有业务

208
00:07:58,200 --> 00:08:00,000
一多多的关系只是为了查看

209
00:08:00,100 --> 00:08:01,900
所以这项某人就没有去记啊

210
00:08:01,900 --> 00:08:03,466
这是第一个

211
00:08:03,666 --> 00:08:05,166
那第二个是

212
00:08:05,400 --> 00:08:06,900
每一个运费模板中间

213
00:08:06,900 --> 00:08:09,900
在不同地区其实是有不同的定义的

214
00:08:09,966 --> 00:08:10,733
因为不同地区

215
00:08:10,733 --> 00:08:13,566
它定义的这个价钱是不一样

216
00:08:14,100 --> 00:08:16,966
所以我们这里的这个做法来说

217
00:08:16,966 --> 00:08:19,299
是针对每一个地区

218
00:08:19,933 --> 00:08:21,399
我们现在是针对每一个地区

219
00:08:21,400 --> 00:08:22,466
都需要定一条

220
00:08:22,866 --> 00:08:26,166
当然这个地方是有一点有一点溶于的

221
00:08:26,166 --> 00:08:27,999
啊就是说我们四个地区是一样的

222
00:08:28,000 --> 00:08:29,066
比如四个省市一样

223
00:08:29,133 --> 00:08:30,299
你就写四点啊

224
00:08:30,300 --> 00:08:31,600
现在目前是这个样子

225
00:08:32,066 --> 00:08:33,566
所以针对每个地区啊

226
00:08:33,566 --> 00:08:35,166
写这么一条

227
00:08:35,500 --> 00:08:36,566
写这么一个对象

228
00:08:36,800 --> 00:08:39,666
他和他之间也是一对多的

229
00:08:39,666 --> 00:08:40,333
就是一个

230
00:08:40,333 --> 00:08:40,799
用什么呢

231
00:08:40,800 --> 00:08:41,900
当然是每个地区

232
00:08:41,966 --> 00:08:42,999
很多地区都会定

233
00:08:43,000 --> 00:08:44,300
不是每个地区都会定义

234
00:08:44,600 --> 00:08:46,100
所以这是个一对多的

235
00:08:46,166 --> 00:08:47,166
但是我们可以拿到对

236
00:08:47,166 --> 00:08:47,599
项目中间

237
00:08:47,600 --> 00:08:50,966
我们没有选择记录一对多的这个方面

238
00:08:51,066 --> 00:08:55,499
而是选择记录了从多到1的这个部分

239
00:08:55,500 --> 00:08:57,066
这个原因也是因为业务的

240
00:08:57,100 --> 00:08:59,766
因为1到多的部分也只是为了看一下

241
00:08:59,766 --> 00:09:01,899
并没有任何业务在上面要去实现

242
00:09:02,100 --> 00:09:04,466
但是一个地区模板

243
00:09:04,466 --> 00:09:06,933
它到底是属于什么样的一个模板的

244
00:09:08,000 --> 00:09:09,100
这个是会

245
00:09:09,800 --> 00:09:11,266
这个是有意义的啊

246
00:09:11,266 --> 00:09:12,299
所以说我们进入了

247
00:09:12,300 --> 00:09:14,866
从这个方向到这个方向的关系

248
00:09:15,133 --> 00:09:16,699
这三个白色的部分

249
00:09:16,700 --> 00:09:19,966
我们都存在了my sequel的数据库里

250
00:09:20,366 --> 00:09:21,066
蓝色的部分

251
00:09:21,066 --> 00:09:21,766
这个region

252
00:09:21,766 --> 00:09:26,099
是从region的那个模块拿过来的

253
00:09:26,100 --> 00:09:26,733
对象啊

254
00:09:26,733 --> 00:09:28,799
所以我们用蓝色的方式去表示

255
00:09:28,800 --> 00:09:29,700
但我们先看一下

256
00:09:29,700 --> 00:09:31,766
这个蓝色的这个对象怎么拿到的

257
00:09:31,966 --> 00:09:32,933
先看下这部分代码

258
00:09:32,933 --> 00:09:33,999
我没有画图啊

259
00:09:34,000 --> 00:09:36,666
大家去了解一下他是怎么做到的

260
00:09:37,300 --> 00:09:38,400
黄色的这几个呢

261
00:09:38,400 --> 00:09:40,866
它是存在芒果数据库里

262
00:09:41,100 --> 00:09:42,966
我们为什么选择把它存在

263
00:09:42,966 --> 00:09:43,766
芒果数据库里

264
00:09:43,766 --> 00:09:46,599
因为我们在运费的计算的时候

265
00:09:46,600 --> 00:09:48,333
是有两种计算方式

266
00:09:48,700 --> 00:09:51,100
一个是按件的计算

267
00:09:51,266 --> 00:09:54,099
一个是按重量去算它的运费

268
00:09:54,300 --> 00:09:55,466
两种计算方式

269
00:09:55,466 --> 00:09:56,199
大家可以看到

270
00:09:56,200 --> 00:10:00,133
它的表述的方式是完全不一样

271
00:10:00,566 --> 00:10:01,733
基本上没有共性

272
00:10:01,733 --> 00:10:03,099
只有一点点有共性

273
00:10:03,266 --> 00:10:06,566
那这个共性我们把它写到了负类里头

274
00:10:07,400 --> 00:10:08,933
然后不同的地方

275
00:10:08,933 --> 00:10:10,299
我们把它写在纸类里头

276
00:10:10,533 --> 00:10:13,366
所以最终我们实现出来的对象

277
00:10:13,366 --> 00:10:15,066
是一个piece time的对象

278
00:10:15,066 --> 00:10:17,066
或者说是一个weight time的对象

279
00:10:17,100 --> 00:10:18,466
这个对象是一个abstract

280
00:10:18,733 --> 00:10:20,866
是不会有实力化出来

281
00:10:21,166 --> 00:10:22,399
那在存的时候呢

282
00:10:22,400 --> 00:10:23,200
这就比较

283
00:10:24,566 --> 00:10:25,466
比较难受了

284
00:10:25,466 --> 00:10:27,866
它其实是把一个peace time的对象

285
00:10:27,866 --> 00:10:28,599
里头的内容

286
00:10:28,600 --> 00:10:30,100
把它一p了两半

287
00:10:30,500 --> 00:10:32,333
它从负类继承来的属性

288
00:10:32,333 --> 00:10:34,133
我们把它存到my simple数据库里

289
00:10:35,266 --> 00:10:38,133
自己的属性存到了芒果数据库里

290
00:10:38,700 --> 00:10:40,500
为什么会这么做的

291
00:10:40,500 --> 00:10:41,733
主要的原因

292
00:10:41,733 --> 00:10:42,166
就是

293
00:10:42,166 --> 00:10:45,899
因为芒果数据库只能用组件去做查询

294
00:10:45,900 --> 00:10:48,200
他不太好去做查询

295
00:10:48,766 --> 00:10:51,333
因为我们现在的这一个对象

296
00:10:51,466 --> 00:10:52,899
实际上是这一个对象

297
00:10:52,900 --> 00:10:55,500
跟这一个对象是一个一对多的关系

298
00:10:55,500 --> 00:10:56,300
我们其实

299
00:10:56,300 --> 00:10:58,300
是需要从他来查到

300
00:10:58,300 --> 00:11:01,166
这个模板底下所有的东西的

301
00:11:01,166 --> 00:11:04,199
因为有一个要看的这个功能

302
00:11:04,200 --> 00:11:05,900
虽然业务上没有这个需求

303
00:11:05,900 --> 00:11:07,800
但是API里有一个需求

304
00:11:08,066 --> 00:11:11,366
需要从它来看到地下所有地区的模板

305
00:11:11,933 --> 00:11:13,899
那如果说整个这个

306
00:11:13,900 --> 00:11:16,466
包括它都存到Mango里头是可以

307
00:11:16,566 --> 00:11:18,466
但是这个需求就不好做

308
00:11:19,466 --> 00:11:21,466
就是从它来看就不好做

309
00:11:21,666 --> 00:11:25,266
所以我们现在把它做成了一切两半

310
00:11:25,800 --> 00:11:27,733
留了一部分在Mac口里头

311
00:11:27,733 --> 00:11:29,266
留了一部分在芒果里头

312
00:11:29,333 --> 00:11:29,799
所以

313
00:11:29,800 --> 00:11:31,900
留了这一部分在Mac口里头的好处

314
00:11:31,900 --> 00:11:32,333
就在于说

315
00:11:32,333 --> 00:11:33,399
当我要看一个模板

316
00:11:33,400 --> 00:11:34,733
底下的所有地区的时候

317
00:11:34,733 --> 00:11:36,866
这部分还能在Mac口里头解决

318
00:11:37,333 --> 00:11:38,466
买c q可以查到

319
00:11:38,466 --> 00:11:40,499
说这个底下所有的这些东西

320
00:11:40,700 --> 00:11:42,866
然后这些东西的后半段的内容

321
00:11:42,966 --> 00:11:44,933
去从芒果里头去找啊

322
00:11:44,933 --> 00:11:46,499
所以因为API里有这个需求

323
00:11:46,500 --> 00:11:49,300
所以我们把它一切到两半啊

324
00:11:49,300 --> 00:11:50,533
这是这个部分

325
00:11:51,500 --> 00:11:53,333
绿色部分则不是

326
00:11:53,333 --> 00:11:54,499
存在数据库里头

327
00:11:54,966 --> 00:11:58,666
绿色部分是我们的存用加瓦写的代码

328
00:11:58,966 --> 00:12:00,066
这个部分是什么呢

329
00:12:00,066 --> 00:12:03,966
这个部分是为了去做我们的分包谷

330
00:12:04,600 --> 00:12:06,400
为什么会有分包裹的问题

331
00:12:06,400 --> 00:12:08,666
就是我们汇集极端情况

332
00:12:09,066 --> 00:12:11,566
当一个顾客买了100件商品

333
00:12:11,900 --> 00:12:12,733
这100件商品

334
00:12:12,733 --> 00:12:15,666
是没有办法用一个包裹寄出去的

335
00:12:16,300 --> 00:12:19,533
那就需要把它分成不同的包裹

336
00:12:19,733 --> 00:12:20,666
去寄出去

337
00:12:21,000 --> 00:12:21,800
怎么分法

338
00:12:22,966 --> 00:12:23,766
怎么分法

339
00:12:24,300 --> 00:12:25,400
这就是一个问题

340
00:12:25,400 --> 00:12:27,533
是吧其实有很多种分法

341
00:12:27,533 --> 00:12:28,899
一种分法就是简单一点

342
00:12:28,900 --> 00:12:30,466
比如说我们的快递公司规定说

343
00:12:30,466 --> 00:12:33,599
一个包裹最多不能超过10公斤

344
00:12:34,300 --> 00:12:35,866
那就以10公斤为上限

345
00:12:35,866 --> 00:12:37,599
把这100个东西一个一个的装进去

346
00:12:37,600 --> 00:12:38,866
装到10公斤装第二个

347
00:12:38,866 --> 00:12:39,799
装到10公斤

348
00:12:39,800 --> 00:12:41,366
装第三个

349
00:12:41,500 --> 00:12:44,500
这就是我们称之为上限分包法

350
00:12:45,300 --> 00:12:48,000
那当然快递公司不喜欢上限分包法

351
00:12:48,000 --> 00:12:50,466
因为把每一个的包裹都搞得很重

352
00:12:50,466 --> 00:12:51,566
他搬起来很累

353
00:12:52,100 --> 00:12:57,966
所以如果说你是10公斤的话啊

354
00:12:57,966 --> 00:13:02,133
你假如说你是你是9090公斤的

355
00:13:02,133 --> 00:13:03,466
80公斤的商品

356
00:13:03,500 --> 00:13:06,133
总重是80公斤的商品啊

357
00:13:06,133 --> 00:13:07,799
上限是10公斤的话

358
00:13:07,933 --> 00:13:10,299
那快递公司其实其实更喜欢

359
00:13:10,300 --> 00:13:12,466
你每一个东西装8公斤

360
00:13:12,466 --> 00:13:15,699
或者装5公斤会更好啊

361
00:13:15,700 --> 00:13:20,466
所以说这个是叫做均匀的分包法

362
00:13:21,166 --> 00:13:23,666
当然对于商户来说

363
00:13:23,666 --> 00:13:25,466
其实他既不喜欢上线

364
00:13:25,466 --> 00:13:26,533
也不喜欢均匀

365
00:13:26,866 --> 00:13:29,166
他喜欢的是价格最便宜的方式

366
00:13:29,400 --> 00:13:30,933
所以快递费怎么算

367
00:13:30,933 --> 00:13:32,866
便宜就怎么装包法

368
00:13:33,066 --> 00:13:35,533
这是商户想要的

369
00:13:35,533 --> 00:13:37,799
这样的一个打包的方式

370
00:13:38,933 --> 00:13:40,733
那怎么做呢

371
00:13:41,200 --> 00:13:44,133
所以我们把三种方式都做了

372
00:13:45,133 --> 00:13:46,933
所以就做了一大堆的东西

373
00:13:46,933 --> 00:13:47,733
看到没有

374
00:13:48,266 --> 00:13:50,266
这个东西是我们目前实现的

375
00:13:50,266 --> 00:13:52,299
各种各样分包的方式

376
00:13:52,333 --> 00:13:53,899
而且在这个基础上头

377
00:13:53,900 --> 00:13:56,766
还可以支持未来可能的分包方式

378
00:13:56,766 --> 00:13:58,799
我们现在做了最大分包

379
00:13:59,500 --> 00:14:00,466
均匀分包

380
00:14:00,866 --> 00:14:04,866
然后最优会最优的费用分包

381
00:14:05,166 --> 00:14:07,699
最优的费用分包里头做了两种实现

382
00:14:07,700 --> 00:14:09,533
一种是用脆骨算吧

383
00:14:09,533 --> 00:14:11,533
因为最优费用是一个NP问题

384
00:14:11,733 --> 00:14:14,666
是违法在有限的时间

385
00:14:14,700 --> 00:14:16,533
找到最优解的一个问题

386
00:14:16,600 --> 00:14:18,866
所以最优费用分包

387
00:14:18,866 --> 00:14:20,266
这比如做了两个算法

388
00:14:20,266 --> 00:14:22,066
一个是用的贪心算法

389
00:14:22,400 --> 00:14:25,666
一个是用的淬火算法来做的

390
00:14:25,900 --> 00:14:27,566
所以就看到一大堆

391
00:14:28,133 --> 00:14:30,199
这个前面还没有这么多

392
00:14:30,200 --> 00:14:32,466
去年碰到了一批做算法的大神

393
00:14:32,466 --> 00:14:34,799
在这方面玩命的发挥自己的天赋

394
00:14:35,066 --> 00:14:37,133
所以就做了很多的自由任务

395
00:14:37,600 --> 00:14:40,666
把这个算法做的很庞大啊

396
00:14:41,300 --> 00:14:41,933
我们的这

397
00:14:41,933 --> 00:14:42,566
门课的重点呢

398
00:14:42,566 --> 00:14:44,099
不是讲这些算法是吧

399
00:14:44,100 --> 00:14:45,100
如果大家有兴趣的话

400
00:14:45,100 --> 00:14:46,733
可以去看看去年的这些大神们

401
00:14:46,733 --> 00:14:47,999
他们写的算法是什么

402
00:14:48,333 --> 00:14:49,699
但是我们的重点是

403
00:14:49,700 --> 00:14:51,166
我们怎么做一个结构

404
00:14:51,166 --> 00:14:52,799
把这些各种算法

405
00:14:53,100 --> 00:14:56,600
全部合到我们的这个系统中间

406
00:14:56,733 --> 00:14:58,766
能把它用起来啊

407
00:14:58,766 --> 00:14:59,666
能把它用起来

408
00:15:00,200 --> 00:15:02,766
这是这三个部分

409
00:15:04,200 --> 00:15:07,300
我们首先呃看一下这个蓝色的部分

410
00:15:07,300 --> 00:15:08,800
因为这个蓝色的部分呢

411
00:15:08,800 --> 00:15:13,800
我们其实没有去讲它的这个设计

412
00:15:13,800 --> 00:15:15,066
因为它其实不是设计

413
00:15:15,066 --> 00:15:16,199
是一个技术问题

414
00:15:16,600 --> 00:15:19,966
这个技术问题其实呃体现了什么呢

415
00:15:19,966 --> 00:15:22,266
体现了我们的层次分层结构

416
00:15:23,133 --> 00:15:24,699
所以我们需要把这个技术问题

417
00:15:24,700 --> 00:15:25,800
放在交往

418
00:15:25,933 --> 00:15:27,999
放在面向对象这门课里来讲一下

419
00:15:28,500 --> 00:15:30,600
就是我们为什么会要这么写在

420
00:15:38,566 --> 00:15:40,866
啊首先看下这个分层的体系结构啊

421
00:15:40,866 --> 00:15:42,466
刚才我们给大家看了这个包

422
00:15:47,666 --> 00:15:48,133
这个包

423
00:15:48,133 --> 00:15:51,099
就是跟我们真实的这个是一模一样的

424
00:15:51,100 --> 00:15:54,900
控制器层就只有DTO VO和一堆的Controller

425
00:15:55,566 --> 00:15:56,766
然后我们的Controller呢

426
00:15:56,766 --> 00:16:00,099
其实分为商铺的Controller啊

427
00:16:00,500 --> 00:16:01,533
运费模板的Controller

428
00:16:01,533 --> 00:16:02,533
因为主要就两个事情

429
00:16:02,533 --> 00:16:03,199
一个是商铺

430
00:16:03,200 --> 00:16:04,366
一个是运费模板

431
00:16:04,366 --> 00:16:05,766
所以分为这两个Controller

432
00:16:05,766 --> 00:16:08,566
然后还有一个内部的Controller啊

433
00:16:08,566 --> 00:16:10,166
主要是这三个Controller

434
00:16:10,800 --> 00:16:12,133
呃switch层呢

435
00:16:12,133 --> 00:16:13,166
我们说了

436
00:16:13,166 --> 00:16:16,166
其实它把分成了正常的设备

437
00:16:16,166 --> 00:16:17,999
是以外分了一个listen呢

438
00:16:18,000 --> 00:16:18,666
这个listen呢

439
00:16:18,666 --> 00:16:20,533
是Rocky number q的啊

440
00:16:20,533 --> 00:16:21,533
所以我们今天不去讲

441
00:16:21,533 --> 00:16:23,999
说他这用Rocky number q做了啥

442
00:16:26,900 --> 00:16:29,100
稻城我们可以看到

443
00:16:29,100 --> 00:16:30,000
稻城的话

444
00:16:30,000 --> 00:16:32,800
我们因为这里的Bo对象比较多啊

445
00:16:32,800 --> 00:16:34,866
所以我们把所有的分包放到这里

446
00:16:34,866 --> 00:16:35,199
大家可以

447
00:16:35,200 --> 00:16:36,366
看到那一堆绿色的代码

448
00:16:36,366 --> 00:16:39,266
其实就是这一堆devite的这些东西

449
00:16:39,500 --> 00:16:40,900
然后黄色的代码呢

450
00:16:40,900 --> 00:16:41,733
就是这一堆

451
00:16:42,333 --> 00:16:43,466
当我们把它那一半

452
00:16:43,466 --> 00:16:45,266
region也放到这里头了啊

453
00:16:45,266 --> 00:16:46,366
就是这个黄色的

454
00:16:46,366 --> 00:16:48,999
将它那个它的放到my sequin的那一半啊

455
00:16:49,000 --> 00:16:53,466
region然后这就是在外面的这个sharp

456
00:16:54,166 --> 00:16:54,966
然后

457
00:16:56,366 --> 00:16:58,966
呃region蓝色的啊

458
00:16:58,966 --> 00:17:00,133
template也放在这里头了

459
00:17:00,133 --> 00:17:01,933
template和region特别都放在这里头了

460
00:17:01,933 --> 00:17:03,133
所以用在模板的这一部分

461
00:17:03,133 --> 00:17:04,066
都放在这里头了

462
00:17:04,100 --> 00:17:05,866
那剩下的就放在这个外面

463
00:17:06,566 --> 00:17:08,699
呃这是这个Bo对象

464
00:17:09,733 --> 00:17:11,166
那倒对向这一边呢

465
00:17:11,166 --> 00:17:13,499
我们可以看到我们分出了一个open face

466
00:17:13,866 --> 00:17:15,533
这个就是我们的一个

467
00:17:17,000 --> 00:17:18,300
region到大家知道

468
00:17:18,300 --> 00:17:19,966
这个是去调其他模块

469
00:17:20,133 --> 00:17:22,199
我们这个其他模块的这个调用

470
00:17:22,200 --> 00:17:25,333
跟在支付模块里一样

471
00:17:25,333 --> 00:17:27,966
我们也是放到了一个Mapper里头

472
00:17:29,366 --> 00:17:30,733
放到一个map里头啊

473
00:17:30,733 --> 00:17:31,933
这个map的话

474
00:17:31,933 --> 00:17:36,499
它就会去通过这个微服务的方式

475
00:17:36,600 --> 00:17:38,000
用resource API去调

476
00:17:38,000 --> 00:17:41,200
我们叫做raging service的这个一个服务器

477
00:17:41,200 --> 00:17:43,966
这个服务器向他发出这个请求

478
00:17:43,966 --> 00:17:45,366
所以我们调这个方法

479
00:17:45,766 --> 00:17:46,766
调这个方法

480
00:17:46,800 --> 00:17:48,200
它其实就是向那台服务器

481
00:17:48,200 --> 00:17:50,066
发出一个reading ID

482
00:17:50,066 --> 00:17:51,533
ID是我们这里的

483
00:17:51,533 --> 00:17:54,566
这个参数构成一个HTC的request的

484
00:17:54,566 --> 00:17:56,133
发到那台服务器上去

485
00:17:56,533 --> 00:17:58,366
它的这个map的问题在于说

486
00:17:58,366 --> 00:18:00,533
它的返回值是一个internal object

487
00:18:01,166 --> 00:18:03,333
就是我们正常在Controller层

488
00:18:03,333 --> 00:18:04,566
所返回的那种东西

489
00:18:04,566 --> 00:18:07,099
就是前面是有irole Lambo message

490
00:18:07,133 --> 00:18:09,299
然后真正有用的内容在data里头

491
00:18:09,600 --> 00:18:10,866
这个我们不友好

492
00:18:11,266 --> 00:18:12,399
不友好怎么办呢

493
00:18:12,400 --> 00:18:13,700
不友好我们就把它做了

494
00:18:13,700 --> 00:18:14,566
一个倒层

495
00:18:15,766 --> 00:18:18,266
这个稻城做的事情其实很简单

496
00:18:19,133 --> 00:18:20,266
稻城做的第一件事情

497
00:18:20,266 --> 00:18:22,366
就是我们把在data里头

498
00:18:22,366 --> 00:18:24,666
就是您看到他返回的东西是不是有错

499
00:18:25,533 --> 00:18:27,066
如果有错呢

500
00:18:27,333 --> 00:18:28,466
那就抛错

501
00:18:28,566 --> 00:18:30,299
所以如果调对方的模块

502
00:18:30,300 --> 00:18:31,600
对方模块有出错了

503
00:18:31,600 --> 00:18:33,200
那我们这里也会出错

504
00:18:33,200 --> 00:18:35,266
就直接把他的错误正常返回

505
00:18:35,266 --> 00:18:36,066
如果没错的话

506
00:18:36,066 --> 00:18:38,266
其实就把他那个data里的东西拿出来

507
00:18:38,700 --> 00:18:40,766
然后把它变成满血对象

508
00:18:41,200 --> 00:18:42,933
注意这把它变成了满血对象

509
00:18:43,100 --> 00:18:44,566
所以通过了这个稻城

510
00:18:44,566 --> 00:18:45,066
我们可以看到

511
00:18:45,066 --> 00:18:45,966
通过稻城以后

512
00:18:45,966 --> 00:18:46,566
所起的作用

513
00:18:46,566 --> 00:18:48,499
就是跟我们所有的稻城一样

514
00:18:48,733 --> 00:18:51,399
不管这个对象来自于何方

515
00:18:51,400 --> 00:18:52,900
不管它是来自于曼西口

516
00:18:52,900 --> 00:18:54,666
来自于曼谷芒果

517
00:18:54,666 --> 00:18:58,166
还是来自于我们的这个其他模块

518
00:18:58,300 --> 00:19:00,100
经过了我们稻城包装以后

519
00:19:00,100 --> 00:19:00,866
我们看到的

520
00:19:00,866 --> 00:19:03,666
就是在对象模型上头

521
00:19:03,666 --> 00:19:05,499
所看到的这样的一个东西

522
00:19:05,866 --> 00:19:08,299
就是整体都是有关联

523
00:19:08,933 --> 00:19:10,899
整体都是有关联的这样的一个东西

524
00:19:10,900 --> 00:19:12,300
啊这个我应该多画了一条

525
00:19:12,300 --> 00:19:13,666
就是我做成刀对象

526
00:19:14,166 --> 00:19:15,066
做成了满意对象以后

527
00:19:15,066 --> 00:19:17,466
那个region是能拿能拿到上级地区

528
00:19:17,866 --> 00:19:19,499
他是可以拿到上级地区的

529
00:19:19,500 --> 00:19:20,766
这样的一个region

530
00:19:23,966 --> 00:19:26,133
所以这就是我们造成的作用

531
00:19:26,500 --> 00:19:28,966
造成的作用就是把我们的

532
00:19:28,966 --> 00:19:30,099
我们这些道的目的

533
00:19:30,100 --> 00:19:32,466
就是构造出我们在这个对象模型中间

534
00:19:32,466 --> 00:19:36,299
看到的这个满血的对象模型啊

535
00:19:36,933 --> 00:19:40,799
这是这个蓝色的部分

536
00:19:40,800 --> 00:19:42,600
因为这个跟我们的体积结构有关

537
00:19:42,600 --> 00:19:45,100
为什么我们在map层写了一个open fine

538
00:19:45,100 --> 00:19:46,366
在倒层写了一个open fine

539
00:19:46,366 --> 00:19:47,533
就是这样的一个原因

540
00:19:49,366 --> 00:19:51,133
啊数据库数据库呢

541
00:19:51,133 --> 00:19:52,999
我们只有Mac的数据库

542
00:19:53,133 --> 00:19:53,733
为啥因

543
00:19:53,733 --> 00:19:55,933
为芒果数据库其实是非结构化的

544
00:19:56,066 --> 00:19:57,966
我们在芒果那边的数据库很简单

545
00:19:57,966 --> 00:20:00,199
就是开了一个集合

546
00:20:00,200 --> 00:20:02,800
那个集合的名字叫做template

547
00:20:03,366 --> 00:20:05,733
然后这里看到的黄色的部分

548
00:20:05,966 --> 00:20:08,333
原样丢到了芒果里去

549
00:20:09,000 --> 00:20:11,966
呃芒果数据库的用法来说

550
00:20:12,100 --> 00:20:13,700
我们在整个课程设计中间

551
00:20:13,700 --> 00:20:15,300
我们其实是把芒果数据库

552
00:20:15,300 --> 00:20:17,533
当作一个no c口的数据库

553
00:20:17,866 --> 00:20:19,366
但是Mango的能力

554
00:20:19,366 --> 00:20:21,566
其实比Nosico的数据库更强

555
00:20:21,566 --> 00:20:23,099
它是可以做查询的

556
00:20:23,466 --> 00:20:24,299
但我们不用

557
00:20:24,533 --> 00:20:27,799
为啥因为我们用Nosiq数据库

558
00:20:27,800 --> 00:20:29,200
就把它当Nosiq的用

559
00:20:29,400 --> 00:20:31,200
其实我们在这个设计结构上头

560
00:20:31,200 --> 00:20:32,800
我们可以把Mango

561
00:20:32,800 --> 00:20:36,066
替换成为其他的Nosiq数据库啊

562
00:20:36,066 --> 00:20:36,733
大家应该知道

563
00:20:36,733 --> 00:20:38,899
市面上还有很多其他的Nosiq数据库

564
00:20:39,366 --> 00:20:41,399
那因为所有的Nosiq数据库

565
00:20:41,400 --> 00:20:43,766
就只能用key和value去做查质

566
00:20:44,133 --> 00:20:44,266
所以

567
00:20:44,266 --> 00:20:46,099
我们在芒果的这个部分使用的时候

568
00:20:46,100 --> 00:20:48,966
我们也仅用它的k和y的差值

569
00:20:49,166 --> 00:20:50,533
使得我们这部分代码

570
00:20:51,400 --> 00:20:53,566
不会依赖于芒果数据库

571
00:20:53,866 --> 00:20:54,899
而是可以

572
00:20:54,900 --> 00:20:56,966
如果说芒果数据库不够用了

573
00:20:57,000 --> 00:20:58,533
我们可以用更大的

574
00:20:58,533 --> 00:21:00,133
这个楼西股数据库

575
00:21:00,133 --> 00:21:01,333
去替换掉芒果数据库

576
00:21:01,333 --> 00:21:02,666
去完成这样的一个东西

577
00:21:02,966 --> 00:21:04,466
那这是因为这样的一个原因

578
00:21:04,766 --> 00:21:05,999
所以在芒果数据库里头

579
00:21:06,000 --> 00:21:06,533
我们就

580
00:21:06,533 --> 00:21:08,999
其实是只是用来去存我们这个对象

581
00:21:09,000 --> 00:21:10,966
对象整进整出

582
00:21:11,700 --> 00:21:13,066
整个对象丢进去

583
00:21:13,066 --> 00:21:14,666
整个对象拿出来啊

584
00:21:14,666 --> 00:21:16,299
是这样的一种方式

585
00:21:16,466 --> 00:21:17,899
那那边就没有任何设计

586
00:21:17,900 --> 00:21:19,700
就是只是开了一个集合

587
00:21:19,733 --> 00:21:21,266
开了一个connection

588
00:21:21,266 --> 00:21:23,566
这个connection是用来放我们这两个黄色

589
00:21:23,866 --> 00:21:25,099
这两类啊

590
00:21:25,100 --> 00:21:26,100
黄色对象

591
00:21:26,733 --> 00:21:27,533
所以数据库呢

592
00:21:27,533 --> 00:21:29,699
就只有三个表

593
00:21:30,733 --> 00:21:31,533
大家可以看到

594
00:21:31,533 --> 00:21:32,766
虽然数据库很简单

595
00:21:32,766 --> 00:21:35,733
但是这部分的代码其实量就很大

596
00:21:35,900 --> 00:21:38,366
因为很多东西其实并不在关系

597
00:21:38,366 --> 00:21:39,199
数据库里

598
00:21:40,266 --> 00:21:40,999
我们三个表

599
00:21:41,000 --> 00:21:41,800
一个是sharp

600
00:21:41,800 --> 00:21:43,300
一个是运费模板

601
00:21:43,300 --> 00:21:45,133
一个是地区的运费

602
00:21:45,266 --> 00:21:46,966
全是一对多的关系

603
00:21:46,966 --> 00:21:50,499
然后诠释改成从多至相依啊

604
00:21:50,500 --> 00:21:53,566
都是就是这样的一种方式来做设计

605
00:21:55,333 --> 00:21:59,133
我们来讲它的这个动态模型怎么做

606
00:21:59,666 --> 00:22:01,266
这个部分的所有的API

607
00:22:01,266 --> 00:22:02,599
大家去看的话

608
00:22:03,333 --> 00:22:06,966
其实主要是三类三种API

609
00:22:07,366 --> 00:22:09,933
一个是针对shop的这三改查

610
00:22:10,333 --> 00:22:11,766
就是因为我有一个shop嘛

611
00:22:11,766 --> 00:22:12,966
所以shop要开店

612
00:22:13,333 --> 00:22:16,966
要更改要状态的迁移啊

613
00:22:16,966 --> 00:22:19,299
要去呃下线

614
00:22:19,300 --> 00:22:20,266
要去上线

615
00:22:20,500 --> 00:22:22,733
要去呃关店等等

616
00:22:22,733 --> 00:22:23,599
这其他的真相

617
00:22:23,600 --> 00:22:26,666
改查这一部分的代码我都不太用点

618
00:22:26,666 --> 00:22:29,499
因为这部分代码全是非常简单的

619
00:22:29,900 --> 00:22:32,733
对吧那第二部分的代码是什么呢

620
00:22:32,733 --> 00:22:33,866
就针对运费模板

621
00:22:34,300 --> 00:22:35,900
运费模板其实包含两个部分

622
00:22:35,900 --> 00:22:37,133
一个是运费模板

623
00:22:37,133 --> 00:22:39,366
一个是运费模板里头的明细

624
00:22:39,366 --> 00:22:41,333
就是地区的这个明细

625
00:22:41,566 --> 00:22:43,133
那它的逻辑来说

626
00:22:44,300 --> 00:22:46,066
主要是正三改查

627
00:22:46,500 --> 00:22:49,000
就是我们要去新建一个模板

628
00:22:49,266 --> 00:22:50,133
然后新建模板里的

629
00:22:50,133 --> 00:22:51,566
要去新建模板底下的

630
00:22:51,566 --> 00:22:53,199
某一个地区的定义

631
00:22:53,466 --> 00:22:55,199
然后要对这个定义进行修改

632
00:22:55,366 --> 00:22:57,933
然后要把已有的第一个定义给他删掉

633
00:22:58,100 --> 00:23:00,333
所以这是我们在这上面做的正三改查

634
00:23:00,533 --> 00:23:02,533
但是正三改查虽然多

635
00:23:03,266 --> 00:23:05,366
它的意义就是这个模块的意义

636
00:23:05,366 --> 00:23:08,899
不是去做运费模板的增长改查的

637
00:23:09,000 --> 00:23:11,900
我们做这个运费模板的主要的目的

638
00:23:11,900 --> 00:23:12,800
是为了什么呢

639
00:23:12,966 --> 00:23:13,999
是为了算运费

640
00:23:14,900 --> 00:23:18,600
就是当我在订单的模块

641
00:23:18,600 --> 00:23:19,966
买了一堆的东西

642
00:23:20,466 --> 00:23:22,499
然后我下了一个订单

643
00:23:23,100 --> 00:23:24,100
那这个模块要

644
00:23:24,100 --> 00:23:25,200
告诉我两件事情

645
00:23:25,200 --> 00:23:27,700
第一件事情是订单里买的这些东西

646
00:23:28,366 --> 00:23:29,699
是打成一个包裹呢

647
00:23:29,700 --> 00:23:30,533
还是两个包裹

648
00:23:31,400 --> 00:23:32,000
对吧

649
00:23:32,000 --> 00:23:33,066
或者三个包裹

650
00:23:33,400 --> 00:23:36,066
那如果打成两个或者三个包裹

651
00:23:36,400 --> 00:23:39,000
那哪些东西要放在一个包裹里头

652
00:23:39,000 --> 00:23:40,533
哪些东西要放在另一个包裹里头

653
00:23:40,533 --> 00:23:41,533
就是你给我的那些东西

654
00:23:41,533 --> 00:23:43,133
中间都要把决定

655
00:23:43,133 --> 00:23:44,466
从哪些东西放到一个包裹里头

656
00:23:44,466 --> 00:23:46,199
哪些东西放另外另外一个包裹里头

657
00:23:46,400 --> 00:23:48,300
所以这个模块第一件事情要告诉我说

658
00:23:48,300 --> 00:23:50,266
订单下的东西怎么打包法

659
00:23:50,933 --> 00:23:53,699
那第二个事情就是打包完成以后

660
00:23:53,700 --> 00:23:55,966
你要告诉我说这些东西运费是多少

661
00:23:56,500 --> 00:23:58,800
那当然这个运费算出来的目的呢

662
00:23:59,166 --> 00:24:03,699
其实主要是给商户一个一个

663
00:24:03,733 --> 00:24:06,166
这个参考值

664
00:24:06,200 --> 00:24:08,300
因为商户其实会做一个免邮门槛

665
00:24:08,300 --> 00:24:10,000
所以说如果他买的很多的话

666
00:24:10,000 --> 00:24:11,366
往往都会达到那个免邮

667
00:24:11,366 --> 00:24:12,199
免邮门槛

668
00:24:12,366 --> 00:24:14,299
但是如果买的很少的话

669
00:24:14,400 --> 00:24:15,600
这个运费就有意义了

670
00:24:15,600 --> 00:24:16,600
就会告诉顾客说

671
00:24:16,600 --> 00:24:19,466
你应该支付一个什么样的

672
00:24:19,466 --> 00:24:20,599
这样的一个运费

673
00:24:21,166 --> 00:24:24,466
这是这个模块的意义啊

674
00:24:24,466 --> 00:24:25,866
所以这个模块我们可以看到

675
00:24:25,866 --> 00:24:27,866
大量的API都是做增长改查的

676
00:24:28,100 --> 00:24:31,000
都是做shop和运费模板的

677
00:24:31,000 --> 00:24:34,700
增长改查只有一个API失去算运费

678
00:24:35,266 --> 00:24:36,766
但是大家应该知道

679
00:24:36,766 --> 00:24:38,199
这个模块存在的意义

680
00:24:38,200 --> 00:24:39,700
就是为了这一个API

681
00:24:40,666 --> 00:24:42,799
就是为了去算这个运费

682
00:24:42,933 --> 00:24:44,133
最主要的意义啊

683
00:24:44,133 --> 00:24:44,799
当然它还有意义

684
00:24:44,800 --> 00:24:46,300
就是要有商铺才会有商品

685
00:24:46,300 --> 00:24:48,166
所以你商铺要有增长改查

686
00:24:48,600 --> 00:24:49,500
然后增长改查

687
00:24:49,500 --> 00:24:52,200
会影响这个商铺里的商品的买卖

688
00:24:52,266 --> 00:24:54,366
这个是会的啊

689
00:24:54,366 --> 00:24:57,933
我们在今天因为就是在这个模块中间

690
00:24:57,933 --> 00:24:58,899
时间有限

691
00:24:58,933 --> 00:25:01,099
针对商铺的增商改查和状

692
00:25:01,100 --> 00:25:01,766
态的迁移

693
00:25:01,766 --> 00:25:03,399
这些部分的代码我们都不讲

694
00:25:03,566 --> 00:25:06,133
因为这个跟那个地区非常的像

695
00:25:06,166 --> 00:25:08,966
没有特别多的业务在那里头

696
00:25:08,966 --> 00:25:11,099
因为他对于商品的控制

697
00:25:11,100 --> 00:25:12,400
不在这个模块里

698
00:25:12,566 --> 00:25:13,699
而在商品模块里

699
00:25:13,700 --> 00:25:15,933
所以对于这个模块里头来说

700
00:25:15,933 --> 00:25:18,699
商铺就是正在改差和改通的状态

701
00:25:19,300 --> 00:25:21,766
这个模块相对比较复杂的是

702
00:25:22,933 --> 00:25:25,099
运费模板的真三改查

703
00:25:25,466 --> 00:25:27,699
还有在这个运费模板的结构上

704
00:25:27,700 --> 00:25:28,933
怎么去算运费

705
00:25:29,800 --> 00:25:31,133
为什么说运费模板的增长

706
00:25:31,133 --> 00:25:34,699
改查也会比商铺要麻烦

707
00:25:34,800 --> 00:25:36,300
这里头有两个因素构成的

708
00:25:36,300 --> 00:25:37,000
第一个因素是

709
00:25:37,000 --> 00:25:37,700
因为大家可以看到

710
00:25:37,700 --> 00:25:39,000
它存在了两个数据库

711
00:25:39,866 --> 00:25:41,733
它存在了my c果和Mango的数据库里

712
00:25:41,733 --> 00:25:42,733
所以这里涉及到说

713
00:25:42,733 --> 00:25:44,733
我们在两个数据库结构上头

714
00:25:44,733 --> 00:25:47,333
怎么去做一个运费模板

715
00:25:47,333 --> 00:25:48,499
把它存下去

716
00:25:48,733 --> 00:25:51,333
那第二个问题是它有两种运费模板

717
00:25:51,733 --> 00:25:53,266
我们这个设计呢

718
00:25:53,266 --> 00:25:55,966
其实在2021年时候就已经形成了

719
00:25:55,966 --> 00:25:58,599
就是2021年的时候没有绿色的这个部分

720
00:25:59,366 --> 00:26:00,799
绿色的部分是2022年

721
00:26:00,800 --> 00:26:02,400
被那帮同学们搞出来的啊

722
00:26:02,400 --> 00:26:03,800
就是2022年我们加上去的

723
00:26:03,800 --> 00:26:06,000
然后被同学们把它逼得这么丰富

724
00:26:06,100 --> 00:26:07,000
2021年的时候

725
00:26:07,000 --> 00:26:09,466
其实只有白色和黄色的这个部分

726
00:26:09,733 --> 00:26:12,499
那2021年的时候我们做这个部分的时候

727
00:26:12,500 --> 00:26:15,466
其实因为那时候是选中模块

728
00:26:15,466 --> 00:26:17,366
我们的选中我们的所谓的逼动模块

729
00:26:17,366 --> 00:26:19,999
就是一年一年的拉一个进来

730
00:26:20,000 --> 00:26:21,500
一年一年的拉一个进来

731
00:26:21,900 --> 00:26:24,366
呃那时候是选中模块

732
00:26:24,366 --> 00:26:26,133
所以说所有的这个API呢

733
00:26:26,133 --> 00:26:27,466
就分给不同同学去做

734
00:26:28,000 --> 00:26:30,000
然后同学们就跨句跨句去写

735
00:26:30,766 --> 00:26:31,333
我们可以看到

736
00:26:31,333 --> 00:26:34,933
这里头其实针对应付模板的这些API

737
00:26:34,933 --> 00:26:36,099
其实分成两类

738
00:26:36,300 --> 00:26:38,800
一类是真的是重量模板

739
00:26:39,166 --> 00:26:41,266
一类真的是件数模板

740
00:26:41,266 --> 00:26:42,799
因为我们知道是两类模板

741
00:26:43,166 --> 00:26:44,166
所以在2021年

742
00:26:44,166 --> 00:26:45,999
大家同学们写出的代码就是两套代码

743
00:26:46,733 --> 00:26:48,966
一个API快去快去写一套代码下去

744
00:26:49,133 --> 00:26:51,533
一个API快快写一套代码下去

745
00:26:51,600 --> 00:26:54,200
然后所有的键数模板之间

746
00:26:54,366 --> 00:26:56,599
就是键数模板的增长改查之间

747
00:26:56,600 --> 00:26:58,566
可能是有一部分重用的

748
00:26:58,600 --> 00:27:01,700
但是键数模板和重量模板之间的代码

749
00:27:01,700 --> 00:27:03,066
就是完全分开

750
00:27:03,533 --> 00:27:06,099
就是各写了两套代码

751
00:27:07,266 --> 00:27:09,166
我们看一下这两个API啊

752
00:27:09,166 --> 00:27:11,333
这两个API大家可以看到

753
00:27:11,466 --> 00:27:13,766
其实它传进去的参数是不一样的

754
00:27:14,400 --> 00:27:16,500
所以在2021年的时候

755
00:27:16,500 --> 00:27:18,266
同学们坐车就把它分开了

756
00:27:18,466 --> 00:27:20,199
2022年呢我把这个模块

757
00:27:20,200 --> 00:27:22,566
从选中模块变成了必中模块

758
00:27:22,700 --> 00:27:24,266
那变成必中模块以后

759
00:27:24,266 --> 00:27:27,266
我其实就把同学们分成两只的代码

760
00:27:27,966 --> 00:27:29,266
把它合成了一纸

761
00:27:29,866 --> 00:27:30,899
因为大家可以看到

762
00:27:30,900 --> 00:27:32,166
在这个运费模板中间

763
00:27:32,166 --> 00:27:33,866
前半段是一样

764
00:27:34,600 --> 00:27:35,933
后半段是不一样的

765
00:27:35,933 --> 00:27:37,266
黄色部分是不一样

766
00:27:37,566 --> 00:27:40,466
所以当我们新增一个重量模板的时候

767
00:27:40,466 --> 00:27:42,133
前半段是一样的东西

768
00:27:42,466 --> 00:27:44,166
为什么要重复写两遍

769
00:27:44,866 --> 00:27:45,966
这个就是个问题

770
00:27:46,100 --> 00:27:46,800
对吧

771
00:27:46,800 --> 00:27:50,533
我们做代码的主要的目的

772
00:27:50,700 --> 00:27:54,266
除了是让他有扩展性和灵活性以外

773
00:27:54,400 --> 00:27:57,600
大家始终不应该忘记写代码的初衷

774
00:27:57,866 --> 00:28:00,166
就是用尽量少的代码

775
00:28:00,500 --> 00:28:02,266
去完成尽量多的功能

776
00:28:02,900 --> 00:28:05,966
所以如何提高代码的重用性

777
00:28:06,133 --> 00:28:08,533
用一套代码来完成

778
00:28:08,700 --> 00:28:11,766
重量模板和件数模板的增删改查

779
00:28:12,100 --> 00:28:13,300
是我们的这个部分

780
00:28:13,300 --> 00:28:16,566
增删改查部分的这个一啊

781
00:28:16,566 --> 00:28:18,266
当然在后头算运费的时候

782
00:28:18,266 --> 00:28:20,666
如果前面的部分做成一套一套代码

783
00:28:20,933 --> 00:28:22,466
那我们就会带来另外一个问题

784
00:28:23,066 --> 00:28:25,533
用件数模板和重量模板

785
00:28:25,533 --> 00:28:26,466
去算运费的时候

786
00:28:26,466 --> 00:28:28,499
如何用一套代码能把它算出来

787
00:28:28,566 --> 00:28:31,166
而不是去区分说件数怎么算

788
00:28:31,566 --> 00:28:32,366
重量怎么算

789
00:28:32,366 --> 00:28:33,766
因为它算的方式是不一样的

790
00:28:33,766 --> 00:28:34,699
确实是不一样的

791
00:28:34,900 --> 00:28:35,666
但是我们想

792
00:28:35,666 --> 00:28:39,666
尽量把它统一到一套代码中间去完成

793
00:28:40,333 --> 00:28:42,466
所以呢这里头大家可以看到

794
00:28:42,466 --> 00:28:45,666
我们在对象模型上面用的多态

795
00:28:46,133 --> 00:28:46,733
那意味着

796
00:28:46,733 --> 00:28:47,133
我们这里

797
00:28:47,133 --> 00:28:50,966
会大量使用模板方法的设计模式

798
00:28:51,166 --> 00:28:53,133
来把它们不同的部分

799
00:28:53,133 --> 00:28:55,133
流到纸类中间去写

800
00:28:55,533 --> 00:28:58,799
把相同的部分留在负累去写

801
00:28:59,133 --> 00:29:01,199
就大量采用这种方式啊

802
00:29:01,200 --> 00:29:05,200
去使得我们把共性的代码只写一遍

803
00:29:05,666 --> 00:29:08,066
差异性的代码肯定是要分开写

804
00:29:08,566 --> 00:29:10,399
我们看一下这个设计是怎么做的

805
00:29:10,466 --> 00:29:12,133
我把两个API放到了一起

806
00:29:12,500 --> 00:29:14,666
两个API输入的参数是完全不一样

807
00:29:16,933 --> 00:29:18,399
啊输入参数完全不一样的

808
00:29:18,466 --> 00:29:20,566
但是这个输入参数虽然是不一样的

809
00:29:20,566 --> 00:29:22,066
但是我们在对象中间可以看到

810
00:29:22,066 --> 00:29:24,566
它都是reading time的指类

811
00:29:25,300 --> 00:29:27,566
所以我们首先想到的一个方式

812
00:29:27,566 --> 00:29:28,966
就是在Controller成

813
00:29:30,000 --> 00:29:32,766
虽然用Weta template和piece template

814
00:29:32,766 --> 00:29:35,599
来接不同的数据

815
00:29:35,800 --> 00:29:37,933
但是传到service的时候

816
00:29:38,200 --> 00:29:42,066
把它抽象成为负类的类型传上去

817
00:29:42,800 --> 00:29:45,733
那如果说把它传成负类的类型

818
00:29:45,766 --> 00:29:47,133
就是它这个结构中间啊

819
00:29:47,133 --> 00:29:48,533
把它传成负类的

820
00:29:48,800 --> 00:29:51,366
把它变成负类类型去处理的话

821
00:29:52,133 --> 00:29:55,499
那负类的类型需要用负类的道去处理

822
00:29:55,700 --> 00:29:57,266
我们在这里可以看到

823
00:29:57,400 --> 00:29:59,100
我们的这个道的设计

824
00:29:59,100 --> 00:30:01,466
其实也做了一个抽象

825
00:30:05,466 --> 00:30:07,533
我们的这个到的部分

826
00:30:09,200 --> 00:30:11,133
这个是做GPA的

827
00:30:12,466 --> 00:30:14,133
这个呢是做Mango的

828
00:30:14,866 --> 00:30:17,599
这是Mango的Mango的GPA

829
00:30:17,733 --> 00:30:19,533
这个是GPA的reputter

830
00:30:19,933 --> 00:30:23,366
所以这个dose访问的数据是它在GPA

831
00:30:23,366 --> 00:30:24,166
的一部分

832
00:30:24,666 --> 00:30:26,099
这两个dose

833
00:30:26,100 --> 00:30:27,166
分别访问的是

834
00:30:27,166 --> 00:30:31,166
在mall中间的重量模板和键数模板

835
00:30:31,466 --> 00:30:32,466
我们在设计上头

836
00:30:32,466 --> 00:30:34,533
我们用了多态的方式

837
00:30:35,300 --> 00:30:38,600
把重量模板和键数模板的行为

838
00:30:38,600 --> 00:30:41,500
用接口把它做了一个定义

839
00:30:41,800 --> 00:30:43,333
然后呢大家可以看到

840
00:30:43,333 --> 00:30:45,299
在我们访问的过程中间

841
00:30:45,300 --> 00:30:48,266
我们是面向接口去访问

842
00:30:48,533 --> 00:30:52,166
而不是面向实际的对象去访问

843
00:30:53,266 --> 00:30:54,266
这个是什么呢

844
00:30:54,866 --> 00:30:57,333
这个不是Adapter的设计模式啊

845
00:30:57,600 --> 00:30:59,166
这个大家看起来很像Adapter

846
00:30:59,166 --> 00:31:00,166
不是Adapter

847
00:31:00,533 --> 00:31:05,733
这个就是简单的多态和面向接口编程

848
00:31:06,066 --> 00:31:06,366
啊

849
00:31:06,366 --> 00:31:11,366
这是简单的多态和面向接口编程啊

850
00:31:11,366 --> 00:31:12,766
所以我们用了多态的方法

851
00:31:12,766 --> 00:31:14,199
grasp的多态的方法

852
00:31:14,400 --> 00:31:17,366
用了这个依赖导致原则

853
00:31:17,666 --> 00:31:20,266
在RE引导中间只使用接口

854
00:31:20,266 --> 00:31:22,399
而不使用具体的对象

855
00:31:22,866 --> 00:31:23,966
因为它是接口

856
00:31:23,966 --> 00:31:26,599
所以它满足disco不可替换原则

857
00:31:26,700 --> 00:31:27,566
从而使得说

858
00:31:27,566 --> 00:31:28,466
我们在这里

859
00:31:28,600 --> 00:31:30,166
在大家可以看到

860
00:31:30,166 --> 00:31:32,199
他提供的三个方法就是真山改查

861
00:31:32,800 --> 00:31:35,500
在做真山改查的所有操作的时候

862
00:31:35,500 --> 00:31:37,100
都可以不加区分的

863
00:31:37,400 --> 00:31:41,066
去真山改查重量模板和真山改查

864
00:31:41,700 --> 00:31:44,533
这个借损模板怎么做到的啊

865
00:31:44,533 --> 00:31:47,066
我们看顺序图就会更加清楚一点

866
00:31:47,333 --> 00:31:50,666
我们从这个switch层开始看起

867
00:31:51,166 --> 00:31:51,599
收费纸层

868
00:31:51,600 --> 00:31:53,666
我们过来的是三个

869
00:31:53,666 --> 00:31:55,333
四个参数

870
00:31:55,333 --> 00:31:57,766
一个是商铺的ID

871
00:31:58,166 --> 00:32:00,199
bo就是我们说的那个负类对象

872
00:32:00,266 --> 00:32:02,399
我们接的时候是用peace template

873
00:32:02,966 --> 00:32:05,866
接的时候是用这两个子类接的

874
00:32:10,866 --> 00:32:12,533
接的时候是用这两个指类接的

875
00:32:12,533 --> 00:32:13,966
但是接完了以后呢

876
00:32:13,966 --> 00:32:16,599
传参的时候是用它的负类的类型传的

877
00:32:16,733 --> 00:32:19,399
所以这里头的第二个参数

878
00:32:19,566 --> 00:32:20,966
是负类的类型

879
00:32:21,400 --> 00:32:23,200
但是它里头放的对象

880
00:32:23,200 --> 00:32:25,533
可是子类的对象这个要注意啊

881
00:32:25,533 --> 00:32:26,299
负类类型

882
00:32:26,300 --> 00:32:27,133
子类对象

883
00:32:27,166 --> 00:32:28,399
然后这是操作者

884
00:32:28,533 --> 00:32:29,966
最后我们还给了个标志位

885
00:32:29,966 --> 00:32:30,566
标志位呢

886
00:32:30,566 --> 00:32:34,299
是标示出它是运费模板还是重量模板

887
00:32:34,400 --> 00:32:35,933
但是我们这里用了一个办法

888
00:32:35,933 --> 00:32:37,766
就是不要去写EFL

889
00:32:37,766 --> 00:32:39,799
我们其实很讨厌写EFL啊

890
00:32:40,166 --> 00:32:43,333
所以我我们用的别的方式来做的

891
00:32:43,666 --> 00:32:45,799
那我们大伙可以看一下这种成方在做

892
00:32:45,933 --> 00:32:48,766
那这个是我们进来以后

893
00:32:48,766 --> 00:32:50,133
收费层进来以后大家应该知道

894
00:32:50,133 --> 00:32:51,599
我们这里不是有这么多ID吗

895
00:32:52,066 --> 00:32:53,533
那ID调变成对象

896
00:32:53,566 --> 00:32:55,399
所以第一个把它变成对象的

897
00:32:55,400 --> 00:32:57,066
是在这个运费

898
00:32:57,300 --> 00:33:00,133
在这个模板里头的地区是哪个地区的

899
00:33:00,333 --> 00:33:02,599
这个地区为什么能直接访问呢

900
00:33:02,600 --> 00:33:05,366
当然对象文件它是放在了负累里头

901
00:33:06,133 --> 00:33:07,866
所以这个地区的对象

902
00:33:07,866 --> 00:33:09,099
其实是不需要什么

903
00:33:09,100 --> 00:33:09,900
不需要

904
00:33:10,600 --> 00:33:12,566
不需要这么去做的

905
00:33:13,733 --> 00:33:13,966
呃

906
00:33:13,966 --> 00:33:18,066
那我们就是直接去把他的ID找出来啊

907
00:33:18,066 --> 00:33:19,766
把他的reading ID找出来

908
00:33:19,933 --> 00:33:20,566
找出来首先

909
00:33:20,566 --> 00:33:21,533
这主要是要看一下

910
00:33:21,533 --> 00:33:22,899
这个地区存不存在啊

911
00:33:22,900 --> 00:33:24,066
如果这地区不存在的话

912
00:33:24,066 --> 00:33:25,199
那你在上面去加

913
00:33:25,933 --> 00:33:28,066
加一个运费模板是没有意义的

914
00:33:28,066 --> 00:33:29,666
是这个其实reading没有用

915
00:33:29,933 --> 00:33:31,166
那第二个才是有用

916
00:33:31,166 --> 00:33:34,066
第二个是我们要把它的模板给找出来

917
00:33:34,066 --> 00:33:37,699
也就是在这张图上面的这个部分

918
00:33:38,166 --> 00:33:39,599
也是在负累上头的

919
00:33:39,766 --> 00:33:40,499
所以我们要知道

920
00:33:40,500 --> 00:33:43,733
它是属于哪一个模板的

921
00:33:44,000 --> 00:33:45,700
所以我们从传过来的值

922
00:33:45,700 --> 00:33:49,166
中间的摊牌的ID把这个模板找出来

923
00:33:49,600 --> 00:33:51,700
然后第三件事情就是我们要

924
00:33:53,166 --> 00:33:54,866
在这个模板下面

925
00:33:54,866 --> 00:33:57,266
去建一个region的template

926
00:33:57,466 --> 00:33:57,766
对吧

927
00:33:57,766 --> 00:34:00,999
大家可以看到这是一个组合关系

928
00:34:01,000 --> 00:34:02,066
因为任何一

929
00:34:02,066 --> 00:34:02,899
个reading temperature

930
00:34:02,900 --> 00:34:04,966
一定归属于某一个模板

931
00:34:05,300 --> 00:34:07,266
然后它也只能属于一个模板

932
00:34:07,400 --> 00:34:08,766
有模板才有它

933
00:34:08,766 --> 00:34:10,366
没有模板它就没有它

934
00:34:10,366 --> 00:34:11,366
所以这是主

935
00:34:11,966 --> 00:34:14,366
这是从这是整体

936
00:34:14,500 --> 00:34:15,366
这是局部

937
00:34:15,700 --> 00:34:17,166
那当我们要去创建一个

938
00:34:17,166 --> 00:34:18,599
因为现在是post

939
00:34:18,700 --> 00:34:20,666
去建一个地区模板的时候

940
00:34:20,666 --> 00:34:23,266
它是一个创建一个这个对象

941
00:34:23,266 --> 00:34:25,966
在数据库里创建这一堆的数据

942
00:34:26,133 --> 00:34:27,266
这样的一个过程

943
00:34:27,366 --> 00:34:28,666
所以我们在这里可以看到

944
00:34:28,666 --> 00:34:32,733
我们在这一步用的是创建者的方法

945
00:34:33,333 --> 00:34:37,599
把这个职责分配给了temper的对象

946
00:34:38,000 --> 00:34:41,300
所以temper对象来负责把它创建出来

947
00:34:41,800 --> 00:34:43,166
创建出来怎么创建出来的呢

948
00:34:43,166 --> 00:34:46,333
它其实就是调的reading temper的道的音色

949
00:34:46,333 --> 00:34:50,066
的方法去把在这个模板底下

950
00:34:50,333 --> 00:34:53,299
把这个bo对象给它创建出来

951
00:34:53,466 --> 00:34:55,566
那reaching timers是怎么做的

952
00:34:55,566 --> 00:34:57,166
我们单换了一张图啊

953
00:34:57,166 --> 00:34:58,799
在做insert的时候

954
00:34:59,100 --> 00:35:01,666
它首先呢把拿过来的

955
00:35:01,666 --> 00:35:04,199
这是指类对象把它copy到

956
00:35:04,200 --> 00:35:06,966
用cloud factory把它copy到Po上

957
00:35:07,533 --> 00:35:08,533
那PU是什么呢

958
00:35:08,533 --> 00:35:10,299
PU就是我们在这张图上看到的

959
00:35:10,300 --> 00:35:11,100
这个部分

960
00:35:11,200 --> 00:35:13,733
所以第一个copy其实只是把整个

961
00:35:13,733 --> 00:35:15,466
因为这个对象其实是有他的属性

962
00:35:15,466 --> 00:35:16,499
他的属性或者他的属性

963
00:35:16,500 --> 00:35:17,300
他的属性

964
00:35:17,466 --> 00:35:19,366
只是把前半段的属性

965
00:35:20,100 --> 00:35:21,500
copy到了PU对象上头

966
00:35:21,500 --> 00:35:22,500
后半段没有

967
00:35:22,500 --> 00:35:24,200
因为后半段我们可以看到

968
00:35:24,200 --> 00:35:27,366
我们现在是用的负类的类型

969
00:35:27,366 --> 00:35:28,266
去做的copy

970
00:35:28,266 --> 00:35:28,566
所以说

971
00:35:28,566 --> 00:35:30,766
他拿不到负类的那些get的方法

972
00:35:30,766 --> 00:35:33,333
只能把拿不到此类的get方法

973
00:35:33,333 --> 00:35:34,566
只能用负类的get方法

974
00:35:34,566 --> 00:35:38,066
把负类的属性copy到Po上面

975
00:35:38,300 --> 00:35:40,133
那第二件事情就是我们在里头写

976
00:35:40,133 --> 00:35:42,933
了一个find template bin的这个方法

977
00:35:42,933 --> 00:35:43,966
在这个道理

978
00:35:44,533 --> 00:35:46,933
这个方法以template的传值

979
00:35:46,966 --> 00:35:48,266
传值过去干嘛呢

980
00:35:48,266 --> 00:35:49,333
我们看一下temp

981
00:35:49,333 --> 00:35:50,299
这个我没画图

982
00:36:05,766 --> 00:36:09,299
我们在这个region template到里头

983
00:36:13,533 --> 00:36:15,933
有一个find的方法

984
00:36:16,900 --> 00:36:17,866
就这个方法

985
00:36:29,800 --> 00:36:31,200
这个方法干的是什么事呢

986
00:36:31,200 --> 00:36:33,400
他去拿temperate的一个属性

987
00:36:33,533 --> 00:36:34,866
get temperate的病

988
00:36:35,333 --> 00:36:37,966
然后用这个名字去找

989
00:36:38,666 --> 00:36:40,899
说它的拼对象是什么

990
00:36:40,933 --> 00:36:41,466
大家知道

991
00:36:41,466 --> 00:36:42,333
我们这里用完了

992
00:36:42,333 --> 00:36:43,866
在前面那个花招

993
00:36:44,000 --> 00:36:45,700
就是temperate里头

994
00:36:48,800 --> 00:36:50,300
template里头啊

995
00:36:50,300 --> 00:36:51,900
其实我们定义了两个常量

996
00:36:51,900 --> 00:36:53,800
一个是piece template到

997
00:36:53,933 --> 00:36:56,666
一个是weight template到

998
00:36:56,800 --> 00:36:58,166
这个就是我们在

999
00:37:03,300 --> 00:37:04,733
这张图上面的

1000
00:37:06,066 --> 00:37:07,866
这个和这个

1001
00:37:08,133 --> 00:37:10,933
所以我们的这个template

1002
00:37:11,533 --> 00:37:12,399
呃我们

1003
00:37:14,266 --> 00:37:16,733
所以我们的这个template

1004
00:37:17,166 --> 00:37:19,299
如果它是重量模板的话

1005
00:37:19,500 --> 00:37:20,733
它里头的那个属性

1006
00:37:20,733 --> 00:37:22,599
写的就是重量模板的那个

1007
00:37:22,600 --> 00:37:24,400
倒对倒的并对象

1008
00:37:24,566 --> 00:37:27,199
如果是键鼠模板的话

1009
00:37:27,200 --> 00:37:31,500
它写的就是键鼠模板的那个对象

1010
00:37:31,900 --> 00:37:34,966
所以呢我们这里根据这个

1011
00:37:37,366 --> 00:37:39,299
根据这个template的

1012
00:37:45,533 --> 00:37:47,266
根据这个template的b name

1013
00:37:47,500 --> 00:37:51,300
去把它对应的那个倒对象拿回来

1014
00:37:51,533 --> 00:37:52,866
拿回来以后啊

1015
00:37:52,866 --> 00:37:53,899
我们在这里可以看到

1016
00:37:53,900 --> 00:37:54,700
再回来看

1017
00:37:56,066 --> 00:37:57,266
好我们先休息会吧

1018
00:37:57,266 --> 00:38:00,666
拿回来以后我们再休息会再讲

1019
00:48:04,800 --> 00:48:07,666
所以在这里啊这

1020
00:48:07,666 --> 00:48:11,066
个find the Beam find the timer的病

1021
00:48:11,066 --> 00:48:12,099
这个方法

1022
00:48:12,100 --> 00:48:12,966
其实从time中间

1023
00:48:12,966 --> 00:48:16,166
拿到他的病的对象的名字

1024
00:48:16,266 --> 00:48:20,099
用screen框架把这个名字的对象找到

1025
00:48:20,600 --> 00:48:22,533
然后呢找到以后

1026
00:48:22,533 --> 00:48:24,333
其实他返回的是什么呢

1027
00:48:24,333 --> 00:48:26,166
返回的是负累对象

1028
00:48:27,100 --> 00:48:28,066
大家可以看到

1029
00:48:28,900 --> 00:48:30,300
哪怕是此类对象

1030
00:48:45,400 --> 00:48:46,366
他返回的时候

1031
00:48:46,366 --> 00:48:48,899
强行做了一个类型的转换

1032
00:48:52,933 --> 00:48:53,366
啊

1033
00:48:53,366 --> 00:48:55,899
返回的时候强行做了一个类型的转换

1034
00:48:56,366 --> 00:48:59,933
把它变成它的负类的那个接口

1035
00:49:00,100 --> 00:49:02,166
然后把它返回回来

1036
00:49:02,900 --> 00:49:05,266
所以变成负类接口以后

1037
00:49:09,533 --> 00:49:10,366
我们可以看到

1038
00:49:10,366 --> 00:49:13,099
找到的其实是这个对象

1039
00:49:13,100 --> 00:49:13,966
或者是这个对象

1040
00:49:13,966 --> 00:49:15,533
关键是看那个template里头

1041
00:49:15,533 --> 00:49:17,533
记得是他的名字还是他的名字

1042
00:49:17,600 --> 00:49:19,100
但是我们返回的时候

1043
00:49:19,100 --> 00:49:22,100
强行转换成为他的这个类型

1044
00:49:22,466 --> 00:49:23,699
而在使用的时候

1045
00:49:23,700 --> 00:49:26,700
是用负类的类型去调

1046
00:49:26,800 --> 00:49:29,000
接口中间的引测的方法

1047
00:49:29,066 --> 00:49:32,799
这个就是叫做依赖导致

1048
00:49:33,266 --> 00:49:35,166
面向接口去写

1049
00:49:35,200 --> 00:49:38,666
而不是面向具体的实际的去写

1050
00:49:39,100 --> 00:49:39,566
这个

1051
00:49:39,566 --> 00:49:42,599
第四步的这个音色的b o的这个方法

1052
00:49:42,733 --> 00:49:46,099
因为面向的是这个接口去写的

1053
00:49:46,166 --> 00:49:48,666
接口里头并没有定义任何行为

1054
00:49:49,000 --> 00:49:49,733
所有的行为

1055
00:49:49,733 --> 00:49:52,399
都在具体的酯类中间去定义的

1056
00:49:52,533 --> 00:49:55,866
所以酯类的对象去任意替换的时候

1057
00:49:55,866 --> 00:49:57,533
我们在刚才那张顺序图中间

1058
00:49:57,533 --> 00:49:59,299
是看不出它的区别的

1059
00:49:59,366 --> 00:50:00,099
这是因为

1060
00:50:00,100 --> 00:50:01,000
酯类在这里

1061
00:50:01,000 --> 00:50:03,500
满足迪斯口服可替换原则

1062
00:50:03,500 --> 00:50:04,566
因为这是个接口

1063
00:50:04,700 --> 00:50:06,100
就是用了依赖导致原则

1064
00:50:06,100 --> 00:50:07,100
因为它是接口

1065
00:50:07,133 --> 00:50:09,599
它必然满足迪斯口服可替换原则

1066
00:50:09,733 --> 00:50:11,766
所以它可以任意去做替换

1067
00:50:12,366 --> 00:50:15,599
但这个地方我们并不是想去做什么呢

1068
00:50:15,600 --> 00:50:16,666
想去做开闭

1069
00:50:17,066 --> 00:50:19,366
因为这地方既不是我们的变化点

1070
00:50:19,666 --> 00:50:20,699
也不是我们的

1071
00:50:20,700 --> 00:50:22,500
扩展点大家知道

1072
00:50:22,533 --> 00:50:23,733
对于运费来说

1073
00:50:23,733 --> 00:50:26,933
目前可能在很长的时间内

1074
00:50:26,933 --> 00:50:28,166
目前也不大可能

1075
00:50:28,166 --> 00:50:30,066
除了重量和件数以外

1076
00:50:30,133 --> 00:50:31,666
还有第三种的计算方式

1077
00:50:31,666 --> 00:50:33,166
所以它不是眼镜点

1078
00:50:33,366 --> 00:50:33,899
而且

1079
00:50:33,900 --> 00:50:37,200
这个重量或者件数的这个计费的方式

1080
00:50:37,400 --> 00:50:39,600
也是相对比较稳定的

1081
00:50:39,600 --> 00:50:42,100
这个结构也不会发生大的变化

1082
00:50:42,133 --> 00:50:45,299
所以它既不是变化点

1083
00:50:45,300 --> 00:50:46,733
也不是演进点

1084
00:50:46,733 --> 00:50:51,766
我们这里之所以要用这个多肽的方式

1085
00:50:51,766 --> 00:50:54,366
用依赖导致disco服可替换原则

1086
00:50:55,466 --> 00:50:57,266
想达到一个最原始的目的

1087
00:50:57,500 --> 00:51:02,966
就是增山改查这些模板的时候

1088
00:51:03,066 --> 00:51:04,566
不要重复写代码

1089
00:51:04,766 --> 00:51:06,099
就是为了达成这个目的

1090
00:51:06,133 --> 00:51:07,733
那不要重复写代码

1091
00:51:07,733 --> 00:51:09,766
我们就把他的所有的代码

1092
00:51:09,900 --> 00:51:10,700
都

1093
00:51:10,866 --> 00:51:13,166
所有可以重复的代码全部写在上面

1094
00:51:13,400 --> 00:51:15,800
然后不同的代码全部写在下面

1095
00:51:15,933 --> 00:51:18,399
用的时候通过这个接口

1096
00:51:19,266 --> 00:51:20,366
利用依赖导致原则

1097
00:51:20,366 --> 00:51:21,699
历史可复合替换原则

1098
00:51:21,700 --> 00:51:23,166
使得它可以无差别的

1099
00:51:23,166 --> 00:51:25,999
去新增改查重量模板

1100
00:51:26,000 --> 00:51:27,133
或者新增改查

1101
00:51:27,400 --> 00:51:30,400
正常改查这个建筑模板啊

1102
00:51:30,466 --> 00:51:31,599
只是为了这个目的啊

1103
00:51:31,600 --> 00:51:33,366
为了让代码重用

1104
00:51:33,600 --> 00:51:37,533
才做的这样的一个多肽的方法

1105
00:51:37,533 --> 00:51:38,799
用了多肽的方法啊

1106
00:51:38,800 --> 00:51:41,100
用了使他满足依赖导致原则

1107
00:51:41,100 --> 00:51:42,866
和Disco复合替换原则啊

1108
00:51:42,866 --> 00:51:44,399
来做到这个东西

1109
00:51:44,733 --> 00:51:45,933
所以这是第四步啊

1110
00:51:45,933 --> 00:51:46,766
这是第四步

1111
00:51:46,800 --> 00:51:49,066
那最后就是把它存到数据库里

1112
00:51:49,600 --> 00:51:52,333
把在白色的my c果的部分

1113
00:51:52,333 --> 00:51:53,199
存到数据库里

1114
00:51:53,200 --> 00:51:53,933
黄色的部分

1115
00:51:53,933 --> 00:51:55,299
用那个音色的的东西

1116
00:51:55,300 --> 00:51:56,800
存到了芒果数据库里

1117
00:51:56,800 --> 00:51:58,500
但因为它是不同的到

1118
00:51:58,500 --> 00:52:00,366
所以他们第四部的音色的

1119
00:52:00,366 --> 00:52:02,199
会做不同的音色

1120
00:52:03,600 --> 00:52:08,100
这个就是我们的这个新增的设计

1121
00:52:08,400 --> 00:52:09,733
那有了新增的设计

1122
00:52:09,733 --> 00:52:12,899
大家其实知道正常改查其实都是一样

1123
00:52:13,533 --> 00:52:15,199
那我就没有都去写了

1124
00:52:15,200 --> 00:52:17,466
我给大家看一个这个修改

1125
00:52:17,933 --> 00:52:19,166
所以修改的呢

1126
00:52:19,300 --> 00:52:20,733
同样的是两个API

1127
00:52:21,133 --> 00:52:23,099
它的输入的参数是不一样的

1128
00:52:23,333 --> 00:52:25,166
接的这个对象是不一样的

1129
00:52:25,200 --> 00:52:26,366
但是传过来的时候

1130
00:52:26,366 --> 00:52:28,133
全是用附类传过来的

1131
00:52:28,133 --> 00:52:29,599
所以super ID啊

1132
00:52:29,600 --> 00:52:30,966
这个我要改一下这个bo

1133
00:52:31,400 --> 00:52:33,200
然后user class

1134
00:52:33,700 --> 00:52:35,533
然后一样的进来

1135
00:52:35,533 --> 00:52:37,499
首先找到这个模板

1136
00:52:38,000 --> 00:52:39,866
然后这个模板是存在的

1137
00:52:40,266 --> 00:52:40,533
然后

1138
00:52:40,533 --> 00:52:45,166
我们把修改这个模板底下的地区的

1139
00:52:45,166 --> 00:52:45,966
这个职责

1140
00:52:45,966 --> 00:52:47,733
用信息专家的原则

1141
00:52:47,733 --> 00:52:48,499
就第三步

1142
00:52:48,500 --> 00:52:49,733
是用信息专家的原则

1143
00:52:49,800 --> 00:52:51,700
给他分配给了模板

1144
00:52:52,066 --> 00:52:53,866
所以在模板里头啊

1145
00:52:53,866 --> 00:52:56,166
我们首先第一件事情是去找一下

1146
00:52:56,200 --> 00:52:56,933
这个模板里

1147
00:52:56,933 --> 00:52:58,333
这个地区是不是有

1148
00:52:59,533 --> 00:53:00,799
如果说他是有

1149
00:53:00,800 --> 00:53:01,700
你就可以改

1150
00:53:01,700 --> 00:53:02,300
如果没有

1151
00:53:02,300 --> 00:53:03,966
这时候返回来一个404的错误

1152
00:53:04,200 --> 00:53:05,366
那如果有的话啊

1153
00:53:05,366 --> 00:53:08,499
他就会下来说直接去改

1154
00:53:08,533 --> 00:53:11,166
所以调这个reading temperature去做修改

1155
00:53:11,566 --> 00:53:12,766
再去做修改的过程

1156
00:53:12,766 --> 00:53:13,599
中间大家可以看到

1157
00:53:13,600 --> 00:53:15,100
其实是一样的

1158
00:53:15,166 --> 00:53:17,266
就是它首先把它变成Po

1159
00:53:17,333 --> 00:53:19,133
把把c滚那个部分

1160
00:53:19,200 --> 00:53:20,600
这次是做了前面了

1161
00:53:20,600 --> 00:53:22,133
其实做前面做后面无所谓

1162
00:53:22,166 --> 00:53:23,499
因为我们现在Mango和它

1163
00:53:23,500 --> 00:53:24,966
都是有事务的啊

1164
00:53:24,966 --> 00:53:25,533
所以都会

1165
00:53:25,533 --> 00:53:26,899
如果出售都会回滚

1166
00:53:27,300 --> 00:53:29,500
所以这其实跨两个数据库的事务啊

1167
00:53:29,500 --> 00:53:31,266
你看到spring的这个事务

1168
00:53:31,266 --> 00:53:32,799
其实做的挺强大的

1169
00:53:33,166 --> 00:53:35,133
所以先把my c口的改了

1170
00:53:35,266 --> 00:53:36,199
然后这里可以看到

1171
00:53:36,200 --> 00:53:38,333
再次用它去找到

1172
00:53:38,533 --> 00:53:40,766
到底打算用哪个道去存

1173
00:53:41,333 --> 00:53:44,133
所以找到到底是piece template到

1174
00:53:44,133 --> 00:53:46,399
还是这个weight template到

1175
00:53:46,400 --> 00:53:48,400
然后调对应的这个到去存

1176
00:53:48,400 --> 00:53:49,733
但是调是负累

1177
00:53:49,766 --> 00:53:52,799
所以这里头同样的用了Dota依

1178
00:53:52,800 --> 00:53:55,300
赖导致Disco复刻替换原则

1179
00:53:55,366 --> 00:53:57,566
所以使得我们的上面的这部分代码

1180
00:53:57,566 --> 00:53:59,599
就是完全是一样啊

1181
00:53:59,600 --> 00:54:03,366
不需要为这个运费

1182
00:54:03,366 --> 00:54:05,766
用件数和重量去分开洗

1183
00:54:06,466 --> 00:54:09,299
那改喝茶我就不说了啊

1184
00:54:09,800 --> 00:54:11,766
啊新增和修改我说了

1185
00:54:12,166 --> 00:54:15,799
那个呃查看和删除我就不说了

1186
00:54:15,800 --> 00:54:17,500
其实是一模一样啊

1187
00:54:17,500 --> 00:54:19,000
其实就是一模一样

1188
00:54:19,600 --> 00:54:22,066
这个是这个设计

1189
00:54:22,066 --> 00:54:23,533
那我们看一下它的代码

1190
00:54:30,966 --> 00:54:32,866
之所以给大家看图

1191
00:54:32,866 --> 00:54:34,066
给大家看代码啊

1192
00:54:34,066 --> 00:54:35,466
就是第一来说

1193
00:54:35,466 --> 00:54:36,999
最基本的情况下头

1194
00:54:37,000 --> 00:54:38,666
你应该能够看到图

1195
00:54:38,666 --> 00:54:40,666
知道那个代码是会写成什么样的

1196
00:54:40,900 --> 00:54:41,966
首先给大家看图

1197
00:54:41,966 --> 00:54:42,966
大家应该能够想到

1198
00:54:42,966 --> 00:54:44,466
那个代码是个什么样的

1199
00:54:44,866 --> 00:54:46,599
然后大家去看代码的话

1200
00:54:46,600 --> 00:54:47,900
再去跟图去做

1201
00:54:48,000 --> 00:54:48,866
去做对应

1202
00:54:50,400 --> 00:54:53,000
啊我们的这个写到了这个control城

1203
00:54:53,000 --> 00:54:54,066
开始看起啊

1204
00:54:54,933 --> 00:54:56,199
我们看新增吧

1205
00:54:56,200 --> 00:54:57,533
不看那个修改

1206
00:54:57,533 --> 00:54:58,766
就是看一个的单

1207
00:55:03,966 --> 00:55:05,099
啊这是个新增

1208
00:55:05,466 --> 00:55:06,466
这是piece temper

1209
00:55:06,466 --> 00:55:07,966
这是重量模板

1210
00:55:08,266 --> 00:55:09,899
所以重量模板大家可以看到

1211
00:55:09,900 --> 00:55:12,600
进来是用重量的对象去接的

1212
00:55:12,900 --> 00:55:15,700
然后呢我在后面的给的这个参数

1213
00:55:15,700 --> 00:55:17,100
是给了他一个类型

1214
00:55:17,100 --> 00:55:18,866
所测试个重量的类型

1215
00:55:18,866 --> 00:55:20,133
为什么要给这个类型

1216
00:55:20,366 --> 00:55:21,733
我们可以看一下

1217
00:55:23,533 --> 00:55:25,099
在这个方法里头啊

1218
00:55:25,666 --> 00:55:27,533
在这个方法里头就跟图上画的一样

1219
00:55:27,533 --> 00:55:29,299
我们首先拿到它的这个reading

1220
00:55:29,300 --> 00:55:30,266
这个其实没有用到

1221
00:55:30,266 --> 00:55:31,199
看见没有灰的

1222
00:55:31,200 --> 00:55:32,600
但是为什么要得一下

1223
00:55:32,733 --> 00:55:35,933
因为这个翻的by ID其实会报错的

1224
00:55:35,933 --> 00:55:37,766
如果这个reading ID是不存在的

1225
00:55:37,766 --> 00:55:40,466
那就会抛出一个 404的错误

1226
00:55:40,466 --> 00:55:41,799
就整个后面就不会做了

1227
00:55:41,966 --> 00:55:43,333
所以当我们新增的时候

1228
00:55:43,333 --> 00:55:45,066
首先那个地区它是存在的啊

1229
00:55:45,266 --> 00:55:46,333
所以虽然它没有用

1230
00:55:46,333 --> 00:55:46,899
但是我们这

1231
00:55:46,900 --> 00:55:48,066
个还是会去做

1232
00:55:48,200 --> 00:55:49,200
第二个是会用到的

1233
00:55:49,200 --> 00:55:50,666
我们要把它这个timerage找到

1234
00:55:50,666 --> 00:55:51,933
而timerage也是要有的

1235
00:55:51,933 --> 00:55:53,266
没有它也会爆出异常

1236
00:55:53,400 --> 00:55:54,333
不但会有

1237
00:55:54,333 --> 00:55:55,999
我们如果看这个API

1238
00:55:56,066 --> 00:55:57,466
翻了白API的时候

1239
00:55:57,766 --> 00:55:58,999
他如果我们的逻辑

1240
00:55:59,000 --> 00:56:00,066
我们其实都是有共性的

1241
00:56:00,066 --> 00:56:02,333
就是所有写API上都有一定的

1242
00:56:02,566 --> 00:56:03,333
一定的共性

1243
00:56:03,333 --> 00:56:04,366
如果没有两个参数

1244
00:56:04,366 --> 00:56:05,266
一个是消防id

1245
00:56:05,266 --> 00:56:06,566
一个是他的对象id

1246
00:56:06,566 --> 00:56:08,966
意味着我们不仅仅会看那个id重振站

1247
00:56:09,166 --> 00:56:10,599
还会判断说

1248
00:56:10,600 --> 00:56:12,800
这个对象是不是这个商铺的

1249
00:56:13,466 --> 00:56:15,533
那如果这个对象不是这个商铺的

1250
00:56:15,533 --> 00:56:17,333
你翻的ID也会抄错

1251
00:56:17,500 --> 00:56:18,666
说超限了

1252
00:56:18,966 --> 00:56:19,599
那意味着说

1253
00:56:19,600 --> 00:56:22,600
你不能在其他商铺的模板底下

1254
00:56:22,600 --> 00:56:24,466
去加一个定义

1255
00:56:24,466 --> 00:56:26,133
是吧这是我们整体的逻辑

1256
00:56:26,133 --> 00:56:26,599
就这个逻辑

1257
00:56:26,600 --> 00:56:27,733
所以所有的办的牌ID

1258
00:56:27,733 --> 00:56:30,466
大家可以看到有一些是没有销牌ID的

1259
00:56:30,466 --> 00:56:31,466
有一些是有销牌ID的

1260
00:56:31,466 --> 00:56:31,933
比如地区

1261
00:56:31,933 --> 00:56:32,799
这个就没有销牌ID

1262
00:56:32,800 --> 00:56:34,533
因为地区不属于某一个商铺

1263
00:56:34,700 --> 00:56:36,200
所以只是看到ID在不在

1264
00:56:36,533 --> 00:56:38,533
但是这个就是有销牌ID的

1265
00:56:38,900 --> 00:56:39,366
有秀派ID

1266
00:56:39,366 --> 00:56:40,766
就意味着他不仅仅会看他在不在

1267
00:56:40,766 --> 00:56:41,166
还会看

1268
00:56:41,166 --> 00:56:43,199
他是不是在这个秀派ID的范围之内

1269
00:56:43,466 --> 00:56:44,466
如果在这个范围之内

1270
00:56:44,466 --> 00:56:45,999
他都可以拿到这个模板

1271
00:56:46,266 --> 00:56:47,266
然后这里大家可以看到

1272
00:56:47,266 --> 00:56:48,299
我们传递的那个参数

1273
00:56:48,300 --> 00:56:49,100
起这个作用

1274
00:56:50,066 --> 00:56:51,499
就是我们去判断一下

1275
00:56:51,500 --> 00:56:54,500
这个template类型是不是这个

1276
00:56:54,766 --> 00:56:58,999
我们在这个对象属性上头

1277
00:56:59,400 --> 00:57:03,133
在数据表里头都没有写它的类型

1278
00:57:03,266 --> 00:57:04,933
那我们怎么知道它的类型的呢

1279
00:57:04,933 --> 00:57:06,166
大家可以看一下啊

1280
00:57:13,333 --> 00:57:14,699
怎么知道它类型的呢

1281
00:57:14,700 --> 00:57:17,066
它其实是去判断一下它自

1282
00:57:17,066 --> 00:57:18,099
己这个属性

1283
00:57:18,766 --> 00:57:20,999
它的这个自己属性作为一个值

1284
00:57:21,066 --> 00:57:21,999
到一个

1285
00:57:23,733 --> 00:57:25,333
到一个map里头去找

1286
00:57:28,700 --> 00:57:30,300
啊到一个map里去找

1287
00:57:30,566 --> 00:57:32,066
所以这个值

1288
00:57:32,166 --> 00:57:34,566
t是我们前面说的这这两个东西

1289
00:57:34,566 --> 00:57:36,133
这两个我们是写使人常量的

1290
00:57:36,133 --> 00:57:37,299
因为数据库里加的时候

1291
00:57:37,300 --> 00:57:39,000
就是你不能自己随便写

1292
00:57:39,000 --> 00:57:40,666
所以说我们是用常量去写的

1293
00:57:40,900 --> 00:57:41,133
所以

1294
00:57:41,133 --> 00:57:43,666
数据库里的那两个常量字符串的值

1295
00:57:43,666 --> 00:57:46,499
我们这里会变成两个类型

1296
00:57:47,166 --> 00:57:49,166
而这两个类型其实后面还有别的用

1297
00:57:49,333 --> 00:57:51,499
这里仅仅就是我们通过这两个类型

1298
00:57:51,700 --> 00:57:53,000
来判断说

1299
00:57:54,800 --> 00:57:56,333
这个是不是

1300
00:57:59,866 --> 00:58:01,733
是不是这个的

1301
00:58:01,733 --> 00:58:02,966
就是Tempet的这个类型

1302
00:58:02,966 --> 00:58:04,933
跟我们传建这个类型是不是一致的

1303
00:58:05,533 --> 00:58:08,599
因为你说你要加一个重量的地区

1304
00:58:08,600 --> 00:58:12,100
模板加在一个计件的模板底下

1305
00:58:12,266 --> 00:58:13,599
那是不行的是吧

1306
00:58:13,766 --> 00:58:14,599
所以我们这个抛错

1307
00:58:14,600 --> 00:58:16,533
就是因为模板是计件的

1308
00:58:16,533 --> 00:58:19,299
但你不给我加一个计重的的明细

1309
00:58:19,300 --> 00:58:20,300
这个是不行的啊

1310
00:58:20,300 --> 00:58:21,366
所以这里就会抛个错

1311
00:58:21,366 --> 00:58:21,899
大家可以看到

1312
00:58:21,900 --> 00:58:22,700
我们这么写

1313
00:58:23,000 --> 00:58:25,400
主要的目的就是避免写什么呢

1314
00:58:25,566 --> 00:58:26,599
EFLS

1315
00:58:27,066 --> 00:58:28,766
就是其实你可以写什么

1316
00:58:28,766 --> 00:58:30,133
good top是等于什么什么

1317
00:58:30,133 --> 00:58:31,399
然后它又等于怎么什么

1318
00:58:31,400 --> 00:58:32,200
可以这么写

1319
00:58:32,400 --> 00:58:33,966
但是我们这么写的主要的目的

1320
00:58:33,966 --> 00:58:35,999
就是避免去写这个EFL

1321
00:58:36,466 --> 00:58:38,699
虽然我们知道这里并不是变化点

1322
00:58:38,700 --> 00:58:40,533
不会有第三种模板出来

1323
00:58:41,000 --> 00:58:43,166
但是预防万一呢

1324
00:58:43,333 --> 00:58:45,166
万一有第三种模板写出来的话

1325
00:58:45,166 --> 00:58:47,399
其实我们这一段代码也不需要去修改

1326
00:58:47,533 --> 00:58:49,866
只需要去改动他那个map的数据结构

1327
00:58:49,933 --> 00:58:51,099
就可以了啊

1328
00:58:51,100 --> 00:58:53,500
所以这其实也是一种数据驱动的

1329
00:58:53,500 --> 00:58:54,366
这种写法

1330
00:58:54,800 --> 00:58:55,366
做完以后

1331
00:58:55,366 --> 00:58:56,799
这个就是由信息专家的原则

1332
00:58:56,800 --> 00:58:58,866
我们把这个职责分配给了这个tempet

1333
00:58:58,866 --> 00:59:00,066
那么去create read

1334
00:59:01,933 --> 00:59:02,466
first reading

1335
00:59:02,466 --> 00:59:02,999
其实很简单

1336
00:59:03,000 --> 00:59:05,533
它直接去调它的instant去查了

1337
00:59:05,700 --> 00:59:06,766
去插入了

1338
00:59:07,000 --> 00:59:09,100
所以插入的时候大家可以看到

1339
00:59:09,100 --> 00:59:11,166
首先我们把买c果的部分

1340
00:59:11,166 --> 00:59:12,933
把它拷到p o对象中间

1341
00:59:13,200 --> 00:59:15,366
然后我们用它去在time中间

1342
00:59:15,366 --> 00:59:17,899
找到它对应的芒果的冰对象

1343
00:59:17,900 --> 00:59:19,700
因为这时候它的类型不同

1344
00:59:19,800 --> 00:59:22,466
它其实给回的这个冰对象就是不一样

1345
00:59:22,800 --> 00:59:25,266
所以我们用它的负类去做音色的

1346
00:59:26,100 --> 00:59:29,466
用不同的并对象给他插进去了

1347
00:59:29,966 --> 00:59:31,166
插进去以后

1348
00:59:31,166 --> 00:59:33,966
然后我们再把它插到关系数据库里

1349
00:59:34,766 --> 00:59:35,733
啊最后就完成

1350
00:59:35,733 --> 00:59:36,566
这里要注意一下

1351
00:59:36,566 --> 00:59:38,699
我们这里其实做了一个track和cash

1352
00:59:38,700 --> 00:59:40,766
为什么因为我们这个关于数据库上

1353
00:59:40,766 --> 00:59:42,999
是有做了一个唯一缩影的

1354
00:59:43,000 --> 00:59:45,800
那个唯一缩影是templine ID加上region ID

1355
00:59:45,800 --> 00:59:47,900
因为我们的逻辑是在同一个地区底下

1356
00:59:47,900 --> 00:59:49,966
在一个模板里不能插入两条

1357
00:59:50,266 --> 00:59:53,099
所以这样的一个业务

1358
00:59:53,100 --> 00:59:55,933
我们并不是先去查再去做的

1359
00:59:55,933 --> 00:59:59,966
而是我们利用数据库的这个叫什么

1360
01:00:00,266 --> 01:00:03,066
叫做数据的唯一索引的约束

1361
01:00:03,400 --> 01:00:05,066
所以建了一个唯一索引

1362
01:00:05,066 --> 01:00:06,199
这么一插进去的话

1363
01:00:06,200 --> 01:00:07,733
如果它的template ID

1364
01:00:07,733 --> 01:00:09,766
和那个reading ID是重了

1365
01:00:09,866 --> 01:00:13,666
它就会抛出一个duplicate key expression的

1366
01:00:13,733 --> 01:00:15,899
这个operation啊

1367
01:00:15,900 --> 01:00:17,933
所以我们这里其实没有做其他的判断

1368
01:00:17,933 --> 01:00:19,566
因为我们只做了一个唯一缩影

1369
01:00:19,700 --> 01:00:22,933
所以说如果抛这个dublicate expression的话

1370
01:00:22,933 --> 01:00:24,766
就肯定是那个唯一缩影出错了

1371
01:00:24,933 --> 01:00:25,999
所以我们告诉他说

1372
01:00:26,000 --> 01:00:29,500
这个地区的模板已经存在

1373
01:00:29,500 --> 01:00:32,133
不能重复在底下间地区啊

1374
01:00:32,133 --> 01:00:33,799
所以这个大家可以看一下

1375
01:00:34,100 --> 01:00:34,366
其实

1376
01:00:34,366 --> 01:00:37,499
你是要善于利用我们的不同的东西

1377
01:00:37,766 --> 01:00:39,366
去完成你的特定的业务的

1378
01:00:39,366 --> 01:00:41,366
而不是先去查一下啊

1379
01:00:41,366 --> 01:00:42,399
再再去做

1380
01:00:43,200 --> 01:00:45,166
这就用唯一缩影去控制的

1381
01:00:46,500 --> 01:00:47,300
啊

1382
01:00:47,566 --> 01:00:50,766
这个就是我们整个叉的过程

1383
01:00:50,766 --> 01:00:51,866
所以大家可以看到

1384
01:00:51,866 --> 01:00:54,066
我们给大家看到的这个叉的代码中心

1385
01:00:54,066 --> 01:00:56,733
是没有任何跟运费模板

1386
01:00:56,933 --> 01:01:00,699
和这个重量模板有关的东西

1387
01:01:00,700 --> 01:01:01,500
有关东西在哪呢

1388
01:01:01,500 --> 01:01:03,100
有关东西在这个音色的里头

1389
01:01:04,000 --> 01:01:06,666
所以在这个音色的里头

1390
01:01:07,466 --> 01:01:10,599
如果我们去看他的p star的音色的的话

1391
01:01:11,066 --> 01:01:11,799
大家可以看到

1392
01:01:11,800 --> 01:01:14,866
他其实做的事情是用了这个

1393
01:01:16,166 --> 01:01:18,199
piece template的pollmapper

1394
01:01:18,300 --> 01:01:21,600
去把这个对象给它插进去了

1395
01:01:21,600 --> 01:01:23,533
而且我们是把这个对象可以看到

1396
01:01:24,133 --> 01:01:26,166
把它转成了piece template的pollmapper

1397
01:01:26,166 --> 01:01:27,599
就是把后面那一半的值

1398
01:01:27,600 --> 01:01:30,333
考到了这个键数模板上面

1399
01:01:30,333 --> 01:01:32,966
然后用键数模板的Mapper给它插进去了

1400
01:01:33,166 --> 01:01:34,733
那重量模板的话

1401
01:01:34,733 --> 01:01:35,999
是一模一样的代码

1402
01:01:36,000 --> 01:01:37,400
但是就是类型不同

1403
01:01:37,533 --> 01:01:38,599
map不同啊

1404
01:01:38,600 --> 01:01:39,500
插进去就不同

1405
01:01:39,733 --> 01:01:43,199
所以把最后这一点点有差异的代码

1406
01:01:43,600 --> 01:01:45,400
放到了纸类中间

1407
01:01:45,700 --> 01:01:49,700
然后让他所有的共性保留在了上面

1408
01:01:49,700 --> 01:01:50,866
这样使得说

1409
01:01:50,866 --> 01:01:54,899
我们插入键插入这个呃

1410
01:01:54,933 --> 01:01:56,666
建筑模板和重量模板的时候

1411
01:01:56,666 --> 01:01:58,366
大量的代码都是共同的

1412
01:01:58,366 --> 01:01:59,699
其实不仅仅是插入

1413
01:01:59,700 --> 01:02:00,600
修改也是一样的

1414
01:02:00,600 --> 01:02:02,000
我们修改的过程就不说了

1415
01:02:02,000 --> 01:02:02,866
大家可以看到

1416
01:02:02,933 --> 01:02:04,299
留在这个指雷中间的

1417
01:02:04,300 --> 01:02:08,666
仅仅是在这个time的上头操作

1418
01:02:08,666 --> 01:02:10,999
就是在PS time的这个几句话的

1419
01:02:11,000 --> 01:02:11,966
这样的一个操作

1420
01:02:12,100 --> 01:02:13,166
删除也是

1421
01:02:14,066 --> 01:02:15,299
然后查询

1422
01:02:15,333 --> 01:02:17,166
查询稍微麻烦一点啊

1423
01:02:17,766 --> 01:02:19,699
查询也是啊

1424
01:02:19,700 --> 01:02:20,733
都是同样的这个

1425
01:02:20,733 --> 01:02:23,933
所以把最后这么一点点差异留在了此

1426
01:02:23,933 --> 01:02:24,099
类

1427
01:02:24,100 --> 01:02:26,733
中间利用这个历史可复可替换原则

1428
01:02:26,733 --> 01:02:28,499
依赖导致的原则啊

1429
01:02:28,500 --> 01:02:31,000
最后实现用多肽的方法啊

1430
01:02:31,000 --> 01:02:32,566
满足了历史可复可替换原则

1431
01:02:32,566 --> 01:02:33,733
和依赖导致原则

1432
01:02:33,733 --> 01:02:36,533
最后实现了这样的一种设计

1433
01:02:39,866 --> 01:02:41,466
啊这个设计要考的话

1434
01:02:41,600 --> 01:02:43,200
估计大家写要写

1435
01:02:43,200 --> 01:02:46,533
我讲了差不多多少讲了30分钟

1436
01:02:46,900 --> 01:02:47,766
估计大概写的话

1437
01:02:47,766 --> 01:02:49,599
至少要写20分钟才能写得完

1438
01:02:55,400 --> 01:02:55,600
所以

1439
01:02:55,600 --> 01:02:58,200
这还算是一个相对比较简单的设计啊

1440
01:02:58,200 --> 01:02:59,300
就是像这种

1441
01:02:59,300 --> 01:03:02,333
就是我没有给出另外一个设计方案的

1442
01:03:02,333 --> 01:03:05,866
就是单纯会去考这个分析题

1443
01:03:05,933 --> 01:03:07,566
那当然我不会去考所有的

1444
01:03:07,566 --> 01:03:10,299
比如说以插入或者修改为例啊

1445
01:03:10,300 --> 01:03:12,700
去讲他的这个整个设计

1446
01:03:12,700 --> 01:03:12,900
中间

1447
01:03:12,900 --> 01:03:14,933
到底用了什么样的面向对象的方法

1448
01:03:14,966 --> 01:03:15,799
关键是说

1449
01:03:15,800 --> 01:03:16,766
你要知道说

1450
01:03:16,766 --> 01:03:19,366
在哪些点用了面向对象的方法

1451
01:03:19,566 --> 01:03:21,266
以及这个方法用了以后

1452
01:03:21,266 --> 01:03:23,733
他满足软件设计的什么原则

1453
01:03:23,933 --> 01:03:25,199
以及用这个原则

1454
01:03:25,200 --> 01:03:27,166
最后为了达成什么样的目的

1455
01:03:27,266 --> 01:03:29,299
把这三件事情讲清楚就好了

1456
01:03:30,666 --> 01:03:31,699
这个有问题吗

1457
01:03:37,000 --> 01:03:38,333
也有都一样

1458
01:03:38,600 --> 01:03:40,733
但我我我真三改

1459
01:03:40,733 --> 01:03:44,899
曹植写的真和改山河的茶

1460
01:03:44,900 --> 01:03:45,933
我没有画图

1461
01:03:46,133 --> 01:03:47,366
但是是一模一样

1462
01:03:47,700 --> 01:03:49,366
都是把代码集中在了上面

1463
01:03:49,366 --> 01:03:51,566
最后把一点点差异性的代码

1464
01:03:51,800 --> 01:03:53,300
放到了此类中间去做

1465
01:03:54,066 --> 01:03:55,533
因为他都有共性的部分

1466
01:03:58,866 --> 01:04:01,199
就是这一个增长改查代码都有写完

1467
01:04:01,666 --> 01:04:04,299
然后有一些面相功能代码就都没写啊

1468
01:04:04,333 --> 01:04:06,266
把面相功能代码全部给它删掉了

1469
01:04:06,366 --> 01:04:06,799
所以

1470
01:04:06,800 --> 01:04:09,333
同学们可以去写写面相功能的代码

1471
01:04:09,766 --> 01:04:10,399
然后去看看

1472
01:04:10,400 --> 01:04:12,166
目前这些面相功能的代码里头

1473
01:04:12,166 --> 01:04:14,366
有哪些还能做面向对象的设计

1474
01:04:14,500 --> 01:04:16,600
这是我们在这个部分的必做任务

1475
01:04:16,866 --> 01:04:17,666
里头的

1476
01:04:18,766 --> 01:04:20,699
啊这个模块中间

1477
01:04:20,700 --> 01:04:22,466
最艰难的其实是这个

1478
01:04:22,900 --> 01:04:24,733
就是怎么算运费

1479
01:04:25,366 --> 01:04:25,933
就换句话说

1480
01:04:25,933 --> 01:04:27,533
这个模块的两个任务

1481
01:04:27,533 --> 01:04:29,733
一个是商铺的竞争改查

1482
01:04:29,733 --> 01:04:30,699
那个都简单

1483
01:04:31,166 --> 01:04:32,299
然后另外一个呢

1484
01:04:32,300 --> 01:04:33,933
就是在运费模板

1485
01:04:34,266 --> 01:04:36,299
运费模板要能算运费

1486
01:04:36,466 --> 01:04:38,466
前面是要有新增长改查的

1487
01:04:38,666 --> 01:04:39,699
那真正改查的部分来说

1488
01:04:39,700 --> 01:04:41,533
我们可以看到我们用了一些方法

1489
01:04:41,700 --> 01:04:43,900
让他的代码尽量的重用

1490
01:04:44,066 --> 01:04:46,466
不要写在不要分开写

1491
01:04:47,266 --> 01:04:48,599
呃在计算运费的时候

1492
01:04:48,600 --> 01:04:50,600
我们同样秉承了这样的一个想法

1493
01:04:50,666 --> 01:04:52,866
就是我们无论是用重量模板

1494
01:04:52,866 --> 01:04:55,399
还是用件数的模板去做

1495
01:04:55,400 --> 01:04:56,866
计算运费的时候

1496
01:04:57,200 --> 01:05:00,933
我们尽量不要去分开两边去写

1497
01:05:01,100 --> 01:05:03,133
而是把它差异的东西

1498
01:05:03,133 --> 01:05:04,699
把它放到最底下啊

1499
01:05:04,733 --> 01:05:06,533
把共性的部分写一套代码

1500
01:05:06,533 --> 01:05:07,966
都是这样的一种设计思路

1501
01:05:10,500 --> 01:05:10,766
所以

1502
01:05:10,766 --> 01:05:14,333
这个是命案对象设计的最朴素的想法

1503
01:05:14,566 --> 01:05:17,666
用少量的代码去完成复杂的功能

1504
01:05:19,466 --> 01:05:21,166
这个部分首要解决的问题

1505
01:05:21,166 --> 01:05:22,299
就是我们如何打包

1506
01:05:23,100 --> 01:05:24,400
呃我们刚刚说到

1507
01:05:24,400 --> 01:05:27,966
就是当一个订单下的这个包裹

1508
01:05:27,966 --> 01:05:30,666
超过它的上限的时候

1509
01:05:30,666 --> 01:05:32,999
你就需要分成多个快递寄出去

1510
01:05:33,000 --> 01:05:34,600
就是一个快递寄不出去了

1511
01:05:35,066 --> 01:05:36,499
但是不同的打包方式呢

1512
01:05:36,500 --> 01:05:37,700
就会有不同的结果

1513
01:05:37,700 --> 01:05:39,700
就是因为你最后给他的结果

1514
01:05:39,700 --> 01:05:41,200
当然可以看到传过来的

1515
01:05:42,800 --> 01:05:44,300
我们把PPT切过来

1516
01:05:49,966 --> 01:05:52,733
大家可以看到传过来的这个参数值

1517
01:05:52,733 --> 01:05:54,399
其实是一个列表

1518
01:05:54,400 --> 01:05:55,266
是一个list

1519
01:05:55,500 --> 01:05:56,900
list里头一共有四个值

1520
01:05:56,900 --> 01:05:58,000
一个是order ID

1521
01:05:58,000 --> 01:05:59,333
一个是product ID

1522
01:05:59,700 --> 01:06:00,700
然后一个是quality

1523
01:06:00,700 --> 01:06:01,466
它的数量

1524
01:06:01,466 --> 01:06:03,333
还有那个东西的单重

1525
01:06:03,333 --> 01:06:05,966
就是每一个商品的单重啊

1526
01:06:05,966 --> 01:06:08,166
我们需要依赖于这些值

1527
01:06:08,600 --> 01:06:11,600
去决定说这个东西怎么打包

1528
01:06:11,866 --> 01:06:14,166
但我们在这里头其实拨打i

1529
01:06:14,366 --> 01:06:18,899
拨打it ID或者product ID其实意义不大

1530
01:06:18,933 --> 01:06:22,199
但是因为它有可能会出现什么呢

1531
01:06:23,133 --> 01:06:25,933
会出现说他的order item ID不同

1532
01:06:25,933 --> 01:06:28,333
但是产品ID是相同的情况

1533
01:06:28,333 --> 01:06:29,566
为什么会传两个字

1534
01:06:29,733 --> 01:06:31,733
就是在某些情况下

1535
01:06:32,000 --> 01:06:35,733
它会出现order item ID是不同的

1536
01:06:35,733 --> 01:06:37,866
但是产品ID是相同的

1537
01:06:38,300 --> 01:06:39,500
这个原因

1538
01:06:39,500 --> 01:06:42,800
通常是因为打折打出折扣不一样

1539
01:06:43,000 --> 01:06:44,566
就是有些时候同一个商品

1540
01:06:44,566 --> 01:06:45,999
你下第一个单

1541
01:06:46,566 --> 01:06:50,166
首件可能能够减个10块钱

1542
01:06:50,600 --> 01:06:51,766
然后你买第二件

1543
01:06:51,766 --> 01:06:53,066
它就不能减10块钱

1544
01:06:53,066 --> 01:06:54,499
所以说这是在word item上面

1545
01:06:54,500 --> 01:06:56,166
就会是两个word item

1546
01:06:56,166 --> 01:06:57,533
然后它的价格是不一样的

1547
01:06:58,133 --> 01:07:00,299
但是它的Prota ID是一样

1548
01:07:00,300 --> 01:07:01,366
所以会出现这种情况

1549
01:07:01,366 --> 01:07:03,666
我们就会把两个值都放进来

1550
01:07:03,666 --> 01:07:04,466
所以在这个里头

1551
01:07:04,466 --> 01:07:07,299
其实是用order ID加上Pro啊

1552
01:07:07,300 --> 01:07:09,400
用order ID作为作为它的主关键字

1553
01:07:09,400 --> 01:07:10,866
但我们这不是从那数据库里头啊

1554
01:07:10,866 --> 01:07:12,299
就是我们在做判断的时候

1555
01:07:12,400 --> 01:07:13,866
我们其实是用order ID

1556
01:07:13,866 --> 01:07:16,533
来做它的主关键字的啊

1557
01:07:16,533 --> 01:07:19,099
这是这个传进来的

1558
01:07:19,100 --> 01:07:21,300
这个参数传出去的是什么呢

1559
01:07:21,300 --> 01:07:21,866
传出去的

1560
01:07:21,866 --> 01:07:22,366
我们可以看见

1561
01:07:22,366 --> 01:07:25,066
我们传出去的是一个链表

1562
01:07:25,066 --> 01:07:27,899
嵌链表有两个

1563
01:07:27,900 --> 01:07:28,800
两个列表

1564
01:07:29,066 --> 01:07:30,366
外头这个列表是什么呢

1565
01:07:30,366 --> 01:07:31,933
是说的是它的包裹

1566
01:07:31,933 --> 01:07:34,099
如果我有两个包裹就是有两个

1567
01:07:34,533 --> 01:07:36,366
如果有三个包裹就有三个

1568
01:07:36,500 --> 01:07:37,700
你的这个列表是什么呢

1569
01:07:37,700 --> 01:07:40,066
你的这个列表是每个包裹里放的是啥

1570
01:07:40,733 --> 01:07:41,866
就是我们给你了

1571
01:07:41,900 --> 01:07:43,333
他给你了这么多东西

1572
01:07:43,466 --> 01:07:45,133
你最终告诉他的结果是

1573
01:07:45,133 --> 01:07:46,966
这些东西到底打成了几个包裹

1574
01:07:47,200 --> 01:07:48,066
以及这些东西到

1575
01:07:48,066 --> 01:07:51,499
底哪些东西放到哪个包裹里

1576
01:07:51,766 --> 01:07:54,099
这个时候就给那个打包的人告诉他说

1577
01:07:54,100 --> 01:07:55,366
你沿着这个方式啊

1578
01:07:55,366 --> 01:07:57,566
把这个东西放到这个包裹里头

1579
01:07:57,566 --> 01:08:00,566
把那些东西放在另外一个包裹里头啊

1580
01:08:00,566 --> 01:08:04,466
就是这样的一个这样的一个结果

1581
01:08:04,500 --> 01:08:05,500
然后除了这个以外

1582
01:08:05,500 --> 01:08:06,766
它还上面有个运费

1583
01:08:07,100 --> 01:08:07,866
就说算出来

1584
01:08:07,866 --> 01:08:09,566
说这个运费是多少

1585
01:08:09,866 --> 01:08:11,866
这就是我们的这个功能的要求

1586
01:08:12,100 --> 01:08:13,733
给你下单的时候

1587
01:08:13,733 --> 01:08:15,566
一堆东西告诉我怎么打包款

1588
01:08:15,866 --> 01:08:17,699
那前面这个路径上大家可以看到

1589
01:08:17,700 --> 01:08:18,333
我们在下单的时候

1590
01:08:18,333 --> 01:08:19,699
其实是有一个限定的

1591
01:08:20,133 --> 01:08:22,266
就是顾客会选很多的商品

1592
01:08:22,533 --> 01:08:22,733
那

1593
01:08:22,733 --> 01:08:25,699
如果这个商品归属于不同的运费模板

1594
01:08:25,800 --> 01:08:27,466
就是打成不同的包裹

1595
01:08:27,466 --> 01:08:28,599
我们就这么处理的

1596
01:08:28,966 --> 01:08:30,933
如果都定义的是同一个运费模板

1597
01:08:30,933 --> 01:08:32,733
那就送过来告诉我说

1598
01:08:32,866 --> 01:08:35,799
我来给你判断说他需要这个

1599
01:08:35,800 --> 01:08:37,400
同一个运费模板里头这些东西

1600
01:08:37,400 --> 01:08:39,333
是不是需要再再变成两个包物

1601
01:08:39,333 --> 01:08:40,299
如果不需要的话嘛

1602
01:08:40,300 --> 01:08:42,333
只是给算一个运费出去

1603
01:08:42,500 --> 01:08:43,766
所以在路径上大家可以看到

1604
01:08:43,766 --> 01:08:44,766
我们在双管程

1605
01:08:44,766 --> 01:08:47,399
就已经把按照不同的运费模板

1606
01:08:47,566 --> 01:08:48,533
给它分开了

1607
01:08:49,000 --> 01:08:51,866
所以调的时候要把template的ID告诉我

1608
01:08:52,500 --> 01:08:52,933
说

1609
01:08:52,933 --> 01:08:55,499
这一堆东西同都是同一个运费模板

1610
01:08:55,800 --> 01:08:57,066
都是用同一个运费模板来

1611
01:08:57,066 --> 01:08:58,666
来算这个运费

1612
01:08:59,366 --> 01:09:01,133
然后呢你要配送到什么地区

1613
01:09:01,133 --> 01:09:03,099
这就是你的那个订单的地址啊

1614
01:09:03,100 --> 01:09:05,400
reading的ID告诉我

1615
01:09:05,400 --> 01:09:07,766
然后最后那个就是要的东西是什么

1616
01:09:07,766 --> 01:09:08,566
怎么打包

1617
01:09:08,600 --> 01:09:10,333
以及它的价格是什么

1618
01:09:10,700 --> 01:09:12,700
所以我们就会返回你要的东西

1619
01:09:14,600 --> 01:09:15,666
怎么打的啊

1620
01:09:15,766 --> 01:09:19,299
这里头就用到了一个我们的设计模式

1621
01:09:19,300 --> 01:09:21,000
叫做策略模式

1622
01:09:21,700 --> 01:09:22,600
策略模式要解决

1623
01:09:22,600 --> 01:09:23,366
的问题是什么

1624
01:09:23,366 --> 01:09:24,999
就是我们这里所说的这个问题

1625
01:09:25,166 --> 01:09:26,999
因为我们有不同的打包方式

1626
01:09:27,300 --> 01:09:28,533
不同的打包方式

1627
01:09:28,533 --> 01:09:31,166
会决定这个结果就是不一样

1628
01:09:31,466 --> 01:09:32,599
比如说你按照上限打包

1629
01:09:32,600 --> 01:09:34,900
按照均匀打包或者按照费用打包

1630
01:09:35,000 --> 01:09:36,700
不但打出来的包裹不一样

1631
01:09:36,700 --> 01:09:38,800
而且每个包裹里放的商品也不一样

1632
01:09:39,366 --> 01:09:40,166
所以

1633
01:09:41,066 --> 01:09:41,866
我们如果说

1634
01:09:41,866 --> 01:09:45,766
要支持这么三种打包策略的话

1635
01:09:46,266 --> 01:09:47,399
我们怎么来做

1636
01:09:47,766 --> 01:09:49,866
而且我们知道这里的会是个变化点

1637
01:09:49,866 --> 01:09:52,399
因为永远会有更好的算法出现啊

1638
01:09:52,400 --> 01:09:53,266
比如去年

1639
01:09:53,700 --> 01:09:55,600
我们前年只做了这个

1640
01:09:55,600 --> 01:09:57,066
上限打包和均匀打包

1641
01:09:57,066 --> 01:09:58,699
去年就做了很多的算法

1642
01:09:58,966 --> 01:10:00,399
那如果有新的算法

1643
01:10:00,400 --> 01:10:01,766
或者更好的算法进来

1644
01:10:01,900 --> 01:10:04,200
我们怎么把新的算法和更好的算法

1645
01:10:04,533 --> 01:10:05,666
融到我们系统里头来

1646
01:10:05,666 --> 01:10:06,666
因为算法嘛

1647
01:10:07,133 --> 01:10:09,099
总是无止境的

1648
01:10:09,266 --> 01:10:10,899
大家聪明人越来越多

1649
01:10:10,900 --> 01:10:12,600
每个人都在前任的方式上面

1650
01:10:12,600 --> 01:10:14,000
去找到一个更好的算法

1651
01:10:14,066 --> 01:10:15,599
所以算法会变得越来越多

1652
01:10:15,800 --> 01:10:17,000
那我们在设计这个部分的时候

1653
01:10:17,000 --> 01:10:18,266
我们可能要考虑到出

1654
01:10:18,266 --> 01:10:20,466
未来还有更好的更新的算法进来

1655
01:10:20,566 --> 01:10:22,566
我们怎么把这个更好的更新的算法

1656
01:10:22,566 --> 01:10:23,933
放到我们这个系统中间

1657
01:10:23,933 --> 01:10:27,066
能得出一个比较比较好的

1658
01:10:27,066 --> 01:10:28,199
这个打包的结果

1659
01:10:28,933 --> 01:10:30,666
这个就是用的策略模式来做

1660
01:10:31,100 --> 01:10:31,933
就是我们知道

1661
01:10:31,933 --> 01:10:34,466
在这个这个API做的这个里头

1662
01:10:34,466 --> 01:10:36,533
其实它有一个很重要的部分

1663
01:10:36,866 --> 01:10:38,499
就是怎么分包法

1664
01:10:39,066 --> 01:10:39,999
怎么分出

1665
01:10:40,000 --> 01:10:41,500
怎么把这个包分出来的

1666
01:10:41,500 --> 01:10:43,566
这个方法其实是有不同的

1667
01:10:43,900 --> 01:10:45,066
那现在这个不同点呢

1668
01:10:45,066 --> 01:10:46,566
我们知道这是个变化点

1669
01:10:47,333 --> 01:10:49,366
因为还有新的算法会出现

1670
01:10:49,533 --> 01:10:51,099
所以我们知道这是个变化点

1671
01:10:51,500 --> 01:10:52,733
变化点怎么办

1672
01:10:52,800 --> 01:10:54,933
我们知道我们要把我们的系统

1673
01:10:54,933 --> 01:10:58,666
和这个变化点来做松偶合

1674
01:10:58,900 --> 01:11:01,600
也就是我们在grasp中间说的那个

1675
01:11:01,600 --> 01:11:02,300
价值观

1676
01:11:02,300 --> 01:11:04,100
这个地方我们判断是个变化点

1677
01:11:04,133 --> 01:11:05,399
我们要做松偶合

1678
01:11:05,733 --> 01:11:06,699
怎么偶合法

1679
01:11:07,066 --> 01:11:09,066
就是把它从我们的代码中间

1680
01:11:09,066 --> 01:11:10,133
给它滴落出来

1681
01:11:10,666 --> 01:11:12,366
本来是写在我们代码里头的啊

1682
01:11:12,366 --> 01:11:12,999
打包嘛

1683
01:11:13,000 --> 01:11:15,200
我们这个里头主要的目的是为了打包

1684
01:11:15,533 --> 01:11:17,466
那本来打包是写在这个代码里头的

1685
01:11:17,466 --> 01:11:20,133
我们现在把打包的这个部分

1686
01:11:20,666 --> 01:11:23,199
从我们的代码中间给它滴漏出来

1687
01:11:23,900 --> 01:11:25,266
不但把它滴了出来

1688
01:11:25,266 --> 01:11:27,599
而且我们还用多肽的方式

1689
01:11:27,900 --> 01:11:31,066
把它不同的打包的方式给它分开写

1690
01:11:32,200 --> 01:11:34,200
然后让所有的打包方式

1691
01:11:34,200 --> 01:11:37,566
去实现了一个相同的负类

1692
01:11:37,900 --> 01:11:39,566
或者是一个接口

1693
01:11:40,000 --> 01:11:41,800
如果实现是一个负类的话

1694
01:11:41,800 --> 01:11:43,133
一定要保证一点

1695
01:11:43,133 --> 01:11:45,933
就是这些子类中间所实现的方法

1696
01:11:46,133 --> 01:11:48,299
不会改变负类的行为

1697
01:11:48,300 --> 01:11:50,700
让他满足disco和替换原则

1698
01:11:50,866 --> 01:11:52,466
这样的话就有个什么好处呢

1699
01:11:52,500 --> 01:11:54,166
就是当我们用一个新的算法

1700
01:11:54,166 --> 01:11:55,133
用到这里的时候

1701
01:11:55,133 --> 01:11:57,499
其实跟原有的算法用起来的时候

1702
01:11:57,666 --> 01:11:59,599
对于我们原来的这些代码

1703
01:11:59,900 --> 01:12:00,766
是没有影响

1704
01:12:01,166 --> 01:12:01,933
所以第一

1705
01:12:01,933 --> 01:12:04,333
用松Dio和的这种方法

1706
01:12:04,333 --> 01:12:05,866
把我们会变化的点

1707
01:12:05,866 --> 01:12:07,999
从原有代码中间给它滴漏出来

1708
01:12:08,333 --> 01:12:11,699
第二用我们多肽的方式

1709
01:12:11,966 --> 01:12:16,266
把不同的这种打包的算法

1710
01:12:16,366 --> 01:12:18,066
写成不同的尺类

1711
01:12:18,400 --> 01:12:23,300
然后用is让他满足依赖导致和IS口服

1712
01:12:23,300 --> 01:12:24,400
可替换原则

1713
01:12:24,700 --> 01:12:25,866
使得我们在未来

1714
01:12:25,866 --> 01:12:29,299
可以在上面去增加新的算法

1715
01:12:29,366 --> 01:12:30,366
那在这个部分

1716
01:12:30,366 --> 01:12:32,466
因为它是变化点

1717
01:12:32,466 --> 01:12:34,466
我们用了依赖导致和Disco复合

1718
01:12:34,466 --> 01:12:35,266
替换原则

1719
01:12:35,500 --> 01:12:37,333
最终死在这一部分

1720
01:12:37,533 --> 01:12:39,499
让它满足开闭原则

1721
01:12:39,900 --> 01:12:42,000
开闭呢就是当新的算法加进来

1722
01:12:42,000 --> 01:12:44,666
的时候仅加一个新的算法

1723
01:12:44,900 --> 01:12:46,400
所有的代码都不动

1724
01:12:47,266 --> 01:12:48,899
如果说是b的话

1725
01:12:49,066 --> 01:12:51,133
如果某个算法我要修改

1726
01:12:51,133 --> 01:12:52,133
发现它有bug

1727
01:12:52,400 --> 01:12:54,133
那我修改这个部分算法的话

1728
01:12:54,133 --> 01:12:56,066
只改这个部分的代码

1729
01:12:56,100 --> 01:12:57,800
而其他地方都不动

1730
01:12:58,200 --> 01:13:00,866
这个就是我们在这个部分的

1731
01:13:00,866 --> 01:13:01,699
这个想法

1732
01:13:01,700 --> 01:13:03,500
属于用策略模式

1733
01:13:03,933 --> 01:13:07,999
把会变化的点把它抽离出来

1734
01:13:08,366 --> 01:13:10,899
用了Grasp中间的do

1735
01:13:10,900 --> 01:13:14,166
和用了WASP中间的多肽

1736
01:13:14,266 --> 01:13:17,466
让他满足依赖导致原则

1737
01:13:17,766 --> 01:13:20,466
和Disco复刻替换原则

1738
01:13:20,733 --> 01:13:24,533
最终的目的是使得算法的部分

1739
01:13:24,866 --> 01:13:26,466
满足面向对象

1740
01:13:26,466 --> 01:13:27,799
设计的终极目标

1741
01:13:28,200 --> 01:13:29,133
开辟原则

1742
01:13:29,866 --> 01:13:31,266
这个讲清楚了吧

1743
01:13:32,366 --> 01:13:35,533
嗯这个是考试的时候你少写了一点

1744
01:13:36,300 --> 01:13:37,500
都是要扣分的啊

1745
01:13:38,133 --> 01:13:40,099
就是我们在讲这个分析题的时候

1746
01:13:40,100 --> 01:13:40,933
其实就是要看

1747
01:13:40,933 --> 01:13:45,166
大家对于我们在后半部分讲的

1748
01:13:45,166 --> 01:13:46,599
grasp的方法

1749
01:13:47,266 --> 01:13:49,966
软件设计的原则的理解

1750
01:13:49,966 --> 01:13:51,499
还有你看到一个设计师

1751
01:13:51,500 --> 01:13:53,000
知道他为什么会这么做

1752
01:13:53,000 --> 01:13:53,900
他的目标是什么

1753
01:13:53,900 --> 01:13:56,466
他用的是什么方式来达成这个目标

1754
01:13:57,366 --> 01:13:59,766
这是他的这个策略模式

1755
01:14:00,400 --> 01:14:02,066
那具体到我们这个样子来说

1756
01:14:02,066 --> 01:14:04,066
我们这个就是一个标准的策略模式

1757
01:14:04,266 --> 01:14:04,699
但是呢

1758
01:14:04,700 --> 01:14:06,900
我们看起来比他策略模式要复杂是吧

1759
01:14:06,900 --> 01:14:07,866
因为策略模式嘛

1760
01:14:07,866 --> 01:14:09,133
相对比较简单一点

1761
01:14:09,333 --> 01:14:10,866
我们这里的策略是什么呢

1762
01:14:10,866 --> 01:14:11,666
就是这个

1763
01:14:11,766 --> 01:14:13,966
我们在名字上故意写的是这个样子了

1764
01:14:14,666 --> 01:14:15,533
这就是策略

1765
01:14:15,866 --> 01:14:17,499
所以打包的这个部分

1766
01:14:17,500 --> 01:14:19,533
我们知道是有不同的打包方式的

1767
01:14:19,866 --> 01:14:21,699
那打包是在哪打包的呢

1768
01:14:21,700 --> 01:14:25,200
是我们是让运费模板去打包的

1769
01:14:25,200 --> 01:14:26,900
所以我们把东西给运费模板

1770
01:14:27,400 --> 01:14:28,500
当运费模板告诉我说

1771
01:14:28,500 --> 01:14:29,900
这个要出多少个包裹

1772
01:14:30,166 --> 01:14:32,299
那我们把打包这部

1773
01:14:32,300 --> 01:14:33,900
分会变化的东西

1774
01:14:33,900 --> 01:14:36,500
从运费模板的代码中间抽离出来

1775
01:14:36,500 --> 01:14:37,800
我们不要放到这个里头

1776
01:14:38,100 --> 01:14:39,666
让他Dio和

1777
01:14:41,133 --> 01:14:42,299
那它do和

1778
01:14:42,600 --> 01:14:43,866
抽离出来以后

1779
01:14:43,866 --> 01:14:45,199
我们这里不是做的接口

1780
01:14:45,200 --> 01:14:46,800
我们这里做的是一个负类

1781
01:14:47,333 --> 01:14:50,333
负类底下做了不同的算法的子类

1782
01:14:51,366 --> 01:14:53,066
做了不同的算法的子类

1783
01:14:53,166 --> 01:14:54,733
这些算法的子类

1784
01:14:54,966 --> 01:14:55,933
不违背

1785
01:14:55,933 --> 01:14:58,666
他的这个负类所定义的这个行为

1786
01:14:59,066 --> 01:15:01,999
那这样的话使得这些子类是可以替换

1787
01:15:03,100 --> 01:15:04,566
那实际上最终的目的就是

1788
01:15:04,566 --> 01:15:06,566
我们当用一种特定的算法的时候

1789
01:15:06,566 --> 01:15:10,733
可以用这种算法去结合

1790
01:15:10,733 --> 01:15:12,666
在这个应用模板中间

1791
01:15:12,700 --> 01:15:15,666
去把那个分包给它做出来啊

1792
01:15:15,666 --> 01:15:18,933
这就是我们用了滴有和的方法

1793
01:15:18,933 --> 01:15:20,333
用了多肽的方法

1794
01:15:20,400 --> 01:15:24,133
让这个多肽的上头满足依赖

1795
01:15:24,266 --> 01:15:25,199
这不是依赖导致

1796
01:15:25,200 --> 01:15:26,566
因为他没有用接口啊

1797
01:15:26,566 --> 01:15:27,999
我们前面这个用的是接口

1798
01:15:28,000 --> 01:15:28,900
所以依赖导致

1799
01:15:28,900 --> 01:15:29,966
这里没有用接口

1800
01:15:30,200 --> 01:15:31,500
所以不是依赖导致

1801
01:15:31,566 --> 01:15:35,899
但是我们让它满足Disco复合TY原则

1802
01:15:35,900 --> 01:15:38,733
最终在打包算法的部分来说

1803
01:15:38,733 --> 01:15:42,133
来实现我们的开币原则

1804
01:15:42,133 --> 01:15:44,466
就是可以增加新的算法

1805
01:15:44,466 --> 01:15:46,133
而不影响现有的代码

1806
01:15:46,600 --> 01:15:47,266
那这里头

1807
01:15:47,266 --> 01:15:50,566
其实我们不是简单的策略模式

1808
01:15:50,566 --> 01:15:52,066
是这边还多出了一对

1809
01:15:53,533 --> 01:15:54,699
这一堆是什么呢

1810
01:15:54,733 --> 01:15:57,399
这一堆是我们在这里头复用的

1811
01:15:57,400 --> 01:15:58,800
第二个设计模式

1812
01:15:58,800 --> 01:16:00,533
叫做桥接器的设计模式

1813
01:16:00,733 --> 01:16:01,933
所以这大家第一次看见

1814
01:16:01,933 --> 01:16:03,766
我们把两个设计模式合起来

1815
01:16:03,766 --> 01:16:05,799
变成一个我们自己的设计模式

1816
01:16:06,100 --> 01:16:08,366
叫做策略桥接设计模式

1817
01:16:09,200 --> 01:16:10,000
就是设计模式

1818
01:16:10,000 --> 01:16:12,466
其实不是单纯的在使用的

1819
01:16:12,666 --> 01:16:15,866
是你在用的过程中间可以自己组合

1820
01:16:15,866 --> 01:16:18,299
就是你可以去吸收不同的设计模式

1821
01:16:18,300 --> 01:16:19,933
组合起来变成你试用

1822
01:16:19,933 --> 01:16:20,999
的一个设计模式

1823
01:16:21,200 --> 01:16:22,900
我们这里为什么要变成桥

1824
01:16:22,900 --> 01:16:25,000
要把桥街的设计模式上来

1825
01:16:25,333 --> 01:16:26,466
是因为我们这里打包时候

1826
01:16:26,466 --> 01:16:27,399
是有一个问题的

1827
01:16:27,400 --> 01:16:28,533
这个问题是什么呢

1828
01:16:28,900 --> 01:16:30,533
我们可以按照上限打包

1829
01:16:30,533 --> 01:16:32,466
可以按照均匀值打包

1830
01:16:32,466 --> 01:16:33,699
就是按照平均值打包

1831
01:16:33,700 --> 01:16:35,066
每个包裹打成一样的

1832
01:16:35,466 --> 01:16:36,566
但是我们有一个问题

1833
01:16:36,566 --> 01:16:38,199
你按照上限打包的时候

1834
01:16:38,200 --> 01:16:41,300
比如说我是上限是20公斤

1835
01:16:41,800 --> 01:16:43,166
然后我的商品呢

1836
01:16:43,166 --> 01:16:45,399
可能是30公斤

1837
01:16:45,466 --> 01:16:47,766
整个一个订单30公斤

1838
01:16:48,000 --> 01:16:49,300
按照上限打包的话

1839
01:16:49,300 --> 01:16:51,166
我其实应该可以打出一个20公斤

1840
01:16:51,166 --> 01:16:53,066
和一个10公斤的东西来

1841
01:16:53,066 --> 01:16:54,933
对吧但是大家知道

1842
01:16:55,166 --> 01:16:57,799
你那个商品不是一样的

1843
01:16:57,800 --> 01:16:59,100
它可能是不一样的

1844
01:16:59,366 --> 01:17:01,666
所以你往往可能就到不了20公斤

1845
01:17:01,866 --> 01:17:04,566
你可能只能到18或者17公斤

1846
01:17:04,566 --> 01:17:06,466
然后把剩下的放在另外一个包裹里头

1847
01:17:06,466 --> 01:17:11,399
了那我怎么样让他尽量的接近20公斤

1848
01:17:11,800 --> 01:17:14,400
然后让另外一个包裹尽量的少呢

1849
01:17:15,333 --> 01:17:17,366
你们觉得背包问题

1850
01:17:17,366 --> 01:17:18,699
对这就是背包问题

1851
01:17:19,000 --> 01:17:21,666
所以我们在这边做了两个算法

1852
01:17:21,666 --> 01:17:23,399
一个算法是没有做算法的

1853
01:17:23,400 --> 01:17:24,666
这都是simple accurate

1854
01:17:25,933 --> 01:17:28,499
就是按照顺序先把前面那个装满

1855
01:17:28,733 --> 01:17:31,399
装到哪一个发现能超过20公斤的

1856
01:17:31,400 --> 01:17:32,366
再放到第二个

1857
01:17:32,766 --> 01:17:33,699
放到放到第二个

1858
01:17:33,700 --> 01:17:34,666
这是simple

1859
01:17:34,800 --> 01:17:36,333
那第二个是背包算法

1860
01:17:38,100 --> 01:17:40,500
第二个是背包算法啊

1861
01:17:40,500 --> 01:17:44,166
所以这边其实做了两个算法来决定

1862
01:17:44,166 --> 01:17:47,499
说最后你在那个重量的限制范围内

1863
01:17:47,966 --> 01:17:48,866
怎么去抓

1864
01:17:49,166 --> 01:17:52,199
对于最大值来说其实不重要

1865
01:17:52,200 --> 01:17:54,700
但是对于君子来说就非常重要

1866
01:17:54,900 --> 01:17:55,866
因为君子来说

1867
01:17:55,866 --> 01:17:56,933
你如果简单抓的话

1868
01:17:56,933 --> 01:17:59,366
就很容易达不到那个君子

1869
01:17:59,766 --> 01:18:01,399
但是你用背包算法的话

1870
01:18:01,400 --> 01:18:04,266
就能够使得两个包裹的重量是

1871
01:18:04,266 --> 01:18:05,599
接近的啊

1872
01:18:05,600 --> 01:18:08,366
所以这边是两个算法

1873
01:18:08,700 --> 01:18:09,800
所以我们可以看到

1874
01:18:09,800 --> 01:18:12,500
在这个分包的过程中间

1875
01:18:12,500 --> 01:18:13,933
我们其实是有两个问题

1876
01:18:14,200 --> 01:18:17,766
第一是我们的包裹的上限是多少

1877
01:18:18,700 --> 01:18:21,100
第二个问题是在这个上限范围内

1878
01:18:21,100 --> 01:18:23,666
把哪些商品放到这个包裹里头

1879
01:18:24,166 --> 01:18:26,133
对吧那我们现在把这两个问题

1880
01:18:26,133 --> 01:18:27,799
给它一拆为二

1881
01:18:28,466 --> 01:18:29,333
这半段呢

1882
01:18:29,333 --> 01:18:32,466
只管他的上限还有田

1883
01:18:32,733 --> 01:18:33,599
这一半呢

1884
01:18:33,600 --> 01:18:35,866
管怎么把东西放进去

1885
01:18:36,466 --> 01:18:36,899
这样的话

1886
01:18:36,900 --> 01:18:39,500
就能够把它做成一个排列组合

1887
01:18:39,966 --> 01:18:41,199
就是用调节器的模式

1888
01:18:41,200 --> 01:18:42,366
做成一个排列组合

1889
01:18:42,500 --> 01:18:42,966
换句话说

1890
01:18:42,966 --> 01:18:44,666
如果说我定的是最大的

1891
01:18:44,666 --> 01:18:45,666
就是20上限

1892
01:18:45,666 --> 01:18:46,899
20公斤上限的

1893
01:18:46,933 --> 01:18:48,866
我可以用简单算法20公斤上限

1894
01:18:48,866 --> 01:18:50,766
可以用背包算法20公斤上限

1895
01:18:51,100 --> 01:18:53,500
如果我是均匀的这个呢

1896
01:18:53,500 --> 01:18:56,933
你可以用简单算法的均匀的这个

1897
01:18:56,933 --> 01:19:00,099
或者用背包上的20均匀的这个

1898
01:19:00,266 --> 01:19:02,066
这边其实还有更多的算法啊

1899
01:19:02,933 --> 01:19:04,399
这边其实还可以做更多的算法

1900
01:19:04,500 --> 01:19:06,100
所以你最后就会形成一个

1901
01:19:06,733 --> 01:19:08,733
两个东西组合起来

1902
01:19:08,733 --> 01:19:10,566
最后形成了我们的分包策略

1903
01:19:10,566 --> 01:19:11,666
的这样一个东西

1904
01:19:11,933 --> 01:19:14,199
这就是我们的调节器的设计模式

1905
01:19:15,200 --> 01:19:16,666
这个用了什么样的方法

1906
01:19:17,466 --> 01:19:18,133
我们直接讲了

1907
01:19:18,133 --> 01:19:20,566
结果啊就调节器看起来很全面

1908
01:19:20,766 --> 01:19:22,799
但其实所有的设计模式

1909
01:19:22,800 --> 01:19:25,333
用的都是graphful的方法

1910
01:19:25,333 --> 01:19:27,066
和软件设计的原则

1911
01:19:27,700 --> 01:19:29,000
调节器的这个设计

1912
01:19:29,066 --> 01:19:30,199
调节器的这个模式

1913
01:19:30,200 --> 01:19:33,766
它用的方法其实跟策略模式一样

1914
01:19:34,133 --> 01:19:35,933
策略模式是把会变化的东西

1915
01:19:35,933 --> 01:19:36,699
给它滴流出来

1916
01:19:36,700 --> 01:19:37,666
放到外面的

1917
01:19:37,733 --> 01:19:38,733
跟它滴流合

1918
01:19:39,000 --> 01:19:41,100
调节器的部分是把它的变化的东西

1919
01:19:41,100 --> 01:19:42,166
中间还会变化的东西

1920
01:19:42,166 --> 01:19:43,133
再把它滴流出来

1921
01:19:44,066 --> 01:19:45,899
所以他又把这个东西一切为二

1922
01:19:45,900 --> 01:19:48,066
把把它变成了两半

1923
01:19:48,333 --> 01:19:49,499
然后把这一半呢

1924
01:19:49,500 --> 01:19:53,133
又用一个多肽Disco可替换原则

1925
01:19:53,800 --> 01:19:55,333
去使得他可以替换

1926
01:19:55,566 --> 01:19:58,399
所以再把这个问题变成了两个

1927
01:19:58,533 --> 01:20:00,566
两半可以替换的东西

1928
01:20:01,333 --> 01:20:02,333
大家都可以换

1929
01:20:02,466 --> 01:20:03,699
就变成一个排列组合

1930
01:20:04,166 --> 01:20:04,966
最后的结果就变成

1931
01:20:04,966 --> 01:20:07,466
一个排列组合可以靠简单的

1932
01:20:07,466 --> 01:20:08,299
比如说我靠4个

1933
01:20:08,300 --> 01:20:10,866
可以靠4个可以做出8个的效果出来

1934
01:20:11,333 --> 01:20:13,166
当然条约界还有更复杂的

1935
01:20:13,200 --> 01:20:15,966
比二桥三桥四桥或者n桥

1936
01:20:16,133 --> 01:20:16,399
那个

1937
01:20:16,400 --> 01:20:18,500
会把它的整个的排列组合做的更爆炸

1938
01:20:18,866 --> 01:20:21,466
但是我们今年因为就是这个学期

1939
01:20:21,466 --> 01:20:23,066
可能主要的目的

1940
01:20:23,066 --> 01:20:24,999
是去讲GRASP的设计方法

1941
01:20:25,166 --> 01:20:26,566
讲面向对象的设计方法

1942
01:20:26,766 --> 01:20:29,299
所以我们不去引申说

1943
01:20:29,300 --> 01:20:31,366
这个调节器能把它做的很复杂

1944
01:20:31,500 --> 01:20:34,133
我们现在看到的就是一个最简单的

1945
01:20:34,733 --> 01:20:38,499
二桥就是两两桥的这样的一个结果

1946
01:20:40,000 --> 01:20:42,533
这是桥接器的设计模式啊

1947
01:20:42,533 --> 01:20:44,066
首先就是把问题独立分成

1948
01:20:44,066 --> 01:20:44,966
就是二桥的话

1949
01:20:44,966 --> 01:20:46,499
是把问题独立分成两个部分

1950
01:20:46,500 --> 01:20:49,200
然后任意组合组成最后的解决方案

1951
01:20:49,333 --> 01:20:50,733
那如果是三桥的话

1952
01:20:50,733 --> 01:20:52,299
就是把问题分成了三个部分

1953
01:20:52,466 --> 01:20:53,099
四桥的话

1954
01:20:53,100 --> 01:20:54,566
就是可以把问题分解

1955
01:20:54,566 --> 01:20:55,933
成为独立的四个部分

1956
01:20:56,133 --> 01:20:58,366
那你就是看去看你把问题怎么分解法

1957
01:20:58,533 --> 01:20:59,699
然后按翘

1958
01:21:01,500 --> 01:21:03,600
啊说完以后大家可能觉得很好奇

1959
01:21:03,600 --> 01:21:04,466
这怎么做的

1960
01:21:04,466 --> 01:21:06,933
是吧我们先看设计图

1961
01:21:06,933 --> 01:21:08,133
再来看代码

1962
01:21:18,333 --> 01:21:19,666
我们下不下

1963
01:21:19,933 --> 01:21:21,399
下星期一讲吧

1964
01:21:21,400 --> 01:21:24,000
还有还有5分钟

1965
01:21:24,366 --> 01:21:25,199
还有这么多

1966
01:21:25,200 --> 01:21:26,533
你肯定讲也讲不完

1967
01:21:27,933 --> 01:21:30,199
星期一讲来有什么问题吗

1968
01:21:30,400 --> 01:21:33,700
这一块是不是一天比一天更难了

1969
01:21:34,866 --> 01:21:36,199
对吧一天比一天更难了

1970
01:21:36,200 --> 01:21:37,000
确实我我

1971
01:21:37,000 --> 01:21:41,066
因为我一直跟大家说越往后头会越难

1972
01:21:41,366 --> 01:21:43,399
所以我们必须要把这个东西给录课

1973
01:21:43,800 --> 01:21:44,933
录完课以后呢

1974
01:21:45,066 --> 01:21:47,566
你可能开始第一遍听的时候听不懂

1975
01:21:47,666 --> 01:21:49,366
但是多听几遍就慢慢的

1976
01:21:49,366 --> 01:21:51,999
特别是看课后去看那些代码

1977
01:21:52,000 --> 01:21:52,733
做必做任务

1978
01:21:52,733 --> 01:21:53,866
你慢慢就会理解

1979
01:21:54,133 --> 01:21:55,933
然后一个月以后你会发现啊

1980
01:21:55,933 --> 01:21:58,133
原来这其实很简单是吧

1981
01:21:59,500 --> 01:22:00,466
因为你相信这一点

1982
01:22:00,466 --> 01:22:02,166
这些很多代码都是同学们写出来的

1983
01:22:02,366 --> 01:22:03,599
如果你不理解他的设计

1984
01:22:03,600 --> 01:22:05,300
你是没办法在上面去扩展代码

1985
01:22:06,666 --> 01:22:07,399
对啊

1986
01:22:07,400 --> 01:22:10,400
所以这就是软件设计的速成的办法

1987
01:22:10,966 --> 01:22:13,166
不是说去看简单的东西

1988
01:22:13,166 --> 01:22:14,666
而是一开始

1989
01:22:14,666 --> 01:22:17,966
就把历年来把同学们积累下来

1990
01:22:17,966 --> 01:22:19,899
最难的部分给大家去看

1991
01:22:20,166 --> 01:22:21,866
所以你能想办法把难的部分

1992
01:22:21,866 --> 01:22:23,333
慢慢的看个5成懂

1993
01:22:23,800 --> 01:22:25,000
简单的部分就会了

1994
01:22:26,900 --> 01:22:28,200
我们还有比这更难的

1995
01:22:30,100 --> 01:22:30,733
还有比这更难

1996
01:22:30,733 --> 01:22:33,266
这商品的打折比这更麻烦啊

1997
01:22:33,266 --> 01:22:34,333
这个还好一点

1998
01:22:38,200 --> 01:22:40,366
但你也相信这都是人做出来的是吧

1999
01:22:44,400 --> 01:22:46,933
所以这个就是我们这门课

2000
01:22:46,933 --> 01:22:50,666
为什么在这个整个软工专业中间

2001
01:22:50,666 --> 01:22:52,933
被称为魔鬼学期和魔鬼课程

2002
01:22:53,166 --> 01:22:54,533
原因就是这个原因

2003
01:22:54,733 --> 01:22:59,499
因为这个东西你如果像软工那样去考

2004
01:22:59,500 --> 01:23:00,566
条条框框的话

2005
01:23:00,566 --> 01:23:01,899
其实是没有任何意义

2006
01:23:02,466 --> 01:23:06,666
因为软工的那种东西呢

2007
01:23:06,666 --> 01:23:08,499
他如果真让大家学会的话

2008
01:23:08,500 --> 01:23:10,966
是需要消耗大家大量的工作量

2009
01:23:11,100 --> 01:23:13,100
所以他没办法只好去考调教工化

2010
01:23:13,733 --> 01:23:15,166
因为他本来就是个捣乱嘛

2011
01:23:15,166 --> 01:23:16,399
有的东西太多了

2012
01:23:16,800 --> 01:23:18,933
如果每样东西让大家去搞清楚的话

2013
01:23:18,933 --> 01:23:20,333
其实是很困难

2014
01:23:20,366 --> 01:23:22,966
我们这门课其实是软工中间的一张

2015
01:23:23,333 --> 01:23:24,399
这一张是什么

2016
01:23:24,566 --> 01:23:25,966
就他的设计那一张

2017
01:23:26,066 --> 01:23:27,066
软工里面也有一个面

2018
01:23:27,066 --> 01:23:27,999
这样设计那一张嘛

2019
01:23:28,000 --> 01:23:28,800
是吧

2020
01:23:29,300 --> 01:23:30,166
就差那一章

2021
01:23:30,866 --> 01:23:32,299
所以你大家应该知道

2022
01:23:32,300 --> 01:23:33,000
在软弓里头

2023
01:23:33,000 --> 01:23:33,400
其实

2024
01:23:33,400 --> 01:23:37,200
每一个章节都是一个独立的工种

2025
01:23:37,600 --> 01:23:38,966
都是很麻烦的

2026
01:23:38,966 --> 01:23:40,099
都是很难的

2027
01:23:40,100 --> 01:23:41,200
但是它是个捣乱

2028
01:23:41,300 --> 01:23:42,133
所以大家学起来

2029
01:23:42,133 --> 01:23:44,933
觉得好像让大家去记那些条条框框

2030
01:23:45,133 --> 01:23:48,466
但是如果你对于软件工程这门课

2031
01:23:48,700 --> 01:23:50,900
或者对于软件工程这个专业的认识

2032
01:23:50,900 --> 01:23:51,966
就是这种条条框框

2033
01:23:51,966 --> 01:23:53,266
或者去写文档的话

2034
01:23:53,700 --> 01:23:56,666
那是太误解这个学科了

2035
01:23:56,700 --> 01:24:00,166
这个学科其实是直接决定的

2036
01:24:00,200 --> 01:24:02,466
软件开发的质量和成本

2037
01:24:03,100 --> 01:24:04,500
就是任何一个软件公司

2038
01:24:04,500 --> 01:24:06,066
如果在市场上的立足

2039
01:24:06,066 --> 01:24:07,166
靠的就是两条

2040
01:24:07,166 --> 01:24:09,166
第一找准的需求

2041
01:24:09,333 --> 01:24:10,166
就是我们前面说的

2042
01:24:10,166 --> 01:24:12,499
你做的东西是满足用户需求的

2043
01:24:12,966 --> 01:24:13,799
是有用的

2044
01:24:14,200 --> 01:24:17,133
第二是你知道找准的需求的时候

2045
01:24:17,133 --> 01:24:18,999
你能够用较低的成本

2046
01:24:19,266 --> 01:24:21,266
较高的质量把它开发出来

2047
01:24:21,866 --> 01:24:22,899
能做到这两点

2048
01:24:23,200 --> 01:24:25,800
这个软件公司就可以在这个市场立足

2049
01:24:26,133 --> 01:24:28,199
做不到这两点你就立足不了

2050
01:24:28,500 --> 01:24:30,100
要么说你找不找不对需求

2051
01:24:30,100 --> 01:24:31,266
做出来东西没人用

2052
01:24:31,533 --> 01:24:33,899
要么是你做出来东西根本就不好用

2053
01:24:34,100 --> 01:24:35,366
或者做出来的成本太高

2054
01:24:35,366 --> 01:24:36,199
别人用不起

2055
01:24:36,766 --> 01:24:37,566
对吧

2056
01:24:37,866 --> 01:24:41,933
所以这个就是我们说的软工捣乱

2057
01:24:41,933 --> 01:24:44,533
这门课里头所讲的所有的东西

2058
01:24:44,533 --> 01:24:46,699
其实都是这门这个学科

2059
01:24:46,733 --> 01:24:49,133
或者说大家如果做开发的话

2060
01:24:49,266 --> 01:24:51,333
立足之本啊

2061
01:24:51,333 --> 01:24:52,533
但是是没办法

2062
01:24:52,533 --> 01:24:54,533
在就是确实这门课

2063
01:24:54,533 --> 01:24:55,733
也没办法在一个学期之内

2064
01:24:55,733 --> 01:24:57,899
让大家就知道说这个东西是有多难

2065
01:24:57,933 --> 01:24:59,533
那我们这门课是一个例子

2066
01:24:59,533 --> 01:25:03,533
把软功中间的一章递出来讲

2067
01:25:03,866 --> 01:25:05,199
然后大家会知道说

2068
01:25:05,266 --> 01:25:08,799
这一章的对于整个软件的设计和开发

2069
01:25:08,800 --> 01:25:10,566
有多大的重的重要性

2070
01:25:13,666 --> 01:25:14,466
有问题吗

2071
01:25:15,766 --> 01:25:16,566
好没问题

2072
01:25:16,566 --> 01:25:17,766
那我们就下课吧

