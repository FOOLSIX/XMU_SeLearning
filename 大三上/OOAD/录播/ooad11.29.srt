1
00:00:30,900 --> 00:00:32,266
好呃

2
00:00:32,266 --> 00:00:34,733
今天我们先花点时间讲一下物流模块

3
00:00:34,733 --> 00:00:36,166
啊因为物流模块

4
00:00:36,166 --> 00:00:39,499
是这个学期新放进来的必做任务

5
00:00:39,800 --> 00:00:41,966
所以基本上是一片空白

6
00:00:41,966 --> 00:00:43,766
我们这学期要从0开始

7
00:00:43,766 --> 00:00:44,933
从设计编码

8
00:00:44,933 --> 00:00:46,399
最后到实现

9
00:00:46,400 --> 00:00:49,566
第一版的这个物流模块的系统

10
00:00:52,066 --> 00:00:53,333
所以现在这个阶段

11
00:00:53,500 --> 00:00:55,800
物流模块没有什么特别多好讲的内容

12
00:00:55,800 --> 00:00:57,333
因为现在啥都没有啊

13
00:00:58,566 --> 00:00:59,666
这给大家看一下

14
00:00:59,900 --> 00:01:01,300
为什么要先讲下物流模块

15
00:01:01,300 --> 00:01:01,533
是因为

16
00:01:01,533 --> 00:01:03,699
物流模块是在我们的产品模块之下

17
00:01:03,933 --> 00:01:07,166
我讲的顺序基本上是地区支付

18
00:01:07,733 --> 00:01:10,599
商铺物流产品

19
00:01:11,166 --> 00:01:12,399
按照这个顺序讲上来的

20
00:01:12,566 --> 00:01:15,066
也就是基本上这个背电容关系

21
00:01:15,066 --> 00:01:16,299
从下往上啊

22
00:01:16,300 --> 00:01:17,666
从我们设计的这个背电容关系

23
00:01:17,666 --> 00:01:19,199
从下往上来讲

24
00:01:19,733 --> 00:01:20,333
物流模块

25
00:01:20,333 --> 00:01:22,133
之前其实我们已经有讲到过

26
00:01:22,133 --> 00:01:24,466
它的像包也没化啊

27
00:01:24,466 --> 00:01:25,566
因为不知道长啥样

28
00:01:25,700 --> 00:01:28,766
所以等到做完再来画

29
00:01:29,066 --> 00:01:30,599
那对象模型的部分来说

30
00:01:30,600 --> 00:01:33,000
我们之前的第二批次的必中

31
00:01:33,000 --> 00:01:35,800
中间有一位同学设计了这个对象模型

32
00:01:36,066 --> 00:01:38,966
所以这个对象模型基本上描述了

33
00:01:39,266 --> 00:01:40,999
我们的这个对象

34
00:01:41,500 --> 00:01:43,566
这个里头他要完成的是什么

35
00:01:43,600 --> 00:01:44,866
他主要就是两块

36
00:01:44,866 --> 00:01:48,199
一块是物流的渠道和仓库

37
00:01:48,500 --> 00:01:49,566
而另外一块呢

38
00:01:49,566 --> 00:01:51,699
则是他的快递单

39
00:01:52,466 --> 00:01:54,866
当这个对象模型我们会发现说

40
00:01:54,866 --> 00:01:55,799
在做的过程中

41
00:01:55,800 --> 00:01:58,100
你会发现有一些业务

42
00:01:58,100 --> 00:01:59,600
可能对象模型没办法做

43
00:01:59,733 --> 00:02:02,066
那就再去来修改这个对象模型

44
00:02:02,066 --> 00:02:04,299
因为这是我们这是唯一的

45
00:02:04,533 --> 00:02:06,799
大家能看到这个学期从零开始

46
00:02:06,800 --> 00:02:08,800
怎么样把这个模块啊

47
00:02:08,800 --> 00:02:10,566
给它搭建出来的过程

48
00:02:12,066 --> 00:02:14,099
好他这个部分啊

49
00:02:14,100 --> 00:02:15,700
我别的就不说了

50
00:02:15,866 --> 00:02:18,099
这个对视俱库我也不说了啊

51
00:02:18,100 --> 00:02:21,100
我说的主要是这个他的状态

52
00:02:21,933 --> 00:02:23,166
他这个状态里头

53
00:02:23,166 --> 00:02:26,199
只有一个东西是需要去描述状态的

54
00:02:26,200 --> 00:02:27,566
就是快递单

55
00:02:27,566 --> 00:02:28,299
这个快递单

56
00:02:28,300 --> 00:02:32,200
主要是指通过物流公司的API

57
00:02:32,200 --> 00:02:33,533
所得到的那个快递单

58
00:02:33,900 --> 00:02:37,133
大家知道三个物流公司有各自的状态

59
00:02:37,666 --> 00:02:39,499
所以这个部分的一个设计

60
00:02:39,500 --> 00:02:42,466
是需要把物流公司的状态

61
00:02:42,466 --> 00:02:44,966
就是比如中通极兔顺丰的状态

62
00:02:45,066 --> 00:02:46,999
和我们的这个状态的做对应

63
00:02:47,366 --> 00:02:48,766
我们这里需求里头

64
00:02:48,766 --> 00:02:50,499
我们需要知道这个物流

65
00:02:50,500 --> 00:02:51,866
这个快递单是个什么状态呢

66
00:02:51,866 --> 00:02:54,133
我们需要知道它的未发货

67
00:02:54,700 --> 00:02:56,533
需要知道它是被取消了

68
00:02:57,533 --> 00:03:00,399
然后需要知道他是在送的过程中间

69
00:03:00,733 --> 00:03:02,166
需要知道他送的结果

70
00:03:02,166 --> 00:03:05,333
是被签收还是被拒收啊

71
00:03:05,333 --> 00:03:08,066
需要知道说除了签收和拒收以外

72
00:03:08,066 --> 00:03:09,133
它其他的结果啊

73
00:03:09,133 --> 00:03:10,099
比如它丢了

74
00:03:10,566 --> 00:03:13,566
需要知道说它被退回来了

75
00:03:13,566 --> 00:03:15,466
需要知道它退回来以后的结果

76
00:03:15,466 --> 00:03:19,199
是因为查看以后是它的破损还是回收

77
00:03:19,766 --> 00:03:21,799
这些状态的迁移里头

78
00:03:21,800 --> 00:03:23,066
大量的迁移

79
00:03:23,066 --> 00:03:25,999
都要靠查第三方的API去完成

80
00:03:26,200 --> 00:03:27,700
因为我们自己其实没办法知道

81
00:03:27,700 --> 00:03:29,000
它整个运送过程

82
00:03:29,266 --> 00:03:30,699
它到底是什么样的

83
00:03:30,900 --> 00:03:32,500
我们这里能知道的就是

84
00:03:33,366 --> 00:03:34,899
创建是由我们来创建的

85
00:03:35,466 --> 00:03:37,199
取消是由我们来取消的

86
00:03:37,566 --> 00:03:40,166
然后退回来以后我们自己会去验收

87
00:03:40,166 --> 00:03:41,099
所以验收合格

88
00:03:41,100 --> 00:03:43,733
不合格会到第七和第八两个状态

89
00:03:43,966 --> 00:03:45,066
其他都不知道

90
00:03:45,733 --> 00:03:48,933
其他都要靠调对方的API来完成

91
00:03:48,966 --> 00:03:49,999
那我们现在这个状态图

92
00:03:50,000 --> 00:03:51,933
其实画的不是个严谨的状态图

93
00:03:52,066 --> 00:03:53,933
因为我们并不会时时刻刻去调

94
00:03:53,933 --> 00:03:55,366
他的这个状态

95
00:03:55,366 --> 00:03:57,799
我们也不想去做回调

96
00:03:57,800 --> 00:03:58,400
因为回调

97
00:03:58,400 --> 00:04:00,500
对于我们的系统的压力太大了

98
00:04:01,966 --> 00:04:03,466
所以我们写的都是查询

99
00:04:03,466 --> 00:04:03,999
那查的时

100
00:04:04,000 --> 00:04:05,333
候会有可能出现这种情况

101
00:04:05,333 --> 00:04:06,999
就是我们是未发货

102
00:04:07,366 --> 00:04:07,999
查的时候呢

103
00:04:08,000 --> 00:04:09,800
可能他在在图的时候我们没有去查

104
00:04:09,800 --> 00:04:12,166
我们一查的时候就直接查到他拒收了

105
00:04:12,333 --> 00:04:14,799
或者直接查到他已经退回了

106
00:04:14,800 --> 00:04:15,700
这是有可能的啊

107
00:04:15,700 --> 00:04:17,933
所以这个下面这个查询

108
00:04:17,933 --> 00:04:18,499
这个状态

109
00:04:18,500 --> 00:04:21,133
其实不是严格的按照这个顺序来

110
00:04:21,966 --> 00:04:22,999
来来来跳的

111
00:04:23,000 --> 00:04:25,566
是因为我们不会是时刻在查

112
00:04:25,566 --> 00:04:27,066
所以他有可能直接一查

113
00:04:27,066 --> 00:04:28,933
就查到这个签收了啊

114
00:04:28,933 --> 00:04:30,566
都是有可能的但是

115
00:04:32,300 --> 00:04:33,200
就不会显示了

116
00:04:33,200 --> 00:04:34,133
就是查的过程中间

117
00:04:34,133 --> 00:04:35,099
中间状态就不会显示了

118
00:04:35,100 --> 00:04:35,900
我们就不知道说

119
00:04:35,900 --> 00:04:37,766
中间状态是什么时候是在图

120
00:04:37,766 --> 00:04:38,933
什么时候是签收

121
00:04:39,133 --> 00:04:40,533
我们就是从我们正常中间

122
00:04:40,533 --> 00:04:41,399
就直接从未发货

123
00:04:41,400 --> 00:04:43,133
一直就跳到签收去了

124
00:04:45,100 --> 00:04:47,566
那个会那个调他的API去获得

125
00:04:47,733 --> 00:04:53,199
调就他的那个叫做配送的轨迹

126
00:04:54,066 --> 00:04:55,533
是支付渠道的

127
00:04:55,533 --> 00:04:56,999
就是的

128
00:04:57,000 --> 00:04:59,700
物流公司的API是有那个返回能力的

129
00:04:59,700 --> 00:05:02,566
去调那个API去得到它的物流轨迹

130
00:05:02,566 --> 00:05:03,299
但那个物流轨迹

131
00:05:03,300 --> 00:05:05,800
并不反映我们的这个状态啊

132
00:05:05,800 --> 00:05:08,266
那只是给顾客的一个显示而已

133
00:05:08,866 --> 00:05:10,799
这个就是我们的这个状态

134
00:05:11,533 --> 00:05:13,399
那数据库我我之前讲过了

135
00:05:13,400 --> 00:05:13,966
我也不说了

136
00:05:13,966 --> 00:05:15,399
所以大片的空白啊

137
00:05:15,400 --> 00:05:16,100
留在我们

138
00:05:16,100 --> 00:05:19,133
在这个学期剩下的一个月之内啊

139
00:05:19,133 --> 00:05:19,966
把它完成

140
00:05:20,866 --> 00:05:22,199
这是物流模块

141
00:05:23,733 --> 00:05:27,333
今天我们主要要讲的是商品

142
00:05:29,166 --> 00:05:30,099
商品应该知道

143
00:05:30,100 --> 00:05:31,066
这是我们在必做模块

144
00:05:31,066 --> 00:05:32,533
中间的最后一个部分啊

145
00:05:32,533 --> 00:05:34,666
也是我们在考试里头会考的

146
00:05:35,400 --> 00:05:36,466
倒数第二个部分

147
00:05:36,466 --> 00:05:38,399
因为物流模块也会考的啊

148
00:05:38,400 --> 00:05:40,133
物流模块也是必做的内容

149
00:05:40,133 --> 00:05:41,333
所以他也会考的

150
00:05:45,566 --> 00:05:47,466
商品模块就产品模块

151
00:05:47,466 --> 00:05:50,066
是我们所有的b种模块

152
00:05:50,066 --> 00:05:51,333
中间最上面这个模块

153
00:05:52,000 --> 00:05:53,166
他也是最复杂的

154
00:05:53,300 --> 00:05:56,466
所以我们打算大概花两个星期左右来

155
00:05:56,933 --> 00:05:58,266
就三次课左右啊

156
00:05:58,266 --> 00:05:59,733
来讲这个产品模块

157
00:05:59,733 --> 00:06:00,766
今天一次课

158
00:06:00,966 --> 00:06:01,699
星期一一次

159
00:06:01,700 --> 00:06:03,933
还有下周三一次课

160
00:06:04,500 --> 00:06:05,533
然后讲完以后

161
00:06:05,533 --> 00:06:06,366
好像差不多

162
00:06:06,366 --> 00:06:10,199
就快做最后一次的这个汇报了

163
00:06:10,200 --> 00:06:11,300
对吧所以差不多

164
00:06:11,300 --> 00:06:12,600
然后如果还多点时间呢

165
00:06:12,600 --> 00:06:14,500
我们再来看看物流模块做的咋样

166
00:06:14,700 --> 00:06:16,466
再来讲讲物流模块

167
00:06:16,466 --> 00:06:17,599
如果没时间的话

168
00:06:17,600 --> 00:06:19,266
就物流模块就完全看大家

169
00:06:19,266 --> 00:06:20,133
最后做出来什么样子

170
00:06:20,133 --> 00:06:21,166
就不讲了啊

171
00:06:23,500 --> 00:06:25,333
产品模块的部分来说

172
00:06:25,400 --> 00:06:26,300
它的包图

173
00:06:26,766 --> 00:06:28,966
基本上我们已经讲了4个模

174
00:06:29,166 --> 00:06:30,399
三个模块的包图了啊

175
00:06:30,400 --> 00:06:31,500
所以大家可以看到

176
00:06:31,966 --> 00:06:33,999
它跟其他的模块的包图最大的区别

177
00:06:34,000 --> 00:06:35,400
就在于它多出来一块

178
00:06:35,466 --> 00:06:36,799
多出来一个model

179
00:06:37,300 --> 00:06:39,066
为什么它会多出来一个model

180
00:06:39,266 --> 00:06:41,299
就是因为这个模块的对象模型

181
00:06:41,300 --> 00:06:43,533
下面黄色部分是极其复杂的

182
00:06:44,100 --> 00:06:45,066
这个黄色部分呢

183
00:06:45,066 --> 00:06:45,699
我们知道啊

184
00:06:45,700 --> 00:06:46,866
按照我们画图的惯例

185
00:06:46,866 --> 00:06:47,766
大家应该知道

186
00:06:48,166 --> 00:06:50,499
就是这是放到芒果里头的是吧

187
00:06:50,500 --> 00:06:51,766
就是我们所有的图

188
00:06:51,766 --> 00:06:52,333
大家可以看到

189
00:06:52,333 --> 00:06:54,399
我们按照同样的一种惯例去画

190
00:06:54,700 --> 00:06:55,766
按照一种惯例去画的话

191
00:06:55,766 --> 00:06:56,999
你慢慢的熟悉这个惯例

192
00:06:57,000 --> 00:06:58,100
所以一看这张图你就知道

193
00:06:58,100 --> 00:06:59,166
白色是Mac口

194
00:06:59,166 --> 00:07:00,399
蓝色是其他部分

195
00:07:00,866 --> 00:07:03,333
黄色是存到芒果里头的

196
00:07:04,000 --> 00:07:05,966
存到芒果里的部分的这个对象特别多

197
00:07:05,966 --> 00:07:06,933
而且特别复杂

198
00:07:07,466 --> 00:07:09,933
所以这部分对象大家知道

199
00:07:10,466 --> 00:07:12,399
它不仅仅是在稻城使用的

200
00:07:12,400 --> 00:07:13,166
它其实也会

201
00:07:13,166 --> 00:07:16,499
直接传到前面的控制气层去

202
00:07:16,566 --> 00:07:18,066
就直接传给前端了

203
00:07:18,366 --> 00:07:19,899
所以我们这张图

204
00:07:19,900 --> 00:07:21,133
其实画的不是很严谨啊

205
00:07:21,133 --> 00:07:22,799
其实应该是收尾时辰Controller层

206
00:07:22,800 --> 00:07:25,566
和盗层都依赖于这个model的这个包

207
00:07:26,533 --> 00:07:28,533
那我们就把这个包

208
00:07:28,533 --> 00:07:31,399
从倒层直接给他滴出来了

209
00:07:31,933 --> 00:07:34,766
就是滴漏出来一个这个东西啊

210
00:07:35,266 --> 00:07:36,733
所以就这个差别

211
00:07:36,733 --> 00:07:38,266
其他的没有差别

212
00:07:38,266 --> 00:07:40,733
所以大家可以看到control层的DTOVO

213
00:07:41,100 --> 00:07:41,733
收尾层呢

214
00:07:41,733 --> 00:07:43,499
是有用到rocking number q啊

215
00:07:43,500 --> 00:07:44,500
所以有listen的

216
00:07:44,933 --> 00:07:45,933
然后盗层嘛

217
00:07:45,933 --> 00:07:46,599
因为有很多

218
00:07:46,600 --> 00:07:48,733
所以首先把Bo中间的一个东西

219
00:07:48,733 --> 00:07:49,466
给它滴流出来

220
00:07:49,466 --> 00:07:50,966
成为一个model的包

221
00:07:51,566 --> 00:07:52,899
那其他的部分呢

222
00:07:52,900 --> 00:07:56,300
就是会把它分成了open fact activity和on sale

223
00:07:56,300 --> 00:07:58,466
就把盗还分了分了好几个

224
00:07:58,700 --> 00:07:59,933
然后map层的话

225
00:07:59,933 --> 00:08:00,533
用了Mango

226
00:08:00,533 --> 00:08:02,866
用了GPA用了open face

227
00:08:02,866 --> 00:08:04,333
用了调用其他模块

228
00:08:04,766 --> 00:08:05,933
所以大家一般来说

229
00:08:05,933 --> 00:08:06,533
大家可以看到

230
00:08:06,533 --> 00:08:08,866
我们画这个包图的目的体现了两个

231
00:08:08,866 --> 00:08:09,866
第一个你能看到

232
00:08:09,866 --> 00:08:12,066
我们用了一个什么样的体系结构

233
00:08:12,700 --> 00:08:13,600
层次体系结构

234
00:08:13,600 --> 00:08:14,700
m v c的层次体结构

235
00:08:14,700 --> 00:08:15,933
包头一眼能看出来

236
00:08:16,133 --> 00:08:16,999
第二个目的呢

237
00:08:17,000 --> 00:08:18,466
就是因为我们所有的这个包

238
00:08:18,466 --> 00:08:20,466
命名是有一定的惯例的

239
00:08:20,800 --> 00:08:21,666
所以有了惯例以后

240
00:08:21,666 --> 00:08:23,399
你基本上一眼看这个包就知道啊

241
00:08:23,400 --> 00:08:24,733
我这个模块用了什么东西

242
00:08:24,733 --> 00:08:26,333
是吧人们用到了芒果

243
00:08:26,333 --> 00:08:28,466
用了GPA用到了吊其他模块

244
00:08:28,466 --> 00:08:29,266
对吧

245
00:08:29,366 --> 00:08:32,466
就通过巴图能得到这两个信息啊

246
00:08:32,466 --> 00:08:33,299
就足够了

247
00:08:35,100 --> 00:08:36,366
呃对象模型

248
00:08:37,200 --> 00:08:38,100
对象模型

249
00:08:39,866 --> 00:08:43,533
我们的这个部分是以商品为核心

250
00:08:44,300 --> 00:08:47,533
描述了这个商品所属的分类

251
00:08:48,066 --> 00:08:51,566
因为商品是允许顾客商户去修改的

252
00:08:51,566 --> 00:08:53,866
而修改过程中间是需要审核的

253
00:08:54,133 --> 00:08:56,933
所以我们把修改过程中间的商品

254
00:08:56,933 --> 00:08:57,733
叫做草稿

255
00:08:57,733 --> 00:09:00,333
商品包括他没有批准的新的商品

256
00:09:00,333 --> 00:09:00,966
都叫做草稿

257
00:09:00,966 --> 00:09:03,699
商品一旦审核通过或者一旦批准

258
00:09:03,700 --> 00:09:05,733
才变成我们所说的正式商品

259
00:09:05,900 --> 00:09:08,600
所以对象模型里头大家可以看到

260
00:09:08,600 --> 00:09:10,666
我们有一个对象叫做草稿商品

261
00:09:11,166 --> 00:09:13,166
那商品本身是有关联的

262
00:09:13,600 --> 00:09:15,200
因为我们有很多商品

263
00:09:15,200 --> 00:09:16,666
是在打包在一起卖的

264
00:09:16,666 --> 00:09:19,099
所以希望买了这个也去买其他的

265
00:09:19,200 --> 00:09:22,066
或者说同一个商品的不同的型号

266
00:09:22,500 --> 00:09:23,466
我们都会把它做成

267
00:09:23,466 --> 00:09:25,166
商品的这个关联关系

268
00:09:25,533 --> 00:09:26,599
然后商品呢

269
00:09:26,600 --> 00:09:28,133
只有商品的基本信息

270
00:09:28,133 --> 00:09:29,399
商品到底卖多少钱

271
00:09:29,400 --> 00:09:31,200
卖什么卖多少数

272
00:09:31,466 --> 00:09:32,133
怎么卖法

273
00:09:32,133 --> 00:09:34,133
我们都放到这个Excel对象中间

274
00:09:34,466 --> 00:09:35,399
严格意义上来说

275
00:09:35,400 --> 00:09:37,566
这两个对象之间的关系是一对多的

276
00:09:37,566 --> 00:09:39,499
因为一个商品在不同的时期

277
00:09:39,500 --> 00:09:40,933
他卖的价格是不一样的

278
00:09:41,266 --> 00:09:42,366
但是我们在这项目中间

279
00:09:42,366 --> 00:09:43,899
只记了一对一的关系

280
00:09:44,333 --> 00:09:45,866
这个一对一的关系

281
00:09:45,866 --> 00:09:47,699
和我们之前在商铺里头

282
00:09:47,700 --> 00:09:48,966
那个处理的一对一关系

283
00:09:48,966 --> 00:09:50,366
不是同一个概念

284
00:09:50,866 --> 00:09:51,766
我们可以看一下

285
00:09:51,766 --> 00:09:52,599
之前我们在

286
00:09:56,333 --> 00:09:58,266
啊这个就只能回到这个上面来看了

287
00:09:58,266 --> 00:09:59,066
啊

288
00:09:59,600 --> 00:10:01,333
之前我们在商铺里头

289
00:10:03,800 --> 00:10:04,366
还要登录

290
00:10:04,366 --> 00:10:05,166
那算了吧

291
00:10:05,800 --> 00:10:08,533
登录还输手机输那个

292
00:10:11,300 --> 00:10:12,400
之前我们在商铺里头

293
00:10:12,400 --> 00:10:15,100
其实也有一个一对多的概念

294
00:10:15,100 --> 00:10:17,900
就是每个商铺是有多个运费模板的

295
00:10:18,000 --> 00:10:19,333
但是我们在对象模型中间

296
00:10:19,333 --> 00:10:20,699
选择了只记一个

297
00:10:21,333 --> 00:10:23,666
就是只记这个商铺的默认运费模板

298
00:10:23,666 --> 00:10:25,466
而没有去记他所有的运费模板

299
00:10:25,466 --> 00:10:26,333
我们的理由是

300
00:10:26,333 --> 00:10:27,299
所有的运费模板嘛

301
00:10:27,300 --> 00:10:28,500
只是用来看的

302
00:10:28,600 --> 00:10:30,800
所以我们用面向功能的方式

303
00:10:30,800 --> 00:10:32,400
去实现他的查看

304
00:10:32,700 --> 00:10:35,133
但是默认运费模板是用在业务里头的

305
00:10:35,133 --> 00:10:36,099
所以对象模型里头

306
00:10:36,100 --> 00:10:38,966
我们就会记住他的一对一的关系

307
00:10:39,366 --> 00:10:40,666
但这里的情况又比

308
00:10:40,666 --> 00:10:41,899
那里更复杂一点

309
00:10:42,066 --> 00:10:42,866
首先来说

310
00:10:42,866 --> 00:10:45,199
我们知道我们不去记低对多的情况

311
00:10:45,200 --> 00:10:47,466
是因为对象朋友中间记忆对多的情况

312
00:10:47,466 --> 00:10:49,099
其实是有这个性能

313
00:10:49,100 --> 00:10:52,766
复制性能的复杂的啊

314
00:10:52,933 --> 00:10:55,099
所以我们尽量会选择说

315
00:10:55,200 --> 00:10:56,566
如果没有业务要求

316
00:10:56,566 --> 00:10:58,066
我们就不会把一对多的关系

317
00:10:58,066 --> 00:10:59,166
记在对象朋友中间

318
00:10:59,466 --> 00:11:01,599
但这里我们没有做这样的一个选择

319
00:11:01,600 --> 00:11:03,333
除了性能的因素以外

320
00:11:03,666 --> 00:11:06,333
还有一个原因是

321
00:11:06,333 --> 00:11:09,466
我们的商品和销售之间的关系

322
00:11:10,500 --> 00:11:11,866
我们记得是一对一的

323
00:11:11,866 --> 00:11:13,766
但这个一对一的时候发生变化

324
00:11:14,066 --> 00:11:15,566
他在不同场景下

325
00:11:15,566 --> 00:11:18,733
他这个一对一是不一样啊

326
00:11:18,733 --> 00:11:20,766
我们当我看到我们的两个API

327
00:11:21,066 --> 00:11:24,466
一个是顾客去看当前的商品的时候

328
00:11:24,766 --> 00:11:27,099
他的商品所关联的ESCEL对象

329
00:11:27,100 --> 00:11:28,700
应该是当前有效的

330
00:11:28,700 --> 00:11:31,866
就这个时间段有效的ESCEL对象

331
00:11:32,300 --> 00:11:34,066
那如果顾客从订单的角度

332
00:11:34,066 --> 00:11:35,133
去看一个商品的时候

333
00:11:35,133 --> 00:11:36,466
他要看到那个ESCEL对象

334
00:11:36,466 --> 00:11:38,333
是在下订单的那一刻

335
00:11:38,966 --> 00:11:40,299
他的Excel对象

336
00:11:40,300 --> 00:11:41,200
实际上他看到的价格

337
00:11:41,200 --> 00:11:43,300
就他下订单的时候那一刻的价格

338
00:11:43,333 --> 00:11:45,333
而不是现在的这个价格

339
00:11:45,600 --> 00:11:47,166
所以product和Excel

340
00:11:47,166 --> 00:11:49,766
我们可以只记一个一对一的关系

341
00:11:50,100 --> 00:11:53,733
但是比商铺的模块更复杂的是这一个

342
00:11:53,733 --> 00:11:55,999
这个一对一的关系不是一个恒定的

343
00:11:56,466 --> 00:11:58,333
而是在不同的API里头

344
00:11:58,333 --> 00:12:01,066
这个一对一的关系需要是不同的

345
00:12:01,466 --> 00:12:02,866
这是我们在之后设计中间

346
00:12:02,866 --> 00:12:04,366
要去解决的问题啊

347
00:12:04,966 --> 00:12:10,333
那这个销售和活动的关系

348
00:12:10,333 --> 00:12:11,499
大家可以选看到

349
00:12:11,500 --> 00:12:13,000
我们选择了一个对象朋友

350
00:12:13,000 --> 00:12:16,566
中间记了一个最复杂的就是多对多的

351
00:12:17,333 --> 00:12:20,266
那多对多的记录下来是有代价的

352
00:12:20,266 --> 00:12:21,766
在对向门口也是有代价的

353
00:12:22,000 --> 00:12:23,133
但是没有办法

354
00:12:23,133 --> 00:12:25,566
双向的对对多的我们都得要记下来

355
00:12:25,566 --> 00:12:26,366
因为我们的业务

356
00:12:26,366 --> 00:12:29,866
严重依赖于这个多对多的关系

357
00:12:30,100 --> 00:12:32,900
所以这个设计大家可以考量一下

358
00:12:32,900 --> 00:12:35,466
我们现在做的方式就是两边的多对多

359
00:12:35,466 --> 00:12:36,333
全记下来

360
00:12:36,866 --> 00:12:38,799
对象模型会会比较有压力

361
00:12:38,800 --> 00:12:40,666
但是因为这两边都有业务

362
00:12:41,166 --> 00:12:43,733
就是无论从销售去看他的所有的活动

363
00:12:44,166 --> 00:12:46,699
还是无论从活动去看他的所有的销售

364
00:12:46,700 --> 00:12:47,566
两边都有业务

365
00:12:47,566 --> 00:12:48,166
所以没办法

366
00:12:48,166 --> 00:12:49,899
就只好把它做了一个双向的

367
00:12:49,900 --> 00:12:50,700
多多多多

368
00:12:53,366 --> 00:12:54,366
秒杀要做的

369
00:12:55,800 --> 00:12:57,466
我们不是说秒杀要做的

370
00:12:57,466 --> 00:12:58,966
我们所有的东西都是秒杀

371
00:13:00,266 --> 00:13:02,066
就所有的东西都有可能被秒杀

372
00:13:02,066 --> 00:13:04,166
所以所有东西都是都是秒杀

373
00:13:04,400 --> 00:13:06,900
就是秒杀和正常的差别在于说

374
00:13:06,900 --> 00:13:09,066
秒杀会有一个预先low的过程

375
00:13:09,066 --> 00:13:09,866
而正常的话

376
00:13:09,866 --> 00:13:11,599
是在第一次买的时候才会去low

377
00:13:11,933 --> 00:13:13,866
所以所有东西都是按照秒杀来处理的

378
00:13:15,866 --> 00:13:18,133
就是正常的东西

379
00:13:18,133 --> 00:13:18,799
你在买的时候

380
00:13:18,800 --> 00:13:21,100
也需要提升到秒杀级别了

381
00:13:21,100 --> 00:13:23,666
但是他不会预先把它搂上来

382
00:13:24,000 --> 00:13:24,766
而秒杀呢

383
00:13:24,766 --> 00:13:27,266
就是我记得这个销售是秒杀的

384
00:13:27,266 --> 00:13:28,199
那就在开始之前

385
00:13:28,200 --> 00:13:29,800
就全部把它全搂到缓存里去了

386
00:13:30,566 --> 00:13:31,899
就事先都到缓存区了

387
00:13:31,900 --> 00:13:33,766
而不是等到满的时候再搂到缓存

388
00:13:33,766 --> 00:13:34,933
因为他是秒杀嘛

389
00:13:35,133 --> 00:13:37,066
所以那秒的时候再搂就来不及了

390
00:13:39,366 --> 00:13:40,166
就是

391
00:13:40,866 --> 00:13:41,666
对对对

392
00:13:43,466 --> 00:13:44,966
对直接去去看

393
00:13:44,966 --> 00:13:46,266
直接去买就会更快

394
00:13:46,600 --> 00:13:48,333
但是正常商品我们也会

395
00:13:48,333 --> 00:13:48,899
就是正常

396
00:13:48,900 --> 00:13:50,466
跟普通的秒杀的差别就在于

397
00:13:50,466 --> 00:13:51,533
他没有预先去喽

398
00:13:59,000 --> 00:13:59,533
我们认为

399
00:13:59,533 --> 00:14:01,866
这个普通销售才能是正常和秒杀

400
00:14:01,866 --> 00:14:03,533
团购是不能去秒杀的

401
00:14:03,533 --> 00:14:05,133
团购和预售是不能去秒的

402
00:14:06,966 --> 00:14:07,333
对啊

403
00:14:07,333 --> 00:14:09,466
团购我们现目前团购和预售是就是

404
00:14:09,466 --> 00:14:09,899
换句话说

405
00:14:09,900 --> 00:14:12,366
团购和预售没有预先low到缓存里去

406
00:14:12,366 --> 00:14:13,366
没有这么去做

407
00:14:13,666 --> 00:14:14,966
当然我们现在这个设计是这样

408
00:14:14,966 --> 00:14:16,599
但其实是可以做到这样的

409
00:14:16,600 --> 00:14:18,333
你就是把秒杀

410
00:14:19,300 --> 00:14:21,333
变成另外一个独立的字段

411
00:14:21,333 --> 00:14:23,066
现在是没有这么做啊

412
00:14:23,066 --> 00:14:24,366
现在就是普通销售

413
00:14:24,366 --> 00:14:26,333
是可以正常和秒杀就会预搂

414
00:14:26,533 --> 00:14:28,866
团购和预售是没有去预先

415
00:14:28,966 --> 00:14:30,299
预先搂上去的

416
00:14:31,900 --> 00:14:32,566
当然要做的话

417
00:14:32,566 --> 00:14:33,199
其实也可以

418
00:14:33,200 --> 00:14:35,100
就是在目前稍微改一下

419
00:14:35,100 --> 00:14:39,066
比如说0123是那个

420
00:14:39,100 --> 00:14:40,466
然后10是秒杀

421
00:14:40,466 --> 00:14:41,533
12是秒杀团购

422
00:14:41,533 --> 00:14:43,133
13是秒杀预售

423
00:14:43,133 --> 00:14:45,766
就目前这个要改也是可以改出来的

424
00:14:45,900 --> 00:14:47,000
没什么太大问题

425
00:14:47,066 --> 00:14:48,933
反正没有这么多类别嘛

426
00:14:48,933 --> 00:14:49,733
是吧

427
00:14:50,200 --> 00:14:52,133
所以说你改成100是秒杀也可以

428
00:14:52,133 --> 00:14:53,099
100100是正常

429
00:14:53,100 --> 00:14:54,666
102是团购

430
00:14:54,666 --> 00:14:57,066
103是那个也行啊

431
00:14:57,100 --> 00:14:58,300
但我们现在没有这么做

432
00:15:02,800 --> 00:15:05,600
嗯这是这个销售啊

433
00:15:06,300 --> 00:15:07,700
那活动大家可以看到

434
00:15:07,700 --> 00:15:08,933
我们的处理方式

435
00:15:09,300 --> 00:15:12,700
跟前面在运费模板里的处理方式一样

436
00:15:12,700 --> 00:15:14,533
一半放到了MYCO数据库里

437
00:15:14,533 --> 00:15:16,133
一半放到了芒果数据库里

438
00:15:16,600 --> 00:15:18,333
放到MYCO数据库里头的部分

439
00:15:18,333 --> 00:15:20,399
是因为要查的啊

440
00:15:20,400 --> 00:15:21,166
芒果数据库里头

441
00:15:21,166 --> 00:15:22,566
依然保持了前面那种做法

442
00:15:22,566 --> 00:15:23,699
只用组件查

443
00:15:23,700 --> 00:15:25,000
不能用其他的东西查

444
00:15:25,366 --> 00:15:26,599
所以可以查的部分呢

445
00:15:26,600 --> 00:15:28,533
就都放到了Mac库里头

446
00:15:28,733 --> 00:15:29,899
不可以查的部分呢

447
00:15:29,900 --> 00:15:31,966
就都丢到了芒果里头去啊

448
00:15:31,966 --> 00:15:34,099
是这样这样来做的

449
00:15:34,200 --> 00:15:35,333
那为什么会把

450
00:15:35,366 --> 00:15:37,333
为什么会再次用到了芒果

451
00:15:37,933 --> 00:15:39,299
原因就是因为这个部分

452
00:15:39,300 --> 00:15:41,166
最复杂的就是这一堆

453
00:15:41,933 --> 00:15:45,133
这一堆就是我们在电子商城中间

454
00:15:45,133 --> 00:15:47,799
大家最喜闻乐见的打折

455
00:15:48,866 --> 00:15:49,999
我们现在这个设计

456
00:15:50,000 --> 00:15:50,466
是认为

457
00:15:50,466 --> 00:15:53,599
这是整个系统的变化点和引进点

458
00:15:54,066 --> 00:15:55,066
我们要支持目

459
00:15:55,066 --> 00:15:55,199
前

460
00:15:55,200 --> 00:15:57,800
所有你能够想得到的所有的打折关系

461
00:15:58,333 --> 00:15:59,799
而且这部分要设计

462
00:15:59,800 --> 00:16:02,900
目标是满足开闭原则

463
00:16:03,000 --> 00:16:04,933
但有一种新的打折关系

464
00:16:05,866 --> 00:16:06,733
新的优惠

465
00:16:06,733 --> 00:16:07,666
你想得出来的

466
00:16:07,666 --> 00:16:08,299
新的优惠

467
00:16:08,300 --> 00:16:09,100
想出来的时候

468
00:16:09,100 --> 00:16:10,566
我们不改现有代码

469
00:16:10,666 --> 00:16:14,166
就能完成这样的一个优惠的过程啊

470
00:16:14,166 --> 00:16:16,299
所以这部分的设计就会比较复杂

471
00:16:16,300 --> 00:16:19,166
我们放到下周再来讲啊

472
00:16:19,733 --> 00:16:21,166
那我们这一周主要讲的是

473
00:16:21,166 --> 00:16:23,133
上面那个白色部分是怎么来完成

474
00:16:23,766 --> 00:16:25,399
就是在my c口的部分啊

475
00:16:25,400 --> 00:16:26,500
是怎么来完成的

476
00:16:28,100 --> 00:16:28,866
数据库的设计

477
00:16:28,866 --> 00:16:31,299
这里只是在白色部分的数据库的设计

478
00:16:31,300 --> 00:16:33,400
啊那当然在对象模型中间

479
00:16:33,400 --> 00:16:34,366
我们可以去省略

480
00:16:34,366 --> 00:16:35,866
在数据库里头是没办法省略的

481
00:16:35,866 --> 00:16:36,533
所以大家可以看到

482
00:16:36,533 --> 00:16:39,166
这里依然记得是一个一对多的关系

483
00:16:39,733 --> 00:16:40,933
然后这边我们可以看到

484
00:16:40,933 --> 00:16:42,299
对巧模中间是做最多的

485
00:16:42,300 --> 00:16:44,300
在数据库里就没有别的办法了

486
00:16:44,766 --> 00:16:46,799
就一定得搞出个第三张表出来

487
00:16:47,000 --> 00:16:48,333
把它塞到中间

488
00:16:49,666 --> 00:16:51,999
对这就是标准的数据库的

489
00:16:52,000 --> 00:16:54,133
多对多的处理办法啊

490
00:16:54,133 --> 00:16:56,733
那这就是这个有问题吗

491
00:16:56,733 --> 00:16:58,499
这就是标准的数据库里的多对多

492
00:16:58,500 --> 00:16:59,333
就这么来做的

493
00:16:59,333 --> 00:17:00,966
做了一张中间表啊

494
00:17:00,966 --> 00:17:02,866
来记录他们两个之间的关系

495
00:17:09,666 --> 00:17:10,766
就是种类中间

496
00:17:10,766 --> 00:17:12,566
它因为种类我们在对对象模型中间

497
00:17:12,566 --> 00:17:14,499
它是一个一对多的

498
00:17:14,766 --> 00:17:15,933
一对一的关系嘛

499
00:17:15,933 --> 00:17:17,999
就是我们只记得它的上期种

500
00:17:20,300 --> 00:17:21,600
一级分类和二级分类

501
00:17:21,600 --> 00:17:22,133
二级分类

502
00:17:22,133 --> 00:17:23,699
记得上一级分类

503
00:17:25,566 --> 00:17:26,699
我们叫两级分类

504
00:17:27,466 --> 00:17:28,999
就只做了一级分类和二级分类

505
00:17:29,000 --> 00:17:29,800
但是这个结构

506
00:17:29,800 --> 00:17:30,966
其实你做三级分类也可以

507
00:17:30,966 --> 00:17:32,299
但是现在一般电商平台

508
00:17:32,300 --> 00:17:33,566
三级分类不会做

509
00:17:33,566 --> 00:17:34,533
点的太多了

510
00:17:35,100 --> 00:17:36,566
所以一般就只做二级分类

511
00:17:36,666 --> 00:17:38,766
所以我们也是做了二级分类啊

512
00:17:39,733 --> 00:17:41,533
一般是不会去做三级分类的

513
00:17:48,200 --> 00:17:53,066
好我们还是从几个比较有代表性的

514
00:17:53,066 --> 00:17:54,133
这个API来看

515
00:17:54,133 --> 00:17:55,566
它怎么来做设计的

516
00:17:56,000 --> 00:17:57,066
我们前面说到过

517
00:17:57,066 --> 00:17:58,766
我们在这个部分的设计

518
00:17:59,100 --> 00:18:00,300
product和Excel

519
00:18:00,300 --> 00:18:01,966
我们只记了一对一的关系

520
00:18:02,366 --> 00:18:03,333
但这个一对一的关系

521
00:18:03,333 --> 00:18:04,766
其实在不同的API上面

522
00:18:04,766 --> 00:18:06,899
它的关系必须是不一样的

523
00:18:07,066 --> 00:18:08,699
那我们来怎么来处理这个问题呢

524
00:18:08,766 --> 00:18:09,966
我们来看这两个API

525
00:18:10,666 --> 00:18:13,333
一个是顾客上来来看一个商品的信息

526
00:18:14,200 --> 00:18:15,466
那他会要看到

527
00:18:15,466 --> 00:18:17,466
这个商品的所有的信息啊

528
00:18:17,466 --> 00:18:20,133
比如说商铺所属的商铺名称啊

529
00:18:20,133 --> 00:18:22,199
原价啊重量啊等等

530
00:18:22,366 --> 00:18:23,199
当然我们知道

531
00:18:23,200 --> 00:18:24,500
我们在看一个商品信息的时候

532
00:18:24,500 --> 00:18:26,400
当然要有商品的现在销售价格

533
00:18:26,400 --> 00:18:28,566
他的可以卖多少数量啊

534
00:18:28,566 --> 00:18:29,666
虽然他可能看不到啊

535
00:18:29,666 --> 00:18:31,899
但这个数量如果小于10的话

536
00:18:31,900 --> 00:18:32,933
就会在界面上显示一下

537
00:18:32,933 --> 00:18:34,099
只剩8件了

538
00:18:34,100 --> 00:18:34,966
只剩6件了

539
00:18:35,133 --> 00:18:35,866
如果很多的话

540
00:18:35,866 --> 00:18:37,199
其实这个都不会去显示

541
00:18:37,766 --> 00:18:39,399
还有一个是不会显示的

542
00:18:39,400 --> 00:18:41,133
就是他一次下单能买多少

543
00:18:41,166 --> 00:18:42,599
所以这个Max quality啊

544
00:18:42,600 --> 00:18:44,066
就是一次下单能买多少

545
00:18:44,166 --> 00:18:45,199
然后还有其他的

546
00:18:45,466 --> 00:18:46,399
不止还有这些啊

547
00:18:46,400 --> 00:18:47,800
其实我们下面你往下翻的话

548
00:18:47,800 --> 00:18:48,866
还有他的分类

549
00:18:49,000 --> 00:18:52,400
还有这个商品可以做的优惠活动等等

550
00:18:52,533 --> 00:18:53,399
全部会给他

551
00:18:53,900 --> 00:18:54,333
这个就是

552
00:18:54,333 --> 00:18:56,133
我们在设计restore API的时候

553
00:18:56,133 --> 00:18:57,133
的一个原则

554
00:18:57,366 --> 00:18:59,466
就是当顾客要拿到这个东西的时候

555
00:18:59,900 --> 00:19:02,700
我就把这个信息的所有东西

556
00:19:02,700 --> 00:19:04,300
全部丢给他了

557
00:19:04,933 --> 00:19:05,699
这个这么做的

558
00:19:05,700 --> 00:19:06,800
主要的目的是为了什么呢

559
00:19:06,800 --> 00:19:10,366
是避免前端多次调用

560
00:19:10,366 --> 00:19:12,733
后端来获取相关的信息

561
00:19:13,133 --> 00:19:14,799
就实际上前端在调后

562
00:19:14,800 --> 00:19:15,300
端的时候

563
00:19:15,300 --> 00:19:17,666
他已经把这个商品的所有的相关信息

564
00:19:17,866 --> 00:19:18,699
都拿到了

565
00:19:18,800 --> 00:19:21,333
但是他用一个界面展现给顾客看

566
00:19:21,333 --> 00:19:22,899
还是用多个界面展现给顾客看

567
00:19:22,900 --> 00:19:24,166
那是前端来决定的

568
00:19:24,500 --> 00:19:27,166
但是不管他要怎么看法

569
00:19:27,166 --> 00:19:29,966
他都不用再找后端去再调API了

570
00:19:30,200 --> 00:19:30,733
这个原因

571
00:19:30,733 --> 00:19:32,466
就是因为他的一个效率问题啊

572
00:19:32,466 --> 00:19:35,799
就是对于前端和后端拒绝GDP的协议

573
00:19:35,800 --> 00:19:37,600
它有一个握手的过程

574
00:19:37,600 --> 00:19:39,600
这个过程都是需要消耗时间的

575
00:19:39,900 --> 00:19:41,466
所以如果我们能够一次性的

576
00:19:41,466 --> 00:19:42,966
把这个东西传给前端

577
00:19:42,966 --> 00:19:44,366
其实就减少了

578
00:19:44,366 --> 00:19:47,299
两边的这个网络通讯的这个握手

579
00:19:47,300 --> 00:19:48,566
所浪费的这个时间

580
00:19:48,566 --> 00:19:50,066
大家知道它有一个连接时间啊

581
00:19:50,066 --> 00:19:51,299
等等这个这个问题

582
00:19:51,966 --> 00:19:53,699
但这个问题对我们后端来说

583
00:19:53,700 --> 00:19:56,500
就产产生了一个很大的压力

584
00:19:57,000 --> 00:19:57,800
为啥呢

585
00:19:57,966 --> 00:19:59,866
大家如果看到对象模型图上头

586
00:19:59,866 --> 00:20:01,333
我们看到这个API

587
00:20:02,333 --> 00:20:05,866
除了这个草稿没有给他以外

588
00:20:06,200 --> 00:20:08,866
整张图上所有的东西全部给他了

589
00:20:10,733 --> 00:20:13,099
整张图上所有东西全部给他了啊

590
00:20:13,100 --> 00:20:14,700
所以这次对于我们后端

591
00:20:14,700 --> 00:20:16,166
就是一个很大的考验了

592
00:20:16,300 --> 00:20:16,800
虽然说

593
00:20:16,800 --> 00:20:20,166
可以有效的降低网络通讯的时间

594
00:20:20,166 --> 00:20:22,066
但是如果我们后端比较慢的话

595
00:20:22,066 --> 00:20:24,566
那也是白白瞎没有用是吧

596
00:20:24,800 --> 00:20:26,400
所以我们后端的一个设计方案就是

597
00:20:26,400 --> 00:20:29,766
怎么样用最快的速度完成这个过程

598
00:20:30,766 --> 00:20:31,733
啊完成这个过程

599
00:20:31,733 --> 00:20:32,899
因为对于我们这个模块说

600
00:20:32,900 --> 00:20:34,800
除了上缴这个东西没给他以外

601
00:20:34,800 --> 00:20:36,000
全部都给他了啊

602
00:20:36,000 --> 00:20:36,900
全部都给他了

603
00:20:37,900 --> 00:20:38,666
那这是第一个

604
00:20:38,666 --> 00:20:41,999
这是获得当前的这个商品信息

605
00:20:42,733 --> 00:20:43,799
第二个API呢

606
00:20:43,800 --> 00:20:45,400
是从订单过来的

607
00:20:45,766 --> 00:20:47,333
所以顾客从订单过来

608
00:20:47,333 --> 00:20:49,333
他会看到订单里的一个商品

609
00:20:49,466 --> 00:20:50,099
那我们在订

610
00:20:50,100 --> 00:20:52,766
单里记得那个商品不是记得是product ID

611
00:20:53,066 --> 00:20:54,366
记得是on sale ID

612
00:20:54,366 --> 00:20:56,766
为什么因为他点过来看的时候

613
00:20:57,266 --> 00:20:59,466
同样要看到这个商品的价格

614
00:21:00,866 --> 00:21:02,999
但是这个价格不是当前的价格

615
00:21:03,000 --> 00:21:06,500
而是他在买这个东西的时候的价格

616
00:21:07,000 --> 00:21:09,133
他在买这个商品的时候

617
00:21:09,166 --> 00:21:11,199
他的价格是什么啊

618
00:21:11,200 --> 00:21:14,866
所以这个时候所看到的这个商品

619
00:21:14,866 --> 00:21:17,099
虽然这些商品的属性是一模一样的

620
00:21:17,500 --> 00:21:18,900
但是里头所呈现的内容

621
00:21:18,900 --> 00:21:20,566
特别是这个价格的这个内容

622
00:21:20,900 --> 00:21:23,700
不是这个商品当前销售的价格

623
00:21:23,933 --> 00:21:24,933
而是这个顾客

624
00:21:24,933 --> 00:21:26,933
在当时买的是哪一个销售

625
00:21:27,800 --> 00:21:30,533
那那个时候的这个价格就会显示在

626
00:21:31,133 --> 00:21:32,699
显示给前端啊

627
00:21:32,700 --> 00:21:33,966
所以这是两个API

628
00:21:34,400 --> 00:21:37,800
虽然返回值的这个格式是一样的

629
00:21:37,800 --> 00:21:39,566
但是其实针是针对这个商品

630
00:21:39,566 --> 00:21:40,699
要返回不同的东西

631
00:21:41,266 --> 00:21:43,566
所以我们知道在这个模型中间啊

632
00:21:43,566 --> 00:21:44,166
就这个API

633
00:21:44,166 --> 00:21:46,399
同样也是除了上缴这个没有以外

634
00:21:46,400 --> 00:21:47,266
全部都要

635
00:21:47,566 --> 00:21:49,899
但是两个API中间最大的差别就在于

636
00:21:49,900 --> 00:21:51,666
说它挂念的Excel是不同的

637
00:21:52,100 --> 00:21:54,966
一个是当前这个时间段有效的Excel

638
00:21:55,300 --> 00:21:57,333
一个是顾客在下单的时候

639
00:21:57,333 --> 00:21:58,666
他买的是哪一个Excel

640
00:21:58,666 --> 00:22:01,299
那这个商品就关联是当时那个Excel

641
00:22:01,366 --> 00:22:02,499
那这个不同

642
00:22:02,500 --> 00:22:04,466
当然后面的东西就都不同啊

643
00:22:04,800 --> 00:22:05,333
这个不同

644
00:22:05,333 --> 00:22:08,166
后面这个东西就是完全不同的

645
00:22:08,466 --> 00:22:09,266
这个是

646
00:22:10,200 --> 00:22:12,133
这个是我们的这两个API

647
00:22:12,533 --> 00:22:15,199
所以这两个API的问题大于说第一

648
00:22:15,200 --> 00:22:18,133
这两个API是有极大的相似性的啊

649
00:22:18,133 --> 00:22:19,933
我们希望在这两个API上头

650
00:22:19,933 --> 00:22:22,366
尽量去重用代码啊

651
00:22:22,366 --> 00:22:25,533
不要写出两套完全不交叉的代码

652
00:22:25,533 --> 00:22:27,133
这是我们第一个设计目标

653
00:22:27,466 --> 00:22:28,066
第二个设计目标

654
00:22:28,066 --> 00:22:28,999
就是我们刚才可以看到

655
00:22:29,000 --> 00:22:31,066
这两个API其实都有同样的问题

656
00:22:31,333 --> 00:22:32,799
就是他会要去查

657
00:22:32,800 --> 00:22:35,200
在数据库里头的多个对象

658
00:22:35,400 --> 00:22:37,300
从MACDO查到Mango

659
00:22:38,000 --> 00:22:38,966
多次查表

660
00:22:39,000 --> 00:22:39,800
如果说这些东西

661
00:22:39,800 --> 00:22:41,300
都要从数据库里出来的话

662
00:22:41,300 --> 00:22:41,933
大家可以想象

663
00:22:41,933 --> 00:22:43,966
他要查多少次表才能查得出来

664
00:22:44,366 --> 00:22:47,866
我们去年是完整的做完了五次的

665
00:22:48,166 --> 00:22:49,166
伽瓦伊的实验

666
00:22:49,166 --> 00:22:52,399
其中第三次实验就是做的这个部分

667
00:22:52,500 --> 00:22:54,933
就这个代码里头做了两套代码

668
00:22:54,933 --> 00:22:57,366
一套是完全没有用缓存的

669
00:22:57,366 --> 00:22:58,866
没做任何优化的情况下

670
00:22:58,866 --> 00:23:00,599
头先做了一套代码

671
00:23:00,600 --> 00:23:02,333
然后让同学们去做测试

672
00:23:02,500 --> 00:23:04,100
然后再做了一次优化

673
00:23:04,100 --> 00:23:05,066
去做对比啊

674
00:23:05,066 --> 00:23:06,666
去让同学们去做了一次测试

675
00:23:06,966 --> 00:23:07,966
我先给大家看的是

676
00:23:07,966 --> 00:23:09,766
就是完全没有做任何设计

677
00:23:09,766 --> 00:23:11,599
直接所有东西去查数据库

678
00:23:12,133 --> 00:23:14,966
10秒发出400个请求

679
00:23:15,766 --> 00:23:16,166
大家觉得

680
00:23:16,166 --> 00:23:17,899
我们现在的服务器是个什么状况

681
00:23:18,533 --> 00:23:20,266
大家可以看到这个数据

682
00:23:20,266 --> 00:23:22,599
就是已经惨不忍睹了

683
00:23:23,166 --> 00:23:25,333
10秒400个请求发出去

684
00:23:25,333 --> 00:23:26,866
每秒40个请求

685
00:23:27,700 --> 00:23:30,700
堵的已经完全不看看不见了啊

686
00:23:30,733 --> 00:23:32,866
从下从头一堵到尾

687
00:23:33,966 --> 00:23:35,866
然后这条线大家应该知道

688
00:23:35,866 --> 00:23:36,566
在my c口中间

689
00:23:36,566 --> 00:23:39,299
这条线越靠前就堵的越厉害

690
00:23:39,533 --> 00:23:41,666
所以说明他一开始就一直在往上堵

691
00:23:41,900 --> 00:23:44,000
对吧就从来没有没有停止过

692
00:23:45,866 --> 00:23:48,699
他的反应时间直线往上涨

693
00:23:48,700 --> 00:23:50,400
就说明越来越慢

694
00:23:50,400 --> 00:23:50,900
越来越慢

695
00:23:50,900 --> 00:23:51,466
越来越慢

696
00:23:51,466 --> 00:23:52,566
前面都没有结束

697
00:23:52,933 --> 00:23:56,666
所以10秒发400个请求

698
00:23:57,533 --> 00:23:59,166
这个速度已经是这个样子了

699
00:23:59,166 --> 00:24:01,199
那这已经是完全没办法满足

700
00:24:01,200 --> 00:24:02,733
我们正常的使用了

701
00:24:02,933 --> 00:24:04,599
对吧这个就就你就是这么去做

702
00:24:04,600 --> 00:24:06,566
代码就完全没有意义是吧

703
00:24:06,600 --> 00:24:08,100
如果说简单的去查数据库

704
00:24:08,100 --> 00:24:09,266
去查表就

705
00:24:09,266 --> 00:24:09,999
没有意义

706
00:24:10,000 --> 00:24:12,133
我们知道解决办法就是用radis缓存

707
00:24:12,866 --> 00:24:15,666
把它由把它查找过的数据

708
00:24:15,666 --> 00:24:17,999
改由Redis缓存来读取

709
00:24:18,566 --> 00:24:19,266
这样的话呢

710
00:24:19,266 --> 00:24:21,366
就会使得说第一次可能会比较慢

711
00:24:21,533 --> 00:24:24,499
但是如果这个商品是被很多人看的话

712
00:24:24,666 --> 00:24:27,133
后面的速度会大幅度的提升

713
00:24:27,966 --> 00:24:29,333
那缓存的话

714
00:24:29,600 --> 00:24:30,733
我们就有一个选择

715
00:24:30,733 --> 00:24:32,599
我们是缓存Po呢

716
00:24:32,666 --> 00:24:33,333
缓存b o呢

717
00:24:33,333 --> 00:24:34,666
还是缓存DTO啊

718
00:24:34,866 --> 00:24:36,366
我们在之前其实已经有看到

719
00:24:36,366 --> 00:24:38,133
我们是做的选择是缓存b o

720
00:24:38,133 --> 00:24:39,399
但是我们其实没有讨论

721
00:24:39,400 --> 00:24:41,700
我们其实还有别的选择可以缓存

722
00:24:42,533 --> 00:24:43,966
大家觉得这三个选择中间

723
00:24:43,966 --> 00:24:45,699
最高效的是哪一个

724
00:24:47,133 --> 00:24:48,299
对速度最快的

725
00:24:49,866 --> 00:24:50,999
PU是吧

726
00:24:53,333 --> 00:24:55,199
你为什么觉得PU最高效

727
00:24:59,466 --> 00:25:01,533
纯PU跟纯PU不是一样的吗

728
00:25:02,900 --> 00:25:04,533
你为什么觉得DTO最高效

729
00:25:09,733 --> 00:25:11,566
DTO存的就是这个上的这个内容

730
00:25:11,700 --> 00:25:13,200
就是我第一次调Controller层

731
00:25:13,200 --> 00:25:14,266
不是返回了这个东西吗

732
00:25:14,266 --> 00:25:15,566
我就把它存到缓存里

733
00:25:16,066 --> 00:25:18,066
第二次再调的时候就不用调设备层了

734
00:25:18,066 --> 00:25:19,766
直接Controller层缓存里拿出来

735
00:25:19,966 --> 00:25:21,099
啪一下就丢回去了

736
00:25:21,466 --> 00:25:22,999
所以DTO是最快的啊

737
00:25:23,466 --> 00:25:24,666
但能存DTO吗

738
00:25:24,766 --> 00:25:28,766
问题在于说为什么不能存DTO呢

739
00:25:32,600 --> 00:25:33,500
没有什么感觉

740
00:25:33,500 --> 00:25:34,766
你要有理由的啊

741
00:25:35,166 --> 00:25:36,366
为什么不能存DTO

742
00:25:37,133 --> 00:25:38,866
存DTO的主要的问题在于说

743
00:25:38,866 --> 00:25:40,566
DTO把整个都存下来了

744
00:25:41,200 --> 00:25:42,933
所以以商品的ID作为key

745
00:25:42,933 --> 00:25:44,866
把整个东西放到read中间

746
00:25:45,166 --> 00:25:45,933
那现在的问题

747
00:25:45,933 --> 00:25:47,333
如果这个商铺改名了

748
00:25:47,733 --> 00:25:49,199
如果它的分类改名了

749
00:25:49,500 --> 00:25:51,166
如果它的活动发生改变了

750
00:25:51,466 --> 00:25:53,533
这个DTO都没办法去反映

751
00:25:54,666 --> 00:25:55,766
有还是有办法

752
00:25:55,766 --> 00:25:57,966
就是你需要去知道这

753
00:25:57,966 --> 00:25:59,866
个DTO到底跟哪些商铺有关

754
00:25:59,866 --> 00:26:00,799
跟哪些活动有关

755
00:26:00,800 --> 00:26:01,666
跟哪些分类有关

756
00:26:01,666 --> 00:26:02,799
全部记住这个关系

757
00:26:03,266 --> 00:26:05,466
然后当去改变这些东西的时候

758
00:26:05,466 --> 00:26:06,699
去把这个detoil给删掉

759
00:26:06,900 --> 00:26:07,733
但我们会发现

760
00:26:07,733 --> 00:26:09,733
说这里头有些东西还不是这个模块的

761
00:26:09,966 --> 00:26:12,966
比如说商铺的修改就不是这个模块了

762
00:26:13,266 --> 00:26:15,266
所以这就做起来很困难

763
00:26:17,666 --> 00:26:19,299
所以呢我们在存的时候

764
00:26:19,300 --> 00:26:22,266
其实PU和Bo都是可以存的

765
00:26:22,400 --> 00:26:24,533
就是Bo和PU存起来

766
00:26:24,533 --> 00:26:26,733
其实效率差距不太大

767
00:26:27,066 --> 00:26:29,766
但是我们整个设计的重点是什么呢

768
00:26:30,466 --> 00:26:31,933
是Bo而不是Bo

769
00:26:32,866 --> 00:26:35,333
所以我们最后选择的是纯Bo

770
00:26:35,666 --> 00:26:36,333
大家可以看到

771
00:26:36,333 --> 00:26:38,133
其他模块里头都是存的Bo

772
00:26:38,366 --> 00:26:39,199
就这个原因

773
00:26:39,400 --> 00:26:41,500
但记住我们在存Bo的时候

774
00:26:41,500 --> 00:26:43,500
是存的一个什么Bo呢

775
00:26:43,666 --> 00:26:45,533
是存的一个贫血的Bo

776
00:26:46,533 --> 00:26:49,299
就是仅仅存了他的什么呢

777
00:26:49,400 --> 00:26:50,866
仅仅存了他的属性

778
00:26:51,166 --> 00:26:53,266
所有的其他东西都没有存

779
00:26:53,866 --> 00:26:55,499
不但所有东西都没有存

780
00:26:55,800 --> 00:26:57,400
连关系都没有存

781
00:26:58,133 --> 00:27:01,199
也就是我这个Po关联的这个Excel对象

782
00:27:01,400 --> 00:27:03,400
我在存一个product的时候

783
00:27:03,400 --> 00:27:06,566
其实我并没有存他所关联的这个product

784
00:27:06,566 --> 00:27:08,399
的关联的这些对象

785
00:27:08,566 --> 00:27:12,866
我全是存的孤立的贫血的bo

786
00:27:12,866 --> 00:27:15,399
对象就是纯的时候是这么纯的

787
00:27:15,700 --> 00:27:17,566
那这么纯的好处在于说

788
00:27:17,566 --> 00:27:19,133
当我这个对象发生改变的时候

789
00:27:19,133 --> 00:27:20,533
只需要把这个贫血的

790
00:27:20,533 --> 00:27:22,299
孤立的对象给他干掉就好了

791
00:27:22,866 --> 00:27:24,699
当我的这个关系发生改变的时候

792
00:27:24,700 --> 00:27:27,366
其实我并不会影响到这个本身

793
00:27:27,366 --> 00:27:28,533
这个对象啊

794
00:27:28,533 --> 00:27:31,866
所以我们的选择就是纯Bo

795
00:27:32,266 --> 00:27:35,299
而且存贫血的孤立的Bo

796
00:27:36,333 --> 00:27:37,399
那这就有个问题

797
00:27:37,400 --> 00:27:40,366
如果我们只存了贫血的孤立的Bo的话

798
00:27:41,200 --> 00:27:42,466
这些关系怎么办

799
00:27:43,900 --> 00:27:45,100
这些关系怎么办

800
00:27:48,800 --> 00:27:52,533
这些关系如果是一对一的关系

801
00:27:52,900 --> 00:27:54,933
其实你要存下来也问题不大

802
00:27:54,933 --> 00:27:55,999
比如说像这个

803
00:27:57,400 --> 00:27:59,500
这个是一个一对一的关系

804
00:27:59,500 --> 00:28:01,466
就是下级跟上级的关系

805
00:28:01,466 --> 00:28:03,899
所以说存的话也问题不大

806
00:28:04,333 --> 00:28:06,766
但是如果说是一个一对多的关系

807
00:28:06,933 --> 00:28:09,366
你就没有办法在这里头把它存下来

808
00:28:10,166 --> 00:28:12,666
因为你没办法把这个一对多的关系

809
00:28:12,666 --> 00:28:15,533
存到这个对象里头

810
00:28:15,666 --> 00:28:16,866
你如果说一对一的关系

811
00:28:16,866 --> 00:28:18,166
是可以存到这个对象里头的

812
00:28:18,166 --> 00:28:19,133
但是这个一对多的关系

813
00:28:19,133 --> 00:28:21,099
是没办法存到这个product对象中间的

814
00:28:21,300 --> 00:28:23,466
所以如果说一对多的关系

815
00:28:23,466 --> 00:28:27,199
那还得要再做一个redist的key

816
00:28:27,200 --> 00:28:29,000
去存关系

817
00:28:29,600 --> 00:28:33,466
那除了这种呃

818
00:28:34,500 --> 00:28:35,466
除了这种

819
00:28:35,600 --> 00:28:38,966
这个贫血的对象以外

820
00:28:39,200 --> 00:28:43,466
我们还存了所有的一对多的关系

821
00:28:43,500 --> 00:28:45,533
也是单独去存储的

822
00:28:45,600 --> 00:28:47,133
所以在我们现在这个设计中间

823
00:28:47,133 --> 00:28:50,766
就是最终把整张图

824
00:28:51,300 --> 00:28:54,600
整张这个这个对象模型的图

825
00:28:54,933 --> 00:28:56,099
存了多少个对象呢

826
00:28:56,100 --> 00:28:57,133
给大家数一下

827
00:28:59,400 --> 00:29:03,933
存了一个两个三个四个五个

828
00:29:04,400 --> 00:29:08,800
然后6个七个7个对象

829
00:29:09,266 --> 00:29:12,866
因为有两个一个一对多的

830
00:29:13,566 --> 00:29:15,899
八个一个一个一对多的

831
00:29:15,900 --> 00:29:18,666
两个双向的多对多的关系

832
00:29:18,666 --> 00:29:20,066
所以这是存了两次

833
00:29:20,400 --> 00:29:21,466
这边往这边存了一次

834
00:29:21,466 --> 00:29:22,566
这边往这边存了一次

835
00:29:22,566 --> 00:29:27,099
加上这里一二三四五五个对象

836
00:29:27,866 --> 00:29:30,266
存了5 存了8个对象

837
00:29:30,366 --> 00:29:31,066
存了8个

838
00:29:31,066 --> 00:29:32,266
Redis中间的key啊

839
00:29:32,266 --> 00:29:33,133
把它存下来

840
00:29:39,066 --> 00:29:40,666
啊我们现在是的方向

841
00:29:40,666 --> 00:29:42,533
是从二级分类指向一级分类

842
00:29:42,533 --> 00:29:43,999
不是从一级分类指向我们对象

843
00:29:44,000 --> 00:29:46,200
中间没有写一对多

844
00:29:46,200 --> 00:29:47,166
而是一对一

845
00:29:47,366 --> 00:29:49,466
是从二级分类指向一级分类

846
00:29:49,466 --> 00:29:50,399
对所以这样

847
00:29:50,400 --> 00:29:51,400
的话就没必要存关系

848
00:29:51,400 --> 00:29:52,266
因为这个二级分类

849
00:29:52,266 --> 00:29:53,899
就已经存在这个category的

850
00:29:53,900 --> 00:29:55,566
贫血的模型里头了

851
00:29:55,733 --> 00:29:57,266
但是这个一对多没办法

852
00:29:58,100 --> 00:29:59,333
我们在数据库里记的时候

853
00:29:59,333 --> 00:30:01,166
他是从多指向一

854
00:30:01,566 --> 00:30:02,199
大家可以看到

855
00:30:02,200 --> 00:30:05,400
从数据库里记的时候他是多指向一的

856
00:30:05,400 --> 00:30:06,766
所以这里都没有画

857
00:30:07,066 --> 00:30:08,266
但是在对向模型中间

858
00:30:08,266 --> 00:30:10,899
我们选择了是一对多

859
00:30:11,000 --> 00:30:12,866
但因为我们存的是对象模型

860
00:30:12,866 --> 00:30:13,566
存的是Bo

861
00:30:13,566 --> 00:30:15,066
就没有做PU的存储

862
00:30:15,066 --> 00:30:15,866
存的是Bo

863
00:30:16,200 --> 00:30:16,733
所以说

864
00:30:16,733 --> 00:30:18,933
那就需要把这个关系也要存下来

865
00:30:18,966 --> 00:30:20,733
所以关系有端的做了一个key

866
00:30:21,266 --> 00:30:21,733
这样的话

867
00:30:21,733 --> 00:30:25,099
在这个里头一共做了8个东西啊

868
00:30:25,100 --> 00:30:25,933
草稿没存

869
00:30:26,933 --> 00:30:28,166
然后这个

870
00:30:28,266 --> 00:30:29,333
这个其实是有存的

871
00:30:29,333 --> 00:30:31,066
因为这是他的子类

872
00:30:31,500 --> 00:30:33,133
所以我们存的是Bo对象

873
00:30:33,133 --> 00:30:34,799
当我们存一个coupon act

874
00:30:34,800 --> 00:30:36,666
或者存一个coupon act时候

875
00:30:36,666 --> 00:30:39,166
其实是包含了它从负类基层来的属性

876
00:30:39,166 --> 00:30:40,366
所以这个是有存了的

877
00:30:40,500 --> 00:30:42,266
就是上面那个没存那个

878
00:30:42,266 --> 00:30:43,133
草稿没存那个

879
00:30:43,133 --> 00:30:43,999
因为它没有

880
00:30:44,366 --> 00:30:45,733
没有这个必要

881
00:30:46,200 --> 00:30:48,100
然后3个蓝色的眉唇

882
00:30:50,666 --> 00:30:51,966
为什么 3个蓝色的不纯

883
00:30:57,966 --> 00:30:58,933
对他不是模块

884
00:30:58,933 --> 00:30:59,866
但是他是

885
00:30:59,866 --> 00:31:00,266
在这个

886
00:31:00,266 --> 00:31:02,699
我们这个代码中间是有这三个对象的

887
00:31:03,266 --> 00:31:03,966
相当于是有的

888
00:31:03,966 --> 00:31:05,766
他那是调其他模块的API

889
00:31:05,766 --> 00:31:06,999
得到的这三个对象

890
00:31:07,200 --> 00:31:08,966
这三个对象我们没有在本地

891
00:31:09,066 --> 00:31:10,799
没有在这个模块里去做缓存

892
00:31:11,466 --> 00:31:13,299
为什么我们选择不做缓存

893
00:31:17,466 --> 00:31:18,766
不做缓冲会影响他的效率吗

894
00:31:18,766 --> 00:31:19,566
你们觉得

895
00:31:23,000 --> 00:31:24,766
不做缓冲当然会影响他的效率

896
00:31:25,766 --> 00:31:27,899
我们叫法意义的实验三就是做

897
00:31:27,900 --> 00:31:28,700
这个

898
00:31:29,166 --> 00:31:31,266
就是我们现在没有做缓存的这个情况

899
00:31:31,266 --> 00:31:33,799
下头到底会有多慢

900
00:31:34,466 --> 00:31:36,266
调三个模块去拿到

901
00:31:36,666 --> 00:31:40,166
他的这个shoplotis的template和shop

902
00:31:40,200 --> 00:31:41,500
就是我们会

903
00:31:41,966 --> 00:31:43,466
我们因为有些的对象

904
00:31:43,466 --> 00:31:45,466
是只有每个对象都有shop的

905
00:31:45,600 --> 00:31:47,000
有些对象是有运费模板的

906
00:31:47,000 --> 00:31:49,000
有些对象是运费模板和这个

907
00:31:49,366 --> 00:31:51,133
呃销售都有的

908
00:31:51,566 --> 00:31:53,133
所以你可以调做三次

909
00:31:53,133 --> 00:31:56,099
去看看你逐次增加了这些对象以后

910
00:31:56,466 --> 00:31:57,966
他的效率会有多慢

911
00:31:58,900 --> 00:32:00,133
是会有效率损失的

912
00:32:00,700 --> 00:32:01,733
但是我们没有存

913
00:32:02,566 --> 00:32:03,966
为什么这叫问为什么

914
00:32:03,966 --> 00:32:04,766
为什么不存

915
00:32:06,266 --> 00:32:08,099
因为按照面对象的原则

916
00:32:08,100 --> 00:32:11,133
这个对象的数据是从谁来的

917
00:32:11,133 --> 00:32:12,366
就是由谁负责

918
00:32:12,600 --> 00:32:15,766
所以我们不负责存其他模块的数据

919
00:32:17,133 --> 00:32:19,299
对如果说他要缓存的话

920
00:32:19,300 --> 00:32:21,366
那也是商铺那个模块他去缓存

921
00:32:21,366 --> 00:32:24,166
而不是我们在这里缓存所以

922
00:32:26,066 --> 00:32:26,933
是要那边去存

923
00:32:26,933 --> 00:32:27,799
但不是在这边存

924
00:32:27,800 --> 00:32:29,400
所以我们这边就不会去缓存

925
00:32:29,400 --> 00:32:30,700
来自于其他模块的

926
00:32:32,166 --> 00:32:33,766
他成不成是他的模块事情

927
00:32:34,300 --> 00:32:37,466
对所以我们会用实验去证明

928
00:32:37,466 --> 00:32:41,466
说通过其他的模块去拿到这些对象

929
00:32:41,533 --> 00:32:42,366
会有多慢

930
00:32:43,100 --> 00:32:43,600
会有多慢

931
00:32:43,600 --> 00:32:44,400
大家觉得

932
00:32:45,100 --> 00:32:46,166
所以做做实验3吧

933
00:32:46,166 --> 00:32:47,166
实验2还没做完啊

934
00:32:47,166 --> 00:32:48,166
我们先预告一下

935
00:32:48,166 --> 00:32:50,299
实验3就是这个内容

936
00:32:50,300 --> 00:32:52,500
我们加法一就是一共做三个实验

937
00:32:53,000 --> 00:32:54,933
那其中第三个实验是最麻烦的

938
00:32:54,933 --> 00:32:57,366
前面两个实验我们都是现有代码

939
00:32:58,400 --> 00:33:00,133
第三个实验大家可以看到

940
00:33:00,800 --> 00:33:02,466
我们是要在OMO上做了

941
00:33:02,466 --> 00:33:05,466
不再是用那些玩具代码去做了啊

942
00:33:05,466 --> 00:33:07,199
所以要做10念3

943
00:33:07,200 --> 00:33:09,333
就必须要先赶快去做b座任务

944
00:33:09,666 --> 00:33:10,966
把欧莫能够跑起来

945
00:33:10,966 --> 00:33:12,533
你如果说欧莫都跑不起来

946
00:33:12,533 --> 00:33:13,699
加瓦一的最后一个实念

947
00:33:13,700 --> 00:33:15,500
肯定是做不出来了啊

948
00:33:15,500 --> 00:33:16,266
顺便可以看到

949
00:33:16,266 --> 00:33:18,666
其实我们去年的整个进度比今年快

950
00:33:18,666 --> 00:33:19,866
我们去年的这个实验

951
00:33:19,866 --> 00:33:21,299
就是在OM上做的

952
00:33:21,700 --> 00:33:24,000
所以去年其实从11月份开始

953
00:33:24,000 --> 00:33:26,100
同学们就已经在OM上做实验了

954
00:33:26,166 --> 00:33:27,333
所以去年的实验3

955
00:33:27,333 --> 00:33:29,466
实验4实验5全是在OM上做的

956
00:33:29,600 --> 00:33:30,066
那今年

957
00:33:30,066 --> 00:33:32,066
因为我们的实验平台出了点问题啊

958
00:33:32,066 --> 00:33:34,066
因为学校把原来那个平台给放弃了

959
00:33:34,066 --> 00:33:34,866
切换了一下

960
00:33:35,400 --> 00:33:38,533
造成我们一直到11月才开始来做试验

961
00:33:38,533 --> 00:33:40,199
所以我们就直接砍掉两个试验

962
00:33:40,366 --> 00:33:42,799
所以焦瓦伊的课的难度在降低了啊

963
00:33:42,933 --> 00:33:45,899
所以算是学校帮大家一个忙

964
00:33:46,700 --> 00:33:48,766
我们就只剩下最后一个试验

965
00:33:48,766 --> 00:33:49,566
是在

966
00:33:50,100 --> 00:33:52,866
是在这个OMO的这个代码上去完成

967
00:33:55,366 --> 00:33:58,499
所以我们缓存了8个东西啊

968
00:33:58,500 --> 00:33:59,900
来记住它的这个关系

969
00:34:04,200 --> 00:34:08,666
我们来看一下说这个API是怎么做的

970
00:34:09,100 --> 00:34:10,900
我们这里做了一个什么事情呢

971
00:34:10,900 --> 00:34:14,466
就是大家可以看到不同的API

972
00:34:14,466 --> 00:34:15,366
这个product

973
00:34:15,366 --> 00:34:19,366
是要去访问不同的Excel的对象的

974
00:34:19,533 --> 00:34:22,533
那我们知道正常情况下头

975
00:34:22,533 --> 00:34:24,166
我们看后面这张图啊

976
00:34:25,133 --> 00:34:26,199
正常情况下头

977
00:34:26,200 --> 00:34:27,333
我们这个Pro dot

978
00:34:27,333 --> 00:34:28,966
为什么拿到这个Excel对象

979
00:34:29,200 --> 00:34:30,500
我们之前的做法来说

980
00:34:30,500 --> 00:34:32,700
我们是把Pro dot变成一个满血模型

981
00:34:33,266 --> 00:34:34,999
对吧满血模型怎么变呢

982
00:34:35,000 --> 00:34:37,300
就是把这个Excel到给它放进来

983
00:34:37,300 --> 00:34:38,800
把它变成满血模型

984
00:34:38,933 --> 00:34:39,699
大家可以看到

985
00:34:39,700 --> 00:34:41,266
今天我们已经变得这么远了

986
00:34:42,100 --> 00:34:43,500
就说明我们现在这个设计

987
00:34:43,500 --> 00:34:45,533
是不是把Excel道放进来的

988
00:34:45,533 --> 00:34:47,366
而是放了中间这一堆东西进来

989
00:34:47,700 --> 00:34:49,533
那为什么我们不能把Excel道

990
00:34:49,533 --> 00:34:50,299
直接放进来

991
00:34:50,300 --> 00:34:51,700
把它变成满血模型呢

992
00:34:51,766 --> 00:34:53,899
是因为我们现在这个word Excel啊

993
00:34:53,900 --> 00:34:55,533
一会儿是ID

994
00:34:56,500 --> 00:35:00,200
就是我们用Excel的ID拿到Excel对象一

995
00:35:00,200 --> 00:35:03,200
会是呢我要是Pro dot ID

996
00:35:03,333 --> 00:35:04,499
我要看这个Pro dot

997
00:35:04,500 --> 00:35:06,866
当天有效的Excel对象是什么

998
00:35:07,066 --> 00:35:09,066
所以它是有两种情况的

999
00:35:09,133 --> 00:35:09,966
而这两种情况

1000
00:35:09,966 --> 00:35:10,566
我们认为

1001
00:35:10,566 --> 00:35:14,299
它是整个系统的一个变化点和引进点

1002
00:35:14,600 --> 00:35:15,533
就是当时做的时候

1003
00:35:15,533 --> 00:35:17,466
我们认为这就是变化点和眼镜点

1004
00:35:17,466 --> 00:35:18,866
没想好他会变化什么

1005
00:35:19,000 --> 00:35:21,000
然后做了后半段的时候发现哎

1006
00:35:21,000 --> 00:35:22,300
第三个变化出来了

1007
00:35:22,400 --> 00:35:24,533
所以如果我们在开始判断

1008
00:35:24,533 --> 00:35:25,166
说他是变化点

1009
00:35:25,166 --> 00:35:27,266
眼镜点我们今天做了一堆的东西

1010
00:35:27,266 --> 00:35:31,099
使得这个东西满足系统的开闭原则

1011
00:35:31,300 --> 00:35:33,600
那当我们对于这个product和Excel

1012
00:35:33,600 --> 00:35:36,200
如果需要再变出第三种Excel

1013
00:35:36,200 --> 00:35:37,566
或者第四种Excel的时候

1014
00:35:37,766 --> 00:35:39,333
我们的目标就是值

1015
00:35:39,900 --> 00:35:43,000
改最小的代码就能让他能够支持啊

1016
00:35:43,000 --> 00:35:43,800
所以

1017
00:35:43,800 --> 00:35:46,000
我们把这里做了一个开闭原则的设计

1018
00:35:46,000 --> 00:35:47,933
就是以开闭原则为目标

1019
00:35:48,066 --> 00:35:49,299
来做了一个设计

1020
00:35:49,566 --> 00:35:51,166
那怎么来做这个设计啊

1021
00:35:51,166 --> 00:35:52,799
我们首先知道这个问题是

1022
00:35:52,800 --> 00:35:55,966
这个product是要放Excel到的

1023
00:35:56,300 --> 00:35:56,966
但放进去以后

1024
00:35:56,966 --> 00:35:57,899
他在不同场合下

1025
00:35:57,900 --> 00:35:59,533
他要调Excel到的不同的方法

1026
00:35:59,533 --> 00:36:00,133
我们现在看到

1027
00:36:00,133 --> 00:36:01,599
我们这里写有两个方法啊

1028
00:36:01,866 --> 00:36:03,133
他其实就在两个场合下

1029
00:36:03,133 --> 00:36:04,933
分别调这个方法和调这个方法

1030
00:36:05,200 --> 00:36:06,733
那我们其实按照前面的办法

1031
00:36:06,733 --> 00:36:07,566
就没办法做了

1032
00:36:07,566 --> 00:36:09,366
因为我们前面去get这个wide

1033
00:36:09,366 --> 00:36:10,266
Excel的时候

1034
00:36:10,466 --> 00:36:12,366
就必须确定说是调他还是调他

1035
00:36:13,500 --> 00:36:14,200
那怎么办

1036
00:36:14,200 --> 00:36:14,766
我们可以看到

1037
00:36:14,766 --> 00:36:17,566
这两个方法没有任何的共同性

1038
00:36:17,566 --> 00:36:19,999
这两个方法无论是方法名还是参数

1039
00:36:20,000 --> 00:36:20,933
都完全不一样

1040
00:36:21,700 --> 00:36:24,666
那我们怎么样把两个完全不同的方法

1041
00:36:24,666 --> 00:36:25,966
把它变成相同的

1042
00:36:26,266 --> 00:36:27,999
变成我们符合历史符

1043
00:36:28,000 --> 00:36:29,100
可复可替换原则

1044
00:36:29,100 --> 00:36:34,366
就是调a和调b是分辨不出来的

1045
00:36:34,566 --> 00:36:35,599
我们的做法是

1046
00:36:35,600 --> 00:36:38,000
我们用了命令模式来完成

1047
00:36:38,866 --> 00:36:41,533
这就是命令模式啊

1048
00:36:42,000 --> 00:36:43,266
命令模式的这个做法啊

1049
00:36:43,266 --> 00:36:44,333
我们直接对着我们这个

1050
00:36:44,333 --> 00:36:45,666
最后设计的这个方案讲

1051
00:36:45,666 --> 00:36:47,666
因为我们其实把命令模式

1052
00:36:47,666 --> 00:36:49,099
又做了一点改动

1053
00:36:49,100 --> 00:36:50,333
所以完整的命令模式嘛

1054
00:36:50,333 --> 00:36:51,533
大家下去再去看

1055
00:36:51,666 --> 00:36:53,266
我们去看我们改过的命令模式

1056
00:36:53,266 --> 00:36:54,766
是怎么解决这个问题的啊

1057
00:36:55,600 --> 00:36:57,366
问题就是他要调这两个方法

1058
00:36:57,800 --> 00:36:59,166
怎么怎么调呢

1059
00:36:59,300 --> 00:37:01,066
我们做了两个命令

1060
00:37:01,066 --> 00:37:03,766
一个叫做specific encel excode的命令

1061
00:37:03,766 --> 00:37:05,766
一个是wide it on cell excode的命令

1062
00:37:06,066 --> 00:37:07,299
这两个命令中间呢

1063
00:37:07,300 --> 00:37:09,366
我们可以看到把道放进去了

1064
00:37:10,100 --> 00:37:11,200
所以道士

1065
00:37:11,200 --> 00:37:13,900
这两个命令的这两个对象的属性

1066
00:37:14,566 --> 00:37:16,933
对吧这两个对象里头

1067
00:37:16,933 --> 00:37:18,466
做了一个什么样的方法呢

1068
00:37:18,466 --> 00:37:19,933
这个方法是叫做EXQ的

1069
00:37:19,933 --> 00:37:21,733
这个EXQ是没有参数的

1070
00:37:22,733 --> 00:37:23,666
是无参的

1071
00:37:23,766 --> 00:37:26,966
这两个对象都实现了这个excuse的方法

1072
00:37:27,000 --> 00:37:28,933
这个方法要干的事情就是去调

1073
00:37:29,766 --> 00:37:30,733
如果是这个对象的话

1074
00:37:30,733 --> 00:37:32,133
就去调范德白ID

1075
00:37:32,400 --> 00:37:33,300
如果是这个对象的话

1076
00:37:33,300 --> 00:37:34,366
他应该去调他

1077
00:37:34,366 --> 00:37:36,133
因为这两个值返回是一样的

1078
00:37:36,133 --> 00:37:38,733
是Excel所以把Excel返回回来

1079
00:37:38,933 --> 00:37:42,099
那如果能够把针对这两个对象

1080
00:37:42,100 --> 00:37:43,300
这两个方法的调用

1081
00:37:43,300 --> 00:37:45,500
变成一个无参的这样的一个东西

1082
00:37:45,500 --> 00:37:45,900
然后返回

1083
00:37:45,900 --> 00:37:46,900
这是一样的

1084
00:37:47,000 --> 00:37:50,766
那我就可以把它放到这个里头来

1085
00:37:50,900 --> 00:37:52,500
对吧如果能做到这样

1086
00:37:52,500 --> 00:37:53,500
把它放这里头来

1087
00:37:53,500 --> 00:37:55,000
所以因为这是实现它

1088
00:37:55,000 --> 00:37:55,900
这是个接口啊

1089
00:37:55,900 --> 00:37:57,733
这是实现它的这个接口

1090
00:37:57,966 --> 00:38:00,399
所以我放它进来或者放它进来

1091
00:38:00,800 --> 00:38:02,100
其实就是一样的了

1092
00:38:02,266 --> 00:38:03,366
对吧那怎么

1093
00:38:03,366 --> 00:38:07,766
样能把一个这个带不同参数的调用

1094
00:38:07,766 --> 00:38:09,099
变成一个无参的

1095
00:38:09,466 --> 00:38:10,966
命理模式的做法是这样的

1096
00:38:11,000 --> 00:38:13,133
把这个参数写到它的属性里

1097
00:38:14,166 --> 00:38:14,866
所以大家可以看到

1098
00:38:14,866 --> 00:38:16,899
这个东西的属性叫做Excel ID

1099
00:38:17,700 --> 00:38:19,666
这个东西属性叫做product ID

1100
00:38:19,933 --> 00:38:22,733
所以当我构造这个这个东西的时候

1101
00:38:22,733 --> 00:38:24,599
我把它的Excel ID放到属性里头

1102
00:38:24,600 --> 00:38:25,933
把它要传的参数啊

1103
00:38:26,466 --> 00:38:27,566
就现在是应该是RSID

1104
00:38:27,566 --> 00:38:28,599
但如果参数不统结

1105
00:38:28,600 --> 00:38:29,733
看他要放什么参数

1106
00:38:29,866 --> 00:38:31,299
把它参数写到他的属性里头

1107
00:38:31,566 --> 00:38:33,466
把这个东西的参数写到他属性里头

1108
00:38:33,566 --> 00:38:34,699
然后让他去实现

1109
00:38:34,700 --> 00:38:35,566
EXQ的时候呢

1110
00:38:35,566 --> 00:38:36,566
他调这个方法

1111
00:38:36,566 --> 00:38:38,533
然后这个值是从他的参数里拿的

1112
00:38:38,866 --> 00:38:40,733
这个值呢是从他的参数里拿的

1113
00:38:41,300 --> 00:38:41,666
这样的话

1114
00:38:41,666 --> 00:38:42,199
就可以把

1115
00:38:42,200 --> 00:38:45,600
我们其实针对任何对象的任何方法

1116
00:38:46,000 --> 00:38:47,933
通过这样的一个命令对象

1117
00:38:48,000 --> 00:38:52,133
把它包装成为一个统一的无参的东西

1118
00:38:52,133 --> 00:38:54,566
当然这有一个有一个前提

1119
00:38:54,566 --> 00:38:55,933
返回值必须是一样

1120
00:38:56,766 --> 00:38:58,499
返回值不都不一样的话

1121
00:38:58,500 --> 00:39:00,000
那你就只有另外一个选择了

1122
00:39:00,900 --> 00:39:02,600
如果两个东西的返回值是不一样的话

1123
00:39:02,600 --> 00:39:03,400
你有另外一个选择

1124
00:39:03,400 --> 00:39:04,333
这个选择是什么

1125
00:39:05,133 --> 00:39:06,399
我就不要他返回值了

1126
00:39:06,400 --> 00:39:08,900
他返回值是什么我都不不关心啊

1127
00:39:08,900 --> 00:39:10,466
所以我就不返回他的东西

1128
00:39:10,533 --> 00:39:11,499
那只去执行

1129
00:39:11,500 --> 00:39:12,500
不管他返回值

1130
00:39:12,900 --> 00:39:15,800
那不返回到被调用方就调用方不返

1131
00:39:15,800 --> 00:39:17,300
不关心这两东西的返回值

1132
00:39:17,400 --> 00:39:18,166
那也可以帮助他

1133
00:39:18,166 --> 00:39:18,999
命令模式

1134
00:39:19,000 --> 00:39:19,966
我们现在这个东西

1135
00:39:19,966 --> 00:39:21,966
恰好是他的返回值是一样的

1136
00:39:23,066 --> 00:39:24,199
所以我们就把它的返回值

1137
00:39:24,200 --> 00:39:25,300
也返回回去了

1138
00:39:25,733 --> 00:39:26,566
这样的话呢

1139
00:39:27,000 --> 00:39:30,933
我的这个部分就可以放他来调他

1140
00:39:31,300 --> 00:39:33,100
放他来调他

1141
00:39:33,333 --> 00:39:34,099
就形成这个

1142
00:39:34,100 --> 00:39:35,066
这个就是标

1143
00:39:35,066 --> 00:39:37,266
准的命令模式就这一溜

1144
00:39:38,200 --> 00:39:39,266
标准的命令模式

1145
00:39:39,266 --> 00:39:40,699
所以我放进去的

1146
00:39:40,700 --> 00:39:42,966
是一个什么什么什么EXQ的

1147
00:39:43,200 --> 00:39:45,466
然后我从product中间去调

1148
00:39:45,466 --> 00:39:46,966
这个什么什么EXQ的

1149
00:39:47,333 --> 00:39:51,333
去EXQ的返回的就是这个Valeta Excel

1150
00:39:53,566 --> 00:39:54,733
这个我我再说啊

1151
00:39:54,733 --> 00:39:55,399
这个我再说

1152
00:39:55,400 --> 00:39:58,133
我首先说我们现在已知的这两个API

1153
00:39:58,133 --> 00:39:59,466
就是用的这两个东西

1154
00:39:59,766 --> 00:40:01,299
那我们现在要反过来说

1155
00:40:01,300 --> 00:40:02,933
它为什么能达成这样的一个结果

1156
00:40:03,100 --> 00:40:05,366
为什么能形成我们这样的一个

1157
00:40:05,366 --> 00:40:06,166
这个效果

1158
00:40:06,900 --> 00:40:09,333
从最基本的地方大家可以看到

1159
00:40:09,333 --> 00:40:12,399
它用到了grasp的多肽的方法

1160
00:40:12,733 --> 00:40:17,299
就是它把针对这两个方法的调用

1161
00:40:18,266 --> 00:40:19,799
写成了一个接口

1162
00:40:20,266 --> 00:40:21,699
然后用这两个东西

1163
00:40:21,700 --> 00:40:23,366
去实现了这个相同的接口

1164
00:40:23,366 --> 00:40:26,199
然后把不同的这个方法的调用

1165
00:40:26,200 --> 00:40:28,366
把它变成了一个相同的东西

1166
00:40:28,366 --> 00:40:29,399
所以这是多肽

1167
00:40:29,933 --> 00:40:31,399
第二呢它不是

1168
00:40:31,400 --> 00:40:33,700
本来是应该是Pro Dot直接来钓它的

1169
00:40:33,700 --> 00:40:35,366
但它现在不是直接来钓它

1170
00:40:35,366 --> 00:40:37,333
而是通过了这个东西来钓

1171
00:40:37,333 --> 00:40:40,266
所以它用了grasp的多肽和间接

1172
00:40:40,266 --> 00:40:42,366
这是两个最基本的方法

1173
00:40:43,000 --> 00:40:44,733
用了多肽和间接以后

1174
00:40:44,733 --> 00:40:45,699
大家注意看

1175
00:40:45,700 --> 00:40:47,333
上面这个东西是一个接口

1176
00:40:47,533 --> 00:40:48,999
所以它满足什么

1177
00:40:49,100 --> 00:40:52,466
满足软件设计原则的依赖导致原则

1178
00:40:53,466 --> 00:40:54,933
他调用的是接口

1179
00:40:54,933 --> 00:40:56,866
而不调他具体的时限

1180
00:40:57,300 --> 00:40:59,933
如果他满足依赖导致原则

1181
00:40:59,933 --> 00:41:02,599
就必然满足Disco复刻替换原则

1182
00:41:03,200 --> 00:41:03,566
对吧

1183
00:41:03,566 --> 00:41:05,733
因为接口里头只定义了这个方法

1184
00:41:05,733 --> 00:41:07,733
没有定义任何实质性的内容

1185
00:41:07,866 --> 00:41:09,499
所以底下你不管写啥

1186
00:41:09,500 --> 00:41:11,700
只要满足那个接口的定义

1187
00:41:12,066 --> 00:41:13,766
他就必然是可以替换的

1188
00:41:13,766 --> 00:41:15,599
所以他满足历史口福可替换的

1189
00:41:15,600 --> 00:41:19,400
他必然跟它的这个负累或者接

1190
00:41:19,400 --> 00:41:20,933
口的定义是一致的啊

1191
00:41:20,933 --> 00:41:21,199
所以说

1192
00:41:21,200 --> 00:41:23,300
它必然就满足历史可复可替换原则

1193
00:41:23,600 --> 00:41:25,333
因为满足历史可复可替换原则

1194
00:41:25,333 --> 00:41:26,666
所以它就满足什么

1195
00:41:26,900 --> 00:41:28,300
满足系统的开闭原则

1196
00:41:28,800 --> 00:41:30,066
这个逻辑听清楚了

1197
00:41:30,266 --> 00:41:31,499
首先他用了多肽

1198
00:41:31,600 --> 00:41:32,500
用了间接

1199
00:41:32,700 --> 00:41:33,266
然后

1200
00:41:33,266 --> 00:41:36,899
他满足我们软件设计的依赖导致原则

1201
00:41:37,166 --> 00:41:38,066
满足依赖导致原则

1202
00:41:38,066 --> 00:41:40,166
必然满足Disco复购替换原则

1203
00:41:40,166 --> 00:41:41,199
满足Disco复购原则

1204
00:41:41,200 --> 00:41:42,933
必然满足开辟原则

1205
00:41:42,933 --> 00:41:45,199
这是一一条线过去的啊

1206
00:41:45,866 --> 00:41:47,566
所以有些时候我们不用接口

1207
00:41:47,566 --> 00:41:48,533
那就不会满足依赖

1208
00:41:48,533 --> 00:41:48,999
岛志愿者

1209
00:41:49,000 --> 00:41:50,366
但是在不用接口的情况下

1210
00:41:50,366 --> 00:41:51,799
如果你满足历史可复刻替换原则

1211
00:41:51,800 --> 00:41:53,400
他就满足开闭原则

1212
00:41:53,700 --> 00:41:56,333
对吧如果说你不满足历史可符

1213
00:41:56,333 --> 00:41:58,533
可不不满足历史可符可替换原则

1214
00:41:58,533 --> 00:42:00,799
那就必然不满足这个开闭原则

1215
00:42:01,100 --> 00:42:03,466
所以整个这个设计就是就是这么来的

1216
00:42:04,466 --> 00:42:05,333
做好了以后啊

1217
00:42:05,333 --> 00:42:06,966
我们知道它满足开闭原则了

1218
00:42:06,966 --> 00:42:07,766
是吧

1219
00:42:07,800 --> 00:42:09,666
所以我们开始没想好它开闭是什么

1220
00:42:09,666 --> 00:42:10,966
然后后头做着做着发现哎

1221
00:42:10,966 --> 00:42:13,933
我们有时候需要拿一个product

1222
00:42:14,733 --> 00:42:16,333
不要带对应的Excel

1223
00:42:16,500 --> 00:42:18,666
我们只需要孤立地拿到一个product

1224
00:42:18,666 --> 00:42:19,766
就在很多地方

1225
00:42:20,066 --> 00:42:21,566
我们对一个product去做什么时候

1226
00:42:21,566 --> 00:42:22,566
我们其实都需要知道

1227
00:42:22,566 --> 00:42:23,766
这个product存不存在

1228
00:42:24,100 --> 00:42:26,133
那既然只需要知道它存不存在

1229
00:42:26,133 --> 00:42:27,599
那后面这东西都不需要了

1230
00:42:27,766 --> 00:42:30,199
单纯的只需要拿到一个孤立的product

1231
00:42:30,533 --> 00:42:31,999
我们就报出一个这样的需求

1232
00:42:32,400 --> 00:42:33,333
报出这样的一个需求

1233
00:42:33,333 --> 00:42:34,933
你当然可以在上面去写代码

1234
00:42:34,933 --> 00:42:35,999
在这个上面去写代码

1235
00:42:36,000 --> 00:42:36,933
去改动它

1236
00:42:37,100 --> 00:42:38,000
但是我们现在发现

1237
00:42:38,000 --> 00:42:39,500
我们已经做了这样的一个

1238
00:42:39,500 --> 00:42:41,000
满足开币原则的设计

1239
00:42:41,333 --> 00:42:42,533
那我们就会量就

1240
00:42:42,533 --> 00:42:43,533
利用这个开币原则

1241
00:42:43,533 --> 00:42:44,399
不改限额

1242
00:42:44,400 --> 00:42:46,500
代码只加了一个

1243
00:42:46,500 --> 00:42:49,200
这个东西叫做no EXQ的

1244
00:42:49,200 --> 00:42:50,400
这里头其实是个废话

1245
00:42:50,400 --> 00:42:51,466
这个废话是什么呢

1246
00:42:51,533 --> 00:42:54,133
就是他没有关联任何对象

1247
00:42:54,366 --> 00:42:55,733
你去调他的EXQ的时候

1248
00:42:55,733 --> 00:42:56,966
他返回是个什么呢

1249
00:42:57,266 --> 00:42:58,166
返回是个空

1250
00:42:59,533 --> 00:43:02,366
就是这个里头的这个exclude就是retina

1251
00:43:02,733 --> 00:43:03,733
返回了一个空

1252
00:43:04,100 --> 00:43:05,600
所以当我们把这个exclude

1253
00:43:05,600 --> 00:43:07,300
置入到product的时候它去

1254
00:43:08,600 --> 00:43:09,933
调他的这个excuter的

1255
00:43:09,933 --> 00:43:12,599
excuter返回的这个Valida Excel就是个空

1256
00:43:12,766 --> 00:43:13,166
所以说

1257
00:43:13,166 --> 00:43:16,299
就是得到了一个孤立的Pro大对象

1258
00:43:16,666 --> 00:43:17,199
所以

1259
00:43:17,200 --> 00:43:19,700
正是因为我们前面做了这个开闭原则

1260
00:43:19,700 --> 00:43:21,333
的开闭的这个设计

1261
00:43:21,533 --> 00:43:22,599
所以当我们后来发现

1262
00:43:22,600 --> 00:43:23,700
他有新的需求的时候

1263
00:43:23,700 --> 00:43:25,533
我们只需要增加这些小块代码

1264
00:43:25,900 --> 00:43:27,566
就能够满足这个新的需求了

1265
00:43:27,566 --> 00:43:29,866
所以他对于扩展啊是开放的

1266
00:43:30,000 --> 00:43:31,266
好我们先休息一会

1267
00:53:14,700 --> 00:53:15,500
好

1268
00:53:15,966 --> 00:53:17,666
所以这一段啊

1269
00:53:17,666 --> 00:53:19,266
就这一块来说

1270
00:53:19,266 --> 00:53:20,866
红色标的这一块来说

1271
00:53:20,866 --> 00:53:24,466
就是我们用来用了命令模式

1272
00:53:24,533 --> 00:53:28,499
用了grasp的多态和间接的方法

1273
00:53:29,000 --> 00:53:33,133
然后让它满足依赖导致原则

1274
00:53:33,133 --> 00:53:34,299
Disco和替换原则

1275
00:53:34,300 --> 00:53:37,100
最后开闭原则啊所实现的

1276
00:53:37,333 --> 00:53:42,199
我们的product和on sale在不同的API上面

1277
00:53:42,466 --> 00:53:46,166
它所关联的on sale对象是不一样

1278
00:53:46,966 --> 00:53:48,799
那这里就会存在着一个问题

1279
00:53:48,800 --> 00:53:51,366
这个问题是我们说了

1280
00:53:51,466 --> 00:53:53,799
因为我们放进去的这个EXQ的

1281
00:53:53,800 --> 00:53:54,900
是不同的

1282
00:53:55,066 --> 00:53:57,599
他就会给你不同的Excel对象

1283
00:53:58,266 --> 00:53:59,666
那我们谁来负责

1284
00:53:59,666 --> 00:54:02,466
把这个excuse的对象放进来了

1285
00:54:02,966 --> 00:54:05,799
我们知道在我们前面的惯例中间

1286
00:54:06,000 --> 00:54:07,966
我们会在productor中间

1287
00:54:07,966 --> 00:54:09,499
做一个build的方法

1288
00:54:10,066 --> 00:54:11,333
这个build的方法是把

1289
00:54:11,333 --> 00:54:14,199
我们从数据库里查出来的这个PU对象

1290
00:54:14,866 --> 00:54:16,466
或者说我们在RES中间拿到的

1291
00:54:16,466 --> 00:54:18,733
一个贫血的pro大对象

1292
00:54:18,966 --> 00:54:22,899
把它变成一个满血的Pro对象

1293
00:54:23,066 --> 00:54:26,566
也就是会要把这个EXQ的给它放进去

1294
00:54:26,900 --> 00:54:27,866
那我们刚才说了

1295
00:54:27,866 --> 00:54:28,899
我们已经把这个部分

1296
00:54:28,900 --> 00:54:30,666
做成了一个开闭原则了

1297
00:54:30,933 --> 00:54:32,766
那我们当然希望说

1298
00:54:33,066 --> 00:54:35,733
当我们增加一个新的EXQ的的时候

1299
00:54:35,733 --> 00:54:38,933
我们在这一边Pro大大当中的build方法

1300
00:54:39,333 --> 00:54:40,733
不去做判断

1301
00:54:40,733 --> 00:54:43,199
不去做if them的判断

1302
00:54:43,666 --> 00:54:46,499
所以我们这里所用的方式就是

1303
00:54:46,500 --> 00:54:47,300
在这一段

1304
00:54:49,966 --> 00:54:50,566
大家可以看到

1305
00:54:50,566 --> 00:54:53,133
这边红色标的这一大块

1306
00:54:53,666 --> 00:54:56,866
是我们把原本在Pro dog

1307
00:54:57,400 --> 00:54:59,000
dog中间的build的方法

1308
00:54:59,500 --> 00:55:01,066
给它deal出来

1309
00:55:01,866 --> 00:55:06,466
把它变成了一个独立的抽象类

1310
00:55:07,566 --> 00:55:09,733
为什么被它变成独立的抽象类

1311
00:55:10,066 --> 00:55:10,899
原因是因为

1312
00:55:10,900 --> 00:55:13,600
我们对于底下的不同的EXQ的

1313
00:55:14,166 --> 00:55:16,666
其实他在做build的时候

1314
00:55:16,666 --> 00:55:18,933
他放进去的EXQ是不一样的

1315
00:55:19,666 --> 00:55:21,399
所以大家可以看到

1316
00:55:21,400 --> 00:55:24,600
我们做了三个不同的子类

1317
00:55:25,000 --> 00:55:28,366
分别用来把不同的EXQ的

1318
00:55:29,366 --> 00:55:31,799
给它build到product上面

1319
00:55:31,800 --> 00:55:33,766
就是本来是在product里头写的方法

1320
00:55:33,766 --> 00:55:34,599
我们把它抽出来

1321
00:55:34,600 --> 00:55:36,600
把它做成了不同的纸类

1322
00:55:37,133 --> 00:55:38,199
让它去

1323
00:55:38,966 --> 00:55:44,066
让它去build出来不同的这样的一个呃

1324
00:55:45,300 --> 00:55:46,733
不同的一个EXQ的啊

1325
00:55:46,733 --> 00:55:48,366
给它放到这个里面去

1326
00:55:48,866 --> 00:55:50,866
这一边的这个设计模式啊

1327
00:55:50,866 --> 00:55:51,399
大家可以看到

1328
00:55:51,400 --> 00:55:53,666
我们用了grasp的多态的方式

1329
00:55:53,966 --> 00:55:55,866
其实它也是一个标准的设计模式

1330
00:55:55,866 --> 00:55:57,099
就红色这一部分

1331
00:55:57,100 --> 00:55:58,366
它是一个标准的设计模式

1332
00:55:58,366 --> 00:55:59,766
就我们前面讲过的

1333
00:55:59,966 --> 00:56:02,533
工厂方法的设计模式

1334
00:56:03,166 --> 00:56:04,866
这个上面这个是工厂

1335
00:56:05,066 --> 00:56:07,466
工厂就是标准的工厂方法的设计模式

1336
00:56:07,466 --> 00:56:09,099
啊上面这个这个是工厂

1337
00:56:09,533 --> 00:56:10,599
这个是产品

1338
00:56:11,266 --> 00:56:12,766
工厂有三个工厂

1339
00:56:13,866 --> 00:56:15,499
产品有三个产品

1340
00:56:16,066 --> 00:56:18,599
然后分别是为了说

1341
00:56:18,733 --> 00:56:20,533
我们不是直接为了要这个产品啊

1342
00:56:20,533 --> 00:56:21,266
我们主要的目的

1343
00:56:21,266 --> 00:56:22,999
是要把这个产品build到

1344
00:56:23,700 --> 00:56:24,933
build到这个

1345
00:56:26,366 --> 00:56:29,266
这个评选的product对象中间去啊

1346
00:56:29,266 --> 00:56:30,999
所以我们这里主要是体现

1347
00:56:31,000 --> 00:56:32,533
是两个build的方法

1348
00:56:32,566 --> 00:56:35,699
但其实它用的就是我们的不同的工厂

1349
00:56:35,700 --> 00:56:38,766
去造出来的这个不同的这个产品啊

1350
00:56:38,766 --> 00:56:39,999
所以这是整个的

1351
00:56:40,000 --> 00:56:43,400
这个设计里头用到了两个设计模式

1352
00:56:43,400 --> 00:56:46,766
一个是我们的命令的设计模式

1353
00:56:46,800 --> 00:56:48,933
一个是呃

1354
00:56:48,933 --> 00:56:50,166
工厂方法的设计模式

1355
00:56:50,166 --> 00:56:50,866
工厂方法设计模式

1356
00:56:50,866 --> 00:56:53,066
我们在之前讲支付模块的时候

1357
00:56:53,066 --> 00:56:54,666
他用用它来产生

1358
00:56:54,666 --> 00:56:58,966
我们的阿里pay Adapter和微pay Adapter

1359
00:56:58,966 --> 00:57:00,199
就是用的同样的模式

1360
00:57:00,200 --> 00:57:01,933
所以我们这里不去仔细讲

1361
00:57:03,500 --> 00:57:04,533
那前面这个命令模式

1362
00:57:04,533 --> 00:57:05,899
我们就就不去讲了啊

1363
00:57:05,900 --> 00:57:07,933
命令模式因为放到下学期大家去讲

1364
00:57:07,933 --> 00:57:09,099
我们这里就直接看到了

1365
00:57:09,100 --> 00:57:10,600
这个命令模式是怎么用的

1366
00:57:10,600 --> 00:57:12,200
我们来看一下他这个设计

1367
00:57:12,500 --> 00:57:12,966
这个设计

1368
00:57:12,966 --> 00:57:16,266
我没有完全从service层的代码去画啊

1369
00:57:16,766 --> 00:57:17,966
一些从稻城来画

1370
00:57:17,966 --> 00:57:19,266
一些从社会层来画

1371
00:57:19,600 --> 00:57:19,900
这个

1372
00:57:19,900 --> 00:57:22,800
就是我们顾客去看到商品的那个API

1373
00:57:23,000 --> 00:57:25,000
这个API从Controller层到社会层

1374
00:57:25,000 --> 00:57:26,600
其实都没有什么太多的代码

1375
00:57:26,800 --> 00:57:29,300
那他我们现在这个写法

1376
00:57:29,300 --> 00:57:32,866
是把这段逻辑写在了这个稻城里头

1377
00:57:33,100 --> 00:57:34,133
所以在稻城里头

1378
00:57:34,133 --> 00:57:38,733
我们除了我们写了一个find the wallet by ID

1379
00:57:38,733 --> 00:57:41,366
其实我们的product没有一个find the by

1380
00:57:41,766 --> 00:57:42,499
find the by ID

1381
00:57:42,500 --> 00:57:43,766
的方法就正常

1382
00:57:43,766 --> 00:57:44,566
我们在稻城

1383
00:57:44,566 --> 00:57:46,299
都会有一个find the by ID的方法嘛

1384
00:57:46,466 --> 00:57:47,799
那product这边呢

1385
00:57:47,800 --> 00:57:49,966
因为这个因为这个原因

1386
00:57:50,133 --> 00:57:53,766
它的这个product关联的Excel是不一样的

1387
00:57:53,766 --> 00:57:53,966
所以

1388
00:57:53,966 --> 00:57:56,366
我们就没办法为product写一个find the by ID

1389
00:57:56,366 --> 00:57:58,499
的方法我们给他写了三个方法

1390
00:57:58,800 --> 00:58:00,166
一个是find the body的by ID

1391
00:58:00,166 --> 00:58:01,366
就是找到一个

1392
00:58:01,600 --> 00:58:04,166
包含了有效销售信息的商品

1393
00:58:04,600 --> 00:58:05,400
的东西

1394
00:58:06,166 --> 00:58:08,166
这个找的过程大家可以看到

1395
00:58:08,166 --> 00:58:09,266
我们首先进来

1396
00:58:09,266 --> 00:58:11,499
因为我要找到一个有效的商品信息

1397
00:58:11,500 --> 00:58:12,900
所以我先建了一个工厂

1398
00:58:13,166 --> 00:58:14,399
就建了一个这个

1399
00:58:15,100 --> 00:58:18,166
建了一个vanida Excel的product工厂

1400
00:58:18,666 --> 00:58:19,899
建了这个工厂以后

1401
00:58:19,900 --> 00:58:21,800
我用这个工厂的主要的目的是干嘛呢

1402
00:58:21,800 --> 00:58:23,100
就是用来做build的

1403
00:58:23,733 --> 00:58:24,733
所以我第一来说

1404
00:58:24,733 --> 00:58:26,133
我在RESE里面有没有redes

1405
00:58:26,133 --> 00:58:27,366
有的话从RESE里拿出来

1406
00:58:27,500 --> 00:58:28,200
我们在RESE里面

1407
00:58:28,200 --> 00:58:30,333
全都是一个贫血的Bo模型

1408
00:58:30,333 --> 00:58:31,533
所以里头啥都没有

1409
00:58:32,200 --> 00:58:33,466
拿过来以后就要做build

1410
00:58:33,666 --> 00:58:34,399
所以这个build

1411
00:58:34,400 --> 00:58:36,500
不再是在Pro Dollar Doll中间做的build

1412
00:58:36,933 --> 00:58:40,399
而是依赖于我这个工厂里头的这个东

1413
00:58:40,566 --> 00:58:42,133
这个build去完成的

1414
00:58:42,300 --> 00:58:43,900
所以工厂里头大家可以看到

1415
00:58:43,900 --> 00:58:45,300
我提供了build的方法

1416
00:58:45,300 --> 00:58:46,966
就下面这个build build的方法

1417
00:58:47,533 --> 00:58:49,166
那待会我们就可以看到这个build

1418
00:58:49,166 --> 00:58:50,066
的build build的方法

1419
00:58:50,066 --> 00:58:52,533
其实在子类中间没有去实现

1420
00:58:52,566 --> 00:58:55,199
子类中间只实现了这个get excude的方法

1421
00:58:55,600 --> 00:58:56,900
所以它在里头

1422
00:58:56,900 --> 00:58:58,733
会把所有的道对象设进去

1423
00:58:58,733 --> 00:59:01,133
其中在设这个excude的时候

1424
00:59:01,300 --> 00:59:03,466
会去调子类的excude的方法

1425
00:59:03,466 --> 00:59:05,566
去把它射进去那

1426
00:59:05,566 --> 00:59:06,366
子类的一个设置方法

1427
00:59:06,366 --> 00:59:08,333
就是返回的就是他对应的这个

1428
00:59:08,333 --> 00:59:09,399
对应的这个商品

1429
00:59:09,733 --> 00:59:11,799
就是返回的是他对应的这个商品啊

1430
00:59:11,800 --> 00:59:13,133
是这样的一种逻辑

1431
00:59:14,933 --> 00:59:16,266
所以这是这个

1432
00:59:16,400 --> 00:59:18,366
那如果说在瑞中间没有

1433
00:59:19,166 --> 00:59:20,466
瑞中有就直接返回了啊

1434
00:59:20,466 --> 00:59:21,899
这也是返回了一个满血模型

1435
00:59:21,900 --> 00:59:22,400
如果没有的话

1436
00:59:22,400 --> 00:59:23,733
我们单做了一个方法

1437
00:59:23,866 --> 00:59:25,666
就是从数据库里去找

1438
00:59:25,766 --> 00:59:27,933
然后把ID和对象在数据库里去找

1439
00:59:27,933 --> 00:59:29,899
因为这个部分后面是重用的

1440
00:59:29,900 --> 00:59:31,400
所以我们就单写了一个方法

1441
00:59:31,400 --> 00:59:32,933
不想写多遍

1442
00:59:34,933 --> 00:59:36,466
这个是会重用的

1443
00:59:36,466 --> 00:59:37,766
这个find the bo的方法

1444
00:59:37,766 --> 00:59:39,899
这个就是到map中间去找到对象

1445
00:59:39,900 --> 00:59:41,466
这个是常规的

1446
00:59:41,666 --> 00:59:43,899
所以如果在map中间找到了这个对象

1447
00:59:43,900 --> 00:59:44,933
如果它存在的话

1448
00:59:44,933 --> 00:59:46,766
我们就就用另外一个build的方法

1449
00:59:46,766 --> 00:59:49,466
把PU对象build成为这个bo对象

1450
00:59:49,466 --> 00:59:51,866
那同样这个be的方build方法不是product

1451
00:59:51,866 --> 00:59:55,099
而是我们传建了这个factory的build方法

1452
00:59:55,100 --> 00:59:57,700
去build然后如果说它不存在的话

1453
00:59:57,700 --> 00:59:58,800
就返回一个错误啊

1454
00:59:58,800 --> 00:59:59,866
这是我们通用的

1455
00:59:59,866 --> 01:00:01,099
这个find the build的方法

1456
01:00:01,400 --> 01:00:03,666
那另外两个其实也是类似的

1457
01:00:03,666 --> 01:00:04,266
大家可以看到

1458
01:00:04,266 --> 01:00:06,599
这是历史的RCL对象

1459
01:00:07,000 --> 01:00:07,800
所以历史来说的

1460
01:00:07,800 --> 01:00:09,266
像我们从社会层开始看起的

1461
01:00:09,266 --> 01:00:10,299
社会层进来

1462
01:00:10,400 --> 01:00:11,933
然后到Pro大到中间去做

1463
01:00:11,933 --> 01:00:12,399
我们这个逻辑

1464
01:00:12,400 --> 01:00:14,100
同样写在Pro到到里头了

1465
01:00:14,266 --> 01:00:15,466
所以Pro到中间的

1466
01:00:15,466 --> 01:00:20,299
这个Pro大头中间的find版Excel ID

1467
01:00:20,766 --> 01:00:24,366
它首先去用ID找到Excel对象啊

1468
01:00:24,366 --> 01:00:27,399
去找到Excel对象这一个逻辑啊

1469
01:00:27,400 --> 01:00:31,700
这个逻辑其实写起来是有存疑的

1470
01:00:31,900 --> 01:00:33,466
就是我们严格

1471
01:00:33,466 --> 01:00:34,699
意义上来说

1472
01:00:34,800 --> 01:00:36,266
大家觉得严格意义上来说

1473
01:00:36,266 --> 01:00:38,566
这句话应该写在哪会更好呢

1474
01:00:39,133 --> 01:00:41,166
按照我们分成的题斜过来说

1475
01:00:41,166 --> 01:00:41,966
大家觉得

1476
01:00:44,700 --> 01:00:46,000
如果要改的话啊

1477
01:00:46,166 --> 01:00:48,966
就是我们现在这个逻辑是进来搬的

1478
01:00:48,966 --> 01:00:51,566
把SL ID然后SL ID到这里头

1479
01:00:51,566 --> 01:00:54,199
去找这个Excel的倒对象

1480
01:00:54,200 --> 01:00:55,733
把它变成这个ID

1481
01:00:55,966 --> 01:00:59,866
然后再用这个ID去

1482
01:00:59,933 --> 01:01:01,333
就是找到这个对象存不存在

1483
01:01:01,333 --> 01:01:02,499
然后再用这个工厂

1484
01:01:02,500 --> 01:01:04,366
去造出来他的这个factory

1485
01:01:04,366 --> 01:01:06,199
然后去调那个犯的bo

1486
01:01:06,200 --> 01:01:08,466
然后把它返回回来啊

1487
01:01:08,466 --> 01:01:09,133
去把它去

1488
01:01:09,133 --> 01:01:09,999
把它返回这个对象

1489
01:01:10,000 --> 01:01:10,966
因为这里没有做缓存

1490
01:01:10,966 --> 01:01:12,466
所以不用到RES中间去找

1491
01:01:13,700 --> 01:01:15,666
大家觉得这个设计的问题在哪

1492
01:01:15,733 --> 01:01:17,133
你们觉得设计问题在哪

1493
01:01:17,400 --> 01:01:18,733
这个设计其实是有一步

1494
01:01:18,733 --> 01:01:21,599
一点点违背了这个分层体系结构的

1495
01:01:21,766 --> 01:01:23,933
就是我们知道分层体系结构里头在说

1496
01:01:23,933 --> 01:01:24,366
设备层

1497
01:01:24,366 --> 01:01:26,799
进来以后第一件事情就是把ID变对象

1498
01:01:27,400 --> 01:01:28,533
但是这个设计

1499
01:01:28,533 --> 01:01:29,866
我觉得做的不太好的地方

1500
01:01:29,866 --> 01:01:30,799
就是在于说

1501
01:01:31,500 --> 01:01:33,800
这个ID编对项判断到稻城去做

1502
01:01:35,400 --> 01:01:36,733
其实是应该把这个东西

1503
01:01:36,733 --> 01:01:38,066
移到这上面来做的

1504
01:01:38,533 --> 01:01:40,299
这样做的好处在于什么

1505
01:01:40,300 --> 01:01:41,333
在于好处在于说

1506
01:01:41,333 --> 01:01:43,499
product到就不再依赖于Excel到了

1507
01:01:43,500 --> 01:01:45,333
而是service依赖于Excel到

1508
01:01:45,766 --> 01:01:48,866
所以这样可以避免倒乘之间的倒对向

1509
01:01:48,966 --> 01:01:50,199
双向的依赖

1510
01:01:50,200 --> 01:01:51,866
目前是存在着双向依赖

1511
01:01:52,266 --> 01:01:54,799
所以之后会把这个代码稍微改一下

1512
01:01:54,800 --> 01:01:55,766
啊把它提到

1513
01:01:55,866 --> 01:01:57,166
提到这个前面去

1514
01:01:57,333 --> 01:01:58,766
这个才更加合理一点

1515
01:01:58,766 --> 01:02:00,866
就是我们说的分层体系结构

1516
01:02:01,100 --> 01:02:03,333
所说的这些设计的原则

1517
01:02:03,333 --> 01:02:05,599
是要体现在你的每一行代码里头

1518
01:02:05,600 --> 01:02:07,266
到底这个代码是写在哪

1519
01:02:07,566 --> 01:02:09,699
都要去满足那个分层体系结构的

1520
01:02:09,766 --> 01:02:11,499
所以这个应该把它写到前面去啊

1521
01:02:11,500 --> 01:02:12,600
才更加合理一点

1522
01:02:13,966 --> 01:02:16,199
呃如果low sell的话就很简单

1523
01:02:16,200 --> 01:02:19,733
就是我们在稻城是一个find the by find

1524
01:02:19,733 --> 01:02:21,933
low sell啊by这个id

1525
01:02:22,100 --> 01:02:25,300
然后它就是直接去create了一个

1526
01:02:25,300 --> 01:02:26,366
low sell的工厂

1527
01:02:26,500 --> 01:02:28,500
然后用find the b o去做

1528
01:02:28,733 --> 01:02:30,533
所以find the b o的这部分代码

1529
01:02:30,533 --> 01:02:33,199
在3个API中间是重用的

1530
01:02:33,900 --> 01:02:36,666
就是饭的这个是重用的

1531
01:02:36,666 --> 01:02:37,999
那每一个稻城中间

1532
01:02:38,000 --> 01:02:39,733
其实大家可以看到

1533
01:02:39,800 --> 01:02:41,100
如果不做缓存的话

1534
01:02:41,100 --> 01:02:43,933
差异就是他会建他各自的一个工厂

1535
01:02:44,600 --> 01:02:45,666
建各自的一个工厂

1536
01:02:45,666 --> 01:02:47,799
然后交给范的b o去完成

1537
01:02:47,866 --> 01:02:48,999
而在范的b o中间

1538
01:02:49,000 --> 01:02:50,000
大家可以看到

1539
01:02:50,000 --> 01:02:52,166
因为它满足历史可福可替换原则

1540
01:02:52,166 --> 01:02:53,533
就是那个工厂本身

1541
01:02:53,533 --> 01:02:55,066
是满足历史可福可替换原则的

1542
01:02:55,133 --> 01:02:57,499
所以我们只需去调它的build的方法

1543
01:02:57,500 --> 01:03:00,800
就会让不同的工厂把不同的excuter啊

1544
01:03:00,800 --> 01:03:02,533
设到我们的这个bo对象中间

1545
01:03:02,533 --> 01:03:05,099
让它成为满血的这个对象

1546
01:03:06,800 --> 01:03:08,800
那都设好了以后啊

1547
01:03:08,966 --> 01:03:09,599
如果说

1548
01:03:09,600 --> 01:03:13,866
我们去调这个product的gatewide on sale

1549
01:03:13,933 --> 01:03:14,966
会发生什么

1550
01:03:15,333 --> 01:03:16,933
发生的事情就很单纯了

1551
01:03:16,933 --> 01:03:20,399
就是我们去看这个excuter是不是空的

1552
01:03:20,400 --> 01:03:21,400
如果不是空的

1553
01:03:21,400 --> 01:03:23,400
我们去调它的excuter的方法

1554
01:03:23,533 --> 01:03:24,666
这底下就会看

1555
01:03:24,666 --> 01:03:27,066
我们字进去的excuter是不同的

1556
01:03:27,266 --> 01:03:28,866
它就会有三个不同的结果

1557
01:03:28,866 --> 01:03:30,766
如果字进去的是valid on CR

1558
01:03:30,766 --> 01:03:33,066
excuter返回来的就是他

1559
01:03:33,066 --> 01:03:36,366
就会去调这个Excel到的这个方法

1560
01:03:36,366 --> 01:03:38,199
然后得回我们要的结果

1561
01:03:38,366 --> 01:03:41,099
如果放进去的是这个EX expect

1562
01:03:41,100 --> 01:03:44,266
Excel execute它调的就是find the BYD的方法

1563
01:03:44,266 --> 01:03:45,499
返回我们要的结果

1564
01:03:45,700 --> 01:03:48,866
如果放进去的是note Excel excude

1565
01:03:49,300 --> 01:03:50,900
它就啥都没做

1566
01:03:50,900 --> 01:03:51,733
谁也没调

1567
01:03:51,733 --> 01:03:53,466
就返回了一个空对象

1568
01:03:54,500 --> 01:03:55,866
返回了一个Excel是不存在的

1569
01:03:55,866 --> 01:03:56,599
这个空对象

1570
01:03:56,600 --> 01:03:58,100
然后丢回来

1571
01:03:58,100 --> 01:03:58,766
然后所以

1572
01:03:58,766 --> 01:04:03,166
这样就会使得我们的product的gatewater

1573
01:04:03,200 --> 01:04:06,966
valida Excel得到了三种不同的对象

1574
01:04:07,166 --> 01:04:08,333
所以对于这边来说

1575
01:04:08,333 --> 01:04:11,499
大家可以看到这个意思

1576
01:04:11,500 --> 01:04:12,366
口服可替换原则

1577
01:04:12,366 --> 01:04:14,266
就是完全会起效果

1578
01:04:14,666 --> 01:04:15,966
如果我们增加第四种

1579
01:04:15,966 --> 01:04:17,166
第五种可能性的话

1580
01:04:17,333 --> 01:04:20,466
我们在这个代码上是完全不会动到

1581
01:04:20,866 --> 01:04:21,999
在这个代码

1582
01:04:22,333 --> 01:04:23,199
在这个代码上

1583
01:04:23,200 --> 01:04:25,733
就需要增加一个新的find的方法

1584
01:04:25,733 --> 01:04:27,299
因为你按照一种新的标准

1585
01:04:27,366 --> 01:04:29,066
去find到一个对象

1586
01:04:29,566 --> 01:04:33,366
然后find b o也是这个方法

1587
01:04:33,366 --> 01:04:35,299
也是完全没有去动的啊

1588
01:04:35,300 --> 01:04:36,466
所以我们在整个设计中间

1589
01:04:36,466 --> 01:04:39,599
如果增加了一个新的可能性的话

1590
01:04:39,600 --> 01:04:42,400
这里增加一个新的EXQ的

1591
01:04:42,400 --> 01:04:44,500
这里增加一个新的对象

1592
01:04:44,600 --> 01:04:46,766
然后呢这里需要增加一个新的方法

1593
01:04:46,766 --> 01:04:48,199
就是唯一的缺陷就是

1594
01:04:48,200 --> 01:04:50,366
这里面需要增加一个新的方法啊

1595
01:04:50,366 --> 01:04:52,333
所以会动到这个部分啊

1596
01:04:52,333 --> 01:04:53,333
会动到这个部分

1597
01:04:54,066 --> 01:04:57,199
这就是我们的这个部分的设计

1598
01:04:57,866 --> 01:04:58,533
那我们看一下

1599
01:04:58,533 --> 01:05:00,533
这个部分设计的代码是怎么做的

1600
01:05:23,466 --> 01:05:24,333
我们看的时候呢

1601
01:05:24,333 --> 01:05:26,199
还是从Controller开始看起啊

1602
01:05:26,300 --> 01:05:28,800
我们的两个方法都是不需要登录的

1603
01:05:28,800 --> 01:05:31,966
一个是product ID

1604
01:05:32,366 --> 01:05:34,599
就这个方法啊

1605
01:05:34,600 --> 01:05:38,966
一个是Excel的ID

1606
01:05:39,066 --> 01:05:39,966
是这个方法

1607
01:05:40,000 --> 01:05:42,666
都是在control城市不需要登录的

1608
01:05:43,100 --> 01:05:44,066
所以大家可以看到

1609
01:05:44,066 --> 01:05:44,566
我们在前面

1610
01:05:44,566 --> 01:05:47,099
都没有写要登录的这个判定

1611
01:05:48,000 --> 01:05:48,866
那这里

1612
01:05:48,866 --> 01:05:51,266
头Controller层做的事情就是进来

1613
01:05:51,266 --> 01:05:52,099
因为是ID嘛

1614
01:05:52,100 --> 01:05:53,133
所以就没有转换

1615
01:05:53,133 --> 01:05:54,566
所以去调Server层的方法

1616
01:05:54,733 --> 01:05:56,366
回来以后他做了一件事情

1617
01:05:56,366 --> 01:05:59,599
就是把product变成了我们的DTO对象

1618
01:05:59,666 --> 01:06:00,399
我们可以看到

1619
01:06:00,400 --> 01:06:02,333
我们把它其实写到了这个里头

1620
01:06:03,000 --> 01:06:03,933
顺便给大家看一下

1621
01:06:03,933 --> 01:06:05,699
我们的这个自由基的壁纸任务

1622
01:06:05,700 --> 01:06:07,800
其实是已经有同学做了

1623
01:06:08,266 --> 01:06:09,366
所以这里头已经用到了

1624
01:06:09,366 --> 01:06:11,266
他的自由基的这个任务

1625
01:06:11,266 --> 01:06:11,866
我们可以看下

1626
01:06:11,866 --> 01:06:13,699
他这个自由壁纸任务到底做了什么

1627
01:06:13,866 --> 01:06:14,866
在这里头我们知道

1628
01:06:14,866 --> 01:06:16,999
对于我们要返回的这个product

1629
01:06:17,000 --> 01:06:17,666
里头的数据

1630
01:06:17,666 --> 01:06:18,866
其实是来自于两个部分

1631
01:06:18,866 --> 01:06:20,599
一个是product本身的数据

1632
01:06:20,933 --> 01:06:22,066
一个是它的get valida

1633
01:06:22,066 --> 01:06:24,066
Excel的数据是两个部分的数

1634
01:06:24,066 --> 01:06:26,799
数据会都会合到这个product里头

1635
01:06:26,800 --> 01:06:27,966
我们在这个product里头

1636
01:06:27,966 --> 01:06:32,333
其实就写了两个confecture的copy去完成

1637
01:06:32,566 --> 01:06:33,866
我们之前的话

1638
01:06:33,866 --> 01:06:35,666
这个copy是要有顺序的

1639
01:06:35,666 --> 01:06:37,599
需要不再把它写在前面

1640
01:06:37,733 --> 01:06:39,166
把它写在后面

1641
01:06:39,266 --> 01:06:40,566
写反了就会出错

1642
01:06:40,933 --> 01:06:44,466
所以今年我们的同学就那位同学

1643
01:06:44,466 --> 01:06:46,933
你你的任务你的名字没写啊

1644
01:06:47,800 --> 01:06:48,533
你做的这个任务

1645
01:06:48,533 --> 01:06:49,699
你没有写你是什么名字

1646
01:06:49,700 --> 01:06:50,966
我怎么把分给你啊

1647
01:06:51,533 --> 01:06:54,266
所以你的注释里头要把你的那个名字

1648
01:06:54,266 --> 01:06:54,999
就是陈一鸣同学

1649
01:06:55,000 --> 01:06:56,333
他不都写的他的名字吗

1650
01:06:56,666 --> 01:06:59,299
你就在后面写一个modified by by

1651
01:06:59,300 --> 01:07:00,966
谁把你的名字写进去啊

1652
01:07:01,666 --> 01:07:03,966
然后再重新提交这个M2

1653
01:07:04,866 --> 01:07:06,266
所以他做的这个修改

1654
01:07:06,266 --> 01:07:07,599
其实在这里就会起作用

1655
01:07:08,300 --> 01:07:12,333
因为我们在这个product DTO里头

1656
01:07:17,800 --> 01:07:20,000
我们的SEDA ID的方法

1657
01:07:20,466 --> 01:07:23,166
因为Excel对象和他都有ID

1658
01:07:23,966 --> 01:07:26,933
say的ID的方法前

1659
01:07:26,933 --> 01:07:29,366
面加了一个今年新加的这个注解

1660
01:07:29,400 --> 01:07:30,466
这个注解就是

1661
01:07:30,466 --> 01:07:33,733
把这个ID只拷贝product的

1662
01:07:33,733 --> 01:07:34,799
因为我们上面写了

1663
01:07:34,800 --> 01:07:38,200
它可以从product copy from可以从

1664
01:07:39,666 --> 01:07:42,466
product和Excel两个类里头出来

1665
01:07:42,566 --> 01:07:44,133
其实今天加了两个注解啊

1666
01:07:44,133 --> 01:07:45,166
一个是排除

1667
01:07:45,166 --> 01:07:46,699
一个是只用了一个

1668
01:07:46,733 --> 01:07:48,566
那我现在这里写的是排除

1669
01:07:49,733 --> 01:07:51,266
所以我们的这个get ID

1670
01:07:51,266 --> 01:07:54,166
是把把Excel排除掉了

1671
01:07:54,266 --> 01:07:54,499
所以

1672
01:07:54,500 --> 01:07:57,266
当我去做后面这个Excel的拷贝的时候

1673
01:07:57,266 --> 01:08:00,533
Excel的ID不会拷贝到我的这个TTO里来

1674
01:08:00,533 --> 01:08:00,766
啊

1675
01:08:00,766 --> 01:08:03,999
所以这是今年所做的这个新的改动

1676
01:08:04,266 --> 01:08:06,199
这个copy from的这个注解啊

1677
01:08:06,200 --> 01:08:07,466
我要特别说一下

1678
01:08:07,533 --> 01:08:10,866
这是我们在做这个MVC的架构里头

1679
01:08:10,866 --> 01:08:12,399
非常常用的一种方式

1680
01:08:12,400 --> 01:08:13,533
就只要做MVC的架构

1681
01:08:13,533 --> 01:08:15,866
都存在着一个从p o到b o

1682
01:08:15,866 --> 01:08:17,499
b o到b o啊

1683
01:08:17,500 --> 01:08:19,766
BO到BOBO到PO

1684
01:08:20,133 --> 01:08:22,166
然后PO到BOBO到DTO

1685
01:08:22,166 --> 01:08:24,099
这样的一个拷贝是必然存在的

1686
01:08:24,200 --> 01:08:25,133
所以目前

1687
01:08:25,133 --> 01:08:27,466
如果大家去看市面上的其他的做法

1688
01:08:27,466 --> 01:08:28,599
其实就是两大类

1689
01:08:28,600 --> 01:08:32,100
一大类是用这个反射机制来做的

1690
01:08:32,200 --> 01:08:35,266
一大类是用这个生成代码来做的

1691
01:08:35,866 --> 01:08:37,699
生成代码的这种策略啊

1692
01:08:37,733 --> 01:08:40,399
必然是比反射机制的速度要快很多

1693
01:08:40,400 --> 01:08:41,533
我们大概在两年前

1694
01:08:41,533 --> 01:08:42,766
是用反射机制来做的

1695
01:08:42,766 --> 01:08:43,566
做了对比

1696
01:08:43,600 --> 01:08:47,000
大概速度要慢到4倍到5倍以上

1697
01:08:47,000 --> 01:08:49,166
就是速度会慢非常多

1698
01:08:49,566 --> 01:08:52,699
所以去年我们做了这个copy from

1699
01:08:53,166 --> 01:08:55,166
然后把它变成生成代码来做的

1700
01:08:55,300 --> 01:08:56,566
那可能同学有在问说

1701
01:08:56,566 --> 01:08:57,566
为什么我们没有用

1702
01:08:57,566 --> 01:08:58,199
现在目前

1703
01:08:58,200 --> 01:09:00,800
大家在市面上看到的这种生成的方式

1704
01:09:00,966 --> 01:09:01,966
目前市面上能

1705
01:09:01,966 --> 01:09:04,466
看到的生成的方式叫做map structure

1706
01:09:06,200 --> 01:09:09,000
叫这个东西是有的啊

1707
01:09:09,000 --> 01:09:11,266
并不是说我没想到这是个问题

1708
01:09:11,266 --> 01:09:12,899
别人就就就没想到

1709
01:09:12,900 --> 01:09:13,800
其实是有这个东西的

1710
01:09:13,800 --> 01:09:15,000
叫做map structure

1711
01:09:15,266 --> 01:09:16,333
好像一个c吧

1712
01:09:16,933 --> 01:09:17,733
是这个东西

1713
01:09:18,966 --> 01:09:20,266
如果大家去看一下Mac structure

1714
01:09:20,266 --> 01:09:21,199
它也是生成代码的

1715
01:09:21,200 --> 01:09:23,466
做出来的效果速度是差不多的

1716
01:09:23,766 --> 01:09:25,366
但是我们去年陈一鸣同学做的

1717
01:09:25,366 --> 01:09:26,699
这个copy from的

1718
01:09:26,966 --> 01:09:28,799
使用的简易程度

1719
01:09:29,066 --> 01:09:31,733
是比Mac structure要简易非常多的

1720
01:09:31,733 --> 01:09:33,733
因为如果说用Mac structure的话

1721
01:09:33,733 --> 01:09:36,399
你还要多写好多的代码才能才能完成

1722
01:09:36,400 --> 01:09:39,166
就是它并不是说呃

1723
01:09:39,400 --> 01:09:41,866
不靠不写代码就能完成这个过程

1724
01:09:41,933 --> 01:09:42,799
那我们可以看到

1725
01:09:42,800 --> 01:09:44,166
陈一鸣同学做的这个copy from

1726
01:09:44,166 --> 01:09:45,499
基本上就是加注解

1727
01:09:45,733 --> 01:09:48,933
而尽量避免在里头去写太多的代码

1728
01:09:48,933 --> 01:09:50,333
去完成这样的一个过程

1729
01:09:50,666 --> 01:09:52,599
所以速度是一样的

1730
01:09:52,600 --> 01:09:56,166
但是copy from其实比这个map structure的

1731
01:09:56,400 --> 01:09:58,666
这个用起来的程度啊

1732
01:09:58,666 --> 01:10:00,133
是要更加简易一些

1733
01:10:00,300 --> 01:10:02,000
那今年我们又在上面去增加了一些

1734
01:10:02,000 --> 01:10:03,066
做了些增强

1735
01:10:03,133 --> 01:10:04,099
我们希望啊

1736
01:10:04,100 --> 01:10:07,333
这个东西经过几年的增强

1737
01:10:07,333 --> 01:10:08,499
我慢慢的把它推出去

1738
01:10:08,500 --> 01:10:10,700
变成一个大家普遍用的工具

1739
01:10:10,700 --> 01:10:11,133
就是我们

1740
01:10:11,133 --> 01:10:13,466
并不是仅仅是为了做一个毕业设计

1741
01:10:13,900 --> 01:10:15,866
我们希望我们的这个毕业设计里头

1742
01:10:15,866 --> 01:10:17,099
做的很多的东西

1743
01:10:17,100 --> 01:10:19,866
能在业界被广泛的使用

1744
01:10:20,066 --> 01:10:22,366
能有更多的人来用我们这些东西

1745
01:10:22,500 --> 01:10:24,300
才是做这些事情的意义啊

1746
01:10:24,300 --> 01:10:25,600
就你做代码的话

1747
01:10:25,666 --> 01:10:26,566
除非是图两个

1748
01:10:26,566 --> 01:10:27,499
一个是图名

1749
01:10:27,900 --> 01:10:29,500
一个是图钱是吧

1750
01:10:29,866 --> 01:10:31,533
当你赚不到钱的时候呢

1751
01:10:31,533 --> 01:10:33,199
你就去图名是吧

1752
01:10:33,200 --> 01:10:34,466
当你有了名呢

1753
01:10:34,466 --> 01:10:35,866
你自然就能赚到很多钱

1754
01:10:36,100 --> 01:10:37,166
所以为什么

1755
01:10:37,166 --> 01:10:39,999
我们会投入很多的力量去

1756
01:10:40,000 --> 01:10:40,666
就是会

1757
01:10:40,666 --> 01:10:42,466
会有很多人去投入很多的精力去做

1758
01:10:42,466 --> 01:10:43,366
开元贷嘛

1759
01:10:43,733 --> 01:10:45,733
会愿意把自己的一些东西给他放出去

1760
01:10:45,733 --> 01:10:46,599
给别人去用

1761
01:10:46,866 --> 01:10:48,133
其实主要就是什么呢

1762
01:10:48,133 --> 01:10:49,966
是图名对吧

1763
01:10:50,000 --> 01:10:51,866
所以对于很多的同学们来说

1764
01:10:51,866 --> 01:10:53,933
可能你们现在赚钱无门

1765
01:10:53,933 --> 01:10:55,466
然后又没有名气的时候

1766
01:10:55,900 --> 01:10:58,866
你就先去努力做些开源的东西

1767
01:10:59,133 --> 01:11:00,533
去建立自己的名气

1768
01:11:00,600 --> 01:11:02,100
比如说你在某个开源项目中间

1769
01:11:02,100 --> 01:11:04,733
你说你是一个这个贡献者

1770
01:11:05,400 --> 01:11:06,366
你其实在写简历的时候

1771
01:11:06,366 --> 01:11:08,799
都能都能吹很久啊

1772
01:11:09,666 --> 01:11:11,566
对啊如果说如

1773
01:11:11,566 --> 01:11:13,399
如果说你的帮你都能贡献干嘛

1774
01:11:13,400 --> 01:11:14,800
那确实是挺不容易的

1775
01:11:14,900 --> 01:11:15,533
因为大家知道

1776
01:11:15,533 --> 01:11:16,733
就算我们现在课程设计

1777
01:11:16,733 --> 01:11:18,066
你往里头能写必做任务

1778
01:11:18,200 --> 01:11:19,800
你也要把里头了解的非常清楚

1779
01:11:19,800 --> 01:11:21,733
你才能写啊

1780
01:11:21,733 --> 01:11:24,933
不是说不是说你你想写就能写的

1781
01:11:24,933 --> 01:11:26,699
我们现在的这个机制就是必做任务

1782
01:11:26,700 --> 01:11:27,166
这个机制

1783
01:11:27,166 --> 01:11:28,999
基本上就是沿用了开源代码的

1784
01:11:29,000 --> 01:11:30,733
这样的一个机制

1785
01:11:30,933 --> 01:11:32,966
就是很多人都会提交这个东西

1786
01:11:32,966 --> 01:11:34,166
然后会去做比较

1787
01:11:34,166 --> 01:11:37,566
去选择就会选择谁是作为这个啊

1788
01:11:37,566 --> 01:11:39,966
必做者贡献者啊

1789
01:11:40,933 --> 01:11:43,933
这个就是这个copy from的轻的改动啊

1790
01:11:43,933 --> 01:11:45,166
所以我顺便多说了几句

1791
01:11:45,166 --> 01:11:45,733
所以这样的话

1792
01:11:45,733 --> 01:11:46,899
我们可以很方便的

1793
01:11:46,966 --> 01:11:48,499
不用管它的顺序了

1794
01:11:48,500 --> 01:11:51,366
就可以任意去把它这样去拷贝

1795
01:11:51,766 --> 01:11:52,999
所以能不能成功啊

1796
01:11:53,000 --> 01:11:54,400
就看别的同学来来测了

1797
01:11:54,400 --> 01:11:55,933
所以我现在已经把你的这个东西

1798
01:11:55,933 --> 01:11:56,799
给改进去了

1799
01:11:56,933 --> 01:11:59,166
然后我也会鼓励更多的同学去用

1800
01:11:59,166 --> 01:12:00,766
这个新的这个注解

1801
01:12:00,933 --> 01:12:01,899
那如果有问题的话

1802
01:12:01,900 --> 01:12:02,700
你就要去改

1803
01:12:03,200 --> 01:12:04,400
然后如果不改的话

1804
01:12:04,400 --> 01:12:07,000
五天不改就给你扣0.50.1分啊

1805
01:12:07,000 --> 01:12:08,100
0.5分吧是吧

1806
01:12:08,400 --> 01:12:09,466
就一次次的扣

1807
01:12:09,466 --> 01:12:12,499
下去所以不但要完成这个避重物

1808
01:12:12,566 --> 01:12:12,899
而且

1809
01:12:12,900 --> 01:12:16,000
还要再让大量同学去使用这个东西

1810
01:12:16,000 --> 01:12:18,566
然后有问题的话都要去负责维护的啊

1811
01:12:19,133 --> 01:12:19,933
这个是

1812
01:12:20,766 --> 01:12:23,266
这个部分就是我们

1813
01:12:23,266 --> 01:12:24,333
我们顺便多说了几句

1814
01:12:24,333 --> 01:12:26,333
这个CLOWN factory

1815
01:12:26,333 --> 01:12:26,866
因为我们这里

1816
01:12:26,866 --> 01:12:29,366
其实第一个的b座任务已经合进去了

1817
01:12:29,733 --> 01:12:30,899
所以你要把你的名字补上去

1818
01:12:30,900 --> 01:12:32,100
然后再提一下Mr

1819
01:12:36,366 --> 01:12:38,866
那我们看里头的这个find the product BYD

1820
01:12:39,266 --> 01:12:41,299
这个里头跟我们的图上画的不一样

1821
01:12:41,300 --> 01:12:42,733
我们其实增加了一些内容

1822
01:12:42,733 --> 01:12:43,999
就前面的这部分内容

1823
01:12:44,000 --> 01:12:45,300
和后面的这部分内容

1824
01:12:45,500 --> 01:12:46,666
其实我们在图上就画了

1825
01:12:46,666 --> 01:12:48,266
就是一个图上没画啊

1826
01:12:48,266 --> 01:12:49,066
其实因为什么没画

1827
01:12:49,066 --> 01:12:49,866
因为图上要画的话

1828
01:12:49,866 --> 01:12:50,399
就这么一句

1829
01:12:50,400 --> 01:12:52,200
它去掉倒成的这个代码了

1830
01:12:52,500 --> 01:12:53,800
那前面这部分内容是

1831
01:12:53,800 --> 01:12:55,100
后面这部分内容是什么呢

1832
01:12:55,566 --> 01:12:56,866
就是我们在做代码的时候

1833
01:12:56,866 --> 01:12:58,933
其实最讨厌的一种人是什么呢

1834
01:12:59,266 --> 01:13:02,333
就是那种没事给你找麻烦的黑客

1835
01:13:03,166 --> 01:13:04,166
我们现在这段代码

1836
01:13:04,166 --> 01:13:06,299
就是为了黑客而存在的

1837
01:13:07,366 --> 01:13:09,099
为啥会为了黑客而存在啊

1838
01:13:09,100 --> 01:13:10,266
就是因为我们可以看到

1839
01:13:10,266 --> 01:13:11,999
在前面这个control层里头

1840
01:13:12,366 --> 01:13:15,266
这两个API是不需要登录访问的

1841
01:13:16,066 --> 01:13:17,466
如果说需要登录访问的

1842
01:13:17,466 --> 01:13:17,866
我们知道

1843
01:13:17,866 --> 01:13:20,066
所有电商的登录都是必须实名制的

1844
01:13:20,100 --> 01:13:21,700
就是你必须要用手机号去注册

1845
01:13:21,700 --> 01:13:23,166
手机号就意味着是实名

1846
01:13:23,766 --> 01:13:25,533
那如果说这个API是登陆的

1847
01:13:25,533 --> 01:13:27,599
我们其实可以把它放松警惕一点

1848
01:13:27,600 --> 01:13:29,266
如果一旦有黑客攻击的话

1849
01:13:29,266 --> 01:13:30,533
我们就会知道这是谁

1850
01:13:30,733 --> 01:13:32,766
至少从电话号码能查出来这是谁

1851
01:13:32,966 --> 01:13:35,699
但是现在这个API是没有登陆的

1852
01:13:36,133 --> 01:13:37,766
所以如果有黑客来攻击的

1853
01:13:37,766 --> 01:13:39,133
话我们就只能知道一个什么了

1854
01:13:39,133 --> 01:13:41,199
只能知道一个IP是哪来的

1855
01:13:41,266 --> 01:13:42,799
除此以外没有别的信息

1856
01:13:43,066 --> 01:13:44,666
但大家知道黑客都很厉害

1857
01:13:44,800 --> 01:13:47,733
那个IP其实都是可以是假的

1858
01:13:48,133 --> 01:13:50,466
或者说是劫持别人的僵尸机

1859
01:13:50,466 --> 01:13:51,466
来往你头发

1860
01:13:51,533 --> 01:13:54,266
最常用的方式就是他首先做一个病毒

1861
01:13:54,266 --> 01:13:55,099
侵入某台机器

1862
01:13:55,100 --> 01:13:56,066
然后劫持那台机器

1863
01:13:56,066 --> 01:13:58,366
那台机器来来发起攻击啊

1864
01:13:58,366 --> 01:13:58,966
特别是黑客

1865
01:13:58,966 --> 01:14:00,066
还有黑客网络

1866
01:14:00,300 --> 01:14:01,200
有那个黑网

1867
01:14:01,200 --> 01:14:03,800
他们其实会把劫持的机器大家共享

1868
01:14:04,133 --> 01:14:06,199
来攻击这个攻击那个

1869
01:14:07,266 --> 01:14:09,933
所以呢为了防止黑客来攻击

1870
01:14:09,933 --> 01:14:11,299
我们这里做了一些代码

1871
01:14:11,466 --> 01:14:13,133
那我们会想说黑客来攻击

1872
01:14:13,133 --> 01:14:13,966
攻击什么

1873
01:14:14,333 --> 01:14:15,066
我们为什么会

1874
01:14:15,066 --> 01:14:17,966
这个API会成为黑客攻击的对象

1875
01:14:18,500 --> 01:14:20,400
黑客有些时候很无聊啊

1876
01:14:20,400 --> 01:14:22,400
他就想让你的这个系统单调

1877
01:14:22,900 --> 01:14:24,800
那你觉得你怎么让他系统单调

1878
01:14:26,300 --> 01:14:27,966
我们在嘉宝一中其实讲了

1879
01:14:27,966 --> 01:14:30,099
就是他不断地调这个API

1880
01:14:30,366 --> 01:14:31,799
然后这后面这个ID

1881
01:14:31,800 --> 01:14:34,366
全部写一些不存在的ID

1882
01:14:34,366 --> 01:14:37,333
任意用随机数去不断地发这个ID啊

1883
01:14:37,333 --> 01:14:38,499
我虽然讲这个道理

1884
01:14:38,500 --> 01:14:40,500
但是大家不要用这种方式去攻击啊

1885
01:14:40,966 --> 01:14:43,599
就是作为作为你写业务系统的时候

1886
01:14:43,600 --> 01:14:45,266
你肯定要知道别人怎么攻击

1887
01:14:45,600 --> 01:14:47,400
但是其实我们在上课的时候

1888
01:14:47,400 --> 01:14:48,333
一般是不会

1889
01:14:48,333 --> 01:14:49,766
除了晚安的那个专业

1890
01:14:49,933 --> 01:14:51,499
会去讲怎么去攻击和防御

1891
01:14:51,500 --> 01:14:53,700
其其他课是不太会去讲

1892
01:14:53,700 --> 01:14:54,700
说怎么去攻击的

1893
01:14:54,700 --> 01:14:56,366
因为这个东西是一个双刃剑

1894
01:14:56,666 --> 01:14:57,566
你万一嗨了以后

1895
01:14:57,566 --> 01:14:59,299
你可能会把你自己送进去啊

1896
01:15:00,700 --> 01:15:01,266
这个

1897
01:15:01,266 --> 01:15:03,099
这个就是我们常见的一种攻击方式

1898
01:15:03,100 --> 01:15:05,533
就是他不断的发这个API

1899
01:15:05,533 --> 01:15:08,133
然后API后面的ID给一个无效的

1900
01:15:08,133 --> 01:15:09,733
ID随机值

1901
01:15:10,166 --> 01:15:11,733
那这会产生什么效果

1902
01:15:12,333 --> 01:15:14,266
就是在这个里头

1903
01:15:20,533 --> 01:15:21,499
在这个里头啊

1904
01:15:21,500 --> 01:15:23,333
我们的这个对象模式里头

1905
01:15:27,000 --> 01:15:29,000
如果说用户发过来的请求

1906
01:15:29,000 --> 01:15:31,000
是一个无效的ID的话

1907
01:15:31,166 --> 01:15:32,999
我们一定会去做一件事情

1908
01:15:33,733 --> 01:15:34,166
这件事情

1909
01:15:34,166 --> 01:15:36,499
首先到锐志去查这个ID有没有缓存

1910
01:15:36,766 --> 01:15:39,499
无效ID的话肯定告诉你没有的

1911
01:15:39,966 --> 01:15:41,999
没有的话就会去查Mac口数据库

1912
01:15:42,933 --> 01:15:43,533
然后也没有

1913
01:15:43,533 --> 01:15:44,566
然后告诉你没有

1914
01:15:44,800 --> 01:15:45,700
但是这个过程

1915
01:15:45,700 --> 01:15:47,466
会动到我们整个系统中间

1916
01:15:47,466 --> 01:15:48,866
最脆弱的部分

1917
01:15:49,300 --> 01:15:50,400
MYCO数据库

1918
01:15:50,800 --> 01:15:51,266
大家知道

1919
01:15:51,266 --> 01:15:53,933
MYCO数据库的性能是很容易被阻塞的

1920
01:15:54,200 --> 01:15:56,866
所以他如果在一秒钟发了1万个请求

1921
01:15:56,866 --> 01:15:58,299
都来查无效的ID的话

1922
01:15:58,300 --> 01:16:00,533
瞬间就把你的MYCO数据库给干掉

1923
01:16:01,766 --> 01:16:02,899
然后你的不是崩掉

1924
01:16:02,900 --> 01:16:03,933
你是不是就被阻塞了吧

1925
01:16:03,933 --> 01:16:05,099
你前面做了实验啊

1926
01:16:05,400 --> 01:16:06,700
你你的不要那么多

1927
01:16:06,700 --> 01:16:07,466
他发1万个

1928
01:16:07,466 --> 01:16:09,499
他就整个把你的MYCO服务器给阻塞掉

1929
01:16:09,500 --> 01:16:11,400
然后你整个系统就全死掉了

1930
01:16:11,466 --> 01:16:12,699
因为我们还有很多的业务

1931
01:16:12,700 --> 01:16:13,933
是基于MYCO的

1932
01:16:14,166 --> 01:16:16,366
所以整个系统就就无法访问了

1933
01:16:16,600 --> 01:16:18,666
对吧那怎么防他们这么点

1934
01:16:19,200 --> 01:16:20,000
怎么防

1935
01:16:21,100 --> 01:16:23,066
我们防的方式就是用布隆过滤器

1936
01:16:23,700 --> 01:16:24,600
布隆过滤器的原理

1937
01:16:24,600 --> 01:16:26,000
我们在加瓦一那门课里头

1938
01:16:26,000 --> 01:16:26,966
其实讲的比较

1939
01:16:28,700 --> 01:16:29,800
讲的比较深一点啊

1940
01:16:29,800 --> 01:16:32,066
所以大家可以去看JRE的课里头

1941
01:16:32,100 --> 01:16:33,333
那这里就是直接在使用的

1942
01:16:33,333 --> 01:16:34,399
一个布隆过滤器

1943
01:16:35,266 --> 01:16:35,966
我们首先

1944
01:16:35,966 --> 01:16:39,099
对于这个用户过来的这个查询

1945
01:16:39,100 --> 01:16:40,166
我们首先可以看到

1946
01:16:40,166 --> 01:16:41,899
我们在不容过滤器里去找了一下

1947
01:16:42,500 --> 01:16:43,533
他这个存不存在

1948
01:16:43,966 --> 01:16:46,499
如果不容过滤器里说他存在了

1949
01:16:46,533 --> 01:16:48,333
直接就告诉他说你就不要做后

1950
01:16:48,333 --> 01:16:49,699
面事情了就丢回去

1951
01:16:49,800 --> 01:16:50,400
所以这时候

1952
01:16:50,400 --> 01:16:51,366
我们是用什么东西

1953
01:16:51,366 --> 01:16:53,466
来扛住黑客的攻击呢

1954
01:16:53,733 --> 01:16:55,599
就是用Redus缓存来扛的

1955
01:16:56,100 --> 01:16:58,733
瑞士缓冲的速度会比MASCO快多少

1956
01:16:58,733 --> 01:16:59,533
快很多

1957
01:16:59,900 --> 01:17:01,900
所以说它对于我们整体的性能

1958
01:17:01,900 --> 01:17:04,266
会相对来说打击比较小

1959
01:17:04,366 --> 01:17:05,766
那通常来说

1960
01:17:05,766 --> 01:17:07,799
我们我们这个例子写的比较简单

1961
01:17:07,800 --> 01:17:08,066
我们瑞士

1962
01:17:08,066 --> 01:17:10,766
瑞士说服务器只用了一台

1963
01:17:10,966 --> 01:17:13,066
那通常我们用来扛黑客攻击的

1964
01:17:13,066 --> 01:17:15,799
这台Redis服务器都会单独分开

1965
01:17:15,866 --> 01:17:17,366
跟我们的业务的Redis服务器分开

1966
01:17:17,366 --> 01:17:18,366
就专门有台服务器

1967
01:17:18,366 --> 01:17:20,399
来扛这个黑客攻击的

1968
01:17:20,500 --> 01:17:23,133
所以我们用这台服务器去扛

1969
01:17:23,133 --> 01:17:24,133
去判断说

1970
01:17:24,300 --> 01:17:25,700
用户的这个ID

1971
01:17:26,300 --> 01:17:27,266
是在我们这个数据库里头

1972
01:17:27,266 --> 01:17:28,299
不存在的东西

1973
01:17:28,300 --> 01:17:29,600
然后我们把它返回

1974
01:17:29,900 --> 01:17:31,733
那我们怎么会知道它不存在

1975
01:17:32,066 --> 01:17:34,166
当用户当他第一次过来的时候

1976
01:17:34,166 --> 01:17:35,266
肯定我们是不知道的

1977
01:17:35,266 --> 01:17:37,199
所以这一关他会过去

1978
01:17:37,266 --> 01:17:38,999
然后去查我们的这个东西

1979
01:17:39,000 --> 01:17:40,466
这会动到我们的数据库

1980
01:17:41,100 --> 01:17:42,566
动到以后我们会发现说哎

1981
01:17:42,566 --> 01:17:43,499
这个ID不存在

1982
01:17:43,500 --> 01:17:44,966
所以我们就会把这个ID

1983
01:17:44,966 --> 01:17:47,666
放到我们的这个不容过滤器里去

1984
01:17:48,166 --> 01:17:49,533
放进去不容过滤器以后

1985
01:17:49,533 --> 01:17:53,099
如果这个ID再一次被查到的话

1986
01:17:53,333 --> 01:17:56,899
它就会被不容过滤器挡回去

1987
01:17:57,466 --> 01:18:00,799
所以第一次的攻击是没有办法扛住的

1988
01:18:00,800 --> 01:18:01,366
因为第一次攻击

1989
01:18:01,366 --> 01:18:03,666
你不知道他会用什么样的ID来查

1990
01:18:03,866 --> 01:18:05,866
但是如果他重复使用了

1991
01:18:05,866 --> 01:18:08,399
之前的ID来做攻击的话

1992
01:18:08,533 --> 01:18:09,533
这就能扛住

1993
01:18:12,766 --> 01:18:13,966
如果那个黑客

1994
01:18:14,100 --> 01:18:17,766
不停的用新的ID来做攻击的话

1995
01:18:17,766 --> 01:18:19,899
目前这个方案还没办法

1996
01:18:19,966 --> 01:18:22,933
那只能再在前面的网关

1997
01:18:23,100 --> 01:18:25,733
靠我们的网安部门去发现

1998
01:18:25,733 --> 01:18:28,499
说某一个哎某

1999
01:18:28,500 --> 01:18:31,966
一个某些IP的这个发的频率过高了

2000
01:18:31,966 --> 01:18:35,599
去发现然后去扛住我们现在的业务

2001
01:18:35,600 --> 01:18:38,700
就是我们现在讲的是做业务的部分

2002
01:18:38,933 --> 01:18:40,266
那做业务的部分呢

2003
01:18:40,266 --> 01:18:43,566
你就只能说在我们这里尽力的说

2004
01:18:43,566 --> 01:18:45,533
如果他是重复来的话

2005
01:18:45,766 --> 01:18:47,133
那我们就能把他扛住

2006
01:18:47,133 --> 01:18:48,599
如果他不是重复来的话

2007
01:18:48,600 --> 01:18:50,066
那就要靠网安部门了

2008
01:18:50,066 --> 01:18:52,266
靠网安部门去去去解决他了

2009
01:18:52,700 --> 01:18:54,566
所以这是布隆过滤器啊

2010
01:18:54,566 --> 01:18:56,133
我们在两个APP上都有用了

2011
01:18:56,133 --> 01:18:56,933
布隆过滤器

2012
01:18:57,333 --> 01:18:58,799
就是防止他用重复ID

2013
01:18:58,800 --> 01:19:00,600
来攻击我们的这个系统

2014
01:19:00,933 --> 01:19:02,266
这是我们最讨厌的事情

2015
01:19:02,266 --> 01:19:04,599
好好的写业务其实就挺简单的

2016
01:19:04,600 --> 01:19:06,133
但是因为黑客来攻击

2017
01:19:06,133 --> 01:19:08,066
所以我们真正的生产性软件

2018
01:19:08,066 --> 01:19:11,099
是要写好多这种防止黑客来捣乱的

2019
01:19:11,100 --> 01:19:11,900
这个代码

2020
01:19:12,300 --> 01:19:13,466
而且非常多啊

2021
01:19:13,466 --> 01:19:14,733
我们现在只是做了一个示意

2022
01:19:14,733 --> 01:19:15,566
给大家看一下

2023
01:19:15,566 --> 01:19:17,333
就真的你们去写业务代码的时候不是

2024
01:19:17,333 --> 01:19:20,099
那么这个世界不是这么简单的就是

2025
01:19:23,400 --> 01:19:24,200
什么

2026
01:19:25,300 --> 01:19:27,500
我们也没有开放在工作上给别人用

2027
01:19:27,800 --> 01:19:29,300
我只是给大家做个事例

2028
01:19:29,300 --> 01:19:31,166
说真正写业务代码之后

2029
01:19:31,166 --> 01:19:34,666
其实所有这些没有登陆的API

2030
01:19:34,700 --> 01:19:37,666
都是需要去做防范的啊

2031
01:19:37,666 --> 01:19:38,533
因为这是重点

2032
01:19:38,533 --> 01:19:39,799
会被攻击的对象

2033
01:19:39,933 --> 01:19:41,266
登陆的API会好一点

2034
01:19:41,266 --> 01:19:42,399
就是需要登陆的话

2035
01:19:42,400 --> 01:19:44,533
因为现在国内的登陆都必须实名认证

2036
01:19:44,666 --> 01:19:45,933
必须跟手机号绑到一起

2037
01:19:45,933 --> 01:19:46,933
黑客是没有那么多

2038
01:19:47,200 --> 01:19:48,933
没有那么多手机号的啊

2039
01:19:48,933 --> 01:19:50,533
然后他如果同一个i

2040
01:19:50,966 --> 01:19:52,299
同一个账户名

2041
01:19:52,300 --> 01:19:53,366
太频繁的访问

2042
01:19:53,366 --> 01:19:54,733
晚晚晚安会发现

2043
01:19:55,200 --> 01:19:56,366
就是最不好发现的

2044
01:19:56,366 --> 01:19:58,399
就是黑客用不同的IP

2045
01:19:58,400 --> 01:20:02,266
用攻击那些不需要登录的那些API

2046
01:20:02,366 --> 01:20:03,699
那是网安部门都比

2047
01:20:03,700 --> 01:20:05,600
较都会比较滞后来发现

2048
01:20:05,600 --> 01:20:05,766
所以

2049
01:20:05,766 --> 01:20:07,799
我们这里还是需要去做一些防范的

2050
01:20:09,400 --> 01:20:10,966
我们再继续往里头看啊

2051
01:20:12,333 --> 01:20:13,366
那factory的BYD

2052
01:20:13,366 --> 01:20:15,166
就是我们跟图上画的代码是一样的

2053
01:20:15,166 --> 01:20:17,466
我们创建了一个factory

2054
01:20:17,733 --> 01:20:20,999
用这个factory呢去build它

2055
01:20:21,200 --> 01:20:22,766
所以如果在锐志中间有

2056
01:20:22,933 --> 01:20:23,699
大家可以看到

2057
01:20:23,700 --> 01:20:25,333
我们正常的做完以后

2058
01:20:25,333 --> 01:20:26,999
我们会用这个factory去build它

2059
01:20:27,200 --> 01:20:28,333
如果它没有查数据后

2060
01:20:28,333 --> 01:20:31,533
我们统一写到了factory这个b o里头

2061
01:20:32,133 --> 01:20:33,533
所以放在b o里头

2062
01:20:33,533 --> 01:20:35,333
大家可以看到会去查数据库

2063
01:20:35,766 --> 01:20:38,099
所以数据库里头如果有查到的话

2064
01:20:38,100 --> 01:20:39,766
我们就会用fact群去build它

2065
01:20:39,766 --> 01:20:40,966
然后把它返回啊

2066
01:20:40,966 --> 01:20:41,999
这就是很正常

2067
01:20:42,266 --> 01:20:43,166
所以在这些代码中间

2068
01:20:43,166 --> 01:20:45,199
你都看不到说它到底是哪一种方式

2069
01:20:45,200 --> 01:20:46,166
特别是放在b o里头

2070
01:20:46,166 --> 01:20:47,133
它就是重用的啊

2071
01:20:47,133 --> 01:20:49,166
看不到是用哪种方式

2072
01:20:49,166 --> 01:20:50,766
去获得的这个东西

2073
01:20:51,766 --> 01:20:54,933
然后如果去看Excel的那部分代码的话

2074
01:20:54,933 --> 01:20:56,166
其实是类似的

2075
01:20:56,166 --> 01:20:58,466
我们就会稍微快点给大家看一下

2076
01:20:59,933 --> 01:21:00,999
Excel的这部分代码

2077
01:21:01,000 --> 01:21:01,966
大家可以看到

2078
01:21:03,600 --> 01:21:03,933
同样的

2079
01:21:03,933 --> 01:21:06,099
我们前面用布隆空滤器去扛了一下啊

2080
01:21:06,100 --> 01:21:07,700
因为它也是不需要登录的

2081
01:21:08,066 --> 01:21:10,766
所以这部分的我觉得可以改进的部分

2082
01:21:10,766 --> 01:21:13,266
就是这个ID其实不应该在稻城去查

2083
01:21:13,266 --> 01:21:14,966
这行代码应该放到前面去

2084
01:21:16,566 --> 01:21:17,866
不是放到control

2085
01:21:18,133 --> 01:21:20,699
是应该放到收费市场去

2086
01:21:22,933 --> 01:21:23,866
应该是放到这

2087
01:21:24,200 --> 01:21:24,766
它比较合理

2088
01:21:24,766 --> 01:21:25,899
就是我们原则上来说

2089
01:21:25,900 --> 01:21:26,700
面向对象的设计

2090
01:21:26,700 --> 01:21:31,066
应该是这个插边对象啊

2091
01:21:31,066 --> 01:21:33,299
所以说稻城应该把它置进来

2092
01:21:48,066 --> 01:21:49,933
然后这里要把它设进来

2093
01:21:53,000 --> 01:21:55,066
我们通常稻城社本城就访问稻城

2094
01:21:55,066 --> 01:21:55,466
那就不会

2095
01:21:55,466 --> 01:21:57,699
出现这个循环依赖

2096
01:21:58,900 --> 01:21:59,600
那如果说

2097
01:21:59,600 --> 01:22:02,600
让稻城过于频繁的去访问自己的话

2098
01:22:02,600 --> 01:22:03,533
就会产生频

2099
01:22:03,533 --> 01:22:05,399
就会产生这个循环依赖

2100
01:22:05,400 --> 01:22:06,566
所以原则上来说

2101
01:22:06,566 --> 01:22:07,899
应该是在这边去

2102
01:22:10,533 --> 01:22:11,666
完成这个过程啊

2103
01:22:11,666 --> 01:22:14,099
这个会比较合理一点所以

2104
01:22:17,933 --> 01:22:19,366
885

2105
01:22:24,533 --> 01:22:26,766
对我刚才那个方法翻的Excel

2106
01:22:26,766 --> 01:22:28,666
这个所以在这个方法中间

2107
01:22:28,666 --> 01:22:30,966
我们应该是调自己的Excel到

2108
01:22:34,566 --> 01:22:36,266
去拿到这个对象

2109
01:22:36,266 --> 01:22:38,199
然后把这个东西变成了

2110
01:22:38,200 --> 01:22:39,933
把Excel对象传回去

2111
01:22:40,000 --> 01:22:40,900
传到后面去

2112
01:22:41,133 --> 01:22:45,899
而不是传这个对象

2113
01:22:45,933 --> 01:22:47,766
所以这里把它变成Excel对象

2114
01:22:55,600 --> 01:22:57,700
把这个方法名字也稍微改一下

2115
01:23:01,600 --> 01:23:02,966
把这个ID去掉

2116
01:23:38,700 --> 01:23:40,400
好然后把它改成这样

2117
01:23:40,400 --> 01:23:42,566
应该还有其他地方调用了这个方法

2118
01:23:43,100 --> 01:23:44,366
所以我们看一下

2119
01:23:56,933 --> 01:23:58,899
这就不用传这个

2120
01:24:08,866 --> 01:24:10,333
在我客户在改吧

2121
01:24:10,800 --> 01:24:12,200
这个应该他要传ID

2122
01:24:12,200 --> 01:24:14,066
那是这边的也得要改

2123
01:24:14,333 --> 01:24:15,699
所以这样的逻辑啊

2124
01:24:15,700 --> 01:24:20,100
他相对比较符合我们在这个

2125
01:24:23,700 --> 01:24:26,266
收尾层和稻城的这样的一个分工

2126
01:24:26,266 --> 01:24:27,699
就是在稻城的话

2127
01:24:27,700 --> 01:24:29,600
我们尽量是用对象过去

2128
01:24:29,600 --> 01:24:30,400
然后在收尾层

2129
01:24:30,400 --> 01:24:33,533
去完成这个ID变对象的过程

2130
01:24:33,766 --> 01:24:36,166
所以在这里fund by ID

2131
01:24:36,166 --> 01:24:36,499
可以看到

2132
01:24:36,500 --> 01:24:37,900
它就是构造这个对象

2133
01:24:37,900 --> 01:24:39,666
然后因为它没有涉及到认证缓存

2134
01:24:39,666 --> 01:24:41,199
直接到find去做

2135
01:24:42,400 --> 01:24:45,933
这是我们的这几个代码啊

2136
01:24:50,700 --> 01:24:52,700
那商铺模块的

2137
01:24:52,700 --> 01:24:53,266
呃不

2138
01:24:53,266 --> 01:24:54,266
产品模块的部分来说

2139
01:24:54,266 --> 01:24:55,199
我们今天早上讲到这

2140
01:24:55,200 --> 01:24:56,600
因为快下课了

2141
01:24:57,066 --> 01:24:58,333
哎有什么问题吗

2142
01:25:00,500 --> 01:25:01,300
啊

2143
01:25:02,866 --> 01:25:03,399
大妈走查

2144
01:25:03,400 --> 01:25:04,100
你可以看一下

2145
01:25:04,100 --> 01:25:05,000
我已经走查过

2146
01:25:05,000 --> 01:25:06,800
刚才那位同学的走查了

2147
01:25:10,100 --> 01:25:12,266
啊你说是最后的那个检查是吧

2148
01:25:12,500 --> 01:25:15,400
最后检查就是你把你的设计文档

2149
01:25:15,500 --> 01:25:16,666
把你的代码写完

2150
01:25:16,666 --> 01:25:18,366
把你的假COGO测试全部跑完

2151
01:25:18,366 --> 01:25:20,899
三个报告提交到课程网站上

2152
01:25:21,166 --> 01:25:23,799
提交完了以后再来跟我约面试的时间

2153
01:25:24,100 --> 01:25:25,366
最后两周都可以

2154
01:25:25,800 --> 01:25:27,600
就期末结束之前的两周

2155
01:25:27,600 --> 01:25:29,133
就第一前

2156
01:25:29,133 --> 01:25:30,999
提前一周就早上两过了

2157
01:25:31,000 --> 01:25:33,933
提前一周就是正常的小组早上

2158
01:25:33,933 --> 01:25:34,866
两会加5分

2159
01:25:39,066 --> 01:25:41,733
全世界不是下次讨论课就讲这个吗

2160
01:25:42,500 --> 01:25:43,733
下次讨论课就讲这个吗

2161
01:25:43,733 --> 01:25:45,133
第三轮讨论课就讲这个

2162
01:25:48,133 --> 01:25:50,466
有啊我现在写的都是前一世纪啊

2163
01:25:54,400 --> 01:25:55,100
在这个

2164
01:25:55,100 --> 01:25:57,900
在这个华为云上头看到的那些东西

2165
01:25:57,900 --> 01:25:58,933
就是祥云射击啊

2166
01:25:59,266 --> 01:25:59,733
就是这个

2167
01:25:59,733 --> 01:26:01,766
这个里头看到的我登不进去了啊

2168
01:26:01,933 --> 01:26:03,866
就是你在上面viki上看到那些东西

2169
01:26:03,866 --> 01:26:04,799
就是祥云射击啊

2170
01:26:05,966 --> 01:26:06,566
我现在已经

2171
01:26:06,566 --> 01:26:08,599
已经把4个模块的详细设计

2172
01:26:08,600 --> 01:26:10,366
全部都都更新完了

2173
01:26:10,466 --> 01:26:11,966
但是我没有写文字啊

2174
01:26:11,966 --> 01:26:13,866
就是你如果说要让我能理解的话

2175
01:26:13,866 --> 01:26:15,999
你应该写更多的文字描述

2176
01:26:16,100 --> 01:26:17,500
就是不仅仅是画图

2177
01:26:17,866 --> 01:26:19,266
应该写更多的文字描述

2178
01:26:19,266 --> 01:26:20,066
写在里头

2179
01:26:23,533 --> 01:26:24,966
嗯你看下wiki就知道

2180
01:26:24,966 --> 01:26:26,699
就wiki底下的那个

2181
01:26:26,700 --> 01:26:29,133
每个模块的详细设计的文档我都写了

2182
01:26:30,500 --> 01:26:31,600
来还有问题吗

2183
01:26:35,566 --> 01:26:36,066
好那没问题

2184
01:26:36,066 --> 01:26:37,566
下面我再说一件事情啊

2185
01:26:37,566 --> 01:26:38,733
就是大家会觉得

2186
01:26:38,733 --> 01:26:41,766
今年的这个就业情况好还是不好

2187
01:26:41,766 --> 01:26:42,566
你们觉得

2188
01:26:44,100 --> 01:26:45,133
你们觉得不好是吧

2189
01:26:45,133 --> 01:26:46,733
那你们问过你们的上一届同学

2190
01:26:46,733 --> 01:26:48,466
他们找工作的情况吗

2191
01:26:49,366 --> 01:26:50,366
没办法去问问

2192
01:26:50,800 --> 01:26:51,600
他们的

2193
01:26:52,366 --> 01:26:54,499
最开始的判断跟你们想法是一样的

2194
01:26:54,500 --> 01:26:56,300
就觉得今年的会特别不好

2195
01:26:57,133 --> 01:27:00,899
所以他们很多人都选择去考研和保研

2196
01:27:00,900 --> 01:27:01,600
就不要说了

2197
01:27:01,600 --> 01:27:03,200
保研就肯定不会去找工作了

2198
01:27:03,366 --> 01:27:04,399
有很多同学去考0考研

2199
01:27:04,400 --> 01:27:04,966
我们往年

2200
01:27:04,966 --> 01:27:06,499
其实没有这么多同学去考研的

2201
01:27:06,566 --> 01:27:07,766
就是当经济局势不好的时候

2202
01:27:07,766 --> 01:27:08,799
就很多同学就想说

2203
01:27:08,800 --> 01:27:11,166
那不就就延迟就业去考研

2204
01:27:11,466 --> 01:27:12,266
但是呢考研

2205
01:27:12,266 --> 01:27:14,733
就不可能说前面这个早就业的过程

2206
01:27:14,733 --> 01:27:15,733
早就业的话

2207
01:27:16,533 --> 01:27:18,899
明年一开学就要去动手去做了

2208
01:27:18,900 --> 01:27:20,466
你至少把古文要背吧

2209
01:27:20,600 --> 01:27:22,866
要去关心大厂的这个春招吧

2210
01:27:22,966 --> 01:27:24,266
就是早实习嘛

2211
01:27:24,266 --> 01:27:25,733
这些东西都要都要去走

2212
01:27:25,900 --> 01:27:26,933
但是考研的话

2213
01:27:26,933 --> 01:27:28,266
他们就不会走这个过程

2214
01:27:28,300 --> 01:27:30,366
我们今年大概统计了一下

2215
01:27:30,933 --> 01:27:34,266
就是大概是有30多个人是保研的

2216
01:27:34,466 --> 01:27:36,266
然后还有30多个同学呢

2217
01:27:36,266 --> 01:27:38,299
是或者是准备考研

2218
01:27:38,300 --> 01:27:39,133
马上要考了

2219
01:27:39,300 --> 01:27:40,700
或者是要出国的

2220
01:27:40,800 --> 01:27:42,733
所以整个大概有60多人

2221
01:27:42,733 --> 01:27:45,466
接近70人就完全没有去找工作

2222
01:27:45,466 --> 01:27:46,566
也没有去找实习

2223
01:27:46,966 --> 01:27:48,133
我们一共是多少同学

2224
01:27:48,266 --> 01:27:50,066
一百三十几个同学嘛

2225
01:27:50,300 --> 01:27:50,933
所以说

2226
01:27:50,933 --> 01:27:55,599
还剩下的60多个同学是有去找工作了

2227
01:27:55,700 --> 01:27:56,733
那大家应该知道

2228
01:27:56,733 --> 01:27:58,799
我们其实每届130个同学中间

2229
01:27:59,366 --> 01:28:03,533
大概有10%到15%的同学是完全躺平的

2230
01:28:03,933 --> 01:28:06,766
就有有职业

2231
01:28:06,766 --> 01:28:08,166
不多啊就十来个同学嘛

2232
01:28:08,166 --> 01:28:09,699
这是完全是躺平的

2233
01:28:10,000 --> 01:28:11,966
所以实际上真正在积极找工作的

2234
01:28:11,966 --> 01:28:12,766
你应该这么算

2235
01:28:12,766 --> 01:28:15,466
就是130个同学减去60个同学

2236
01:28:15,466 --> 01:28:16,466
剩下70个同学

2237
01:28:16,766 --> 01:28:18,599
再减去十来个同学

2238
01:28:18,766 --> 01:28:20,799
大概有四十几个同学

2239
01:28:20,800 --> 01:28:22,733
到五十几到五十几个同学吧

2240
01:28:22,733 --> 01:28:27,066
大概50多个同学是在有去找工作的

2241
01:28:27,066 --> 01:28:29,199
当然大家的每个人的可能积极性不同

2242
01:28:29,200 --> 01:28:30,500
做的东西不一样

2243
01:28:30,900 --> 01:28:32,400
那最终的结果是这样的

2244
01:28:32,400 --> 01:28:33,700
就是我们现在这个时间点

2245
01:28:33,700 --> 01:28:34,533
已经知道说

2246
01:28:34,533 --> 01:28:37,499
第一批的这个大厂的offer全部发完了

2247
01:28:37,900 --> 01:28:40,500
我们通常混成大厂中厂小厂啊

2248
01:28:40,700 --> 01:28:43,000
大厂是指头部的那几家公司

2249
01:28:43,000 --> 01:28:43,866
比如智洁

2250
01:28:44,166 --> 01:28:46,299
阿里然后腾讯

2251
01:28:46,500 --> 01:28:49,400
然后还有华为那百

2252
01:28:49,400 --> 01:28:50,533
度现在招的人很少

2253
01:28:50,533 --> 01:28:52,933
就是我们通常来说招人数比较多的

2254
01:28:53,133 --> 01:28:54,266
华为是最多的

2255
01:28:54,466 --> 01:28:56,566
然后是阿里

2256
01:28:56,700 --> 01:28:58,166
腾讯还有智捷

2257
01:28:58,366 --> 01:28:59,699
那还拼多多啊

2258
01:28:59,700 --> 01:29:02,400
我们这五家公司通常称之为头部企业

2259
01:29:02,600 --> 01:29:03,466
然后中场呢

2260
01:29:03,466 --> 01:29:04,699
就是美团啊

2261
01:29:04,866 --> 01:29:07,466
携程啊等等啊这些

2262
01:29:07,466 --> 01:29:08,166
这些公司

2263
01:29:08,166 --> 01:29:09,099
其实大厂

2264
01:29:09,100 --> 01:29:11,766
中厂的工资差距并不是那么大

2265
01:29:12,366 --> 01:29:14,099
那我们现在大厂的这些offer

2266
01:29:14,100 --> 01:29:15,166
现在基本上都发完了

2267
01:29:15,166 --> 01:29:17,466
我们现在大概拿到手上的offer

2268
01:29:17,466 --> 01:29:19,066
大概有接近20个同学

2269
01:29:20,000 --> 01:29:20,933
也就是大家可以算一下

2270
01:29:20,933 --> 01:29:21,499
这个比例

2271
01:29:21,500 --> 01:29:25,666
就是我们去掉了70个同学是去考研的

2272
01:29:25,666 --> 01:29:26,499
或者已经保研的

2273
01:29:26,500 --> 01:29:27,200
他们是不会去找

2274
01:29:27,200 --> 01:29:28,566
他们也没有精力去找工作

2275
01:29:28,566 --> 01:29:29,199
要么不找工作

2276
01:29:29,200 --> 01:29:30,933
要么没有精力去去找实习

2277
01:29:31,600 --> 01:29:34,766
然后剩下的这个六七十个同学中间

2278
01:29:34,766 --> 01:29:36,466
大概有十几个同学是躺平的

2279
01:29:37,066 --> 01:29:39,166
然后呢大概就是四五十个同学

2280
01:29:39,166 --> 01:29:40,499
50多个同学在市场上呢

2281
01:29:40,500 --> 01:29:41,333
会去找工作

2282
01:29:41,333 --> 01:29:43,133
但是大家的积极程度是不一样的

2283
01:29:43,600 --> 01:29:45,666
然后大概有接近20个同学

2284
01:29:45,666 --> 01:29:47,699
是能拿到一线大厂的offer的

2285
01:29:48,200 --> 01:29:50,533
那二线大厂的offer还没有完全出来

2286
01:29:50,700 --> 01:29:53,066
如果说二线大厂的offer

2287
01:29:53,133 --> 01:29:54,499
二二线厂的就是中场的

2288
01:29:54,500 --> 01:29:55,966
这个offer能拿到的话

2289
01:29:56,333 --> 01:29:58,599
估计我们可能有一多半的同学

2290
01:29:58,666 --> 01:30:01,399
是能拿到相对比较好的offer的

2291
01:30:01,400 --> 01:30:01,966
大家应该知道

2292
01:30:01,966 --> 01:30:03,733
一线大厂的offer开出工资多少

2293
01:30:04,533 --> 01:30:05,333
40万

2294
01:30:06,000 --> 01:30:07,366
三十几万到四十几万

2295
01:30:07,366 --> 01:30:09,099
看你的谈的这个结果

2296
01:30:09,466 --> 01:30:11,199
然后我说是年薪

2297
01:30:11,266 --> 01:30:12,899
对就是全包总包

2298
01:30:14,733 --> 01:30:18,966
呃我们有一个同学在阿里拿到了P5 P4

2299
01:30:19,566 --> 01:30:21,866
SP吗正常的

2300
01:30:21,866 --> 01:30:22,966
不是不是SP

2301
01:30:23,566 --> 01:30:25,199
然后如果说是中场的话嘛

2302
01:30:25,200 --> 01:30:27,733
大概在二十几万到三十多万

2303
01:30:27,733 --> 01:30:30,266
之间但差距就这么就这么几万块钱

2304
01:30:30,700 --> 01:30:33,666
所以所以今年的这个局势

2305
01:30:33,666 --> 01:30:34,499
从现在的同学

2306
01:30:34,500 --> 01:30:36,566
拿到大厂offer的这个局势来看

2307
01:30:36,566 --> 01:30:38,699
是比想象的要好很多

2308
01:30:39,266 --> 01:30:40,966
然后他们反过来的情况是什么呢

2309
01:30:40,966 --> 01:30:42,533
是大厂确实在裁员

2310
01:30:42,566 --> 01:30:44,499
大家知道机器大厂都在裁员

2311
01:30:45,200 --> 01:30:47,366
因为他们的收益在减少

2312
01:30:47,533 --> 01:30:50,533
所以他们采取一个办法叫做降本增效

2313
01:30:51,066 --> 01:30:52,766
把高薪的员工裁掉

2314
01:30:52,900 --> 01:30:54,733
然后招低薪的新员工

2315
01:30:55,266 --> 01:30:56,699
所以反正对大家来说

2316
01:30:56,700 --> 01:30:58,400
就今年的同学毕业来说

2317
01:30:58,666 --> 01:31:01,599
大厂没有像往年那样那么难进

2318
01:31:02,266 --> 01:31:04,733
原因在于二一大厂他在裁员

2319
01:31:05,166 --> 01:31:06,933
再有一些成绩比较好的同学

2320
01:31:07,766 --> 01:31:09,099
他们会去考研

2321
01:31:09,766 --> 01:31:11,333
所以说他们反而没有在市场上

2322
01:31:11,333 --> 01:31:11,699
去跟

2323
01:31:11,700 --> 01:31:16,000
这些就是中等以下的这些同学去竞争

2324
01:31:16,066 --> 01:31:16,999
就成绩比较好的同学

2325
01:31:17,000 --> 01:31:19,333
他会想着去考研

2326
01:31:19,333 --> 01:31:20,499
再去再去拖几年

2327
01:31:20,500 --> 01:31:21,966
那可能不考研的同学呢

2328
01:31:21,966 --> 01:31:23,933
要么就是觉得自己肯定是没希望考上

2329
01:31:24,166 --> 01:31:26,199
要么就是觉得对考研没兴趣啊

2330
01:31:26,200 --> 01:31:27,300
不想去读研究生

2331
01:31:27,300 --> 01:31:29,700
就想尽早进到就业市场

2332
01:31:29,866 --> 01:31:31,199
所以对于这部分同学来说

2333
01:31:31,200 --> 01:31:32,600
今年反而是一个机会

2334
01:31:32,900 --> 01:31:35,400
是吧所以呃

2335
01:31:35,400 --> 01:31:36,400
如果说啊

2336
01:31:36,400 --> 01:31:39,466
想本科毕业完了就去就业的同学

2337
01:31:39,800 --> 01:31:41,000
看看明年的局势什么

2338
01:31:41,000 --> 01:31:41,966
因为这个很难说

2339
01:31:42,166 --> 01:31:43,666
如果明年局势大好的话

2340
01:31:43,933 --> 01:31:44,499
可能呢

2341
01:31:44,500 --> 01:31:46,800
那些成绩好的同学就又不想工作了

2342
01:31:47,066 --> 01:31:47,799
又不想读研了

2343
01:31:47,800 --> 01:31:49,700
又去又去找工作

2344
01:31:49,866 --> 01:31:51,866
所以就对大家是个挤压

2345
01:31:51,866 --> 01:31:53,699
就特别对于成绩中等以下的同学

2346
01:31:53,700 --> 01:31:55,933
就是一个就是个挤压啊

2347
01:31:58,066 --> 01:31:58,866
去中场

2348
01:32:02,500 --> 01:32:03,100
没有中场

2349
01:32:03,100 --> 01:32:04,166
同样也有一个问题啊

2350
01:32:04,166 --> 01:32:05,766
就是中场在招人的时候

2351
01:32:05,966 --> 01:32:06,899
他有选择

2352
01:32:06,900 --> 01:32:09,400
说他要么就是低端的员工把他裁掉

2353
01:32:09,400 --> 01:32:11,933
去用新员工替补高端

2354
01:32:11,933 --> 01:32:12,766
的员工呢

2355
01:32:13,500 --> 01:32:15,133
就吸引大厂下来的人

2356
01:32:15,133 --> 01:32:17,399
来增加他的中层和高层啊

2357
01:32:18,366 --> 01:32:19,099
就是这样的

2358
01:32:19,100 --> 01:32:21,600
这个世界不就是这个大鱼吃小鱼

2359
01:32:21,600 --> 01:32:22,533
小鱼吃虾米

2360
01:32:22,533 --> 01:32:23,799
这么一层层的吃下去

2361
01:32:26,866 --> 01:32:28,699
你比如在厦门的这些这些厂子

2362
01:32:28,700 --> 01:32:29,800
就是可能从美团

2363
01:32:29,800 --> 01:32:33,166
或者从这个携程不干的人

2364
01:32:33,166 --> 01:32:34,599
再到厦门回来找工作

2365
01:32:36,466 --> 01:32:37,499
那当然算小厂了

2366
01:32:37,500 --> 01:32:38,666
那都排不上号了

2367
01:32:38,966 --> 01:32:41,399
就是就是你

2368
01:32:41,400 --> 01:32:43,666
你不是以不单纯以薪水来说

2369
01:32:43,666 --> 01:32:44,899
就是有些小厂的薪水

2370
01:32:44,900 --> 01:32:48,300
可能是比这个中厂或者大厂还要高

2371
01:32:48,466 --> 01:32:49,266
但是

2372
01:32:49,700 --> 01:32:51,933
既然大家如果说从职业起步来说

2373
01:32:51,933 --> 01:32:52,533
大家应该知道

2374
01:32:52,533 --> 01:32:53,566
无论从鞋带嘛

2375
01:32:53,866 --> 01:32:55,533
还是去做设计

2376
01:32:55,566 --> 01:32:58,133
你在起步阶段都需要有人带

2377
01:32:58,566 --> 01:32:59,699
都需要有人指点

2378
01:32:59,700 --> 01:33:01,366
你说这个东西应该怎么去做

2379
01:33:01,700 --> 01:33:02,566
那大家应该知道

2380
01:33:02,566 --> 01:33:03,466
在大厂里头

2381
01:33:03,466 --> 01:33:06,766
他整个的这个水平比较高一些

2382
01:33:06,766 --> 01:33:08,299
比你的mental的水平比较高一些

2383
01:33:08,300 --> 01:33:10,066
整个做事布局要规范一些

2384
01:33:10,400 --> 01:33:12,066
所以说你在成长阶段

2385
01:33:12,166 --> 01:33:13,766
如果有机会能进大厂

2386
01:33:14,066 --> 01:33:15,199
当然应该进大厂

2387
01:33:15,866 --> 01:33:17,199
你会成长的比较快

2388
01:33:17,600 --> 01:33:19,666
计算是你将来年纪大了

2389
01:33:19,666 --> 01:33:20,799
跟不上这个大厂节奏

2390
01:33:20,800 --> 01:33:22,400
比如像拼多多我们

2391
01:33:22,400 --> 01:33:24,366
我们今年去实习的那个同学

2392
01:33:24,366 --> 01:33:25,199
拼多多说

2393
01:33:25,500 --> 01:33:25,800
拼多多

2394
01:33:25,800 --> 01:33:27,933
就没有人在晚上12点钟之前下班了

2395
01:33:28,700 --> 01:33:30,700
就没有人在晚上12点钟之前下班了

2396
01:33:31,000 --> 01:33:32,766
所有人都干到12点钟以后

2397
01:33:33,866 --> 01:33:35,733
没有你那么高工资

2398
01:33:35,733 --> 01:33:37,533
你回去打个车是问题吗

2399
01:33:38,366 --> 01:33:39,733
何况还有很多人还有车

2400
01:33:39,933 --> 01:33:41,166
但他上午不用上班

2401
01:33:42,366 --> 01:33:44,566
对因为干到晚上两三点钟

2402
01:33:44,566 --> 01:33:45,899
谁会上午还9点钟才去上班

2403
01:33:45,900 --> 01:33:47,166
不可能的对吧

2404
01:33:47,166 --> 01:33:50,099
所以他的他的规定是你超过晚上12点

2405
01:33:50,133 --> 01:33:51,066
上午就不用来上班

2406
01:33:51,066 --> 01:33:52,866
可以12点钟以后再来上上班

2407
01:33:53,600 --> 01:33:55,400
但是基本上你超过了12点

2408
01:33:55,400 --> 01:33:58,066
以后大家都会干到两三点钟再回家

2409
01:33:58,533 --> 01:33:59,666
然后去睡觉

2410
01:34:00,000 --> 01:34:01,700
是这个压力会比较大

2411
01:34:01,700 --> 01:34:03,166
但是他的薪酬

2412
01:34:03,166 --> 01:34:05,566
会让你觉得在年轻的时候

2413
01:34:05,566 --> 01:34:06,966
有体力的时候值得付出

2414
01:34:06,966 --> 01:34:08,666
这个薪酬是你正常

2415
01:34:08,666 --> 01:34:11,499
比如说你在在一个普通工作

2416
01:34:11,500 --> 01:34:14,066
大概十几万二十几万的两倍到三倍

2417
01:34:14,366 --> 01:34:16,399
然后你想人生30年是吧

2418
01:34:16,400 --> 01:34:17,600
你工作30年嘛

2419
01:34:18,133 --> 01:34:20,066
你10年把30年钱都挣完

2420
01:34:20,400 --> 01:34:21,500
剩下20年呢

2421
01:34:21,766 --> 01:34:22,866
就少挣点钱呗

2422
01:34:22,866 --> 01:34:23,666
是吧

2423
01:34:24,300 --> 01:34:26,866
而且不不单纯说钱的问题了

2424
01:34:26,866 --> 01:34:29,133
但是你的成长的速度会比较快

2425
01:34:29,333 --> 01:34:31,733
所以万一哪一天被大厂淘汰了

2426
01:34:31,733 --> 01:34:32,499
这个是必然的

2427
01:34:32,500 --> 01:34:33,966
因为大部分人都是这个样子

2428
01:34:34,000 --> 01:34:35,100
你应该清醒的认识到

2429
01:34:35,100 --> 01:34:38,200
说你同一批进入这个公司的人

2430
01:34:38,200 --> 01:34:39,166
几百个人中间

2431
01:34:39,166 --> 01:34:42,166
最后可能10年20年以后剩下10%

2432
01:34:42,200 --> 01:34:43,400
很正常啊

2433
01:34:43,400 --> 01:34:45,600
因为他毕竟是毕竟是

2434
01:34:45,600 --> 01:34:47,600
这么高的强度的压力

2435
01:34:48,000 --> 01:34:49,666
不是很多人都能承受的

2436
01:34:50,000 --> 01:34:52,133
所以即算是你以后不在那里干了

2437
01:34:52,133 --> 01:34:53,333
第一挣到钱了

2438
01:34:53,700 --> 01:34:57,700
第二你也可以去一个中场或者下

2439
01:34:57,700 --> 01:35:00,900
或者更就是压力更小的单位去干

2440
01:35:01,100 --> 01:35:01,900
对吧

2441
01:35:03,733 --> 01:35:05,899
所以如果说啊

2442
01:35:05,900 --> 01:35:07,766
如果没有读研究会的同学

2443
01:35:08,066 --> 01:35:09,699
就是从今年局势看

2444
01:35:09,700 --> 01:35:11,500
真的是明年要好好的准备

2445
01:35:11,500 --> 01:35:12,566
千万不要躺平

2446
01:35:12,966 --> 01:35:13,666
躺平的话

2447
01:35:13,666 --> 01:35:16,799
你真的是浪费了你这个985的文凭

2448
01:35:17,600 --> 01:35:18,100
你知道吗

2449
01:35:18,100 --> 01:35:20,733
因为对于那些211的

2450
01:35:20,733 --> 01:35:22,533
甚至那些双飞的同学来说

2451
01:35:22,533 --> 01:35:24,333
能进到他的面试

2452
01:35:24,333 --> 01:35:25,366
能进到他的笔试

2453
01:35:25,366 --> 01:35:26,933
都是可遇不可求的

2454
01:35:27,300 --> 01:35:28,500
你拿那个985的文凭

2455
01:35:28,500 --> 01:35:30,700
不管你成绩再再差

2456
01:35:31,066 --> 01:35:33,499
你发一个申请过去

2457
01:35:33,500 --> 01:35:35,666
他都会让你做笔试对吧

2458
01:35:35,666 --> 01:35:37,166
那笔试做的好不好

2459
01:35:37,266 --> 01:35:38,933
面试是不是能杀过去

2460
01:35:39,133 --> 01:35:40,199
这就看你自己

2461
01:35:41,000 --> 01:35:42,166
这就看你自己了

2462
01:35:42,200 --> 01:35:43,733
但是你至少来说你

2463
01:35:43,733 --> 01:35:45,266
知道你这个酒吧舞的文凭

2464
01:35:45,566 --> 01:35:47,699
在毕业的这一刻是有用的

2465
01:35:48,000 --> 01:35:50,166
就是你高考付出的这个努力

2466
01:35:50,366 --> 01:35:51,499
相当于那些高考

2467
01:35:51,500 --> 01:35:53,533
比你考的更低的那些同学来说

2468
01:35:53,533 --> 01:35:55,099
在这一刻是有用的

2469
01:35:55,566 --> 01:35:56,899
但是之后啊

2470
01:35:56,900 --> 01:35:58,966
之后你随着你的毕业时间越长

2471
01:35:59,600 --> 01:36:02,766
你这个就越慢慢的就越越不保值了

2472
01:36:02,766 --> 01:36:04,666
是吧那要看你自己的个人能力了啊

2473
01:36:04,666 --> 01:36:06,533
不能完全看你这个文凭了

2474
01:36:06,600 --> 01:36:08,100
但这个时候能用到它的时候

2475
01:36:08,100 --> 01:36:09,466
干嘛不干嘛

2476
01:36:09,466 --> 01:36:10,566
不努力去用一下

2477
01:36:10,566 --> 01:36:13,199
对吧要不要不白瞎了那个高中三年

2478
01:36:13,200 --> 01:36:15,266
那么玩命的去去高考

2479
01:36:15,666 --> 01:36:17,299
对吧好

2480
01:36:19,533 --> 01:36:21,366
国企你就想躺平养老的呗

2481
01:36:24,066 --> 01:36:25,266
国企也好进啊

2482
01:36:25,266 --> 01:36:25,966
也不是什么不好进

2483
01:36:25,966 --> 01:36:28,299
你比如说厦门的这些国企就挺好进的

2484
01:36:29,366 --> 01:36:31,299
项羽啊建发啊

2485
01:36:32,800 --> 01:36:34,366
对啊这都是国企啊

2486
01:36:35,400 --> 01:36:36,866
对项项羽其实

2487
01:36:38,400 --> 01:36:39,366
项羽就很对口啊

2488
01:36:39,366 --> 01:36:40,966
项羽做港口的呀

2489
01:36:41,166 --> 01:36:42,933
他港口全是靠计算机管的

2490
01:36:42,933 --> 01:36:43,666
他都自己开发

2491
01:36:43,666 --> 01:36:44,866
他不用外头人开发

2492
01:36:44,933 --> 01:36:46,933
项羽好大的一个it部门

2493
01:36:49,966 --> 01:36:51,066
对建发也是啊

2494
01:36:51,066 --> 01:36:52,933
建发我我现在刚签了一个合同

2495
01:36:52,933 --> 01:36:53,866
就是跟建发做的

2496
01:36:53,866 --> 01:36:55,799
建发所有的物业系统全自己做的

2497
01:37:02,533 --> 01:37:04,199
电网也也也也也会啊

2498
01:37:04,200 --> 01:37:05,900
电网的话你如果不做开发的话

2499
01:37:05,900 --> 01:37:06,766
你就做维护啊

2500
01:37:06,766 --> 01:37:07,466
还有银行

2501
01:37:07,466 --> 01:37:10,099
银行现在银行是现在所有的银行

2502
01:37:10,100 --> 01:37:11,900
是分为了几大开发中心

2503
01:37:11,900 --> 01:37:12,666
比如说建行

2504
01:37:12,666 --> 01:37:14,599
它是有开发中心的

2505
01:37:14,866 --> 01:37:16,599
厦门是有一个开发中心

2506
01:37:21,366 --> 01:37:22,999
对国企就是去养老

2507
01:37:23,000 --> 01:37:25,800
但是你想像建行开发中心的话

2508
01:37:25,800 --> 01:37:27,600
大概也就是20多万的年薪

2509
01:37:32,466 --> 01:37:34,366
对啊他但是你去进

2510
01:37:34,366 --> 01:37:34,733
比如说你

2511
01:37:34,733 --> 01:37:35,933
同样的这个水平啊

2512
01:37:35,933 --> 01:37:39,133
你到进厦门的建行开发中心的难度

2513
01:37:39,900 --> 01:37:42,333
比进比如说厦门的比较好的公司

2514
01:37:42,333 --> 01:37:44,333
比如像瑞幸要难多

2515
01:37:44,333 --> 01:37:45,266
了瑞幸

2516
01:37:45,266 --> 01:37:46,199
是那个瑞幸吗

2517
01:37:46,200 --> 01:37:47,166
对瑞幸咖啡啊

2518
01:37:47,400 --> 01:37:48,933
瑞幸咖啡的开发部在厦门

2519
01:37:49,566 --> 01:37:51,166
就是全国瑞幸的系统

2520
01:37:51,166 --> 01:37:52,366
都是在厦门开发的

2521
01:37:52,400 --> 01:37:53,300
所以在厦门来说

2522
01:37:53,300 --> 01:37:54,100
瑞幸开发

2523
01:37:54,100 --> 01:37:56,900
瑞幸的开发部算是一个工资比较高

2524
01:37:56,900 --> 01:37:58,333
然后招人比较多的地方

2525
01:37:59,300 --> 01:38:01,200
我当然只以厦门来论了

2526
01:38:01,900 --> 01:38:02,700
嗯

