1
00:00:02,800 --> 00:00:05,200
我们从这个策略开始看起

2
00:00:06,966 --> 00:00:09,266
Devite的Devite strategy啊

3
00:00:09,266 --> 00:00:11,099
从这个中间这个地方开始看起

4
00:00:11,900 --> 00:00:14,066
这就是他的Devite的方法

5
00:00:14,200 --> 00:00:15,266
那Devite的方法

6
00:00:15,266 --> 00:00:17,933
基本上跟我们在图上画的是一致的

7
00:00:17,933 --> 00:00:19,566
我们刚才在图上没有看到这个

8
00:00:19,566 --> 00:00:21,166
就是这个就是

9
00:00:21,166 --> 00:00:22,533
我们可以看从图上看到

10
00:00:22,533 --> 00:00:23,999
它已经违背了de米特原则

11
00:00:24,000 --> 00:00:26,133
对吧它本来应该直接调tablet方法

12
00:00:26,133 --> 00:00:27,733
现在是Tablet got type的方法

13
00:00:27,733 --> 00:00:29,166
再去Ctrl t total

14
00:00:29,600 --> 00:00:31,900
这个是开口的

15
00:00:31,900 --> 00:00:33,966
total是陌生人啊

16
00:00:33,966 --> 00:00:35,399
所以说他是不能这么调的

17
00:00:35,400 --> 00:00:37,333
如果按照迪比特原则是不能这么调的

18
00:00:37,333 --> 00:00:38,499
这么调的后果是什么

19
00:00:38,500 --> 00:00:39,300
你应该知道

20
00:00:39,400 --> 00:00:40,400
这么调的后果是

21
00:00:40,400 --> 00:00:42,000
如果这个方法发生改变了

22
00:00:42,066 --> 00:00:44,599
他就会影响到我们的这个divide straight

23
00:00:44,600 --> 00:00:45,333
这个方法

24
00:00:45,333 --> 00:00:47,266
虽然它并没有直接跟它有关联

25
00:00:47,400 --> 00:00:48,300
但是它会

26
00:00:49,300 --> 00:00:51,266
就是它影响面会变得更更大

27
00:00:51,666 --> 00:00:54,099
那它怎么我们在内图上看到type的

28
00:00:54,100 --> 00:00:55,300
这是reading type的

29
00:00:55,366 --> 00:00:56,666
不是那个模板

30
00:00:56,766 --> 00:00:57,733
是这个类型

31
00:00:58,066 --> 00:00:59,899
我们在内图上你看得到reading type

32
00:00:59,900 --> 00:01:02,366
并没有并没有type这个东西

33
00:01:02,466 --> 00:01:04,299
那它的god type是怎么做的

34
00:01:04,300 --> 00:01:06,700
什么呢我们也点进去看一下

35
00:01:07,600 --> 00:01:10,266
我们可以看到在reading template中的got tap

36
00:01:11,100 --> 00:01:12,866
确实它是没有tap类型

37
00:01:13,100 --> 00:01:14,200
但是它有template

38
00:01:14,600 --> 00:01:16,800
所以它是调的got template的got tap

39
00:01:17,533 --> 00:01:18,966
对吧这为什么

40
00:01:18,966 --> 00:01:19,966
我们做一个这样的方法

41
00:01:19,966 --> 00:01:22,566
就是我们不想把陌生人变得更陌生人

42
00:01:22,766 --> 00:01:24,966
其实如果说不写这个方法也可以

43
00:01:24,966 --> 00:01:26,766
我们这里就要写成什么呢

44
00:01:29,266 --> 00:01:30,066
这里要写成什么呢

45
00:01:30,066 --> 00:01:31,566
这里就要写成template的

46
00:01:31,766 --> 00:01:32,566
template的

47
00:01:32,566 --> 00:01:33,533
god type的

48
00:01:33,866 --> 00:01:36,199
copilot total要求休息越长是吧

49
00:01:36,533 --> 00:01:39,666
所以我们为了把它不变成陌生人

50
00:01:39,666 --> 00:01:41,333
我们这里的做法就是

51
00:01:41,733 --> 00:01:43,466
我们把它的这个type翻过来了

52
00:01:43,466 --> 00:01:44,533
其实你要想办

53
00:01:44,566 --> 00:01:48,199
把这个代码改成符合低米特原则

54
00:01:48,200 --> 00:01:49,333
大家觉得怎么改法

55
00:01:51,300 --> 00:01:52,766
啊你们觉得怎么改法

56
00:01:54,166 --> 00:01:56,666
就是在这个方法中间

57
00:01:57,266 --> 00:01:58,799
在reading tempered里头

58
00:02:03,366 --> 00:02:05,366
不是做他的god type的方法

59
00:02:05,366 --> 00:02:07,533
是做一个copy的total的方法

60
00:02:08,266 --> 00:02:10,133
然后让它的total的方法

61
00:02:10,133 --> 00:02:13,099
去调它的GOP type的copy的方法

62
00:02:13,300 --> 00:02:16,300
然后对于我们的divide strategy来说啊

63
00:02:16,966 --> 00:02:18,533
对于我们的这个Dyster来说

64
00:02:18,533 --> 00:02:20,666
它就不是叫做跟陌生人说话

65
00:02:20,800 --> 00:02:23,700
它是通过了template的这个方法

66
00:02:23,800 --> 00:02:26,333
去掉它的template高type方法

67
00:02:26,333 --> 00:02:27,466
把这个写到另一端去

68
00:02:27,466 --> 00:02:29,199
就不是跟陌生人说话

69
00:02:29,533 --> 00:02:30,599
所以你如果要改一下的话

70
00:02:30,600 --> 00:02:31,600
可以可以这么改

71
00:02:31,766 --> 00:02:33,366
那我之所以没有去这么改的话

72
00:02:33,366 --> 00:02:36,566
是因为我认为最后这个type of total

73
00:02:36,566 --> 00:02:37,099
这个方法

74
00:02:37,100 --> 00:02:38,266
是不会发生改变的

75
00:02:38,700 --> 00:02:39,866
为什么不会发生改变

76
00:02:39,866 --> 00:02:41,066
大家可以看一下啊

77
00:02:41,500 --> 00:02:42,466
他是怎么做的呢

78
00:02:42,466 --> 00:02:44,799
他是调的template的这个type方法

79
00:02:44,800 --> 00:02:46,566
我们知道他自己其实没有type

80
00:02:46,600 --> 00:02:48,000
但是temperate是有type

81
00:02:48,300 --> 00:02:50,500
所以temperate type是什么

82
00:02:50,500 --> 00:02:52,400
temperate type其实并不是一个属性是type

83
00:02:52,400 --> 00:02:53,500
它是根据它的属性

84
00:02:53,500 --> 00:02:55,300
这个temperate的并来算出来的

85
00:02:55,600 --> 00:02:57,200
他们的兵我们之前已经有看过

86
00:02:57,200 --> 00:02:58,666
这是记录的是这个对象

87
00:02:58,666 --> 00:03:00,733
他的spring框架中心的兵

88
00:03:00,733 --> 00:03:01,566
对象是什么

89
00:03:01,566 --> 00:03:04,533
我们都会利用这个东西去调他的对象

90
00:03:04,533 --> 00:03:06,699
就是我们在周三讲的

91
00:03:06,700 --> 00:03:11,166
我们避免说让kiss template和weight template是

92
00:03:11,166 --> 00:03:12,499
同样的正常改查

93
00:03:12,500 --> 00:03:13,400
那么写两套

94
00:03:13,733 --> 00:03:15,266
所以我们利用了这种方式啊

95
00:03:15,266 --> 00:03:18,166
去把它的并对象存在到它的属性里头

96
00:03:18,166 --> 00:03:19,366
这样子可以调过来

97
00:03:19,500 --> 00:03:21,500
但是这个东西不能判断出来

98
00:03:21,500 --> 00:03:23,533
说它怎么去做它的carry的

99
00:03:23,766 --> 00:03:24,399
所以我们可以看到

100
00:03:24,400 --> 00:03:25,400
我们做了一个Mac

101
00:03:25,533 --> 00:03:26,933
下面做了一个Mac

102
00:03:27,133 --> 00:03:28,299
这个Mac的作用呢

103
00:03:28,300 --> 00:03:30,500
就是把这个字符串

104
00:03:30,500 --> 00:03:33,100
换成了我们的peace对象和wet对象

105
00:03:33,733 --> 00:03:35,666
那peace对象和wet对象是什么

106
00:03:35,933 --> 00:03:37,133
我们可以点过去看一下

107
00:03:37,200 --> 00:03:40,133
它实现了这个temporary的type这个类型

108
00:03:40,333 --> 00:03:41,299
这个类型中间写了

109
00:03:41,300 --> 00:03:42,766
我们所说的carry的total

110
00:03:42,766 --> 00:03:43,566
这个方法

111
00:03:43,800 --> 00:03:45,533
这个就是算总量

112
00:03:46,133 --> 00:03:47,366
他怎么算总量的啊

113
00:03:47,366 --> 00:03:48,466
大家可以看一下

114
00:03:48,933 --> 00:03:50,666
这里是用的流边层的方式

115
00:03:51,000 --> 00:03:54,100
他把每一个元素滴落出来

116
00:03:54,266 --> 00:03:55,466
每一个元素呢

117
00:03:55,666 --> 00:03:58,699
他去调这个自己的get to come的

118
00:03:58,700 --> 00:03:59,466
这个方法

119
00:03:59,466 --> 00:04:00,366
get to come的方法是什么

120
00:04:00,366 --> 00:04:01,866
这上面写的是个抽象方法

121
00:04:01,866 --> 00:04:03,399
是在纸类中间实现的

122
00:04:03,400 --> 00:04:05,200
所以这里又是一个什么设计模式

123
00:04:07,000 --> 00:04:08,733
这个地方又是个什么数据模式

124
00:04:09,933 --> 00:04:11,999
当你看到在负类去调子类的方法

125
00:04:12,566 --> 00:04:14,499
在负类去调一个抽象的类的方法

126
00:04:14,500 --> 00:04:15,700
这个抽象的类的方法

127
00:04:15,700 --> 00:04:16,866
是在子类中间实现的

128
00:04:16,866 --> 00:04:17,799
这是什么数据模式

129
00:04:19,500 --> 00:04:22,366
黑板上这个template method

130
00:04:22,866 --> 00:04:23,899
所以你可以看到

131
00:04:23,900 --> 00:04:26,966
当我们在用简单多态解决问题的时候

132
00:04:27,066 --> 00:04:29,733
我们为了把代码尽量的写在负类里头

133
00:04:29,733 --> 00:04:32,166
都会大量的使用这个template method

134
00:04:32,166 --> 00:04:32,966
这个设计模式

135
00:04:32,966 --> 00:04:34,966
这又是template method设计模式啊

136
00:04:35,400 --> 00:04:36,466
乘上它的数量

137
00:04:37,066 --> 00:04:39,366
所以我们知道这个get come这个方法

138
00:04:39,366 --> 00:04:41,166
就会是因为它是不

139
00:04:41,166 --> 00:04:43,733
同的东西就会返回不同的值

140
00:04:43,800 --> 00:04:44,733
如果是piece的话

141
00:04:44,733 --> 00:04:46,333
返回就是一就是件数

142
00:04:46,500 --> 00:04:47,966
所以它的get come就是件数

143
00:04:47,966 --> 00:04:48,699
乘上它的数量

144
00:04:48,700 --> 00:04:50,400
直接就是它的数量对吧

145
00:04:50,766 --> 00:04:52,699
如果说是重量模板的话呢

146
00:04:52,700 --> 00:04:53,366
这个get come

147
00:04:53,366 --> 00:04:55,099
大家应该预见到它返回的是什么值

148
00:04:56,200 --> 00:04:57,700
返回的是它的重量值

149
00:04:58,333 --> 00:05:00,566
所以重量值

150
00:05:01,966 --> 00:05:04,333
乘上键数就是它的总重数

151
00:05:04,466 --> 00:05:05,933
后面这个就是对丢失方法

152
00:05:05,933 --> 00:05:08,866
是我们在Java的训里头

153
00:05:08,866 --> 00:05:09,933
常用的一种方式

154
00:05:09,933 --> 00:05:11,266
这叫做reduce函函数

155
00:05:11,766 --> 00:05:13,666
大家知道这个reduce函数是干什么用吗

156
00:05:15,600 --> 00:05:16,800
知道吗熟悉吗

157
00:05:17,333 --> 00:05:18,133
不知道是吧

158
00:05:18,133 --> 00:05:19,566
这就是做累加

159
00:05:20,066 --> 00:05:22,099
实际上就是把当前这个元素

160
00:05:22,100 --> 00:05:26,366
和他之前算到这个地方为止的这个值

161
00:05:26,766 --> 00:05:27,866
把这两个值拉出来

162
00:05:27,866 --> 00:05:30,333
然后把它相加记下来

163
00:05:30,700 --> 00:05:32,400
然后当下个元素过来的时候

164
00:05:32,466 --> 00:05:34,299
把下个元素算出来的这个值

165
00:05:35,333 --> 00:05:38,666
就是把上个下个元素算出来的这个值

166
00:05:38,700 --> 00:05:42,100
和当前的这个值再相加又记下来

167
00:05:42,166 --> 00:05:44,666
所以当所有的元素走完了以后

168
00:05:44,700 --> 00:05:47,200
他得出来的就是加总的值

169
00:05:47,333 --> 00:05:48,466
那每一个值是什么

170
00:05:48,466 --> 00:05:50,333
每一个值就是这个count乘上

171
00:05:52,600 --> 00:05:55,066
这个item的gate quality

172
00:05:55,066 --> 00:05:56,733
因为我们就是这个map函数嘛

173
00:05:56,733 --> 00:05:57,199
它里头

174
00:05:57,200 --> 00:05:59,366
本来这个数组里头的每个对象

175
00:05:59,366 --> 00:06:00,099
是一个item

176
00:06:00,100 --> 00:06:00,933
我们用map函数

177
00:06:00,933 --> 00:06:03,999
把这个item变成了一个整数

178
00:06:04,200 --> 00:06:05,466
然后用你的丢失函数

179
00:06:05,466 --> 00:06:08,099
把所有的整数依次的累加出来

180
00:06:08,366 --> 00:06:10,066
最后调一个get方法

181
00:06:10,400 --> 00:06:12,366
返回的就是我们的总数

182
00:06:13,566 --> 00:06:16,066
所以这个get con的方法大家应该知道

183
00:06:16,066 --> 00:06:17,666
在对于p对象来说

184
00:06:20,466 --> 00:06:23,533
返回的恒定就是一对吧

185
00:06:23,866 --> 00:06:26,199
对于wet对象来说

186
00:06:29,366 --> 00:06:30,066
返回的什么呢

187
00:06:30,066 --> 00:06:33,099
返回的是item里头的重量值

188
00:06:34,466 --> 00:06:35,199
对吧所以

189
00:06:35,200 --> 00:06:38,333
这里就是用的这个模板方法的方式

190
00:06:38,366 --> 00:06:39,166
我们

191
00:06:40,533 --> 00:06:45,733
用两个值类去告诉他说can't是什么

192
00:06:45,800 --> 00:06:47,666
然后用can't怎么去算

193
00:06:47,666 --> 00:06:51,099
那个加总的值是写在它的负类中间的

194
00:06:51,133 --> 00:06:54,499
我们在这里调他的

195
00:06:54,500 --> 00:06:57,800
是template的负类的方法

196
00:06:58,100 --> 00:06:59,500
去caplate的total

197
00:06:59,700 --> 00:07:01,000
所以最后算出来的话

198
00:07:01,000 --> 00:07:03,500
就会根据当前这个region template

199
00:07:03,500 --> 00:07:06,866
到底是计重的模板还是计件的模板

200
00:07:07,000 --> 00:07:09,200
就算出来了不同的总量

201
00:07:09,666 --> 00:07:10,666
所以这个里头啊

202
00:07:10,666 --> 00:07:11,333
大家可以看到

203
00:07:11,333 --> 00:07:13,666
我们用了职责分配的方式啊

204
00:07:13,666 --> 00:07:15,133
用了信息专家的方式

205
00:07:15,400 --> 00:07:17,933
用了瓜用了这个设计模式

206
00:07:17,933 --> 00:07:18,866
中间的template

207
00:07:18,866 --> 00:07:20,066
master的这个设计模式

208
00:07:20,066 --> 00:07:22,166
这两种方式合起来

209
00:07:22,166 --> 00:07:23,699
最后达成了我们的这个目标

210
00:07:23,700 --> 00:07:25,466
我们的目标是在代码上面布写

211
00:07:25,466 --> 00:07:26,399
EFLS

212
00:07:27,100 --> 00:07:27,866
不在这里写

213
00:07:27,866 --> 00:07:29,533
如果他是计重模板

214
00:07:29,533 --> 00:07:30,566
则这样去算

215
00:07:31,000 --> 00:07:32,733
或者是计件模板

216
00:07:32,733 --> 00:07:33,599
就这么去算

217
00:07:33,866 --> 00:07:34,966
不是这么去写的

218
00:07:35,266 --> 00:07:36,133
不这么写的话

219
00:07:36,133 --> 00:07:37,333
这样的一个设计模式

220
00:07:37,333 --> 00:07:38,966
我们在这张图上可以看到

221
00:07:44,166 --> 00:07:45,533
这样的一个设计的结果

222
00:07:45,533 --> 00:07:46,799
在这张图上可以看到

223
00:07:47,100 --> 00:07:49,300
其实就是在那边的那个东西

224
00:07:50,266 --> 00:07:51,066
这个东西

225
00:07:52,600 --> 00:07:53,933
能达成什么目标

226
00:07:57,266 --> 00:07:58,699
我们用了模板方法

227
00:07:58,700 --> 00:08:00,166
用了多态的方式

228
00:08:00,200 --> 00:08:01,166
在多态方式上呢

229
00:08:01,166 --> 00:08:02,299
在grap多态方式上呢

230
00:08:02,300 --> 00:08:04,066
用了模板方法的设计模式

231
00:08:04,200 --> 00:08:05,966
最终的目标是为了想干嘛呢

232
00:08:08,366 --> 00:08:09,799
满足开币原则

233
00:08:10,400 --> 00:08:10,800
就是

234
00:08:10,800 --> 00:08:13,966
我们现在只有wait和piece两种方式

235
00:08:14,600 --> 00:08:16,100
未来还会有第三种吗

236
00:08:16,100 --> 00:08:16,900
你们觉得

237
00:08:18,800 --> 00:08:20,166
你觉得还会有第三种吗

238
00:08:21,133 --> 00:08:21,933
如果有第三种的话

239
00:08:21,933 --> 00:08:24,099
就自己再加一个出来

240
00:08:25,133 --> 00:08:26,499
如果还会有第三种

241
00:08:26,500 --> 00:08:28,566
就这样去加一个出来

242
00:08:28,866 --> 00:08:32,966
我们的那个中国邮政

243
00:08:33,866 --> 00:08:36,799
他的计算方式就如果说是超

244
00:08:37,366 --> 00:08:38,566
就是超限的

245
00:08:38,866 --> 00:08:41,066
这个东西他不是按照介数算的

246
00:08:41,066 --> 00:08:42,466
他是按照体积算的

247
00:08:42,900 --> 00:08:46,466
所以那些货要再形成一种新的方式啊

248
00:08:46,966 --> 00:08:48,733
叫体积折算的方式啊

249
00:08:48,733 --> 00:08:50,133
用体积折算重量的方式

250
00:08:50,133 --> 00:08:51,899
叫体重的方式去折算

251
00:08:52,300 --> 00:08:54,733
所以说这就会有一种新的方式出来

252
00:08:55,333 --> 00:08:57,933
目的就是为了实现开闭原则啊

253
00:08:57,933 --> 00:08:59,066
目的就是为了实现排便的

254
00:08:59,066 --> 00:09:01,266
在代码中尽量避免去写EFL

255
00:09:01,333 --> 00:09:05,099
因为担心会有第三种的这种模板出现

256
00:09:05,133 --> 00:09:07,499
那这里就不会去动到他的代码

257
00:09:07,500 --> 00:09:09,166
如果有第三种模板出现的话

258
00:09:09,166 --> 00:09:11,699
我们希望的状态就是这里加一个代码

259
00:09:12,000 --> 00:09:13,166
这里加一个代码

260
00:09:13,766 --> 00:09:14,766
其他都不动

261
00:09:15,266 --> 00:09:16,966
这个设计就是想做成这个样子

262
00:09:17,100 --> 00:09:18,366
只是在这里加一个

263
00:09:18,466 --> 00:09:19,266
这里加一个

264
00:09:19,266 --> 00:09:21,099
让他满足开闭原则啊

265
00:09:21,100 --> 00:09:22,066
满足开闭原则

266
00:09:23,133 --> 00:09:24,799
这是在这个部分

267
00:09:25,000 --> 00:09:26,800
那后面代码就比较清晰了啊

268
00:09:26,800 --> 00:09:27,800
这个我们刚才已经说过了

269
00:09:27,800 --> 00:09:29,666
这是没有超过他的上限

270
00:09:29,666 --> 00:09:31,166
所以就直接放在一个包裹里

271
00:09:31,666 --> 00:09:33,299
如果超过了上限

272
00:09:33,300 --> 00:09:34,700
则去分包裹

273
00:09:34,700 --> 00:09:35,533
所以分包裹之前

274
00:09:35,533 --> 00:09:37,999
要知道它是按照哪种逻辑去分包裹

275
00:09:38,133 --> 00:09:40,966
这个get package就是一个抽象类

276
00:09:41,166 --> 00:09:43,099
这个抽象类有有4个实线

277
00:09:43,100 --> 00:09:44,900
但其实只有两个实线是有意义的

278
00:09:44,966 --> 00:09:45,999
一个是average

279
00:09:46,266 --> 00:09:47,766
average这是算平均值

280
00:09:48,200 --> 00:09:48,766
大家应该能看到

281
00:09:48,766 --> 00:09:49,733
我们首先做了一个整

282
00:09:49,733 --> 00:09:51,466
除它的total

283
00:09:52,700 --> 00:09:54,366
除上它的这个uplimit

284
00:09:55,133 --> 00:09:55,966
然后除下来

285
00:09:55,966 --> 00:10:00,966
去看呢要看它的这个余数是什么

286
00:10:01,766 --> 00:10:03,399
那如果它有余数的话

287
00:10:03,400 --> 00:10:04,400
这把number加一

288
00:10:04,400 --> 00:10:05,566
如果没有余数的话

289
00:10:05,566 --> 00:10:08,166
那它的平均值就是total除上number

290
00:10:08,566 --> 00:10:10,799
对吧这就实在是在算它的平

291
00:10:10,800 --> 00:10:13,066
均值啊没有切过来是吧

292
00:10:13,700 --> 00:10:14,500
看一下

293
00:10:25,333 --> 00:10:27,099
这就是算平均值

294
00:10:27,466 --> 00:10:29,966
所以它是把total除上它的up limit

295
00:10:30,100 --> 00:10:31,066
得到它的number

296
00:10:31,466 --> 00:10:33,266
然后如果它有余数的话

297
00:10:33,266 --> 00:10:34,699
再把再给它加个一

298
00:10:35,300 --> 00:10:36,866
然后用total除number

299
00:10:36,866 --> 00:10:39,666
那就是它的每个包裹的平均重量

300
00:10:40,100 --> 00:10:41,300
那另外一个呢

301
00:10:41,566 --> 00:10:42,733
就比较简单了

302
00:10:42,733 --> 00:10:44,366
如果我们看另外一个

303
00:10:45,700 --> 00:10:46,766
这个maximum的话

304
00:10:46,766 --> 00:10:48,766
它就直接把它的上限返回回来

305
00:10:49,466 --> 00:10:51,499
所以在这个代码中间

306
00:10:52,133 --> 00:10:54,199
在device shirt这个代码中间

307
00:10:55,666 --> 00:10:57,266
我们的这个god package

308
00:10:57,266 --> 00:10:59,399
package是用了模板方法

309
00:10:59,400 --> 00:11:01,966
在子类中间给出了不同的答案

310
00:11:02,366 --> 00:11:04,999
在负类中间这个package就会是不同的

311
00:11:05,066 --> 00:11:08,733
然后呢这就是把它展成单个

312
00:11:09,900 --> 00:11:11,000
展成单个以后

313
00:11:11,000 --> 00:11:12,333
我们这里做了一个循环

314
00:11:12,333 --> 00:11:13,899
因为我们并不是说

315
00:11:14,300 --> 00:11:15,600
一次性的分包完成的

316
00:11:15,600 --> 00:11:17,533
我们是一次次来完成的

317
00:11:17,666 --> 00:11:18,499
所以这个算法

318
00:11:18,500 --> 00:11:19,566
就是我们在那边那个算法

319
00:11:19,566 --> 00:11:21,066
是完成一次打包过程

320
00:11:21,166 --> 00:11:23,766
他会从现有的所有的包裹中间挑出来

321
00:11:23,766 --> 00:11:26,333
说我们把哪些包裹

322
00:11:26,400 --> 00:11:27,400
按照我们前面说

323
00:11:27,400 --> 00:11:29,800
这个party size的这个原则

324
00:11:29,900 --> 00:11:31,733
去打成一个包裹

325
00:11:32,733 --> 00:11:34,799
所以如果说他挑出来

326
00:11:34,800 --> 00:11:35,800
把它打成一个包裹的话

327
00:11:35,800 --> 00:11:37,166
他会作为返回值返回回来

328
00:11:37,166 --> 00:11:38,599
然后把挑出来这些商品

329
00:11:38,600 --> 00:11:40,500
从single item中间给它删掉

330
00:11:40,733 --> 00:11:43,066
所以大家可以看到我们的判断值里头

331
00:11:43,066 --> 00:11:45,133
就是我们判断single item的这个size

332
00:11:45,133 --> 00:11:45,799
是不是大于0

333
00:11:45,800 --> 00:11:46,666
如果大于0的话

334
00:11:46,666 --> 00:11:48,166
说明它还有东西没有挑出来

335
00:11:48,166 --> 00:11:49,199
那就继续挑

336
00:11:49,766 --> 00:11:51,766
挑到说他却等于0了

337
00:11:51,766 --> 00:11:53,066
其实他不会小于0啊

338
00:11:53,566 --> 00:11:54,766
挑到他等于0了

339
00:11:55,000 --> 00:11:58,533
或者说他挑了一次跟前一次是一样的

340
00:11:58,533 --> 00:11:59,533
他挑不出来了

341
00:11:59,933 --> 00:12:00,999
那这个原因

342
00:12:01,000 --> 00:12:02,133
通常就是

343
00:12:02,133 --> 00:12:03,133
剩下的这些包裹

344
00:12:03,133 --> 00:12:05,366
都超过了他的指定这个尺寸了

345
00:12:06,533 --> 00:12:07,066
那这些包裹

346
00:12:07,066 --> 00:12:07,766
实际上是不能按照

347
00:12:07,766 --> 00:12:08,899
这个尺寸来做打包的

348
00:12:08,900 --> 00:12:10,100
所以他就一直留着

349
00:12:10,200 --> 00:12:12,466
把能打包的包裹把它返回回去

350
00:12:12,566 --> 00:12:14,266
作为这个值把它返回来

351
00:12:14,333 --> 00:12:16,399
所以这就是要把能打包的包裹

352
00:12:16,400 --> 00:12:17,466
要把它合并起来

353
00:12:17,500 --> 00:12:19,133
然后把它一并返回回来

354
00:12:19,533 --> 00:12:20,699
好我们先休息一会

