1
00:00:15,733 --> 00:00:17,733
这是我们shop的包的结构

2
00:00:19,666 --> 00:00:21,999
跟之前的那个图上

3
00:00:22,000 --> 00:00:24,133
头包图上画的是一致的

4
00:00:24,200 --> 00:00:26,733
那Controller称我们就不看了

5
00:00:26,733 --> 00:00:27,866
这个非常简单

6
00:00:28,133 --> 00:00:28,966
设备指层呢

7
00:00:28,966 --> 00:00:29,733
我们刚才说了

8
00:00:29,733 --> 00:00:31,366
是因为它加了一个listen了

9
00:00:31,366 --> 00:00:32,266
所以大家可以看到

10
00:00:32,266 --> 00:00:34,266
除了正常的这些设备时以外

11
00:00:34,600 --> 00:00:35,800
我们还有一个listener的包

12
00:00:35,800 --> 00:00:37,566
这里头是用来做rock them q的

13
00:00:37,566 --> 00:00:39,799
是为了消大家可以看到这个名字

14
00:00:39,800 --> 00:00:41,800
删除模板的listen

15
00:00:42,133 --> 00:00:44,133
实际上是我们先往服务器发了个消息

16
00:00:44,133 --> 00:00:45,699
服务器在专门回掉了一个消息

17
00:00:45,700 --> 00:00:47,066
说他已经收到这个消息了

18
00:00:47,200 --> 00:00:48,366
然后我们才会在这里头去

19
00:00:48,366 --> 00:00:50,133
真正的删除运费模板

20
00:00:50,500 --> 00:00:52,800
所以这是在收费时成的listener

21
00:00:53,400 --> 00:00:54,366
那稻城的话

22
00:00:54,366 --> 00:00:54,799
我们看到

23
00:00:54,800 --> 00:00:56,666
因为我们这里的稻城的Bo对象啊

24
00:00:56,666 --> 00:00:57,699
变得比较多了

25
00:00:57,900 --> 00:00:59,300
所以我们把Bo对象中间呢

26
00:00:59,300 --> 00:01:01,066
分门别类的做了两个纸包

27
00:01:01,166 --> 00:01:03,599
把所有的不需要存储的这些对象

28
00:01:03,600 --> 00:01:05,200
就是用来做分包的那些绿色对象

29
00:01:05,200 --> 00:01:07,666
放到DIY DI DIY的里头

30
00:01:08,000 --> 00:01:10,166
把运费模板有关的对象放到这里

31
00:01:10,566 --> 00:01:12,333
然后把其他的对象放在了这里

32
00:01:12,333 --> 00:01:15,166
这里除了我们的sharp region以外

33
00:01:15,166 --> 00:01:16,533
我们还有一个product item

34
00:01:16,533 --> 00:01:18,166
这个是从前端传过来

35
00:01:18,933 --> 00:01:20,299
是从钱单传过来的啊

36
00:01:20,300 --> 00:01:22,133
就是我们用来做运费的时候

37
00:01:22,133 --> 00:01:23,899
钱单它也不会存在任何地方

38
00:01:23,900 --> 00:01:26,000
就是我们在内部所使用的一个结构

39
00:01:26,266 --> 00:01:27,733
所以我们把这三个

40
00:01:27,966 --> 00:01:30,499
把这些东西放到了这个Bo对象中间

41
00:01:31,566 --> 00:01:32,933
那在do的这个部分来说

42
00:01:32,933 --> 00:01:33,599
我们也对应的

43
00:01:33,600 --> 00:01:35,133
因为Bo对象变多了

44
00:01:35,133 --> 00:01:36,666
do对象也就变多了

45
00:01:36,700 --> 00:01:38,600
所以do对象的部分来说

46
00:01:38,600 --> 00:01:40,200
我们可以看到我们做了一个template

47
00:01:40,466 --> 00:01:43,199
把所有跟应聘文版有关的这个do对象

48
00:01:43,200 --> 00:01:44,666
都放到这个template里头

49
00:01:44,666 --> 00:01:45,799
然后做了一个open Fi

50
00:01:45,866 --> 00:01:47,533
我们重点来看这个open Fi啊

51
00:01:47,966 --> 00:01:48,466
这个问分

52
00:01:48,466 --> 00:01:51,533
主要是为了去访问其他的模块的

53
00:01:51,533 --> 00:01:53,266
我们现在是为了访问region模块

54
00:01:53,266 --> 00:01:54,566
获得一个region对象

55
00:01:54,566 --> 00:01:56,733
就我们在对象模型图上看到的

56
00:01:56,733 --> 00:01:58,266
唯一的一个蓝色的对象

57
00:01:58,700 --> 00:02:00,533
那我们做这个reading Doll的目的是

58
00:02:00,533 --> 00:02:01,566
让这个蓝色的对象

59
00:02:01,566 --> 00:02:03,699
看起来跟其他的所有对象是一样

60
00:02:03,800 --> 00:02:05,266
就是并不是认为说

61
00:02:05,266 --> 00:02:07,099
他不是从我资讯里查出来的

62
00:02:07,133 --> 00:02:08,866
就看起来跟别人不太一样

63
00:02:09,300 --> 00:02:10,566
目的就是完全一样的

64
00:02:11,133 --> 00:02:11,999
所以大家可以看到

65
00:02:12,000 --> 00:02:13,066
在这个Doll对象中

66
00:02:13,066 --> 00:02:14,699
我们依然延续了

67
00:02:14,866 --> 00:02:16,733
像其他的Doll对象一样的做法

68
00:02:17,066 --> 00:02:18,299
比如说find the ID

69
00:02:19,166 --> 00:02:20,733
但是因为我们没有insert

70
00:02:20,733 --> 00:02:22,333
没有safe

71
00:02:22,333 --> 00:02:23,166
没有delete

72
00:02:23,166 --> 00:02:24,099
我们需求中间

73
00:02:24,100 --> 00:02:27,066
对于对于地区模块来说

74
00:02:27,066 --> 00:02:28,199
我们不会去增删改

75
00:02:28,200 --> 00:02:31,000
查增删改那些地区的信息

76
00:02:31,066 --> 00:02:33,499
我们只是去获得地区的信息

77
00:02:33,600 --> 00:02:35,666
所以我们做了一个同样的翻的白ID

78
00:02:36,000 --> 00:02:37,566
但是里头我们可以看到

79
00:02:37,566 --> 00:02:40,133
我们调的是我们的reading Mapper

80
00:02:40,133 --> 00:02:42,133
这就是我们在Mapper的那个open FIN

81
00:02:42,133 --> 00:02:42,566
里头的包

82
00:02:42,566 --> 00:02:43,466
里头的那个类

83
00:02:43,733 --> 00:02:45,099
去find by reading ID

84
00:02:45,100 --> 00:02:45,733
我们看一下

85
00:02:45,733 --> 00:02:46,766
这个就是open FIN

86
00:02:47,466 --> 00:02:50,366
这个就是我们在Mapper的那个open friend

87
00:02:50,366 --> 00:02:52,499
包里头放的RAGING Mapper

88
00:02:52,500 --> 00:02:53,733
我们用open friend技术

89
00:02:53,733 --> 00:02:56,466
跟那个支付模块里都一样

90
00:02:56,666 --> 00:02:58,366
用open finish技术啊

91
00:02:58,933 --> 00:03:00,499
标注了它是一个fankind

92
00:03:00,500 --> 00:03:02,400
然后name表示的是它会去调

93
00:03:02,400 --> 00:03:03,366
哪台服务器

94
00:03:03,466 --> 00:03:06,133
因为我们这里用的是Swarm集群

95
00:03:06,133 --> 00:03:06,333
所以

96
00:03:06,333 --> 00:03:09,066
我们不需要去指定那台服务器的IP啊

97
00:03:09,066 --> 00:03:11,399
只需要说那个服务器的名称啊

98
00:03:11,400 --> 00:03:11,933
这个名称

99
00:03:11,933 --> 00:03:14,466
会登记在我们的locks的服务器里头啊

100
00:03:14,500 --> 00:03:14,733
所以

101
00:03:14,733 --> 00:03:16,733
我们其实是因为使用了locks服务器

102
00:03:16,733 --> 00:03:17,699
所以会用这个名称

103
00:03:17,700 --> 00:03:19,400
到locks去查到对应的IP

104
00:03:19,666 --> 00:03:21,066
然后就会去调用它

105
00:03:21,400 --> 00:03:22,133
调用它的时候

106
00:03:22,133 --> 00:03:22,866
我们可以看到

107
00:03:22,866 --> 00:03:26,499
我们把每一个HTTP的请求的URL

108
00:03:26,500 --> 00:03:28,700
还有它需要传递的这个参数

109
00:03:28,933 --> 00:03:30,399
把它用open FIN的技术

110
00:03:30,400 --> 00:03:32,733
把它变成了我们的一个方法

111
00:03:33,200 --> 00:03:35,600
那这个方法所返回的值

112
00:03:35,600 --> 00:03:37,933
是我们正常发http的请求返回的值

113
00:03:37,933 --> 00:03:39,466
就我们所有的前端API里

114
00:03:39,466 --> 00:03:40,333
所看到的那个值

115
00:03:40,400 --> 00:03:40,866
我们知道

116
00:03:40,866 --> 00:03:43,366
我们所有前端API返回都是error number

117
00:03:43,366 --> 00:03:46,133
errormessage然后是data data

118
00:03:46,133 --> 00:03:47,333
里头是一堆的东西

119
00:03:47,566 --> 00:03:50,666
所以如果我们调region的那个API

120
00:03:51,300 --> 00:03:52,300
要read模块的API

121
00:03:52,300 --> 00:03:54,866
去翻的read吧ID把这个请求发过去

122
00:03:54,866 --> 00:03:56,799
我们拿回来的也是一个这样的结构

123
00:03:57,166 --> 00:03:58,933
这个结构不好用是吧

124
00:03:59,133 --> 00:04:00,866
这个结构跟我们正常用的时候

125
00:04:00,866 --> 00:04:01,599
不太好用

126
00:04:01,600 --> 00:04:02,366
这也就是为什么

127
00:04:02,366 --> 00:04:05,133
我们在上面的倒层做了一层包装

128
00:04:05,600 --> 00:04:07,200
也就是我们拿回来这个结构以后

129
00:04:07,200 --> 00:04:08,733
我们会去判断一下

130
00:04:08,900 --> 00:04:11,566
这个结构里头的error number是不是OK的

131
00:04:11,933 --> 00:04:13,566
如果error number不是OK的

132
00:04:13,566 --> 00:04:14,733
这是find的请求啊

133
00:04:14,733 --> 00:04:15,933
如果是find的请求

134
00:04:15,933 --> 00:04:17,133
r number不是OK的

135
00:04:17,333 --> 00:04:19,566
肯定是在调用过程中间出了错

136
00:04:19,733 --> 00:04:20,766
所以大家可以看到

137
00:04:20,766 --> 00:04:22,133
我们依然会把这个错

138
00:04:22,400 --> 00:04:24,000
在我们这个模块里头给

139
00:04:24,000 --> 00:04:24,933
它输入出来

140
00:04:25,333 --> 00:04:25,599
所以

141
00:04:25,600 --> 00:04:28,300
发生在reading模块里头的那个错误

142
00:04:28,700 --> 00:04:29,900
我们在调用的时候

143
00:04:29,900 --> 00:04:32,533
他会通过他的返回指示告诉我们的

144
00:04:32,533 --> 00:04:33,766
这个商铺模块

145
00:04:33,866 --> 00:04:35,666
然后我们在商铺模块中间就会知道

146
00:04:35,666 --> 00:04:38,333
reading模块又出了什么样的错啊

147
00:04:38,333 --> 00:04:39,333
所以这是第一

148
00:04:39,600 --> 00:04:42,400
我们通过这个外面的这个啊

149
00:04:42,400 --> 00:04:43,600
iron number和message

150
00:04:43,600 --> 00:04:45,966
把它的错误再还原出来

151
00:04:46,066 --> 00:04:47,333
那如果没出错的话

152
00:04:47,466 --> 00:04:49,199
我们可以看到我们就把它里头的东西

153
00:04:49,200 --> 00:04:51,333
把它get the data拿出来

154
00:04:51,466 --> 00:04:51,799
然后build

155
00:04:51,800 --> 00:04:55,066
build就是我们说的把它变成满选对象

156
00:04:55,100 --> 00:04:56,366
因为这里同样的

157
00:04:56,666 --> 00:04:58,699
我们的region对象里头

158
00:04:58,700 --> 00:05:01,766
其实是要把它的PU变成bo

159
00:05:02,100 --> 00:05:04,200
然后要给它置进去region道

160
00:05:04,200 --> 00:05:07,000
因为region对象是可以访问到上一层的

161
00:05:07,066 --> 00:05:09,466
就是可能访问他的父亲的是有关系的

162
00:05:09,466 --> 00:05:10,166
这个对象

163
00:05:10,166 --> 00:05:13,566
我们依然用这个regional的另外一个API

164
00:05:13,666 --> 00:05:16,899
这个API就是获得他所有的

165
00:05:17,000 --> 00:05:18,466
这个上级节点的

166
00:05:18,466 --> 00:05:19,199
这个API

167
00:05:19,200 --> 00:05:24,600
去形成我们在这里所看到的这个呃

168
00:05:24,600 --> 00:05:26,300
region和region对象之间的

169
00:05:26,300 --> 00:05:27,966
这样的一个关系

170
00:05:28,200 --> 00:05:31,933
这个是我们的层次体系结构啊

171
00:05:32,000 --> 00:05:32,866
顺便说了一下

172
00:05:32,866 --> 00:05:35,066
在里头我们用到的open FIN

173
00:05:35,666 --> 00:05:37,333
实际上是把它做成了

174
00:05:37,333 --> 00:05:39,533
Mapper和Doll两个部分

175
00:05:39,800 --> 00:05:42,733
Mapper真正的Urpan FIN去访问微景模块

176
00:05:42,733 --> 00:05:43,333
而Doll呢

177
00:05:43,333 --> 00:05:44,766
把这个访问就把它还原

178
00:05:44,766 --> 00:05:48,299
成为了我们很熟悉的一个满血的对象

179
00:05:48,400 --> 00:05:49,266
所以这样的话

180
00:05:49,266 --> 00:05:51,066
在整个的对象模型里头

181
00:05:51,766 --> 00:05:52,966
我们这里的reading对象

182
00:05:52,966 --> 00:05:54,466
我这里其实应该画个关联

183
00:05:54,466 --> 00:05:56,566
没画啊我们这个reading对象

184
00:05:56,566 --> 00:05:58,266
其实跟其他的对象看起来就是

185
00:05:58,266 --> 00:06:00,466
不会有任何的差别啊

186
00:06:00,466 --> 00:06:01,266
因为

187
00:06:01,366 --> 00:06:03,566
经过了我们的那个reading dog包装以后

188
00:06:03,566 --> 00:06:06,266
他就看起来跟我们从本地查出来的

189
00:06:06,266 --> 00:06:08,266
这个数据库里头的那些对象

190
00:06:08,533 --> 00:06:09,599
是一模一样

191
00:06:09,600 --> 00:06:10,900
用起来是无差别的啊

192
00:06:10,900 --> 00:06:13,600
这就是我们在稻城那些盗对象

193
00:06:13,666 --> 00:06:14,366
所要起的

194
00:06:14,366 --> 00:06:15,366
重要的目的是这样

195
00:06:15,366 --> 00:06:17,399
完成最基本的这3个改查

196
00:06:17,666 --> 00:06:19,766
把它变成一个满血对象

197
00:06:23,933 --> 00:06:25,999
这是它的层次体系结构

198
00:06:26,566 --> 00:06:27,399
那对象模型

199
00:06:27,400 --> 00:06:28,500
我们在之前讲过

200
00:06:28,800 --> 00:06:31,166
这一部分的对象模型变得比较复杂了

201
00:06:31,700 --> 00:06:33,666
我们在这个模块里头的任务就是

202
00:06:33,666 --> 00:06:35,333
这个模块的目标其实很简单

203
00:06:35,333 --> 00:06:36,166
就两个目标

204
00:06:36,300 --> 00:06:37,533
一个是管住商铺

205
00:06:37,800 --> 00:06:40,866
就是所有的商品都是应该先有商铺

206
00:06:40,866 --> 00:06:41,599
再有商品

207
00:06:41,600 --> 00:06:42,766
再有其他的

208
00:06:42,800 --> 00:06:43,900
就整个电商平台

209
00:06:43,900 --> 00:06:45,766
中间是首先要有商铺

210
00:06:46,500 --> 00:06:48,300
所以对于商铺的部分来说

211
00:06:48,300 --> 00:06:49,333
在这个模块中间

212
00:06:49,333 --> 00:06:51,133
主要是针对商铺的侦探

213
00:06:51,133 --> 00:06:52,933
改差还有他状态的牵引

214
00:06:53,533 --> 00:06:55,266
这个跟我们前面的地区模块

215
00:06:55,266 --> 00:06:55,966
其实很类似

216
00:06:55,966 --> 00:06:56,766
因为商铺本身

217
00:06:56,766 --> 00:06:58,699
我们并没有做太多的业务

218
00:06:58,966 --> 00:07:00,533
把他的很多业务简化了

219
00:07:00,666 --> 00:07:01,799
所以在这个模块中间

220
00:07:01,800 --> 00:07:04,300
我们现在简化掉的商铺就是正常改差

221
00:07:04,466 --> 00:07:06,266
还有他的状态迁移

222
00:07:06,266 --> 00:07:08,099
他啊

223
00:07:08,900 --> 00:07:10,933
在线还是呃

224
00:07:10,933 --> 00:07:11,566
不在线

225
00:07:11,566 --> 00:07:13,733
就是说东西能够临时卖还是不卖

226
00:07:13,733 --> 00:07:15,999
还有把它关闭等等这些东西

227
00:07:16,333 --> 00:07:17,266
那这是一块

228
00:07:18,066 --> 00:07:18,899
另外一块是什么呢

229
00:07:18,900 --> 00:07:19,366
另外一块

230
00:07:19,366 --> 00:07:22,399
是我们跟商铺有关的运费模板

231
00:07:22,900 --> 00:07:24,100
也就是我们前面说过

232
00:07:24,100 --> 00:07:26,333
每一个商铺会定义自己的运费模板

233
00:07:27,133 --> 00:07:28,366
这个运费模板呢

234
00:07:28,933 --> 00:07:29,733
分为两种

235
00:07:29,733 --> 00:07:31,466
一种是计重的运费模板

236
00:07:31,733 --> 00:07:33,333
一种是计件的运费模板

237
00:07:33,533 --> 00:07:34,366
计重的运费模板

238
00:07:34,366 --> 00:07:36,099
通常来说是比较普遍的

239
00:07:36,100 --> 00:07:37,533
也只会定一个一半

240
00:07:37,533 --> 00:07:39,199
会定一个计重的运费模板

241
00:07:39,533 --> 00:07:41,166
然后大部分的商品

242
00:07:41,166 --> 00:07:43,199
都是用的计重的运费模板

243
00:07:43,766 --> 00:07:46,466
少部分如果超限的商品

244
00:07:46,566 --> 00:07:50,133
则会定义按件来做的计件的运费模板

245
00:07:50,600 --> 00:07:53,000
所以在这里运费模板被分成了两类

246
00:07:53,000 --> 00:07:54,100
计重和计件

247
00:07:54,100 --> 00:07:55,966
那实际上在整个系统中间

248
00:07:56,733 --> 00:07:57,766
计重只有一个

249
00:07:57,800 --> 00:07:59,300
计件会有非常多

250
00:07:59,533 --> 00:08:01,466
因为每一种特殊的商品

251
00:08:01,500 --> 00:08:04,133
他如果不能按照重量去做运送的话

252
00:08:04,200 --> 00:08:06,566
他就会给他定义一个计件的模板啊

253
00:08:06,566 --> 00:08:07,899
虽然在我们的代码上看起来

254
00:08:07,900 --> 00:08:10,366
还是两个计件模板

255
00:08:10,400 --> 00:08:12,300
但是两个计费模板

256
00:08:12,466 --> 00:08:14,533
其实实际的运行工程中间

257
00:08:14,533 --> 00:08:15,399
大家应该知道

258
00:08:15,500 --> 00:08:16,733
计重应该只有一个

259
00:08:16,966 --> 00:08:19,266
而且这个就是我们所说的默认模板

260
00:08:19,533 --> 00:08:21,099
而计件的会有非常多

261
00:08:21,266 --> 00:08:22,866
就是所有特殊的商品

262
00:08:22,866 --> 00:08:26,166
都会定义这个计件模板

263
00:08:26,766 --> 00:08:28,333
对于商铺来说

264
00:08:28,333 --> 00:08:30,466
它跟模板之间的关系

265
00:08:30,466 --> 00:08:31,866
是一个一对多的关系

266
00:08:31,866 --> 00:08:32,366
我们刚才说了

267
00:08:32,366 --> 00:08:34,199
因为它定义很多的模板嘛

268
00:08:34,333 --> 00:08:36,099
但是我们在对象模型中间可以看到

269
00:08:36,333 --> 00:08:38,566
我们只定义了一个一对一的关系

270
00:08:39,066 --> 00:08:40,466
也就是我们选择性的

271
00:08:40,466 --> 00:08:41,866
忽略了他的一对多的关系

272
00:08:41,866 --> 00:08:45,466
而只记录了他的其中的一个默认模板

273
00:08:45,466 --> 00:08:47,133
的关系也就在这个地方

274
00:08:48,300 --> 00:08:50,000
这就是你在对象门面经常会做的

275
00:08:50,000 --> 00:08:54,500
我们并不需要把现实中间所存在的

276
00:08:54,500 --> 00:08:55,966
所有的关系

277
00:08:55,966 --> 00:08:57,099
全部把它搬过来

278
00:08:57,100 --> 00:08:58,800
我们在API上头也有这个API

279
00:08:58,800 --> 00:08:59,333
这是一个商铺

280
00:08:59,333 --> 00:09:01,099
进去看到他所有定的运费模板

281
00:09:01,100 --> 00:09:02,100
这个API是有的

282
00:09:02,700 --> 00:09:04,933
但是我们在对象模型中间没有去记录

283
00:09:04,933 --> 00:09:07,199
它意味着这个API实现的时候

284
00:09:07,200 --> 00:09:08,533
都要用什么方式实现呢

285
00:09:09,200 --> 00:09:10,766
用面向功能的方式去实现

286
00:09:10,800 --> 00:09:11,733
因为后面数据库

287
00:09:11,733 --> 00:09:12,533
是有记录的

288
00:09:12,866 --> 00:09:13,366
就是数据库

289
00:09:13,366 --> 00:09:14,999
他没有损失这个信息

290
00:09:15,100 --> 00:09:17,066
但是对象模型去损失了

291
00:09:17,100 --> 00:09:20,100
我们这里为什么选择了既默认模板

292
00:09:20,100 --> 00:09:21,400
因为上面是有业务的

293
00:09:21,400 --> 00:09:22,600
我们的业务是这样

294
00:09:23,166 --> 00:09:28,299
当商品本身没有定义运费模板的时候

295
00:09:28,466 --> 00:09:31,366
这个商品就是用的默认的运费模板

296
00:09:31,800 --> 00:09:32,600
所以大家知道

297
00:09:32,600 --> 00:09:35,600
实际上在这个商铺的所卖的商品中间

298
00:09:35,800 --> 00:09:37,700
可能90%以上的商品

299
00:09:37,700 --> 00:09:39,533
都不会定义英雄模板

300
00:09:39,533 --> 00:09:40,866
因为他没有什么特殊的

301
00:09:41,300 --> 00:09:44,000
那就是简单的按照他的默认模板

302
00:09:44,100 --> 00:09:45,666
去计算他的运费

303
00:09:45,933 --> 00:09:47,499
所以这个关系

304
00:09:47,500 --> 00:09:49,266
就必须要在对象模型给你记下来

305
00:09:49,266 --> 00:09:51,099
因为他是有业务

306
00:09:51,200 --> 00:09:52,000
而且

307
00:09:52,066 --> 00:09:54,199
大部分手上都在算他的运费的时候

308
00:09:54,200 --> 00:09:57,266
都是在用这个默认的运费模板

309
00:09:57,300 --> 00:09:58,800
所以我们把这个关系啊

310
00:09:58,800 --> 00:10:02,133
给他记了下来啊

311
00:10:02,466 --> 00:10:04,166
模板说的是一个模板

312
00:10:04,366 --> 00:10:05,166
但是我们知道

313
00:10:05,166 --> 00:10:07,333
这个模板对于不同的地区

314
00:10:07,500 --> 00:10:10,266
是有不同的计算标准的

315
00:10:10,466 --> 00:10:11,733
就是我们并不是说

316
00:10:11,733 --> 00:10:12,366
在全国

317
00:10:12,366 --> 00:10:15,899
都是用同样的运费标准在配送东西

318
00:10:16,066 --> 00:10:17,733
所以我们这样的一个运费模板

319
00:10:17,733 --> 00:10:20,599
是允许他在每一个地区去定义

320
00:10:20,600 --> 00:10:23,200
他自己的计算运费的方式

321
00:10:23,466 --> 00:10:24,766
都可以是不一样啊

322
00:10:24,766 --> 00:10:26,899
比如说他的首重计重都是可以不一样

323
00:10:26,900 --> 00:10:28,000
都没有关系

324
00:10:28,500 --> 00:10:30,133
那这样的一种方式

325
00:10:30,133 --> 00:10:30,966
我们知道

326
00:10:31,900 --> 00:10:33,333
地区的运费模板

327
00:10:33,333 --> 00:10:34,899
和上面这个运费模板

328
00:10:34,900 --> 00:10:36,500
这实际上是我们的一个运费模板

329
00:10:36,500 --> 00:10:38,666
每个运费模板都会有一个实力对象

330
00:10:38,866 --> 00:10:41,499
那这个跟他的关系其实就是一对多的

331
00:10:41,966 --> 00:10:44,566
对吧就是我们任何一个运费模板

332
00:10:44,566 --> 00:10:46,599
会在不同地区会有不同的定义

333
00:10:46,600 --> 00:10:48,266
所以模板和reading

334
00:10:48,266 --> 00:10:50,333
template是一个一对多的关系

335
00:10:50,666 --> 00:10:51,533
同样大家可以看到

336
00:10:51,533 --> 00:10:52,266
在这个对象门中间

337
00:10:52,266 --> 00:10:53,799
我们没有进入一对多的关系

338
00:10:54,333 --> 00:10:55,666
我们只记录了什么呢

339
00:10:55,666 --> 00:10:57,333
只记录了从这个方向

340
00:10:57,333 --> 00:10:59,999
往这个方向的一对一的关系

341
00:11:00,133 --> 00:11:01,299
这个原因也就是认为

342
00:11:01,300 --> 00:11:03,966
我们认为那个一对多只是为了看

343
00:11:04,366 --> 00:11:04,599
就是

344
00:11:04,600 --> 00:11:07,400
只是他在查询的时候会看到一个模板

345
00:11:07,400 --> 00:11:09,000
中间到底在每个地区定义了什么

346
00:11:09,000 --> 00:11:10,733
那个会有这个API去给你看

347
00:11:10,933 --> 00:11:11,933
但是我们业务上头

348
00:11:11,933 --> 00:11:14,399
是没有从这个方向上头去做任何业务

349
00:11:14,733 --> 00:11:15,399
我们的业务在哪

350
00:11:15,400 --> 00:11:15,966
我们的业务

351
00:11:15,966 --> 00:11:17,566
实际上是从这个方向过来的

352
00:11:17,766 --> 00:11:18,899
待会我们会看到

353
00:11:18,900 --> 00:11:20,733
因为我们实际上在这个模板中间

354
00:11:20,733 --> 00:11:22,899
并没有定义他是计重还是计件

355
00:11:23,533 --> 00:11:25,599
他的计重和计件定义在这个里头了

356
00:11:26,400 --> 00:11:26,866
就换句话说

357
00:11:26,866 --> 00:11:28,199
我们定义了一个计重模板

358
00:11:28,200 --> 00:11:29,300
还是个计件模板

359
00:11:29,333 --> 00:11:30,899
那下面的所有的这个地区模板

360
00:11:30,900 --> 00:11:33,400
就自然就是计重的还是计件的

361
00:11:33,933 --> 00:11:35,133
所以我们需要从这个方向

362
00:11:35,133 --> 00:11:37,699
往这个方向有一条关联线

363
00:11:37,800 --> 00:11:38,800
使得他能够知道

364
00:11:38,800 --> 00:11:40,800
说我这个是一个计重的呢

365
00:11:40,800 --> 00:11:42,933
还是一个计件的模板

366
00:11:43,500 --> 00:11:45,500
那计重和计件的模板

367
00:11:45,666 --> 00:11:47,899
我们知道它的表述是不一样的

368
00:11:48,333 --> 00:11:51,699
我们把它的一些共性的属性提出来

369
00:11:51,700 --> 00:11:52,700
作为它的负类

370
00:11:52,700 --> 00:11:53,800
它有什么共性属性呢

371
00:11:53,800 --> 00:11:55,533
比如说上限

372
00:11:55,800 --> 00:11:56,400
大家注意

373
00:11:56,400 --> 00:11:58,666
我们这个上限是定义在什么呢

374
00:11:58,766 --> 00:12:00,133
定义在地区的

375
00:12:00,600 --> 00:12:02,400
这个有可能可以做到什么

376
00:12:02,400 --> 00:12:04,200
就我们现在这个结构是可以做到

377
00:12:04,400 --> 00:12:05,900
比如说在省内

378
00:12:05,900 --> 00:12:08,333
它的上限是比较大的

379
00:12:08,466 --> 00:12:09,733
然后可能在省外

380
00:12:09,733 --> 00:12:11,566
比如说在其他地区

381
00:12:11,766 --> 00:12:13,299
他的上限又是不一样的

382
00:12:13,300 --> 00:12:14,166
是可以做到这样的

383
00:12:14,166 --> 00:12:14,966
当然简单化

384
00:12:14,966 --> 00:12:16,333
就是所有地方上限是一样的

385
00:12:16,333 --> 00:12:18,466
目前大部分快递公司都是

386
00:12:18,466 --> 00:12:18,766
这样的

387
00:12:18,766 --> 00:12:21,466
就是所有地区的上限都是一样的

388
00:12:21,500 --> 00:12:22,866
但是我们现在这个数据结构

389
00:12:22,866 --> 00:12:24,466
是可以允许他在不同地区

390
00:12:24,700 --> 00:12:26,466
定义不同的上限

391
00:12:26,933 --> 00:12:27,399
那第二个

392
00:12:27,400 --> 00:12:30,066
则是它的这个续重续件的单位

393
00:12:30,266 --> 00:12:30,966
这个是什么呢

394
00:12:30,966 --> 00:12:34,533
这个因为我们无论是手计重模板

395
00:12:34,533 --> 00:12:35,533
还是计件模板

396
00:12:35,533 --> 00:12:36,933
它有一个起步费用

397
00:12:37,533 --> 00:12:42,133
但是他的这个续件的费用是什么单位

398
00:12:42,666 --> 00:12:44,499
这个是可以定义的

399
00:12:44,733 --> 00:12:46,766
对于这个计重模板来说

400
00:12:46,766 --> 00:12:48,066
我们可以看到

401
00:12:48,066 --> 00:12:51,133
他是有一个首重和首重的费用

402
00:12:51,200 --> 00:12:52,766
然后后面就有一个门槛值

403
00:12:53,333 --> 00:12:54,999
门槛值是低于什么样的时候

404
00:12:55,000 --> 00:12:56,000
它的价格是多少

405
00:12:56,000 --> 00:12:57,533
这个价格不是说低于这个东西

406
00:12:57,533 --> 00:12:58,399
都这个价格

407
00:12:58,600 --> 00:12:59,566
这个价格怎么算呢

408
00:12:59,566 --> 00:13:01,766
是按照这个计算单位算的

409
00:13:01,966 --> 00:13:05,733
如果这个价格计算单位是0.5千克的话

410
00:13:06,466 --> 00:13:09,299
那就是每再低于这个值

411
00:13:09,300 --> 00:13:11,766
每0.5千克他就会加这么多钱

412
00:13:11,900 --> 00:13:13,500
所以这个价格是一个单价

413
00:13:13,733 --> 00:13:15,899
是这个计重单位的

414
00:13:15,900 --> 00:13:18,333
续重的计重单位的这个单价

415
00:13:19,066 --> 00:13:20,466
计件也是一样的

416
00:13:20,466 --> 00:13:22,466
它是有一个续件数目的

417
00:13:22,566 --> 00:13:25,333
这个续件数目比如说是6件以上

418
00:13:25,466 --> 00:13:27,533
然后它的这个续件6件以下

419
00:13:27,533 --> 00:13:28,733
续件费用是多少钱

420
00:13:28,800 --> 00:13:30,366
这个同样也会有这个计件单位

421
00:13:30,366 --> 00:13:31,966
如果这个计件单位是一的话

422
00:13:32,066 --> 00:13:34,166
这个续件费用就是每一件是多少钱

423
00:13:34,566 --> 00:13:36,499
如果这个计件单位是2的话

424
00:13:36,500 --> 00:13:40,000
那这个续件费用就是每两件是多少钱

425
00:13:40,000 --> 00:13:42,900
然后这个是它的续件的数目啊

426
00:13:42,900 --> 00:13:46,400
是它的这个续件的续件的值

427
00:13:46,900 --> 00:13:50,133
这是两个计费模板

428
00:13:50,166 --> 00:13:51,666
公用的属性

429
00:13:51,666 --> 00:13:53,733
我们把它放到了他的负类里头

430
00:13:53,966 --> 00:13:56,299
不同的属性放在了子类里头

431
00:13:57,066 --> 00:13:58,866
这里头我们不仅仅是把公用属性

432
00:13:58,866 --> 00:13:59,899
放到腹内里头

433
00:14:00,333 --> 00:14:02,333
其实不放到腹里头也没有关系

434
00:14:02,333 --> 00:14:03,066
大家应该知道

435
00:14:03,066 --> 00:14:05,799
说这两个东西其实也没占太多地方

436
00:14:05,800 --> 00:14:06,966
你就是放到子类中间

437
00:14:06,966 --> 00:14:08,299
也没有什么太大问题

438
00:14:08,366 --> 00:14:10,733
我们最关键的因素是什么呢

439
00:14:10,733 --> 00:14:13,666
是我们这个腹类是白色的

440
00:14:14,000 --> 00:14:15,700
而子类是黄色的

441
00:14:16,200 --> 00:14:19,400
也就是我们打算用两种不同的技术

442
00:14:19,533 --> 00:14:21,133
来存这个对象

443
00:14:21,500 --> 00:14:23,000
之前的所有的对象

444
00:14:23,000 --> 00:14:24,966
都是存在MYC口数据库里头

445
00:14:25,500 --> 00:14:26,733
那我们从这个模块开始

446
00:14:26,733 --> 00:14:29,966
第一次把对象存到了芒果数据库里

447
00:14:30,166 --> 00:14:32,899
而且还把一个对象一批两半

448
00:14:33,366 --> 00:14:35,566
一半存在了MYC库里

449
00:14:35,866 --> 00:14:38,133
一半存在了芒果里头

450
00:14:38,500 --> 00:14:39,200
大家会想说

451
00:14:39,200 --> 00:14:40,566
为什么会这么麻烦

452
00:14:41,333 --> 00:14:43,166
干嘛不就一撇子

453
00:14:43,166 --> 00:14:45,366
全存到芒果里不就就完了吗

454
00:14:45,733 --> 00:14:46,399
对吧

455
00:14:46,400 --> 00:14:48,966
为什么还要把它一半存到my secret里

456
00:14:48,966 --> 00:14:50,599
一半存到芒果里

457
00:14:51,000 --> 00:14:52,333
这个原因是因为

458
00:14:52,766 --> 00:14:54,766
芒果本身是执行查询功能的

459
00:14:54,766 --> 00:14:57,166
就是芒果他不仅仅可以用组件查

460
00:14:57,300 --> 00:14:59,400
而且还可以用他所有的字段查

461
00:14:59,466 --> 00:14:59,733
所以

462
00:14:59,733 --> 00:15:04,266
芒果并不是严格的一个low secret数据库

463
00:15:04,266 --> 00:15:04,566
啊

464
00:15:04,566 --> 00:15:06,766
不是一个严格的这个非结构化数据库

465
00:15:06,766 --> 00:15:07,066
通常

466
00:15:07,066 --> 00:15:09,599
我们把芒果称之为半结构化的数据库

467
00:15:09,600 --> 00:15:12,600
因为它比其他的非结构化的数据库

468
00:15:12,600 --> 00:15:13,500
要更强大一点

469
00:15:13,500 --> 00:15:14,666
它可以用它制断茶

470
00:15:15,066 --> 00:15:16,866
所以如果单纯是用Mango

471
00:15:16,866 --> 00:15:17,899
就是我们单纯这个设计

472
00:15:17,900 --> 00:15:19,600
是为了在Mango里头去实现的话

473
00:15:19,733 --> 00:15:20,333
我们实际上

474
00:15:20,333 --> 00:15:21,799
是可以把它全部放到Mango里头

475
00:15:21,800 --> 00:15:24,066
而不需要一半放在欢迎数据库里

476
00:15:24,066 --> 00:15:25,266
一半放到Mango里头

477
00:15:25,400 --> 00:15:26,100
那关键是

478
00:15:26,100 --> 00:15:29,066
我们现在这个设计的目标是

479
00:15:29,066 --> 00:15:30,366
这个部分的数据

480
00:15:30,900 --> 00:15:32,500
是放在no seque数据库里

481
00:15:32,800 --> 00:15:34,500
而不是单纯是Mango

482
00:15:34,500 --> 00:15:35,766
只不过是我们现在

483
00:15:36,166 --> 00:15:37,333
在做课程设计的时候

484
00:15:37,333 --> 00:15:38,133
我们选择了一种

485
00:15:38,133 --> 00:15:40,199
最便宜的no seque数据库

486
00:15:40,366 --> 00:15:42,799
就是芒果数据库来做这个实现

487
00:15:43,500 --> 00:15:44,300
我们还可以选择

488
00:15:44,300 --> 00:15:45,566
如果这个数据量更大的话

489
00:15:45,566 --> 00:15:47,799
我们还可以选择更贵的local数据库

490
00:15:47,966 --> 00:15:49,899
那local数据库它的性能

491
00:15:50,100 --> 00:15:51,900
它的这个性能是有差别的

492
00:15:51,900 --> 00:15:52,333
其中

493
00:15:52,333 --> 00:15:54,933
芒果是在local数据库中间功能最强的

494
00:15:55,300 --> 00:15:58,400
但是所有的local数据库

495
00:15:58,566 --> 00:15:59,799
都至少支持一点

496
00:15:59,800 --> 00:16:00,100
就是

497
00:16:00,100 --> 00:16:04,800
它只支持用key和用组件去做查询

498
00:16:04,866 --> 00:16:06,733
不支持用其他东西去做查询

499
00:16:06,733 --> 00:16:07,999
但是芒果是更强一点

500
00:16:08,000 --> 00:16:09,566
所以他可以用其他东西去做查询

501
00:16:09,766 --> 00:16:11,566
所以我们为了让我们这个设计

502
00:16:11,566 --> 00:16:13,733
可以在其他的local的数据库上呢

503
00:16:13,733 --> 00:16:17,899
也能用而不是局限于用芒果数据库

504
00:16:17,966 --> 00:16:18,933
所以我们在这里

505
00:16:18,933 --> 00:16:20,166
虽然在用的芒果数据库

506
00:16:20,166 --> 00:16:23,266
但是我们在芒果里头只用组件查啊

507
00:16:23,266 --> 00:16:25,466
不用其他的字段去查

508
00:16:26,100 --> 00:16:28,333
就只用芒果的组件去做查询啊

509
00:16:28,333 --> 00:16:30,099
不用芒果的其他字段去做查询

510
00:16:30,100 --> 00:16:31,066
虽然芒果是可以的

511
00:16:31,066 --> 00:16:32,399
但我们不这么不这么用

512
00:16:32,600 --> 00:16:33,200
原因是因为

513
00:16:33,200 --> 00:16:35,933
我们有可能会使用其他的这个

514
00:16:36,700 --> 00:16:38,933
其他的这个no c股数据库啊

515
00:16:39,066 --> 00:16:40,666
那正是因为这样一个原因

516
00:16:40,666 --> 00:16:41,966
他只能用组件厂

517
00:16:41,966 --> 00:16:44,266
就会造成我们的一些问题

518
00:16:44,733 --> 00:16:46,166
比如说我们知道

519
00:16:46,166 --> 00:16:49,066
我们在API上是有一个要求的

520
00:16:49,066 --> 00:16:51,699
这个API求是我们拿到一个运费模板

521
00:16:51,700 --> 00:16:52,866
要看到这个运费模板底下

522
00:16:52,866 --> 00:16:53,966
所有的地区的

523
00:16:54,966 --> 00:16:57,566
那如果说只能用组件查

524
00:16:57,766 --> 00:16:58,966
这其实就做不到了

525
00:16:59,300 --> 00:17:00,700
因为我们拿到一个运费模板

526
00:17:00,700 --> 00:17:02,500
其实我们并不知道这个运费模板底下

527
00:17:02,500 --> 00:17:04,566
所有的芒果的组件是什么

528
00:17:04,600 --> 00:17:05,466
我们需要用一

529
00:17:05,466 --> 00:17:07,733
张表去记录说

530
00:17:07,733 --> 00:17:10,299
Mango里头的这些组件是什么

531
00:17:10,533 --> 00:17:11,333
这就是为什么

532
00:17:11,333 --> 00:17:13,699
我们把这个数据库一拆两半

533
00:17:13,733 --> 00:17:17,099
因为我们横竖要占买CO数据库中间

534
00:17:17,400 --> 00:17:18,333
去做一张表

535
00:17:18,366 --> 00:17:20,599
这张表去记录说在这个底下

536
00:17:20,600 --> 00:17:22,566
他所有的芒果的组件是什么

537
00:17:22,900 --> 00:17:24,133
那我们就索性呢

538
00:17:24,133 --> 00:17:26,299
再把它公用的属性也放过来

539
00:17:26,333 --> 00:17:28,166
因为放过来的属性其实都是可以查

540
00:17:28,166 --> 00:17:29,899
虽然我们没有没有必要去查

541
00:17:30,333 --> 00:17:32,533
但是我们就既然已经做了一张表的话

542
00:17:32,533 --> 00:17:34,966
这个这张表c一些公用的属性

543
00:17:35,000 --> 00:17:36,800
所以最后就变成我们现在看到这个设

544
00:17:36,800 --> 00:17:40,800
这个设计就是一个计件模板

545
00:17:40,866 --> 00:17:42,699
或者说一个计重模板

546
00:17:43,766 --> 00:17:44,866
有一半的属性

547
00:17:44,866 --> 00:17:46,966
有一部分的属性是放在my circle里头

548
00:17:47,166 --> 00:17:49,399
一部分属性是放在芒果里头啊

549
00:17:49,400 --> 00:17:51,166
所以这是这么设计的

550
00:17:51,166 --> 00:17:53,266
这个游览是因为

551
00:17:53,266 --> 00:17:54,966
我们虽然使用芒果数据库

552
00:17:54,966 --> 00:17:55,166
但是

553
00:17:55,166 --> 00:17:57,766
我们只想用芒果数据库最基本的特性

554
00:17:57,800 --> 00:17:59,266
用组件去查值

555
00:17:59,333 --> 00:18:00,933
而不想用它其他的特性

556
00:18:01,000 --> 00:18:01,733
原因是因为

557
00:18:01,733 --> 00:18:04,266
我们还希望以后这个数据量多了

558
00:18:04,266 --> 00:18:06,099
会用到其他的no c股数据库啊

559
00:18:06,100 --> 00:18:07,166
因为我们不止在这个模块

560
00:18:07,166 --> 00:18:08,199
用到no c股数据库

561
00:18:08,733 --> 00:18:10,733
在其他模块也会用到Losiko数据库

562
00:18:11,000 --> 00:18:13,200
Losiko数据库最大的好处就是

563
00:18:13,333 --> 00:18:15,666
它的数据量可以做的非常非常大

564
00:18:15,666 --> 00:18:16,966
我们知道买Skiko数据库

565
00:18:16,966 --> 00:18:19,166
其实单库即算做分秒分库

566
00:18:19,166 --> 00:18:23,099
它的数据量都是有有极限的对吧

567
00:18:23,500 --> 00:18:26,166
但是大家知道在整个电商系统中间

568
00:18:26,166 --> 00:18:27,566
数据量最大的是什么东西

569
00:18:29,200 --> 00:18:30,000
你们觉得

570
00:18:31,533 --> 00:18:32,333
是什么

571
00:18:33,666 --> 00:18:34,866
数量最大的是什么

572
00:18:35,200 --> 00:18:37,400
是大家的选做模块订单

573
00:18:38,266 --> 00:18:41,066
你想想我们这里头最基本的有

574
00:18:41,066 --> 00:18:43,399
商铺一个商铺可以卖很多商品

575
00:18:43,700 --> 00:18:45,800
一个商品可以卖出多少订单呢

576
00:18:46,766 --> 00:18:49,299
对吧所以这些数量级就是往上乘的

577
00:18:49,400 --> 00:18:51,800
在整个电商系统里面

578
00:18:51,800 --> 00:18:54,133
数据量最大的是订单

579
00:18:54,500 --> 00:18:56,800
如果说有某个部分的数据

580
00:18:56,800 --> 00:18:58,733
超过了my c口的极限

581
00:18:58,966 --> 00:19:00,866
首先超过的部分是什么呢

582
00:19:01,500 --> 00:19:02,466
就是订单模块

583
00:19:02,766 --> 00:19:04,699
就是如果说你的数据量大了

584
00:19:04,733 --> 00:19:05,666
会超过极限了

585
00:19:05,666 --> 00:19:07,466
那我们知道在整个电商系统中间

586
00:19:07,466 --> 00:19:10,466
最先超过极限的部分就是订单模块

587
00:19:10,500 --> 00:19:12,733
会超过my c股的上限

588
00:19:13,133 --> 00:19:16,299
所以我们现在很多的这个电商系统

589
00:19:16,300 --> 00:19:17,566
在订单部分

590
00:19:17,566 --> 00:19:19,766
都不会采用满辛苦的数据库

591
00:19:19,766 --> 00:19:21,799
不会采用这个关系数据库去做

592
00:19:21,966 --> 00:19:23,599
而是改用no辛苦的数据库

593
00:19:23,600 --> 00:19:25,933
因为它能够做到更大量的数据

594
00:19:26,133 --> 00:19:27,366
而且数据量大了以后

595
00:19:27,366 --> 00:19:28,799
查询也会变慢

596
00:19:29,300 --> 00:19:30,566
插入也会变慢

597
00:19:31,066 --> 00:19:32,699
所以Noseco数据库

598
00:19:32,700 --> 00:19:36,800
在大数据量上的查询和插入的性能

599
00:19:37,066 --> 00:19:38,699
会比Myco更好

600
00:19:39,200 --> 00:19:41,566
所以我们的第二个交换意义的实验

601
00:19:41,866 --> 00:19:44,599
就是要在芒果上面去做读和写

602
00:19:44,733 --> 00:19:45,999
大家去感受一下

603
00:19:46,333 --> 00:19:48,899
在三台芒果机器上的去做读和写

604
00:19:48,900 --> 00:19:51,200
它的性能和my CICO的差距

605
00:19:51,200 --> 00:19:52,933
到底有多少啊

606
00:19:58,133 --> 00:19:59,599
当然因为芒果是最入门的

607
00:19:59,600 --> 00:20:00,766
最入门级的

608
00:20:00,766 --> 00:20:01,899
这个楼是一个服务器啊

609
00:20:01,900 --> 00:20:03,733
所以它的差距不会那么夸张

610
00:20:04,100 --> 00:20:05,400
当数量越大的时候

611
00:20:05,400 --> 00:20:08,133
这个差距会变得越来越大

612
00:20:09,733 --> 00:20:11,266
那正是因为这样的一个因素啊

613
00:20:11,266 --> 00:20:12,966
所以既然我们在使用local的时候

614
00:20:12,966 --> 00:20:15,333
我们有可能在订单那一块

615
00:20:15,333 --> 00:20:16,366
使用一个

616
00:20:16,800 --> 00:20:19,266
可以称海量数据的local数据库

617
00:20:19,400 --> 00:20:21,700
那我们这里就就重复

618
00:20:21,700 --> 00:20:24,100
再用这个海量数据的local数据库

619
00:20:24,333 --> 00:20:24,999
所以这个地方虽

620
00:20:25,000 --> 00:20:25,933
然数据量不大

621
00:20:25,966 --> 00:20:29,066
但是我们也是打算是用no c口

622
00:20:29,066 --> 00:20:29,466
数据库的

623
00:20:29,466 --> 00:20:32,133
最基本的功能只用组件查对象

624
00:20:32,266 --> 00:20:34,666
所以就把这个拆成了两半

625
00:20:35,066 --> 00:20:36,799
每一个设计都是有原因的

626
00:20:36,800 --> 00:20:37,966
不是无缘无故

627
00:20:37,966 --> 00:20:40,333
我们会这么这么去做设计啊

628
00:20:40,333 --> 00:20:42,666
是因为我们是有一定的考量

629
00:20:42,766 --> 00:20:43,899
才会这么去做的

630
00:20:44,600 --> 00:20:45,966
这个是这个部分

631
00:20:46,533 --> 00:20:47,733
那绿色部分是什么呢

632
00:20:47,733 --> 00:20:49,166
绿色部分就是我们在

633
00:20:50,566 --> 00:20:52,733
运费模块中间最麻烦的一个部分

634
00:20:52,900 --> 00:20:55,533
运费模块中间最麻烦的部分是什么

635
00:20:55,533 --> 00:20:56,333
大家猜

636
00:20:57,100 --> 00:20:58,066
不是算运费

637
00:20:58,733 --> 00:21:00,199
而是分包裹

638
00:21:00,600 --> 00:21:02,533
也就是我们在某些极端情况下

639
00:21:02,533 --> 00:21:07,299
头某一个顾客买了 700公斤的东西

640
00:21:08,300 --> 00:21:10,100
然后一个快递送不出去

641
00:21:10,600 --> 00:21:11,566
不是700公斤吗

642
00:21:11,566 --> 00:21:13,399
70公斤东西一个快递都送不出去了

643
00:21:13,500 --> 00:21:16,800
因为快递他是有这个重量的上限

644
00:21:17,066 --> 00:21:18,533
对无论是重量还是件数

645
00:21:18,533 --> 00:21:21,266
它都有一个体积的上限和重量的上限

646
00:21:21,533 --> 00:21:22,999
所以当你买的东西太多的时候

647
00:21:23,000 --> 00:21:24,266
超过了它那个上限

648
00:21:24,400 --> 00:21:26,866
你就需要把它拆成多个包裹

649
00:21:27,333 --> 00:21:28,133
怎么拆呢

650
00:21:28,533 --> 00:21:29,399
大家就怎么拆

651
00:21:31,100 --> 00:21:33,100
简单拆法就是玩的上限拆

652
00:21:33,100 --> 00:21:34,700
比如说假如我上限是20公斤

653
00:21:34,700 --> 00:21:35,666
是一个包裹的话

654
00:21:35,800 --> 00:21:36,900
那我买了70公斤嘛

655
00:21:36,900 --> 00:21:38,066
我就拆多少个包裹

656
00:21:39,533 --> 00:21:40,499
拆4个包裹

657
00:21:40,500 --> 00:21:42,366
202024对吧

658
00:21:42,766 --> 00:21:45,533
那如果对于快递友好来说

659
00:21:45,533 --> 00:21:46,599
应该均匀的拆

660
00:21:47,333 --> 00:21:49,133
你应该把70公斤拆成多少呢

661
00:21:49,133 --> 00:21:52,466
70公斤拆成15公斤或者16公斤一个

662
00:21:52,566 --> 00:21:54,133
就是每个包裹是一样重

663
00:21:54,333 --> 00:21:55,999
这个对于快递比较友好

664
00:21:56,533 --> 00:21:58,499
如果对于商户比较友好了

665
00:21:58,500 --> 00:21:59,466
他应该这么拆

666
00:21:59,800 --> 00:22:01,566
就是看我当时跟商

667
00:22:01,566 --> 00:22:03,366
跟商家签的是什么协议

668
00:22:03,466 --> 00:22:05,466
如果签的是一个日发

669
00:22:05,466 --> 00:22:06,999
月发3,000单的协议

670
00:22:07,200 --> 00:22:09,400
我就立刻把这订单全部拆到我的

671
00:22:09,400 --> 00:22:13,066
标准的标准的那个包裹上头

672
00:22:13,066 --> 00:22:16,199
因为他签的比如说月发3,000单

673
00:22:16,466 --> 00:22:18,699
那个是说是不超重的包裹

674
00:22:18,700 --> 00:22:19,566
可以发3,000单

675
00:22:19,566 --> 00:22:20,799
超重包裹要额外加钱

676
00:22:20,800 --> 00:22:21,600
是这么签

677
00:22:21,766 --> 00:22:23,533
所以我就宁可把所有的包裹全部拆成

678
00:22:23,533 --> 00:22:26,333
什么呢拆成标准包裹对吧

679
00:22:26,366 --> 00:22:26,766
这样的话

680
00:22:26,766 --> 00:22:28,899
我就能在我的3,000的限额里头

681
00:22:28,900 --> 00:22:30,166
把这些包裹全发出去

682
00:22:30,466 --> 00:22:31,966
对吧超过限额了再说

683
00:22:32,600 --> 00:22:34,766
所以这个拆法我就很讲究了

684
00:22:34,800 --> 00:22:36,866
就看你想怎么拆法

685
00:22:37,300 --> 00:22:39,266
看你以什么东西作为考量来

686
00:22:39,266 --> 00:22:41,399
拆法其实是有各种各样的算法的

687
00:22:41,900 --> 00:22:43,100
我们去年大家应该知道

688
00:22:43,100 --> 00:22:44,600
我们去年的这一届学生之间

689
00:22:44,600 --> 00:22:46,733
是有一些算法的大神的

690
00:22:46,933 --> 00:22:49,799
对吧他们对于做系统没有兴趣

691
00:22:50,133 --> 00:22:52,666
对于做算法有极大的热情

692
00:22:52,966 --> 00:22:54,966
所以就给我们搞出了这么一大堆的

693
00:22:54,966 --> 00:22:55,866
绿色的东西

694
00:22:55,900 --> 00:22:58,000
就是各种各样的拆包算法

695
00:22:58,700 --> 00:22:59,533
塞进去了好多啊

696
00:22:59,533 --> 00:23:00,699
因为他们为了做b座任务

697
00:23:00,700 --> 00:23:03,366
所以说就做自由基的b座任务

698
00:23:03,366 --> 00:23:04,999
也是想出了很多很多的

699
00:23:05,000 --> 00:23:06,566
这个拆包的算法

700
00:23:06,666 --> 00:23:07,733
那我们这门课呢

701
00:23:07,733 --> 00:23:09,899
其实并不是着重点不在算法

702
00:23:09,966 --> 00:23:11,599
我们这门课在证明说

703
00:23:11,600 --> 00:23:12,733
我们这个结构

704
00:23:12,733 --> 00:23:16,099
是允许不断的在上面去开发新的算法

705
00:23:16,333 --> 00:23:19,599
加入进来不影响我们现有代码

706
00:23:19,933 --> 00:23:21,566
所以我们在这部分的设计

707
00:23:21,566 --> 00:23:23,299
是把新的算法

708
00:23:23,300 --> 00:23:26,366
作为我们这个部分的引进点

709
00:23:26,666 --> 00:23:27,466
和变化点

710
00:23:27,466 --> 00:23:29,266
当然算法本身也会改进是吧

711
00:23:29,466 --> 00:23:31,199
算法本身也会有新的算法出来

712
00:23:31,300 --> 00:23:33,766
那我们在这一部分设计的目标就是

713
00:23:33,866 --> 00:23:34,999
我们在新的算法

714
00:23:35,000 --> 00:23:36,600
和先有算法的这个部分来说

715
00:23:36,600 --> 00:23:39,566
要达成系统的开闭原则

716
00:23:39,933 --> 00:23:40,966
最终极的目标

717
00:23:40,966 --> 00:23:43,066
开闭原则用了什么手段呢

718
00:23:43,066 --> 00:23:44,133
用了很复杂的手段

719
00:23:44,133 --> 00:23:44,999
我们综合

720
00:23:45,000 --> 00:23:48,266
使用了三种射击模式

721
00:23:48,300 --> 00:23:50,700
就是我们前面讲过的模板射击模式

722
00:23:50,933 --> 00:23:53,099
还有我们没讲过的策略射击模式

723
00:23:53,166 --> 00:23:55,266
还有调节器的射击模式

724
00:23:55,533 --> 00:23:57,399
用了三种设计模式符合起来

725
00:23:57,400 --> 00:23:58,266
最后形成了

726
00:23:58,266 --> 00:23:59,299
在算法这个部分

727
00:23:59,300 --> 00:24:00,200
就是分包算法

728
00:24:00,200 --> 00:24:03,266
这个部分是符合开币的

729
00:24:03,566 --> 00:24:05,766
新的算法加进来完全不用多现有代码

730
00:24:06,166 --> 00:24:07,299
旧的算法改变的话

731
00:24:07,300 --> 00:24:09,500
只改变旧的算法那一小块

732
00:24:09,500 --> 00:24:12,000
而不会动到其他的部分

733
00:24:13,100 --> 00:24:14,966
所以这是绿色的部分啊

734
00:24:14,966 --> 00:24:15,866
这是绿色对象模型

735
00:24:15,866 --> 00:24:17,099
我们在后面再仔细讲说

736
00:24:17,100 --> 00:24:18,466
这部分设计是怎么做

737
00:24:19,266 --> 00:24:21,266
都是为了去算怎么分包

738
00:24:21,666 --> 00:24:24,333
怎么把包裹分成不同的部分

739
00:24:24,500 --> 00:24:26,800
当然这些部分是不用存数据库的

740
00:24:27,166 --> 00:24:29,866
就是他只是我们在里头写好的代码

741
00:24:29,966 --> 00:24:31,133
然后定义说

742
00:24:31,133 --> 00:24:33,099
我们现在定义是自然配置文件中间

743
00:24:33,100 --> 00:24:34,366
但其实也可以定义

744
00:24:34,366 --> 00:24:35,933
在每一个运费模板里头

745
00:24:36,066 --> 00:24:36,599
去定义说

746
00:24:36,600 --> 00:24:38,600
这个运费模板怎么拆包啊

747
00:24:38,600 --> 00:24:40,200
我们现在是定义在整个系统里的

748
00:24:40,200 --> 00:24:42,733
就整个系统定义了一种拆包的策略

749
00:24:42,933 --> 00:24:45,133
然后他就会按照这个策略来做拆包

750
00:24:46,366 --> 00:24:48,133
我们的数据库来说

751
00:24:48,133 --> 00:24:49,799
因为黄色部分

752
00:24:49,800 --> 00:24:51,566
是放到芒果数据库里去的

753
00:24:51,566 --> 00:24:53,933
绿色部分是不用存到数据库里的

754
00:24:53,933 --> 00:24:55,466
所以数据库就很简单

755
00:24:55,700 --> 00:24:56,366
大家可以看到

756
00:24:56,366 --> 00:24:57,866
我们有一个商铺的数据表

757
00:24:58,200 --> 00:25:00,200
然后他跟运费模板的数据表

758
00:25:00,200 --> 00:25:01,333
是一对多的关系

759
00:25:01,333 --> 00:25:02,666
那我们选择的方向是

760
00:25:02,666 --> 00:25:04,533
从运费模板到商铺

761
00:25:04,533 --> 00:25:05,599
多到1啊

762
00:25:05,866 --> 00:25:08,533
这个关系一对多的关系还是要记的

763
00:25:08,533 --> 00:25:09,999
在数据库里是100%要记的

764
00:25:10,000 --> 00:25:11,666
要不然你做面向功能的方式

765
00:25:11,666 --> 00:25:14,566
是看不到说一个商铺有多少运费模板

766
00:25:15,000 --> 00:25:16,000
所以我们在数据库里

767
00:25:16,000 --> 00:25:17,766
记得是从1到多的这

768
00:25:17,766 --> 00:25:19,399
个方从多到1的这个方向

769
00:25:19,400 --> 00:25:21,300
这样不用建立中间表

770
00:25:22,100 --> 00:25:25,000
模板和地区模板之间也是个一对多的

771
00:25:25,000 --> 00:25:25,166
所以

772
00:25:25,166 --> 00:25:27,466
我们同样采用了从多到1的这个方式

773
00:25:27,466 --> 00:25:28,399
这都是套路啊

774
00:25:28,400 --> 00:25:29,366
都是这个方式

775
00:25:29,666 --> 00:25:30,599
所以就三张表

776
00:25:30,800 --> 00:25:33,900
芒果呢芒果的存储我们不用写设计

777
00:25:33,900 --> 00:25:34,300
为啥

778
00:25:34,300 --> 00:25:36,300
因为芒果就是所有的LOCIFO数据库啊

779
00:25:36,300 --> 00:25:37,166
不管是芒果

780
00:25:37,666 --> 00:25:39,333
它的特征就是整进整出

781
00:25:39,333 --> 00:25:40,566
连Po对象都不要

782
00:25:40,700 --> 00:25:42,000
我们直接把bo对象

783
00:25:42,000 --> 00:25:44,366
丢到芒果数据库里就好了

784
00:25:44,366 --> 00:25:45,766
然后从芒果数据库把它查出来

785
00:25:45,766 --> 00:25:46,766
又回到原样

786
00:25:46,866 --> 00:25:48,999
但是不是满血对象啊

787
00:25:49,000 --> 00:25:51,600
还要build一下把它变成满血对象啊

788
00:25:51,600 --> 00:25:53,800
所以他就不需要设计任何数据表

789
00:25:53,866 --> 00:25:55,366
因为所有的LOCIC口数据库

790
00:25:55,366 --> 00:25:57,733
我们都称之为非结构化数据库

791
00:25:58,066 --> 00:25:59,566
既然是非结构化数据库呢

792
00:25:59,566 --> 00:25:59,999
那我们实际上

793
00:26:00,000 --> 00:26:02,100
我们可以把对象就直接丢进去

794
00:26:02,100 --> 00:26:03,700
对象进对象出

795
00:26:03,700 --> 00:26:05,333
所以它其实连Po对象都没有

796
00:26:05,733 --> 00:26:06,533
他的PU对象

797
00:26:06,533 --> 00:26:09,499
其实就是我们把PU对象当PU对象用

798
00:26:09,700 --> 00:26:10,800
丢丢进去

799
00:26:10,800 --> 00:26:11,466
把它拿出来

800
00:26:11,466 --> 00:26:12,366
就是这个样子

801
00:26:12,800 --> 00:26:13,900
我们现在的这个设计是

802
00:26:13,900 --> 00:26:16,600
我们把所有的运费放到一个集合里

803
00:26:16,600 --> 00:26:18,700
其实啊你要是做的极端化的话

804
00:26:18,966 --> 00:26:20,866
他连他连集合都不用设计

805
00:26:20,866 --> 00:26:23,066
他可以把所有东西都丢到一个集合里

806
00:26:23,333 --> 00:26:25,699
当然这个看起来有点太诡异了是吧

807
00:26:25,933 --> 00:26:27,366
所以我们在芒果部分

808
00:26:27,366 --> 00:26:28,699
就在local的设计时候

809
00:26:28,700 --> 00:26:30,266
我们还是按照模块

810
00:26:30,533 --> 00:26:32,566
或者按照这个特性就画了集合

811
00:26:32,566 --> 00:26:33,933
我们现在定义了一个集合

812
00:26:33,933 --> 00:26:35,099
专门放运费模板

813
00:26:35,466 --> 00:26:37,299
所以无论是重量运费模板

814
00:26:37,300 --> 00:26:38,866
还是件数的运费模板

815
00:26:39,000 --> 00:26:42,000
就通通的丢在了一个集合里

816
00:26:42,000 --> 00:26:43,600
头丢到了一个connection里头

817
00:26:43,866 --> 00:26:45,133
然后后面大家会看到

818
00:26:45,133 --> 00:26:46,766
我们的产品的优惠规则

819
00:26:46,966 --> 00:26:47,699
优惠活动

820
00:26:47,700 --> 00:26:49,500
放了一个集合丢进去

821
00:26:49,766 --> 00:26:50,799
再往后头大家会看到

822
00:26:50,800 --> 00:26:51,700
我们把订单

823
00:26:52,166 --> 00:26:54,499
就是订单和订单的明细做了一个集合

824
00:26:54,666 --> 00:26:56,366
把订单跨界整个丢进去

825
00:26:56,666 --> 00:26:56,999
所以说

826
00:26:57,000 --> 00:26:59,600
他是不需要做任何数据表设计的

827
00:26:59,600 --> 00:27:01,733
我们只是人为给他做了一些集合啊

828
00:27:01,733 --> 00:27:03,299
把这些东西分分别类

829
00:27:03,800 --> 00:27:04,900
就像一个大箱子啊

830
00:27:04,900 --> 00:27:06,666
分分别类的把它放进去

831
00:27:06,666 --> 00:27:08,199
然后所有放的这个箱子里的东西

832
00:27:08,200 --> 00:27:10,766
都只能用key去找到它的字

833
00:27:11,166 --> 00:27:12,466
没有办法用其他东西找

834
00:27:12,466 --> 00:27:13,466
虽然芒果可以

835
00:27:13,533 --> 00:27:15,133
但是我们其实没有用其他的

836
00:27:15,133 --> 00:27:16,533
其他的属性去做查询

837
00:27:16,533 --> 00:27:17,799
只用了它的组件

838
00:27:18,100 --> 00:27:19,800
去找到对应的这个对象

839
00:27:20,133 --> 00:27:22,466
丢进去拿出来就做这个

840
00:27:22,900 --> 00:27:24,333
又组建来做正常改查

841
00:27:24,333 --> 00:27:26,166
就是做这么的一个动作

842
00:27:26,800 --> 00:27:27,500
所以数据表呢

843
00:27:27,500 --> 00:27:28,300
就只有三张

844
00:27:30,466 --> 00:27:32,799
啊我们的具体的这个部分来说

845
00:27:32,800 --> 00:27:35,800
我们的后面的这个模块的完成度

846
00:27:35,800 --> 00:27:36,866
会逐步的降低

847
00:27:36,866 --> 00:27:37,499
大家可以看到

848
00:27:37,500 --> 00:27:40,066
region模块我基本上完成了9*9是吧

849
00:27:40,133 --> 00:27:41,299
所以它还有bug啊

850
00:27:41,300 --> 00:27:42,933
但是我连代码到测试

851
00:27:42,933 --> 00:27:44,566
基本都写完了啊

852
00:27:44,566 --> 00:27:45,366
不能说文字版

853
00:27:45,366 --> 00:27:46,566
九成九是肯定有的

854
00:27:46,866 --> 00:27:48,599
然后支付模块呢

855
00:27:48,600 --> 00:27:51,300
我大概完成了八成到九成之间

856
00:27:51,366 --> 00:27:54,299
只有极少数的代码是没有没有做的

857
00:27:54,300 --> 00:27:55,400
当然没有做测试

858
00:27:55,400 --> 00:27:55,966
所以说

859
00:27:55,966 --> 00:27:57,933
留大同学们去发现一个什么样的问题

860
00:27:57,933 --> 00:27:58,766
去做测试

861
00:27:58,933 --> 00:28:00,866
去看有没有设计上需要改进的

862
00:28:00,866 --> 00:28:02,133
或者代码没有写完的

863
00:28:02,133 --> 00:28:03,066
把它去补全

864
00:28:03,200 --> 00:28:04,533
就做填空题啊

865
00:28:05,100 --> 00:28:05,966
那商铺模块呢

866
00:28:05,966 --> 00:28:07,166
我完成了6层

867
00:28:07,400 --> 00:28:09,766
这6层里头是里头最复杂的6层

868
00:28:10,166 --> 00:28:11,899
简单的部分我我就基本上

869
00:28:11,900 --> 00:28:13,533
把原来的代码给它删掉了

870
00:28:13,866 --> 00:28:15,066
就去年同学没有做了

871
00:28:15,066 --> 00:28:17,199
我把这个商铺的代码基本上删光了

872
00:28:17,200 --> 00:28:18,566
都没有商铺的生产

873
00:28:18,566 --> 00:28:20,333
改查都把它去掉了啊

874
00:28:20,566 --> 00:28:23,866
然后运费模板的真三改查我做完了

875
00:28:23,866 --> 00:28:26,166
运费模板的是增和改

876
00:28:26,866 --> 00:28:28,666
然后我把查留着

877
00:28:28,666 --> 00:28:30,199
查是去年同学做的三

878
00:28:30,200 --> 00:28:31,866
我把它就是三

879
00:28:31,866 --> 00:28:32,666
我把它去掉

880
00:28:33,100 --> 00:28:35,566
然后呢最复杂的部分算这个

881
00:28:35,566 --> 00:28:37,733
计件的算这个部分

882
00:28:37,733 --> 00:28:39,699
我把它全部保留下来啊

883
00:28:39,700 --> 00:28:43,166
所以把这些保留代码进行了整理以后

884
00:28:43,166 --> 00:28:45,866
啊最后形成了我们的这个商铺模块

885
00:28:45,866 --> 00:28:46,099
所以

886
00:28:46,100 --> 00:28:50,000
这里头会有可能有3层到4层的空白

887
00:28:50,400 --> 00:28:52,566
由做b多任务的同学去把它填满

888
00:28:52,900 --> 00:28:55,333
所以到产品文化就会更少

889
00:28:55,333 --> 00:28:58,199
我们可能把它完成都在五成以下

890
00:28:58,333 --> 00:29:00,899
然后把最难最难的部分把它完成

891
00:29:00,900 --> 00:29:01,533
其他的部分

892
00:29:01,533 --> 00:29:03,599
让大家在这个结构上面去做

893
00:29:03,600 --> 00:29:05,466
填满通过这个过程啊

894
00:29:05,466 --> 00:29:07,299
其实是让大家有束缚的

895
00:29:07,300 --> 00:29:08,900
去做设计和实现

896
00:29:09,066 --> 00:29:09,999
就是做设

897
00:29:10,000 --> 00:29:12,166
学会做设计和做代码

898
00:29:12,566 --> 00:29:15,899
不是说你一开始就放开手脚去做

899
00:29:15,933 --> 00:29:16,999
就让大家练字

900
00:29:17,200 --> 00:29:18,266
就开始要在什么地方练

901
00:29:18,266 --> 00:29:19,499
要在九宫格上练

902
00:29:19,500 --> 00:29:21,066
而不是给你一张白纸去练

903
00:29:21,200 --> 00:29:23,966
我们无论是写代码还是做设计

904
00:29:24,333 --> 00:29:25,199
同样也是这个样子

905
00:29:25,200 --> 00:29:28,400
就是慢慢的给束缚很多

906
00:29:28,400 --> 00:29:29,366
基本上结构做好了

907
00:29:29,366 --> 00:29:30,399
只在这结构上做

908
00:29:30,666 --> 00:29:32,399
到慢慢的束缚越放越少

909
00:29:32,400 --> 00:29:32,933
越放越少

910
00:29:32,933 --> 00:29:33,999
到物流模块的时候

911
00:29:34,000 --> 00:29:35,133
我们事情没做了

912
00:29:35,500 --> 00:29:37,866
所以就放由放任同学们去做设计

913
00:29:37,866 --> 00:29:39,133
但是我会矫正你的设计

914
00:29:39,133 --> 00:29:40,599
最后去实现物流模块

915
00:29:40,800 --> 00:29:41,333
选中模块

916
00:29:41,333 --> 00:29:42,733
我就完全不管你的设计了

917
00:29:42,733 --> 00:29:43,766
也不管你实现了

918
00:29:43,766 --> 00:29:45,333
我就看你最后能做成个什么样子

919
00:29:45,333 --> 00:29:46,266
然后根据你最后做成

920
00:29:46,266 --> 00:29:48,499
的样子来做这个评分啊

921
00:29:48,500 --> 00:29:49,133
所以是这样的

922
00:29:49,133 --> 00:29:50,499
逐步放开的过程

923
00:29:50,733 --> 00:29:51,999
好我们先休息一会

