1
00:04:03,200 --> 00:04:04,000
好

2
00:04:05,333 --> 00:04:07,899
呃先说一个通知

3
00:04:07,900 --> 00:04:12,933
就是我们这一周焦瓦一是讨论课

4
00:04:13,000 --> 00:04:15,466
就是上一周是OAD的讨论课

5
00:04:15,466 --> 00:04:17,333
那这一周是焦瓦一的讨论课

6
00:04:17,533 --> 00:04:18,499
讨论的内容呢

7
00:04:18,500 --> 00:04:20,533
主要是我们焦瓦一的第一次实验

8
00:04:20,866 --> 00:04:22,966
所以实验的话是本周末

9
00:04:22,966 --> 00:04:26,666
大家交实验报告和JTL文件啊

10
00:04:26,666 --> 00:04:27,733
这个一定注意

11
00:04:27,800 --> 00:04:30,333
我们的实验是不仅你要撰写实验报告

12
00:04:30,333 --> 00:04:33,299
还需要把实验的原始数据提交上来的

13
00:04:33,366 --> 00:04:35,799
那个原始数据就在那个JTL文件里头

14
00:04:36,000 --> 00:04:37,366
所以最后交作业时候

15
00:04:37,366 --> 00:04:39,366
要交实验报告和JTL文件

16
00:04:39,566 --> 00:04:41,866
那当然跟那个面向对象一样的

17
00:04:41,933 --> 00:04:46,066
就是啊愿意在周四的课上头

18
00:04:46,066 --> 00:04:47,333
给大家分享一下

19
00:04:47,733 --> 00:04:50,333
你们小组的实验做的咋样的

20
00:04:50,333 --> 00:04:51,299
小组啊

21
00:04:51,300 --> 00:04:57,000
就可以在啊周三周二晚上之前

22
00:04:57,133 --> 00:05:00,533
把你们的PPT发到邮箱里

23
00:05:00,533 --> 00:05:02,566
还是那个163的邮箱啊

24
00:05:02,566 --> 00:05:04,666
然后我看过以后

25
00:05:04,666 --> 00:05:05,566
如果OK的话

26
00:05:05,566 --> 00:05:07,199
就可以在周四的课上发言

27
00:05:07,200 --> 00:05:10,700
那因为面向对象是呃

28
00:05:10,700 --> 00:05:11,400
两个班

29
00:05:11,400 --> 00:05:14,333
所以说我们一共可以有6个组发言

30
00:05:14,566 --> 00:05:17,133
这个应该有一部分小组是全组的

31
00:05:17,133 --> 00:05:18,733
没有选OAD的

32
00:05:18,800 --> 00:05:22,566
所以呃焦瓦伊的拿分的

33
00:05:22,700 --> 00:05:26,566
这个难度是比OAD要小一些的啊

34
00:05:26,600 --> 00:05:28,866
因为整个小组数会更少

35
00:05:29,300 --> 00:05:31,166
那特瓦一的所有的实验

36
00:05:31,166 --> 00:05:33,533
也是以小组为单位来提交的

37
00:05:33,966 --> 00:05:36,366
所以不管你的小组里头有多少人选了

38
00:05:36,366 --> 00:05:39,366
叫Y1 就是提交一份就可以了

39
00:05:39,366 --> 00:05:40,533
有个别小组的话

40
00:05:40,533 --> 00:05:41,766
可能只有一个人选了

41
00:05:41,766 --> 00:05:45,166
叫Y1 那就也需要提交一份啊

42
00:05:45,166 --> 00:05:47,499
就是以同样的小组为单位

43
00:05:47,533 --> 00:05:49,999
来提交我们的实验

44
00:05:51,400 --> 00:05:54,933
好那我们回来再来讲这个

45
00:05:56,166 --> 00:06:00,299
呃我们还没有讲完的Grasp的设计方法

46
00:06:00,866 --> 00:06:02,999
我们在上上周的

47
00:06:03,000 --> 00:06:06,266
时候啊讲到了创建者和信息专家

48
00:06:06,566 --> 00:06:09,566
然后以我们若干所有的模块中间

49
00:06:09,566 --> 00:06:13,333
最容易的地区模块来讲

50
00:06:13,333 --> 00:06:15,399
说这个创建者和信息专家

51
00:06:15,400 --> 00:06:17,866
是怎样用在这个模块里头设计的啊

52
00:06:17,866 --> 00:06:18,399
我们知道

53
00:06:18,400 --> 00:06:21,300
在整个的设计者所有的代码中间

54
00:06:21,466 --> 00:06:25,199
我们其实柔和使用了面向对象

55
00:06:25,200 --> 00:06:26,700
和面向功能的方式

56
00:06:27,100 --> 00:06:30,400
我们会选择那些呃

57
00:06:30,700 --> 00:06:33,533
能在面向对象上头去实现的这些业务

58
00:06:33,533 --> 00:06:35,799
啊用面向对象的方式去实现

59
00:06:35,933 --> 00:06:38,299
那最常用的两种方式

60
00:06:38,300 --> 00:06:40,133
就是创建者和信息专家

61
00:06:40,366 --> 00:06:42,933
创建者决定了对象如何创建

62
00:06:42,933 --> 00:06:44,933
这样避免我们把所有的对象创建

63
00:06:44,933 --> 00:06:47,499
写在一个某一个特定的方法中间啊

64
00:06:47,500 --> 00:06:50,133
他其实也是把创建对象的这个代码

65
00:06:50,466 --> 00:06:53,866
按照我们谁拥有他的信息

66
00:06:53,866 --> 00:06:56,066
或者谁是他的主体的这种方式

67
00:06:56,066 --> 00:06:58,066
给他分配给不同的对象中间去

68
00:06:58,300 --> 00:06:59,066
而信息专家

69
00:06:59,066 --> 00:07:00,533
都使得我们在每一个对象中间

70
00:07:00,533 --> 00:07:01,499
就有了方法

71
00:07:01,700 --> 00:07:03,100
因为这些方法

72
00:07:03,100 --> 00:07:07,200
就是用来去操作这个对象的属性的

73
00:07:07,266 --> 00:07:08,599
那为什么会有这个方法呢

74
00:07:08,600 --> 00:07:10,600
是因为我们的API代表我们的功能

75
00:07:10,600 --> 00:07:12,933
我们会把API分成两个职责

76
00:07:13,000 --> 00:07:14,566
然后看哪些对象

77
00:07:14,566 --> 00:07:17,266
具备完成这些职责所需要的信息

78
00:07:17,400 --> 00:07:18,933
就把这些职责分配给他

79
00:07:18,933 --> 00:07:20,866
那从而使得他有了这个方法

80
00:07:21,600 --> 00:07:23,500
地区模块相对比较简单一点

81
00:07:23,500 --> 00:07:26,366
因为它只有一个对象一张表啊

82
00:07:26,366 --> 00:07:27,966
所以大家看不到说

83
00:07:27,966 --> 00:07:30,099
它的职责分配的部分

84
00:07:30,100 --> 00:07:31,600
更复杂的东西

85
00:07:31,933 --> 00:07:32,466
呃

86
00:07:32,466 --> 00:07:35,066
我们的支付模块相对于地区模块来说

87
00:07:35,066 --> 00:07:37,199
就相对比较复杂一点

88
00:07:37,933 --> 00:07:39,466
呃上一周啊

89
00:07:39,466 --> 00:07:41,299
大家在做讨论课的这一周里头

90
00:07:41,300 --> 00:07:42,666
我把地区模

91
00:07:42,700 --> 00:07:45,266
把这个支付模块完整的整理完了

92
00:07:45,266 --> 00:07:47,899
那目前的代码是可以编译无措的

93
00:07:47,933 --> 00:07:50,499
但是我没有去做调试啊

94
00:07:50,566 --> 00:07:54,266
测试和调试的任务我分成了三个

95
00:07:55,900 --> 00:07:57,466
对分成了3个

96
00:07:57,800 --> 00:07:59,533
第二阶段的必做任务啊

97
00:07:59,533 --> 00:08:00,899
放到课程网站上去了

98
00:08:00,900 --> 00:08:02,900
那其中呃

99
00:08:02,900 --> 00:08:05,800
还包括两个我们的模拟模块啊

100
00:08:05,800 --> 00:08:06,733
待会我会讲

101
00:08:06,733 --> 00:08:08,499
我们有两个模拟模块

102
00:08:08,566 --> 00:08:13,499
所以支付的这个模块一共放出了5个

103
00:08:13,666 --> 00:08:14,999
第二阶段的必做任务

104
00:08:16,100 --> 00:08:18,133
这一部分的这个结构啊

105
00:08:18,133 --> 00:08:19,766
我做了一点点的调整

106
00:08:19,766 --> 00:08:21,466
就是跟我们上周

107
00:08:21,566 --> 00:08:23,333
上上周所看到那个包图

108
00:08:23,333 --> 00:08:24,866
是有一定的差别

109
00:08:25,266 --> 00:08:27,299
那主要的调整是

110
00:08:27,300 --> 00:08:31,666
我们可以看到我们这样的一个结构

111
00:08:32,600 --> 00:08:35,600
从control层Server层到层到map层

112
00:08:36,000 --> 00:08:38,100
那每一层的这个职责

113
00:08:38,500 --> 00:08:42,966
我们需要写的代码是是比较清楚的

114
00:08:43,100 --> 00:08:45,666
这里头无关面向对象的设计

115
00:08:45,666 --> 00:08:47,766
只是整个软件的体系结构设计

116
00:08:47,933 --> 00:08:51,899
所以大家在这一个这一个模块中间

117
00:08:51,900 --> 00:08:53,466
其实在所有的模块中间都这样的

118
00:08:53,466 --> 00:08:54,299
在控制层

119
00:08:54,300 --> 00:08:57,300
看到的全是输入数据和输出数据

120
00:08:57,666 --> 00:08:58,799
就是输入什么数据

121
00:08:58,800 --> 00:09:00,666
我做数据格式的转换

122
00:09:00,966 --> 00:09:02,166
输出什么数据

123
00:09:02,166 --> 00:09:03,999
我拿到的是对象模型

124
00:09:04,000 --> 00:09:04,933
我把对象模型

125
00:09:04,933 --> 00:09:05,533
转成

126
00:09:05,533 --> 00:09:08,899
我们在前端所希望看到的这个数据

127
00:09:09,000 --> 00:09:10,066
这一切的代码

128
00:09:10,066 --> 00:09:12,099
都是在控制器层去完成的

129
00:09:12,500 --> 00:09:15,400
收集层的代码相对比较单薄

130
00:09:15,400 --> 00:09:18,200
因为我们把身份层的很多的业务

131
00:09:18,400 --> 00:09:19,966
按照面向对象的原则

132
00:09:20,066 --> 00:09:22,799
分给了do对象或者do对象

133
00:09:23,133 --> 00:09:24,933
所以目前大家在收费层代码中间

134
00:09:24,933 --> 00:09:27,166
看的看到的是比较单薄的

135
00:09:27,200 --> 00:09:28,866
但依然还会有一些代码

136
00:09:28,866 --> 00:09:31,333
这些代码主要是用来做资质分配的

137
00:09:31,400 --> 00:09:32,533
那还有一些代码

138
00:09:32,533 --> 00:09:35,166
就是我们说的非面向对象的方式

139
00:09:35,166 --> 00:09:36,466
所实现的那个功能

140
00:09:36,466 --> 00:09:37,699
就是用面向功能的方式

141
00:09:37,700 --> 00:09:38,766
实现的这个功能

142
00:09:38,800 --> 00:09:41,500
那这些代码会在收费层和稻城

143
00:09:41,900 --> 00:09:42,933
稻城的话

144
00:09:43,400 --> 00:09:45,666
单纯的各个道的这个代码

145
00:09:45,666 --> 00:09:47,666
就是用来做征商改查的

146
00:09:47,866 --> 00:09:48,366
那其中

147
00:09:48,366 --> 00:09:51,266
我们主要的代码是在那个Bo里头

148
00:09:51,266 --> 00:09:52,866
就是Bo和do这个包里头

149
00:09:52,866 --> 00:09:55,466
这就是我们所说的对象模型啊

150
00:09:55,466 --> 00:09:57,399
我们我们现在还是把它叫做Bo

151
00:09:57,600 --> 00:10:00,133
其实就是我们的这个对象模型

152
00:10:00,500 --> 00:10:03,200
那对于支付模块来说

153
00:10:03,200 --> 00:10:03,933
我们可以看到

154
00:10:03,933 --> 00:10:06,466
除了我们在region那个模块中间

155
00:10:06,466 --> 00:10:07,099
看到的Bo

156
00:10:07,100 --> 00:10:07,733
那个包以外

157
00:10:07,733 --> 00:10:09,699
我们还有另外一个包叫做China

158
00:10:10,100 --> 00:10:10,700
这个是什么呢

159
00:10:10,700 --> 00:10:11,900
这个就是支付渠道

160
00:10:12,000 --> 00:10:14,300
因为支付模块相对于地区模块来说

161
00:10:14,300 --> 00:10:15,700
它比较复杂的部分是

162
00:10:15,700 --> 00:10:18,866
它需要接多种支付的渠道

163
00:10:19,133 --> 00:10:22,099
所以我们把支付渠道的一部分代码

164
00:10:22,100 --> 00:10:23,333
也放到了这个稻城

165
00:10:23,333 --> 00:10:25,066
我们单给他开了一个包啊

166
00:10:25,066 --> 00:10:25,866
叫做channel

167
00:10:26,000 --> 00:10:27,666
那最后是它的Mapper

168
00:10:28,066 --> 00:10:28,766
Mapper的话

169
00:10:28,766 --> 00:10:31,266
我们在地区这个模块里头

170
00:10:31,266 --> 00:10:32,533
采用了另外一种技术

171
00:10:32,533 --> 00:10:34,599
就是我们用的是metas的技术

172
00:10:34,800 --> 00:10:36,333
用了Metas Generator

173
00:10:36,333 --> 00:10:38,933
去产生了它的自动的代码

174
00:10:38,933 --> 00:10:40,766
这些代码都在map Generator底下

175
00:10:40,766 --> 00:10:41,766
包括它的Mapper

176
00:10:41,766 --> 00:10:43,266
它都是它的PU

177
00:10:43,800 --> 00:10:45,933
它的这个secure provider

178
00:10:45,933 --> 00:10:48,266
都在这个Generator的那个包里头

179
00:10:48,366 --> 00:10:50,299
那除了自动生成代码以外

180
00:10:50,300 --> 00:10:53,066
我们也手工写了一部分的Meta代码

181
00:10:53,133 --> 00:10:55,299
所以放在了这个menu里头啊

182
00:10:55,366 --> 00:10:58,166
那这是Meta的这两个部分

183
00:10:58,200 --> 00:11:01,266
那还有就是跟外部的接口

184
00:11:01,666 --> 00:11:03,133
我们跟支付宝和微信

185
00:11:03,133 --> 00:11:04,299
目前在这个模块中间

186
00:11:04,300 --> 00:11:08,066
做了微信宝和微微信支付

187
00:11:08,066 --> 00:11:12,066
和支付宝两个支付渠道的接口

188
00:11:12,400 --> 00:11:13,166
这部分的接

189
00:11:13,166 --> 00:11:15,333
口我们也放到了map城这里

190
00:11:15,333 --> 00:11:17,266
用到了我们在后面会讲到的

191
00:11:17,266 --> 00:11:19,399
微服务的一个open friend的技术

192
00:11:19,700 --> 00:11:22,533
就是他会把啊基于restful

193
00:11:22,533 --> 00:11:23,566
因为这两个模块

194
00:11:23,566 --> 00:11:26,133
目前都是提供了基于restful API的

195
00:11:26,133 --> 00:11:28,566
我们在之前叙旧分析中间有讲到

196
00:11:28,566 --> 00:11:30,933
阿里是脑接口

197
00:11:31,600 --> 00:11:34,933
微信支付是基于RESO API的接口啊

198
00:11:34,933 --> 00:11:35,699
在今年

199
00:11:35,700 --> 00:11:38,766
就是在我们讲课的这个时间里头

200
00:11:38,866 --> 00:11:40,966
阿里要把它的接口做了升级

201
00:11:41,266 --> 00:11:42,533
所以目前这个代码

202
00:11:42,533 --> 00:11:45,133
我们是按照阿里的最新的接口来写的

203
00:11:45,133 --> 00:11:47,666
就是它的V3第三版本的接口来写的

204
00:11:47,666 --> 00:11:50,199
是个完全基于rest of API的接口

205
00:11:50,400 --> 00:11:53,500
这样就跟微信支付是保持一致了

206
00:11:53,700 --> 00:11:54,933
这两部分的接口

207
00:11:54,933 --> 00:11:57,966
我们用了一种open fine技术

208
00:11:58,066 --> 00:12:00,499
把它模拟成为呃

209
00:12:00,500 --> 00:12:03,300
类似于我们control的那种代码啊

210
00:12:03,300 --> 00:12:05,533
来调用它的接口

211
00:12:05,666 --> 00:12:07,566
这个在加瓦伊伊的微服务

212
00:12:07,566 --> 00:12:08,299
那个体系结构

213
00:12:08,300 --> 00:12:10,300
中间会讲这个技术

214
00:12:10,300 --> 00:12:11,966
但是我们会看到这部分的代码

215
00:12:11,966 --> 00:12:13,999
因为它相对比较简单啊

216
00:12:14,000 --> 00:12:14,933
所以大家会知道

217
00:12:14,933 --> 00:12:18,366
说那两个部分的代码是用来跟啊

218
00:12:18,366 --> 00:12:20,566
微信和支付宝来做接口的

219
00:12:20,900 --> 00:12:23,000
那为什么会放在Mapper层

220
00:12:23,066 --> 00:12:24,899
因为我们这个结构

221
00:12:24,900 --> 00:12:27,800
不是一个单纯的MVC的结构

222
00:12:27,933 --> 00:12:30,366
这个结构是一个MVC的结构

223
00:12:30,366 --> 00:12:32,766
融合了六边形的体系结构

224
00:12:33,000 --> 00:12:37,400
所以我们把跟外围系统接口的代码

225
00:12:37,766 --> 00:12:39,966
也把它放到了最外头一圈

226
00:12:39,966 --> 00:12:42,066
就实际上我们在这个体育结构中间

227
00:12:42,166 --> 00:12:43,199
control层和map层

228
00:12:43,200 --> 00:12:44,533
是我们六边形体育结构的

229
00:12:44,533 --> 00:12:45,533
最外头那一圈

230
00:12:46,166 --> 00:12:49,333
然后中间的是service

231
00:12:49,366 --> 00:12:53,466
再往中间的是我们的道

232
00:12:54,000 --> 00:12:57,600
包括在道上面所实现的Bo和

233
00:12:57,766 --> 00:13:00,299
Controller所以Bo和channel

234
00:13:00,300 --> 00:13:02,166
这是我们最核心的部分

235
00:13:02,300 --> 00:13:04,866
然后在外头一圈是我们的设备

236
00:13:04,900 --> 00:13:09,333
然后在外头一圈是Controller和matter啊

237
00:13:09,333 --> 00:13:09,599
那

238
00:13:09,600 --> 00:13:12,533
这是我们整个的这样的一个体系结构

239
00:13:14,766 --> 00:13:17,733
呃对象模型做了一点点的修改

240
00:13:17,733 --> 00:13:19,166
这个修改其实就是

241
00:13:19,166 --> 00:13:21,133
原本我们的这个

242
00:13:21,666 --> 00:13:24,166
是把对账集中在age里头的啊

243
00:13:24,166 --> 00:13:25,066
age里头的

244
00:13:25,166 --> 00:13:26,799
我们现在的这个做法

245
00:13:26,800 --> 00:13:28,933
是把对账全部改成了

246
00:13:28,933 --> 00:13:30,699
从transaction指向对账

247
00:13:30,700 --> 00:13:32,466
而不是从对账指向transaction

248
00:13:32,466 --> 00:13:34,666
这个方向也做了一点修改

249
00:13:34,666 --> 00:13:36,866
这个主要为什么会做修改的原因

250
00:13:37,200 --> 00:13:38,266
是因为我们在写

251
00:13:38,366 --> 00:13:39,966
我在整理API时候发现

252
00:13:40,000 --> 00:13:43,133
从lajor指向transaction不好处理

253
00:13:43,200 --> 00:13:44,166
因为大家可以看到

254
00:13:44,166 --> 00:13:47,266
transaction这边它是一个负类

255
00:13:47,800 --> 00:13:49,566
那later到底指向的是

256
00:13:49,566 --> 00:13:50,866
具体是哪个指类

257
00:13:50,866 --> 00:13:52,199
在代码上头比较难处理

258
00:13:52,200 --> 00:13:54,100
所以我就索性给它换了个方向

259
00:13:54,266 --> 00:13:56,899
其他没有去做大的修改啊

260
00:13:57,800 --> 00:13:59,266
啊数据库的设计

261
00:13:59,300 --> 00:14:00,966
也是因为这个方向改变了

262
00:14:00,966 --> 00:14:03,499
所以在所有的这个表中间

263
00:14:03,500 --> 00:14:05,766
都改成了指向nature ID啊

264
00:14:05,766 --> 00:14:08,466
其他都没有去做大的变动

265
00:14:10,266 --> 00:14:11,999
我们来一个一个的API来讲说

266
00:14:12,000 --> 00:14:12,333
这里头

267
00:14:12,333 --> 00:14:15,399
是怎样使用创建者和信息专家的

268
00:14:16,066 --> 00:14:18,733
呃我们第一个API给大家讲的是

269
00:14:18,933 --> 00:14:22,599
我们定义的无效支付渠道

270
00:14:22,900 --> 00:14:24,400
这个API大家知道

271
00:14:24,400 --> 00:14:25,933
这个API的功能就是

272
00:14:25,933 --> 00:14:28,766
我们的平台要把比如说微信

273
00:14:28,766 --> 00:14:30,699
我们全平台都不用了

274
00:14:31,000 --> 00:14:32,733
所以我们定义了一个API

275
00:14:32,766 --> 00:14:34,466
允许我们平台的管理员

276
00:14:34,466 --> 00:14:36,766
去把比如说微信支付的这个渠道

277
00:14:36,766 --> 00:14:37,666
全部关掉

278
00:14:37,733 --> 00:14:40,499
那所有的商家的微信支付渠道

279
00:14:41,000 --> 00:14:42,666
其实都是不能用来支付的啊

280
00:14:42,666 --> 00:14:45,199
这就可能是我们跟微信吵崩了

281
00:14:45,500 --> 00:14:46,866
所以我们会在商务上头

282
00:14:46,866 --> 00:14:48,333
把这个给它关掉

283
00:14:48,466 --> 00:14:50,166
或者把支付宝啊把它关掉

284
00:14:50,166 --> 00:14:52,533
就是这个API来完成的

285
00:14:52,900 --> 00:14:56,133
那这个API的这个设计

286
00:14:56,133 --> 00:14:58,166
是是怎么做的呢

287
00:14:58,200 --> 00:14:59,000
我们同样

288
00:14:59,000 --> 00:15:01,600
我们还是从这个收费层开始讲起

289
00:15:01,600 --> 00:15:03,066
因为control城没什么好说的

290
00:15:03,066 --> 00:15:04,933
就是负责输入和输出数据

291
00:15:05,066 --> 00:15:06,333
对于这个API来说

292
00:15:06,333 --> 00:15:08,133
在control城其实是没有代码的

293
00:15:08,133 --> 00:15:10,566
因为它的输入数据很简单

294
00:15:10,566 --> 00:15:13,966
没有输出数据返回的就是成功啊

295
00:15:14,333 --> 00:15:16,766
所以我们从收费层代码开始讲起

296
00:15:16,966 --> 00:15:18,133
我们在收费层代码上呢

297
00:15:18,133 --> 00:15:22,466
做了一个invalid con imatter的channel

298
00:15:22,566 --> 00:15:23,733
这是面向功能的

299
00:15:23,733 --> 00:15:25,333
就是因为我们看到的是一个API

300
00:15:25,333 --> 00:15:26,499
API是一个功能

301
00:15:26,600 --> 00:15:29,566
就是无效支付渠道是一个功能

302
00:15:29,666 --> 00:15:31,566
所以在社会层上就有一个方法

303
00:15:31,566 --> 00:15:33,199
这个方法是实现了

304
00:15:33,800 --> 00:15:35,500
把我们的这个某一个支付渠道

305
00:15:35,500 --> 00:15:37,300
给他关闭啊

306
00:15:37,300 --> 00:15:38,933
这样的一种功能

307
00:15:39,266 --> 00:15:40,533
传建了两个参数

308
00:15:40,566 --> 00:15:41,733
一个是我们要关闭的

309
00:15:41,733 --> 00:15:43,266
那个支付渠道的ID

310
00:15:43,366 --> 00:15:45,566
还有是谁来关的啊

311
00:15:45,566 --> 00:15:47,333
因为我们整个系统人员都是有记录

312
00:15:47,333 --> 00:15:49,399
记录是谁去动这个事情的

313
00:15:49,733 --> 00:15:51,899
所以这是我们针对这个功能

314
00:15:51,900 --> 00:15:52,766
所传进去的

315
00:15:52,766 --> 00:15:54,099
这两个参数

316
00:15:54,466 --> 00:15:55,766
那这样的一个事情

317
00:15:55,766 --> 00:15:56,733
我们可以看到

318
00:15:56,733 --> 00:15:57,766
我们在里头

319
00:15:57,766 --> 00:16:00,799
把这个功能分成了两个职责

320
00:16:01,400 --> 00:16:03,866
一个职责是我们要找到一个对象

321
00:16:04,333 --> 00:16:05,066
找到什么呢

322
00:16:05,066 --> 00:16:07,366
找到渠道这个对象

323
00:16:07,900 --> 00:16:11,300
所以我们找到这个渠道的

324
00:16:11,300 --> 00:16:12,866
这个对象的一个职责

325
00:16:12,933 --> 00:16:15,899
我们把它分配给了稻城的channel到

326
00:16:16,100 --> 00:16:18,066
这个不是面向对象

327
00:16:18,200 --> 00:16:19,933
这个是面向功能

328
00:16:20,166 --> 00:16:22,666
就是我们在service层上面写的代码

329
00:16:22,666 --> 00:16:23,966
在稻城所表现出

330
00:16:23,966 --> 00:16:25,766
来的这些API其实都是功能

331
00:16:26,266 --> 00:16:27,933
所以我们在channel当中呢

332
00:16:27,933 --> 00:16:28,733
做了一个方法

333
00:16:28,733 --> 00:16:30,066
这个方法是find把ID

334
00:16:30,066 --> 00:16:33,133
这个会去调map层去查到这个对象

335
00:16:33,366 --> 00:16:35,099
所以我们给他一个参数channel ID

336
00:16:35,100 --> 00:16:36,866
让他找到我们的channel对象

337
00:16:37,200 --> 00:16:40,600
第一个职责的分配过程是非面向对象

338
00:16:40,866 --> 00:16:42,699
就是单纯是功能

339
00:16:42,700 --> 00:16:46,200
我们完成了从数据库里按照这个ID

340
00:16:46,200 --> 00:16:49,900
把这个对象找到的这个功能

341
00:16:50,600 --> 00:16:52,166
拿到这个对象以后

342
00:16:52,400 --> 00:16:53,900
我们做的事情是

343
00:16:53,900 --> 00:16:57,900
我们把整个无效平台的这个职责

344
00:16:58,200 --> 00:17:00,166
分配给了这个对象

345
00:17:00,300 --> 00:17:02,600
所以我们第三步做的这个事情

346
00:17:02,600 --> 00:17:03,500
是面向对象

347
00:17:04,100 --> 00:17:05,400
这里头用的是什么呢

348
00:17:05,400 --> 00:17:07,700
用的是信息专家的原则

349
00:17:07,866 --> 00:17:09,499
为什么是信息专家的原则

350
00:17:09,500 --> 00:17:10,466
因为我们发现

351
00:17:10,466 --> 00:17:13,599
当我们要把一个支付渠道去无效的

352
00:17:13,600 --> 00:17:14,333
这个过程中间

353
00:17:14,333 --> 00:17:16,333
他需要做的事情是

354
00:17:16,333 --> 00:17:18,499
首先要把那个支付渠道的状态

355
00:17:18,800 --> 00:17:19,866
给他关闭掉

356
00:17:20,266 --> 00:17:23,099
然后会使得这个支付渠道所

357
00:17:24,900 --> 00:17:27,166
关联的所有商铺的支付渠道

358
00:17:27,200 --> 00:17:28,700
也会变成无效的

359
00:17:29,100 --> 00:17:30,866
所以这个信息

360
00:17:30,866 --> 00:17:33,466
首先这个支付渠道的状态

361
00:17:33,466 --> 00:17:34,733
是属于支付渠道

362
00:17:34,733 --> 00:17:35,533
这个对象

363
00:17:35,800 --> 00:17:37,166
因为他具备

364
00:17:37,166 --> 00:17:40,533
完成这个职责所需要的信息

365
00:17:41,333 --> 00:17:43,166
所以我们用信息专家的原则

366
00:17:43,166 --> 00:17:45,266
把这个职责分配给了channel

367
00:17:45,266 --> 00:17:45,866
而这个channel

368
00:17:45,866 --> 00:17:47,899
就是我们在前面用功能找到的

369
00:17:47,900 --> 00:17:48,700
这个对象

370
00:17:49,133 --> 00:17:50,533
把职责分配给他

371
00:17:50,533 --> 00:17:53,166
所以他就有了一个方法叫做invalid

372
00:17:53,733 --> 00:17:56,799
把一个channel对象给他无效掉

373
00:17:57,000 --> 00:17:59,100
那他是怎样去做这个事情的呢

374
00:17:59,100 --> 00:17:59,500
这里头

375
00:17:59,500 --> 00:18:02,166
我们又再一次使用了面相功能的方式

376
00:18:02,166 --> 00:18:03,499
因为我们后来发现

377
00:18:03,600 --> 00:18:05,700
我们不仅仅会在这里去无效

378
00:18:05,700 --> 00:18:08,300
他也会在会使得

379
00:18:08,300 --> 00:18:09,900
他从无效变成有效

380
00:18:10,966 --> 00:18:12,166
从无效变成有效

381
00:18:12,166 --> 00:18:13,266
从有效变成无效

382
00:18:13,266 --> 00:18:15,199
其实在代码上头是可以重用的

383
00:18:15,333 --> 00:18:17,333
所以里头我们又写了自己的一个方法

384
00:18:17,333 --> 00:18:18,933
叫做change status

385
00:18:18,933 --> 00:18:19,599
这个方法

386
00:18:19,600 --> 00:18:21,533
这个不是面向对象

387
00:18:21,766 --> 00:18:24,166
第四步这个设计做的不是面向对象

388
00:18:24,166 --> 00:18:27,466
单纯的是面向功能的做法

389
00:18:27,466 --> 00:18:29,666
也就是因为我们发现他有两个方法

390
00:18:29,666 --> 00:18:31,466
里头有相同的代码

391
00:18:31,766 --> 00:18:32,866
那当然我们知道

392
00:18:32,866 --> 00:18:34,933
设计的一个最基本的原则

393
00:18:34,933 --> 00:18:38,299
就是不要让任何的代码重复写两遍

394
00:18:38,600 --> 00:18:40,100
所以我们把它提提出来

395
00:18:40,100 --> 00:18:42,866
变成一个方法叫做change status

396
00:18:42,933 --> 00:18:43,766
在这个方法中间

397
00:18:43,766 --> 00:18:45,066
我们会判断说

398
00:18:45,066 --> 00:18:49,333
我们能不能把这个tender状态

399
00:18:49,333 --> 00:18:52,566
从当前状态改到你要去的状态

400
00:18:52,566 --> 00:18:53,866
我们现在是调这个方法

401
00:18:53,866 --> 00:18:55,966
去把它改成隐瞒的状态

402
00:18:55,966 --> 00:18:58,266
当然我们是会去做判断它能不能改

403
00:18:58,400 --> 00:18:59,933
如果它能改的话

404
00:18:59,933 --> 00:19:02,133
它就创建了一个新的签到对象

405
00:19:02,133 --> 00:19:04,399
然后把这个签到对象附上它要改的值

406
00:19:04,500 --> 00:19:06,466
这步我们没有把它画出来

407
00:19:06,466 --> 00:19:09,366
然后再再调签到到的方法

408
00:19:09,366 --> 00:19:10,533
把它更新到

409
00:19:10,533 --> 00:19:11,299
用了seven方法

410
00:19:11,300 --> 00:19:12,800
其实是把它更新到

411
00:19:13,133 --> 00:19:14,266
我们的数据库里去

412
00:19:14,266 --> 00:19:15,166
这就完成了

413
00:19:15,566 --> 00:19:18,866
所以这样的一个无效化的

414
00:19:18,866 --> 00:19:22,666
这个无效渠道的这样的一个设计

415
00:19:22,666 --> 00:19:23,366
我们可以看到

416
00:19:23,366 --> 00:19:27,299
在里头我们做了第二部第三部第四部

417
00:19:27,300 --> 00:19:28,566
第五部第六部

418
00:19:28,566 --> 00:19:30,066
做了六部的设计

419
00:19:30,166 --> 00:19:32,399
其中仅仅第三部

420
00:19:32,800 --> 00:19:36,533
是用的面向对象的设计的想法

421
00:19:36,666 --> 00:19:38,966
用了信息专家的原则

422
00:19:39,133 --> 00:19:41,266
把这个职责分配给了channel

423
00:19:41,500 --> 00:19:43,800
从而使得channel有了一个方法

424
00:19:43,800 --> 00:19:44,933
叫做invalid

425
00:19:45,333 --> 00:19:47,666
而第二步第四步第五步第六步

426
00:19:47,700 --> 00:19:50,266
全部是非面向对象

427
00:19:50,500 --> 00:19:53,333
就是面向功能的这个设计

428
00:19:53,666 --> 00:19:55,566
所以从这个非常简单例子

429
00:19:55,566 --> 00:19:56,299
大家可以看到

430
00:19:56,300 --> 00:19:57,500
我们在做设计过程中间

431
00:19:57,500 --> 00:20:00,966
并不是单纯的在使用面向对象的设计

432
00:20:01,900 --> 00:20:02,866
非面向对象的设计

433
00:20:02,866 --> 00:20:04,666
是我们一个基本的设计方法

434
00:20:04,800 --> 00:20:06,133
就是你可以看到

435
00:20:06,133 --> 00:20:08,066
其实在整体代码中间也是这样

436
00:20:08,333 --> 00:20:10,399
超过一半以上的代码

437
00:20:10,400 --> 00:20:13,200
不是用面向对象的方式去设计和实现

438
00:20:13,566 --> 00:20:16,399
是用面向功能的方式去设计实现的

439
00:20:16,466 --> 00:20:19,299
但是我们在里头的很关键的一些

440
00:20:19,966 --> 00:20:21,366
一些方向性的地方

441
00:20:21,700 --> 00:20:23,666
会用面向对象的设计方法

442
00:20:23,666 --> 00:20:25,466
我们这里的这个方向性的地方

443
00:20:25,466 --> 00:20:25,866
就是这个

444
00:20:25,866 --> 00:20:28,533
第三步如果大家想象一下

445
00:20:28,533 --> 00:20:31,266
你不用面向对象的方式去设计的话

446
00:20:31,666 --> 00:20:35,266
所有的我们的3456这些代码会在哪呢

447
00:20:37,566 --> 00:20:39,566
3456这些代码会在哪呢

448
00:20:39,966 --> 00:20:44,166
会在China service的这个方法里头

449
00:20:44,733 --> 00:20:46,666
就是你如果不用面向对象的方式

450
00:20:46,666 --> 00:20:49,466
去把这个职责分配给channel对象的话

451
00:20:49,600 --> 00:20:52,100
这些代码就大家普遍的写法

452
00:20:52,100 --> 00:20:53,700
就市面上大家看到的写法

453
00:20:53,966 --> 00:20:57,266
会在channel service里头的inmanit channel里头

454
00:20:57,733 --> 00:20:59,366
那就是面向功能的做法

455
00:20:59,366 --> 00:21:01,466
因为你没有用面向对象的方式

456
00:21:01,500 --> 00:21:02,900
把这个职责分配出去

457
00:21:02,900 --> 00:21:06,100
那他就会在这个image channel

458
00:21:06,100 --> 00:21:06,733
这个方法中间

459
00:21:06,733 --> 00:21:09,066
一二三四五六七八九十这么写下来啊

460
00:21:09,066 --> 00:21:12,366
就是会是这样的这样的一种做法

461
00:21:12,400 --> 00:21:13,533
那这样的一种做法

462
00:21:13,533 --> 00:21:14,366
我们可以看到

463
00:21:14,366 --> 00:21:18,866
针对channel的这些属性的获取

464
00:21:18,866 --> 00:21:21,266
都必须依赖于他的gate和set方法

465
00:21:21,300 --> 00:21:21,733
就最后

466
00:21:21,733 --> 00:21:23,333
比如说我们要去改变它的状态的话

467
00:21:23,333 --> 00:21:25,199
我们会要去调它的set方法

468
00:21:25,333 --> 00:21:26,599
把它的状态改变了

469
00:21:26,600 --> 00:21:29,166
然后再去把它存下来

470
00:21:29,166 --> 00:21:30,466
那现在的这个做法来说

471
00:21:30,466 --> 00:21:33,199
我们都把它写到了channel的对象里面

472
00:21:33,766 --> 00:21:36,533
我们看一下它的这个代码

473
00:21:43,900 --> 00:21:44,933
看一下代码啊

474
00:21:44,933 --> 00:21:46,133
大家就会发现

475
00:21:46,133 --> 00:21:49,566
我们在里头其实主要写了的部分

476
00:21:49,766 --> 00:21:52,733
就是它的职责分配的部分

477
00:21:52,733 --> 00:21:55,533
而不是里头的细节

478
00:21:55,533 --> 00:21:56,899
也就是我们在设计的时候

479
00:21:56,900 --> 00:21:59,333
我们其实做的事情是

480
00:22:02,000 --> 00:22:02,866
在设计的时候

481
00:22:02,866 --> 00:22:03,933
我们做的是

482
00:22:04,366 --> 00:22:06,466
把这个事情分成几样东西去做

483
00:22:06,666 --> 00:22:08,133
那最后的每一个方法

484
00:22:08,133 --> 00:22:10,766
你都会用代码去把它写出来

485
00:22:11,133 --> 00:22:12,766
所以怎么写出来的

486
00:22:12,766 --> 00:22:14,599
这个细节是在代码里头的

487
00:22:29,500 --> 00:22:30,333
这可能

488
00:22:31,866 --> 00:22:32,999
有点小啊

489
00:23:26,300 --> 00:23:29,266
我们从他的控制气层的方法开始看起

490
00:23:29,266 --> 00:23:30,066
啊

491
00:23:37,666 --> 00:23:41,266
在控制器程中间的这个方法是

492
00:23:49,666 --> 00:23:50,466
这个方法

493
00:23:58,600 --> 00:24:03,566
是无效化一个channel的这个方法

494
00:24:03,700 --> 00:24:05,500
在这个方法中间大家可以看到

495
00:24:05,500 --> 00:24:08,300
它里头没有写额外的东西

496
00:24:08,666 --> 00:24:09,733
我们说在控制器层

497
00:24:09,733 --> 00:24:12,066
主要是负责输入和输出的

498
00:24:12,100 --> 00:24:13,766
那在这段代码中间大家可以看到

499
00:24:13,766 --> 00:24:15,499
除了输入和输出以外

500
00:24:15,600 --> 00:24:16,666
他还做了一个判断

501
00:24:16,666 --> 00:24:17,266
这个判断

502
00:24:17,266 --> 00:24:19,999
就是判断传进来的那个修牌ID

503
00:24:20,200 --> 00:24:22,700
修牌ID是用路径过来的传建的

504
00:24:22,700 --> 00:24:25,900
这个修牌ID必须是平台管理员

505
00:24:25,933 --> 00:24:27,299
如果不是平台管理员的话

506
00:24:27,300 --> 00:24:29,600
是不允许把一个支付渠道

507
00:24:29,600 --> 00:24:30,900
整体无效化的

508
00:24:31,266 --> 00:24:33,466
这个判断我们是放在控制7层去做的

509
00:24:33,466 --> 00:24:36,266
这个并不是因为分层的体系结构

510
00:24:36,500 --> 00:24:37,333
所决定的

511
00:24:37,333 --> 00:24:37,933
这个就是

512
00:24:37,933 --> 00:24:40,399
我们在做任何一个判断的时候

513
00:24:40,733 --> 00:24:41,599
他的依据是

514
00:24:41,600 --> 00:24:43,066
如果当前的信息

515
00:24:43,066 --> 00:24:44,933
足以把这个判断做出来

516
00:24:45,000 --> 00:24:47,766
那就在尽量早的去把它做出来

517
00:24:47,800 --> 00:24:49,866
然后不要去执行后面的代码

518
00:24:49,866 --> 00:24:52,399
因为现在目前进来的时候的信息

519
00:24:52,533 --> 00:24:55,699
已足以知道说当前的用

520
00:24:55,700 --> 00:24:58,266
户是不是平台管理员的用户

521
00:24:58,566 --> 00:25:00,666
为啥啊

522
00:25:00,666 --> 00:25:01,999
为啥已经足以知道

523
00:25:02,000 --> 00:25:04,000
是因为我们前面用AOP切了一下

524
00:25:04,933 --> 00:25:08,466
这就是我们在权限部分里头做的AOP

525
00:25:08,766 --> 00:25:11,266
这个AOP就是做的这个注解

526
00:25:11,266 --> 00:25:12,399
它的作用就是

527
00:25:12,400 --> 00:25:13,466
它会去判断

528
00:25:13,466 --> 00:25:15,966
当前发现的HDP的request里头

529
00:25:16,200 --> 00:25:17,133
它的头里头

530
00:25:17,133 --> 00:25:19,799
是不是有个叫做operation的头

531
00:25:19,800 --> 00:25:21,466
那个头里头放的是TOKEN

532
00:25:21,600 --> 00:25:23,966
把那个TOKEN把它解密解出来

533
00:25:24,133 --> 00:25:24,899
然后判断

534
00:25:24,900 --> 00:25:30,566
那个TOKEN里头所描述的用户的商铺

535
00:25:30,600 --> 00:25:34,200
是不是等于我们路径上面的这个商铺

536
00:25:35,166 --> 00:25:37,966
如果TOKEN里头所描述的那个商铺

537
00:25:37,966 --> 00:25:38,999
跟我们在路径上面

538
00:25:39,000 --> 00:25:40,566
这个商铺是不一致的

539
00:25:40,900 --> 00:25:44,933
这一个AOP就会把请求挡回去

540
00:25:45,333 --> 00:25:46,866
如果说他的

541
00:25:48,266 --> 00:25:49,933
商铺的ID是一致的

542
00:25:50,000 --> 00:25:51,933
那就证明当前登陆用户

543
00:25:51,933 --> 00:25:54,966
跟这个路径访问的URL上面所写的

544
00:25:54,966 --> 00:25:57,299
这个showpa ID是一致的

545
00:25:57,366 --> 00:25:58,266
所以进来以后

546
00:25:58,266 --> 00:25:59,399
我们只需要判断

547
00:25:59,400 --> 00:26:01,000
路径上的showpa ID是不是0

548
00:26:01,166 --> 00:26:02,933
这其实也就是代表说

549
00:26:02,933 --> 00:26:04,599
当前这个登录用户

550
00:26:04,800 --> 00:26:08,100
他的这个所属部门是不是平台

551
00:26:08,400 --> 00:26:10,566
如果是的话才能进来啊

552
00:26:10,566 --> 00:26:12,733
如果不是平台的话就就不用进来了

553
00:26:12,800 --> 00:26:14,366
这个就是因为我们用AOP

554
00:26:14,533 --> 00:26:15,733
在这里截了一下

555
00:26:15,933 --> 00:26:18,266
所以在代码中间就写的非常的简单了

556
00:26:18,400 --> 00:26:21,800
所有的代码我们都会用同样的方式

557
00:26:21,800 --> 00:26:23,300
因为有很多的API

558
00:26:23,566 --> 00:26:27,266
都要对操作这个东西的人

559
00:26:27,266 --> 00:26:29,799
和他的范围进行判断的

560
00:26:29,933 --> 00:26:32,266
其实都是用同样的方式去做的

561
00:26:32,500 --> 00:26:33,766
那因为这个没有输

562
00:26:34,366 --> 00:26:35,899
没有输入数据的加工

563
00:26:35,900 --> 00:26:37,533
没有输出数据的返回

564
00:26:38,400 --> 00:26:41,000
输入数据过来就直接传给了收费时辰

565
00:26:41,366 --> 00:26:42,699
没有返回的数据

566
00:26:42,700 --> 00:26:44,600
所以我们在这一个control中间

567
00:26:44,600 --> 00:26:46,666
就看不到任何其他的代码

568
00:26:47,066 --> 00:26:49,533
我们的图是从收费时辰开始画起的

569
00:26:49,533 --> 00:26:50,333
所以我们看一下

570
00:26:50,333 --> 00:26:52,266
收费时辰的unit channel做了什么

571
00:26:56,133 --> 00:26:57,166
这是社会整形的圈

572
00:26:57,166 --> 00:26:59,699
这个跟我们图上画的是一模一样

573
00:27:00,166 --> 00:27:01,299
图上画了

574
00:27:06,933 --> 00:27:08,333
图上画了两个事情

575
00:27:08,333 --> 00:27:10,466
一个事情是去找到对象

576
00:27:10,533 --> 00:27:13,066
第二个事情是到对象的invalid

577
00:27:13,200 --> 00:27:15,500
我们在代码里头写了三件事情

578
00:27:15,500 --> 00:27:16,333
写了3行

579
00:27:27,900 --> 00:27:29,533
除了图上画的两件事情以外

580
00:27:29,533 --> 00:27:30,333
第三件事情

581
00:27:30,333 --> 00:27:33,666
是把因为把这个渠道无效化

582
00:27:33,666 --> 00:27:34,499
所造成的

583
00:27:34,500 --> 00:27:37,933
在缓存中间存的数据给它删掉

584
00:27:38,533 --> 00:27:40,933
因为现在我们的渠道是存在缓存里的

585
00:27:40,966 --> 00:27:41,799
因为这是一个

586
00:27:41,800 --> 00:27:44,766
会高度重复被读取的数据

587
00:27:44,900 --> 00:27:45,933
为了提速啊

588
00:27:45,933 --> 00:27:47,533
所以我们并不是每次都到数据库里

589
00:27:47,533 --> 00:27:48,566
去找这个东西

590
00:27:48,800 --> 00:27:52,566
而是重在缓存里啊

591
00:27:52,733 --> 00:27:55,799
所以在这个channel到的Funda ID里头

592
00:28:07,766 --> 00:28:09,766
我们这段代码是没有画到图上的

593
00:28:09,766 --> 00:28:10,333
这段代码

594
00:28:10,333 --> 00:28:13,799
是一个面向功能的方式写的代码

595
00:28:13,900 --> 00:28:18,266
他就是从数据库里把这个对象找出来

596
00:28:18,500 --> 00:28:19,333
在这段代码中间

597
00:28:19,333 --> 00:28:19,933
大家可以看到

598
00:28:19,933 --> 00:28:21,733
他其实用到了reduce的缓存

599
00:28:21,733 --> 00:28:23,733
他首先在reduce缓存中间去找

600
00:28:23,733 --> 00:28:24,533
说有没有

601
00:28:24,800 --> 00:28:26,966
如果有的话则把它返回

602
00:28:26,966 --> 00:28:27,999
如果没有的话

603
00:28:28,000 --> 00:28:32,800
才会真正用Generator所生成的那个代码

604
00:28:32,933 --> 00:28:34,933
去在数据库里去找

605
00:28:35,066 --> 00:28:37,866
那数据库里如果找到了

606
00:28:38,000 --> 00:28:40,400
那它则会把它返回

607
00:28:40,500 --> 00:28:41,733
这里头我们都可以看到

608
00:28:41,733 --> 00:28:43,733
它调了一个build的方法

609
00:28:44,666 --> 00:28:45,699
这个build的方法

610
00:28:45,700 --> 00:28:48,733
是我们在所有的稻城

611
00:28:49,100 --> 00:28:51,366
都会去做的一个方法

612
00:28:51,533 --> 00:28:53,366
那在China道里头的

613
00:28:53,366 --> 00:28:54,799
这个build方法是干嘛呢

614
00:28:56,266 --> 00:28:56,999
大家可以看一下

615
00:28:57,000 --> 00:28:57,966
我们写了两个

616
00:28:57,966 --> 00:28:58,799
build的方法

617
00:28:58,900 --> 00:29:05,300
一个build的方法是从PU到这个呃Bo

618
00:29:06,533 --> 00:29:07,666
另外一个build方法呢

619
00:29:07,666 --> 00:29:08,599
就是给它Bo

620
00:29:08,600 --> 00:29:10,733
我们再把它build回Bo

621
00:29:10,733 --> 00:29:14,566
这是两个这个build的方法

622
00:29:15,700 --> 00:29:17,733
这个build的方法干的事情

623
00:29:17,733 --> 00:29:20,533
就是把我们的面向对象的

624
00:29:20,533 --> 00:29:23,133
这个对象模型里头

625
00:29:23,500 --> 00:29:25,166
设上他的

626
00:29:25,500 --> 00:29:27,700
什么呢设上他的倒对象

627
00:29:27,866 --> 00:29:29,966
我们为什么现在的Bo对象里头

628
00:29:29,966 --> 00:29:31,699
能承担这么多的职责

629
00:29:31,900 --> 00:29:34,866
是因为我们在Bo对象中间放了倒对象

630
00:29:35,500 --> 00:29:38,666
所以对于一个签了的这样的一个对象

631
00:29:38,666 --> 00:29:40,366
他到底需要放一些什么样的刀

632
00:29:40,366 --> 00:29:41,166
对象进去

633
00:29:41,166 --> 00:29:41,966
我们可以看到

634
00:29:41,966 --> 00:29:43,566
我们在下面这个方法中间

635
00:29:43,933 --> 00:29:45,999
其实真正的是在做这件事情

636
00:29:46,366 --> 00:29:47,499
也就是在Bo对象中间

637
00:29:47,500 --> 00:29:48,966
我们把self chain到

638
00:29:48,966 --> 00:29:49,899
把chain到

639
00:29:50,133 --> 00:29:55,666
和我们后面接口支付平台的一个Adapter

640
00:29:55,966 --> 00:29:56,999
给他放进去了

641
00:29:57,000 --> 00:29:58,300
放了三个东西进去

642
00:29:58,500 --> 00:29:59,600
上面的这个呢

643
00:29:59,866 --> 00:30:01,533
其实是做了比这个

644
00:30:01,533 --> 00:30:02,899
下面这个多做了一些事情

645
00:30:02,900 --> 00:30:06,133
他首先是把Po对象把它变成Bo对象

646
00:30:06,866 --> 00:30:10,266
然后呢把它设到了这个缓存里

647
00:30:10,533 --> 00:30:11,499
这时候判断说

648
00:30:11,500 --> 00:30:13,000
当前这个key是有传过来的

649
00:30:13,000 --> 00:30:14,933
没有如果传了一个key过来

650
00:30:15,066 --> 00:30:17,266
那就把它放到缓存里

651
00:30:17,466 --> 00:30:20,299
然后再把它build回去

652
00:30:20,300 --> 00:30:21,333
把它返回回去

653
00:30:21,500 --> 00:30:24,700
所以这个是我们所有的盗称的方法

654
00:30:24,700 --> 00:30:25,600
都会去写的

655
00:30:25,733 --> 00:30:27,599
写这个方法的主要的目的

656
00:30:27,600 --> 00:30:29,600
就是为了把我们的Bo对象里头

657
00:30:29,600 --> 00:30:30,666
设上盗对象

658
00:30:30,766 --> 00:30:31,999
因为这些盗对象

659
00:30:32,000 --> 00:30:34,666
是我们在Bo对象中间会去调用的

660
00:30:34,666 --> 00:30:37,499
我们单纯从数据库里查过来的Bo对象

661
00:30:37,733 --> 00:30:38,133
或者说

662
00:30:38,133 --> 00:30:41,333
我们从release缓存中间所返回的这

663
00:30:41,333 --> 00:30:42,266
个Bo对象里头

664
00:30:42,266 --> 00:30:43,966
其实是不具备这些盗对象

665
00:30:44,100 --> 00:30:46,666
那都是在获得它的第一时间

666
00:30:46,666 --> 00:30:47,966
把它封满起来啊

667
00:30:47,966 --> 00:30:48,999
把它封满起来

668
00:30:49,333 --> 00:30:52,533
这是我们的这个犯者的方法

669
00:30:52,733 --> 00:30:53,699
大家应该注意到说

670
00:30:53,700 --> 00:30:55,733
我们现在在看到的这个cloud object

671
00:30:55,733 --> 00:30:56,766
是cloud factor

672
00:30:56,766 --> 00:30:57,666
是红色的

673
00:30:58,300 --> 00:31:00,333
啊在import中间也是红色的

674
00:31:00,333 --> 00:31:01,299
这个是什么原因呢

675
00:31:01,300 --> 00:31:03,700
这个是因为在这一个机器上头

676
00:31:03,700 --> 00:31:05,533
我还从来没有编译过

677
00:31:05,966 --> 00:31:07,699
没有编译过cloud object

678
00:31:07,700 --> 00:31:09,133
就是没有生成过的

679
00:31:09,166 --> 00:31:11,166
要想把它变成不是红色啊

680
00:31:11,166 --> 00:31:11,866
其实很简单

681
00:31:11,866 --> 00:31:13,066
把它编译下就好了

682
00:31:13,600 --> 00:31:16,100
我们目前在这里头是没有这个touch的

683
00:31:16,100 --> 00:31:18,200
这个目录Deta是

684
00:31:19,700 --> 00:31:20,900
没有这个方法的

685
00:31:21,166 --> 00:31:23,899
没有这个cloud object cloud factor这个类的

686
00:31:24,133 --> 00:31:27,566
这个是我们需要把它编译一下

687
00:31:27,600 --> 00:31:29,800
他就会把这个生成出来

688
00:31:29,800 --> 00:31:31,066
我们来编译一下吧

689
00:31:50,266 --> 00:31:51,799
啊这个是SDK

690
00:31:52,333 --> 00:31:53,333
SDK要换一下

691
00:31:53,333 --> 00:31:55,066
我们直接改成17了

692
00:32:07,566 --> 00:32:09,766
嗯这个SDK应该是在

693
00:32:14,933 --> 00:32:17,566
这个地方SDK改成17了啊

694
00:32:18,900 --> 00:32:20,933
所以用11是不行的

695
00:32:22,200 --> 00:32:23,600
要用17的SDK

696
00:32:42,966 --> 00:32:44,366
编译好了以后啊

697
00:32:49,700 --> 00:32:51,200
啊这是因素没有装

698
00:32:51,733 --> 00:32:54,499
要把要把扣要装一下

699
00:32:54,666 --> 00:32:55,966
因为它依赖于扣

700
00:32:58,200 --> 00:32:59,533
因为我之前是有装过的

701
00:32:59,533 --> 00:32:59,933
所以

702
00:32:59,933 --> 00:33:02,399
以后每次只要把扩音缩下就可以了

703
00:33:15,600 --> 00:33:17,000
好我们再编一下

704
00:33:31,933 --> 00:33:33,966
好现在是能够编译过的啊

705
00:33:34,133 --> 00:33:34,866
编译完了以后

706
00:33:34,866 --> 00:33:35,699
大家就能看到

707
00:33:35,700 --> 00:33:39,200
在这个底下color up fact产生了

708
00:33:39,300 --> 00:33:41,266
这个就是因为我们用了注解

709
00:33:41,300 --> 00:33:42,400
用了那个copiform

710
00:33:42,400 --> 00:33:43,200
那个注解

711
00:33:43,400 --> 00:33:47,500
使得我们在编译的时候

712
00:33:47,500 --> 00:33:50,300
会把这个cloud fact给它自动产生出来

713
00:33:50,400 --> 00:33:52,133
这个就是按照我们的那个注解

714
00:33:52,133 --> 00:33:53,066
它产生了一系列

715
00:33:53,066 --> 00:33:53,866
的方法

716
00:33:54,366 --> 00:33:56,699
就是调对应的copy和set

717
00:33:56,700 --> 00:33:58,366
的方法所以这样的话

718
00:33:58,366 --> 00:34:00,399
我们再回到看到我们的收费指层

719
00:34:00,400 --> 00:34:01,200
中间的

720
00:34:02,500 --> 00:34:04,366
好在稻城中间的这个

721
00:34:09,666 --> 00:34:11,399
这个就不会再变成红色了

722
00:34:12,566 --> 00:34:14,466
对吧当然这个过程中间

723
00:34:14,466 --> 00:34:16,466
我们其实要要做一个这个动作

724
00:34:16,466 --> 00:34:19,333
就是我们需要把这个方法啊

725
00:34:19,333 --> 00:34:22,333
把它mark the s generate sosroot

726
00:34:22,333 --> 00:34:25,699
就是它是我们自动生成的原代码的根

727
00:34:26,100 --> 00:34:26,400
然后

728
00:34:26,400 --> 00:34:28,300
在工作人员做了这样一个设定以后

729
00:34:28,566 --> 00:34:30,966
这就不会再变成红色了

730
00:34:31,000 --> 00:34:34,400
所以clock factory这个这个类

731
00:34:34,666 --> 00:34:37,599
整个都是我们根据注解去

732
00:34:37,600 --> 00:34:39,600
在编译的时候

733
00:34:40,266 --> 00:34:41,266
自动生成的

734
00:34:41,266 --> 00:34:43,099
就是在编译我们的代码之前

735
00:34:43,100 --> 00:34:45,366
他会自动生成这个代码

736
00:34:46,466 --> 00:34:47,966
这个东西的

737
00:34:47,966 --> 00:34:49,299
这个生成过程

738
00:34:49,333 --> 00:34:52,099
就是我们在这个上面看到的

739
00:34:52,100 --> 00:34:53,100
这个copy from

740
00:34:53,533 --> 00:34:54,099
这个注解

741
00:34:54,100 --> 00:34:57,166
起的作用就是我们加了这个注解以后

742
00:34:57,166 --> 00:34:59,866
他会在编译之前去把这个代码写出来

743
00:34:59,866 --> 00:35:03,499
这是我们去年同学写的一个这个注解

744
00:35:03,500 --> 00:35:04,300
啊

745
00:35:05,133 --> 00:35:10,399
这是我们的find by ID的方法

746
00:35:10,766 --> 00:35:14,799
那当我们用find by ID从缓存中间

747
00:35:14,800 --> 00:35:17,366
或者从数据库里找到这个对象以后

748
00:35:17,500 --> 00:35:18,300
我们

749
00:35:19,766 --> 00:35:23,066
把invite的这个职责分给了channel

750
00:35:23,933 --> 00:35:25,299
所以我们去看一下

751
00:35:26,866 --> 00:35:27,866
这个里头怎么做呢

752
00:35:27,866 --> 00:35:28,466
这个里头

753
00:35:28,466 --> 00:35:30,533
因为我们in vilet和vilet

754
00:35:31,200 --> 00:35:33,666
其实用到的是相同的东西

755
00:35:33,666 --> 00:35:36,333
所以我们把这两部分相同的代码

756
00:35:36,766 --> 00:35:38,666
抽出来写了一个独立的方法

757
00:35:38,666 --> 00:35:40,199
这个不是面向对下的

758
00:35:40,200 --> 00:35:41,200
这是面向功能的

759
00:35:41,200 --> 00:35:43,333
也就是我们最基本的一个原则

760
00:35:43,766 --> 00:35:46,466
任何一段代码不能写两次

761
00:35:46,666 --> 00:35:49,866
所以把word和invite的代码给它抽出来

762
00:35:49,866 --> 00:35:50,999
写到这里这里

763
00:35:51,000 --> 00:35:51,800
头大家可以看到

764
00:35:51,800 --> 00:35:53,733
我们在图上没有画的词情

765
00:35:53,733 --> 00:35:55,166
是我们在这里判断了

766
00:35:55,166 --> 00:35:57,133
当前这个状态

767
00:35:57,333 --> 00:36:00,533
是否允许迁移到新的状态上去

768
00:36:00,533 --> 00:36:01,866
我们之前有看到

769
00:36:01,866 --> 00:36:05,066
在reading中间其实有看到相同的写法

770
00:36:05,066 --> 00:36:07,399
在这个代码中间也是一样的写法

771
00:36:07,900 --> 00:36:09,300
所以第一个方法

772
00:36:09,300 --> 00:36:10,000
是去判断

773
00:36:10,000 --> 00:36:12,666
当前状态是否能迁移到目标状态上去

774
00:36:12,866 --> 00:36:13,799
如果不可以迁移

775
00:36:13,800 --> 00:36:14,933
就说我们状态基础里头

776
00:36:14,933 --> 00:36:16,533
没有画这个迁移线

777
00:36:16,766 --> 00:36:18,099
那就不允许迁移

778
00:36:18,300 --> 00:36:20,266
如果允许迁移的话

779
00:36:20,866 --> 00:36:23,799
那我们就把这个对象的状态

780
00:36:23,800 --> 00:36:24,766
给它改过去

781
00:36:24,800 --> 00:36:26,666
所以后面的这4行代码

782
00:36:26,900 --> 00:36:30,066
就是把对象状态给它改过去啊

783
00:36:30,066 --> 00:36:32,766
所以这是我们的这张图

784
00:36:33,266 --> 00:36:36,299
和代码的对应关系啊

785
00:36:36,733 --> 00:36:38,266
所以通过这个简单的东西

786
00:36:38,266 --> 00:36:40,399
大家应该知道我们在图上画的是什么

787
00:36:40,966 --> 00:36:42,899
我们的代码中间写的是什么

788
00:36:42,933 --> 00:36:46,299
我们的图和代码是有差异的

789
00:36:46,666 --> 00:36:49,133
我们图画这张图的主要的目的

790
00:36:49,133 --> 00:36:51,133
是想表述出来

791
00:36:51,300 --> 00:36:53,500
我们这个事情是怎么做的

792
00:36:53,600 --> 00:36:54,966
但并不是说

793
00:36:54,966 --> 00:36:58,566
把所有的细节和判断都写进去了

794
00:36:59,133 --> 00:37:01,699
这个图给我们看到的东西就是

795
00:37:01,700 --> 00:37:02,500
我们至少知道

796
00:37:02,500 --> 00:37:04,600
我们在整个弹法中间会有多少的方法

797
00:37:04,766 --> 00:37:06,566
这些方法之间的关系

798
00:37:06,733 --> 00:37:09,333
调用关系是一个什么样的关系

799
00:37:10,100 --> 00:37:17,133
这里头在1234在234566次做分配的时候

800
00:37:17,133 --> 00:37:19,866
只有第三次用的是面向对象的

801
00:37:20,800 --> 00:37:22,000
信息专家的原则

802
00:37:22,533 --> 00:37:27,499
2456都是面向功能的这样的一个设计

803
00:37:28,500 --> 00:37:29,766
这是第一个方法

804
00:37:30,533 --> 00:37:31,933
那第二个方法

805
00:37:32,200 --> 00:37:33,100
第二个API

806
00:37:33,100 --> 00:37:34,700
我们要讲的是

807
00:37:36,000 --> 00:37:37,000
呃查询

808
00:37:38,333 --> 00:37:40,933
这这是获取

809
00:37:42,733 --> 00:37:47,133
一个商铺的所有的支付渠道的API

810
00:37:47,533 --> 00:37:49,999
这个API中间大家可以看到他返回的

811
00:37:50,000 --> 00:37:51,200
是一个列表

812
00:37:51,800 --> 00:37:55,333
这个列表里头其实包含了渠道的名称

813
00:37:57,200 --> 00:37:59,733
渠道的这个商铺的ID

814
00:38:01,100 --> 00:38:04,200
它在支付平台中间登记的那个ID

815
00:38:04,566 --> 00:38:06,866
还有当前的状态

816
00:38:07,900 --> 00:38:10,400
那这个状态我们知道

817
00:38:10,400 --> 00:38:13,133
他会受到我们前面那个API的影响

818
00:38:13,366 --> 00:38:14,533
我们那个前面API

819
00:38:14,533 --> 00:38:17,333
如果把微信整个关掉了

820
00:38:17,700 --> 00:38:18,966
那所有商铺

821
00:38:18,966 --> 00:38:19,366
在拿到

822
00:38:19,366 --> 00:38:21,766
他自己的支付渠道的状态的时候

823
00:38:21,966 --> 00:38:23,999
应该也是被关闭的状态

824
00:38:24,000 --> 00:38:27,066
也就是他不能通过这个渠道去支付啊

825
00:38:27,100 --> 00:38:29,733
所以我先把先把这个问题提在这

826
00:38:29,733 --> 00:38:31,066
就是我们现在这里看到的

827
00:38:31,066 --> 00:38:32,599
就是我们用这个API所拿到的

828
00:38:32,600 --> 00:38:34,466
这个支付渠道的状态

829
00:38:34,666 --> 00:38:37,166
其实会受到我们平台整体关闭

830
00:38:37,166 --> 00:38:39,133
某一个支付渠道的状态的影响

831
00:38:39,366 --> 00:38:41,166
那这个部分是怎么做呢

832
00:38:42,466 --> 00:38:43,133
我们可以看到

833
00:38:43,133 --> 00:38:44,199
在这部分代码中间

834
00:38:44,200 --> 00:38:46,600
我们不用去看里头的代码

835
00:38:47,300 --> 00:38:47,900
大家可以看到

836
00:38:47,900 --> 00:38:51,300
这部分代码所有的设计都是什么

837
00:38:52,466 --> 00:38:54,866
都是面向功能的

838
00:38:55,200 --> 00:38:56,766
都是非面向对象

839
00:38:56,966 --> 00:38:58,166
所以他的代码上呢

840
00:38:58,166 --> 00:39:00,933
大家可以看到就是呃control

841
00:39:00,933 --> 00:39:02,099
曾经的一个方法

842
00:39:02,166 --> 00:39:04,499
这个方法要查super ID

843
00:39:05,066 --> 00:39:06,399
对应的所有的渠道

844
00:39:06,400 --> 00:39:08,066
所以收尾层写的一个方法

845
00:39:08,066 --> 00:39:11,299
去retrieve show panel ID page

846
00:39:11,300 --> 00:39:14,100
page size调到成的一个方法

847
00:39:14,100 --> 00:39:15,466
去查数据库

848
00:39:15,566 --> 00:39:17,066
查出来就返回

849
00:39:17,800 --> 00:39:21,600
这个就是我们在这个设计中间

850
00:39:21,766 --> 00:39:24,899
完全看不到面向对象的东西

851
00:39:25,000 --> 00:39:27,733
那我为什么要把这个方法提出来讲

852
00:39:28,300 --> 00:39:29,400
是因为这个方法里头

853
00:39:29,400 --> 00:39:30,933
有面向对象的内容

854
00:39:30,933 --> 00:39:32,099
它内容在哪呢

855
00:39:32,300 --> 00:39:34,100
它的内容不在这个图上头啊

856
00:39:34,100 --> 00:39:36,200
我们看这个对应的这个方法

857
00:39:36,866 --> 00:39:37,799
圈到收尾室里头

858
00:39:37,800 --> 00:39:38,766
对应这个方法

859
00:39:44,800 --> 00:39:46,100
啊就是这个方法

860
00:39:51,766 --> 00:39:53,866
这就是我们图图上头

861
00:40:07,700 --> 00:40:09,366
这是我们图上看到的这个方法

862
00:40:09,733 --> 00:40:13,799
retrieve shop channel就是调稻城的方法

863
00:40:14,100 --> 00:40:15,333
这个注意一下啊

864
00:40:15,733 --> 00:40:16,766
我们可以看到

865
00:40:16,766 --> 00:40:21,499
在收拾城我们的返回值并不是什么

866
00:40:21,500 --> 00:40:25,133
并不是我们在API上看到的

867
00:40:25,133 --> 00:40:26,399
预期的那个返回值

868
00:40:27,066 --> 00:40:28,566
我们在收尾层返回的是什么

869
00:40:28,566 --> 00:40:29,666
是对象模型

870
00:40:29,766 --> 00:40:31,466
所以我们返回了一个列表

871
00:40:31,533 --> 00:40:32,999
列表里头每一个对象

872
00:40:33,133 --> 00:40:34,533
是我们的这个shop channel

873
00:40:34,533 --> 00:40:37,999
而这些shop channel是在稻城给他查出来

874
00:40:44,533 --> 00:40:45,766
所以造成的

875
00:40:45,766 --> 00:40:46,699
方法里头

876
00:40:47,066 --> 00:40:48,266
我们可以看到

877
00:40:48,300 --> 00:40:50,133
我们做了这样的一个查询

878
00:40:50,966 --> 00:40:52,299
去查询

879
00:40:53,666 --> 00:40:55,933
数据库构造了example

880
00:40:56,266 --> 00:40:59,933
然后去把这个example把它构造出来

881
00:40:59,933 --> 00:41:01,133
然后调这个方法

882
00:41:01,133 --> 00:41:03,566
这个同样也是非面向对象的

883
00:41:04,600 --> 00:41:06,900
因为我们会用各种条件去查它

884
00:41:09,266 --> 00:41:11,066
所以我们把所有的查询

885
00:41:11,066 --> 00:41:13,466
把它写到这样一个方法中间

886
00:41:13,466 --> 00:41:16,166
这就是直接会去search by example

887
00:41:16,166 --> 00:41:17,933
用我们前面构造那个example

888
00:41:18,366 --> 00:41:19,299
去把它查出来

889
00:41:19,300 --> 00:41:21,800
然后这里有我们的分页

890
00:41:22,666 --> 00:41:25,366
查出来的这个对象是PU对象对吧

891
00:41:25,466 --> 00:41:27,299
所以我们这里在稻城负责的

892
00:41:27,300 --> 00:41:29,300
把PU对象转成BU对象

893
00:41:29,566 --> 00:41:30,499
注意我们这个转法

894
00:41:30,500 --> 00:41:32,000
就是用我们刚才说的那个build

895
00:41:33,000 --> 00:41:34,933
这时候转出来的do对象

896
00:41:34,933 --> 00:41:36,333
不是单纯的do对象

897
00:41:36,333 --> 00:41:38,866
是里头设了do的do对象

898
00:41:39,266 --> 00:41:41,366
我们为什么要在里头去设

899
00:41:41,366 --> 00:41:42,566
这个do的do对象

900
00:41:42,566 --> 00:41:44,399
从这一段代码中间都看不出来

901
00:41:44,400 --> 00:41:46,500
这个这个do会起什么样的作用

902
00:41:46,733 --> 00:41:49,133
我们回到control上的方法

903
00:42:12,666 --> 00:42:14,499
在Controller层的方法里头

904
00:42:14,733 --> 00:42:16,866
大家可以看到我们刚才调了设位层的

905
00:42:18,500 --> 00:42:19,566
啊不是这个

906
00:42:19,600 --> 00:42:20,500
应该是这个

907
00:42:22,700 --> 00:42:24,500
这个啊大家可以看到

908
00:42:24,500 --> 00:42:26,400
我们刚才调了收费层的retrieve

909
00:42:26,400 --> 00:42:29,333
shop channel的方法

910
00:42:29,600 --> 00:42:30,466
在数据库里

911
00:42:30,466 --> 00:42:31,566
就是面向功能的方式

912
00:42:31,566 --> 00:42:32,599
收费层调稻城

913
00:42:32,600 --> 00:42:34,500
稻城到数据库里去把它查出来

914
00:42:34,700 --> 00:42:37,466
查出来以后他返回的是shop channel list

915
00:42:37,466 --> 00:42:38,933
这是面向对象的模型

916
00:42:39,333 --> 00:42:40,966
但这时候的shop channel历史

917
00:42:40,966 --> 00:42:42,266
里头的每一个对象

918
00:42:42,533 --> 00:42:44,499
都是一个完整的bo对象

919
00:42:44,500 --> 00:42:46,600
就是它里头是治了道的方法

920
00:42:46,866 --> 00:42:48,599
这些治了道的这些对象

921
00:42:48,600 --> 00:42:50,000
我们整来干什么用呢

922
00:42:50,166 --> 00:42:51,799
其实干的事情就是这个事情

923
00:42:52,300 --> 00:42:53,500
就是我们这里

924
00:42:53,500 --> 00:42:59,566
会把它转化成为我们要形成的VO对象

925
00:43:00,500 --> 00:43:01,800
所以我们可以看到

926
00:43:01,800 --> 00:43:04,166
我们要形成的这个DTO对象

927
00:43:04,166 --> 00:43:07,066
我们是写在消费枪的DTO的

928
00:43:07,066 --> 00:43:07,699
我们这时候

929
00:43:07,700 --> 00:43:10,733
再使用了CROWN factory的copy的方法

930
00:43:10,866 --> 00:43:14,299
去把那个对象给他拷贝

931
00:43:14,300 --> 00:43:16,466
成为我们所要的东西

932
00:43:16,566 --> 00:43:18,199
大家觉得这没什么好稀奇的嘛

933
00:43:18,300 --> 00:43:20,466
那面向对象的东西会发生在哪呢

934
00:43:20,700 --> 00:43:23,266
会发生在这个copy的过程中间

935
00:43:23,366 --> 00:43:25,366
我们如果点进去看这个copy方法

936
00:43:25,366 --> 00:43:27,066
这是我们刚才自动生成的这个方法

937
00:43:30,366 --> 00:43:31,366
我们可以看到啊

938
00:43:31,366 --> 00:43:33,066
他所做的事情就是

939
00:43:33,066 --> 00:43:35,133
他会调自动生成代码

940
00:43:35,266 --> 00:43:38,933
就是去调SOS的get方法

941
00:43:39,300 --> 00:43:43,133
去set到touch的state方法中间去

942
00:43:43,366 --> 00:43:44,733
这个事情发生在哪呢

943
00:43:44,733 --> 00:43:47,899
这个事情发生在source的get status里头

944
00:43:48,100 --> 00:43:48,933
我们知道

945
00:43:48,933 --> 00:43:50,766
这时候我们去拿到一个short channel

946
00:43:50,766 --> 00:43:52,199
去拿到它的状态的时候

947
00:43:52,333 --> 00:43:54,199
它不应该是它自己的状态

948
00:43:54,466 --> 00:43:55,999
它应该是自己的状态

949
00:43:56,000 --> 00:43:59,366
加上整个平台的

950
00:43:59,366 --> 00:44:00,799
那个支付渠道的状态

951
00:44:00,800 --> 00:44:01,966
如果整自己的状

952
00:44:01,966 --> 00:44:02,933
态是OK的

953
00:44:03,200 --> 00:44:04,966
整个支渠道

954
00:44:04,966 --> 00:44:07,499
整个平台把那个支付宝或者微信关了

955
00:44:07,566 --> 00:44:09,399
这时候商铺拿回来的状态

956
00:44:09,533 --> 00:44:10,899
应该也是不OK的

957
00:44:10,900 --> 00:44:12,466
也是不能用的这个状态

958
00:44:12,700 --> 00:44:14,133
所以这一端代码

959
00:44:14,700 --> 00:44:17,966
我们其实用的是信息专家的原则

960
00:44:18,133 --> 00:44:20,766
把它写到了datas datas方法里

961
00:44:24,000 --> 00:44:25,500
所以一个get的方法

962
00:44:25,500 --> 00:44:29,300
并不是简单的去把这个状态反驳回来

963
00:44:29,400 --> 00:44:30,133
我们可以看到

964
00:44:30,133 --> 00:44:31,533
在这个get的方法中间

965
00:44:31,566 --> 00:44:33,966
我们写的这个逻辑是

966
00:44:35,066 --> 00:44:36,666
获得自己的渠道

967
00:44:37,066 --> 00:44:40,599
如果自己的渠道的状态是Valet的话

968
00:44:40,666 --> 00:44:43,933
那就把自己的真实状态返回回去

969
00:44:44,300 --> 00:44:47,366
如果自己的渠道状态不是Valet

970
00:44:47,966 --> 00:44:49,599
就返回渠道的状态

971
00:44:50,333 --> 00:44:52,099
因为我们渠道只有两种状态

972
00:44:52,100 --> 00:44:54,333
就是有效和无效

973
00:44:54,933 --> 00:44:55,733
所以这样的话

974
00:44:55,733 --> 00:44:58,999
就会使得渠道的无效状态啊

975
00:44:59,000 --> 00:45:01,766
会影响到我们商铺的

976
00:45:01,866 --> 00:45:04,166
具体的这个支付渠道的这个状态

977
00:45:04,533 --> 00:45:06,766
这里头我们的倒对象

978
00:45:06,766 --> 00:45:08,733
其实就用在了这个get channel里头

979
00:45:11,366 --> 00:45:13,199
所以当我们去调他的get枪的时候

980
00:45:13,200 --> 00:45:17,266
我们其实是去通过他的倒对象

981
00:45:17,566 --> 00:45:20,599
去把他的这个枪的对象给他盘回来

982
00:45:20,700 --> 00:45:24,100
当然这做了一个缓存是吧

983
00:45:24,100 --> 00:45:26,266
如果说他有第一次被收过了

984
00:45:26,266 --> 00:45:29,299
那第二次就不会再去调他的盗对象

985
00:45:29,466 --> 00:45:30,899
去做收了

986
00:45:31,100 --> 00:45:32,066
这个过程啊

987
00:45:32,066 --> 00:45:34,533
又回到了签那盗的犯的吧ID这里头

988
00:45:34,533 --> 00:45:35,899
我们知道会去数据库

989
00:45:35,900 --> 00:45:37,000
会去缓存里拿

990
00:45:37,466 --> 00:45:39,999
所以从这个例子中间我们可以看到

991
00:45:40,300 --> 00:45:42,300
虽然整个的设计

992
00:45:42,300 --> 00:45:44,166
是一个非面向对象的设计

993
00:45:45,766 --> 00:45:47,899
就是整个的整体的设计

994
00:45:48,266 --> 00:45:50,099
是一个非面向对向的设计

995
00:45:50,166 --> 00:45:52,899
但是我们在里头的某些局部

996
00:45:53,200 --> 00:45:57,700
还是会渗透进去面向对向的方法

997
00:45:57,933 --> 00:46:00,099
也就是我们这里所看到的这个

998
00:46:01,766 --> 00:46:04,199
shop channel的data status方法

999
00:46:04,666 --> 00:46:07,299
我们里头其实是按照

1000
00:46:07,300 --> 00:46:09,266
面向对象的职责分配的原则

1001
00:46:09,700 --> 00:46:12,333
去做了一个设计哈

1002
00:46:12,400 --> 00:46:12,766
但是

1003
00:46:12,766 --> 00:46:15,133
我们从整体代码中间是看不太出来

1004
00:46:15,166 --> 00:46:17,199
就是你如果单纯从代码

1005
00:46:18,066 --> 00:46:20,933
从controller层service层稻城去看的话

1006
00:46:20,933 --> 00:46:22,466
其实看不出来这个过程

1007
00:46:22,466 --> 00:46:23,066
因为这个过程

1008
00:46:23,066 --> 00:46:24,066
被藏到了

1009
00:46:24,200 --> 00:46:26,533
我们的自动生成的代码里头的

1010
00:46:26,533 --> 00:46:28,966
datastates的方法里头啊

1011
00:46:29,300 --> 00:46:33,466
这是我们要讲的这个第二个

1012
00:46:34,066 --> 00:46:34,933
第二个设计

1013
00:46:34,933 --> 00:46:35,933
其实这两个设计里头

1014
00:46:35,933 --> 00:46:37,866
都是用的信息专家的原则

1015
00:46:38,666 --> 00:46:39,499
两个设计

1016
00:46:39,500 --> 00:46:41,466
一个是在主体的设计过程中间

1017
00:46:41,466 --> 00:46:45,399
我们把中间的职责分配的一步

1018
00:46:45,400 --> 00:46:47,100
用了面向对象的方式

1019
00:46:47,133 --> 00:46:48,366
而这个设计呢

1020
00:46:48,366 --> 00:46:50,933
就是在主体设计中间全是面向功能的

1021
00:46:51,166 --> 00:46:53,133
但是在细微的部分

1022
00:46:53,133 --> 00:46:55,199
我们用面向对象去做

1023
00:46:55,800 --> 00:46:57,866
所以如果大家想象一下

1024
00:46:57,866 --> 00:47:00,099
没有用面向对象的设计

1025
00:47:00,566 --> 00:47:04,333
所有的这些逻辑都要用代码写出来

1026
00:47:04,566 --> 00:47:07,966
而这些要写出来的代码将会在哪呢

1027
00:47:08,266 --> 00:47:11,066
都全部会在我们的channel

1028
00:47:11,066 --> 00:47:12,933
service的对应的方法中间

1029
00:47:12,933 --> 00:47:15,199
我想之前大家如果有写过代码的话

1030
00:47:15,400 --> 00:47:16,700
应该都是这么写的

1031
00:47:16,866 --> 00:47:19,099
但是我们现在使用面向对象的

1032
00:47:19,100 --> 00:47:20,666
这样的一种设计的方法

1033
00:47:20,800 --> 00:47:21,300
其实

1034
00:47:21,300 --> 00:47:25,266
把原本在service层里头写的那些代码

1035
00:47:25,466 --> 00:47:28,666
给分配到了不同的对象上去

1036
00:47:28,933 --> 00:47:31,166
把它变成了更小的模块

1037
00:47:31,366 --> 00:47:33,899
从而使得说从你去阅读

1038
00:47:33,900 --> 00:47:36,133
或者说去使用这个代码来说

1039
00:47:36,466 --> 00:47:37,533
他更容易理解

1040
00:47:37,533 --> 00:47:38,466
更容易阅读

1041
00:47:38,766 --> 00:47:39,866
那更重要的是

1042
00:47:39,866 --> 00:47:41,866
把它分成了这些小块以后

1043
00:47:42,000 --> 00:47:43,133
其实大家会知道

1044
00:47:43,133 --> 00:47:46,933
它的重用的可能性会大幅度的提高啊

1045
00:47:46,933 --> 00:47:48,533
重用的可能性会大幅提高

1046
00:47:48,533 --> 00:47:50,299
比如说我们现在这个状态

1047
00:47:50,300 --> 00:47:51,266
在任何时候

1048
00:47:51,266 --> 00:47:54,933
我们拿到一个channel的状态的时候

1049
00:47:54,933 --> 00:47:57,266
他都是按照我们这个逻辑去做的

1050
00:47:57,266 --> 00:47:59,499
他不是写在社会市层里头的

1051
00:47:59,500 --> 00:48:01,533
而是写在我们的对象的

1052
00:48:01,733 --> 00:48:03,466
get社会市的方法里头的

1053
00:48:04,300 --> 00:48:08,000
这是我们的两个最基本的设计

1054
00:48:09,300 --> 00:48:12,066
用到的就是主要是信息专家

1055
00:48:12,133 --> 00:48:14,366
因为我们这里没有创建对象

1056
00:48:17,066 --> 00:48:19,966
在这个支付模块中间

1057
00:48:19,966 --> 00:48:20,699
其实我们知道

1058
00:48:20,700 --> 00:48:24,200
我们的除了这些常规的问题以外

1059
00:48:24,200 --> 00:48:26,466
其实我们有一个很困难的问题

1060
00:48:26,466 --> 00:48:27,499
要去面对

1061
00:48:27,700 --> 00:48:29,333
这个问题就是

1062
00:48:29,333 --> 00:48:33,733
我们是有不同的不同的交易的

1063
00:48:33,733 --> 00:48:35,899
我们这里一共有支付退款

1064
00:48:35,900 --> 00:48:38,900
支付分账和退款分账四种交易

1065
00:48:39,133 --> 00:48:41,866
这四种交易上头是有不同的行为

1066
00:48:42,066 --> 00:48:43,466
有相同的属性

1067
00:48:43,466 --> 00:48:45,699
不同的属性不同的行为的

1068
00:48:45,866 --> 00:48:47,299
我们在整体的设计中间

1069
00:48:47,300 --> 00:48:49,466
是用了一个多态的方式

1070
00:48:50,200 --> 00:48:53,300
多肽就是用继承的方式

1071
00:48:53,566 --> 00:48:55,933
去实现了这个不同的交易

1072
00:48:55,966 --> 00:48:57,133
好我们去休息一会

1073
00:59:23,533 --> 00:59:24,333
好

1074
00:59:25,700 --> 00:59:27,966
这里头我们在代码中间

1075
00:59:27,966 --> 00:59:30,766
做了一个简单的继承关系

1076
00:59:30,766 --> 00:59:33,733
这样把的共性的部分

1077
00:59:33,733 --> 00:59:35,299
放到了全sax性中间

1078
00:59:35,600 --> 00:59:38,900
呃差异部分放到了各自里头啊

1079
00:59:38,900 --> 00:59:39,966
我们看一下这个代码

1080
00:59:39,966 --> 00:59:41,333
这就没有画图了

1081
00:59:53,900 --> 00:59:57,366
也就是在bo对象的这个transaction里头

1082
00:59:57,366 --> 01:00:01,266
我们把共性的属性放到了这个里面

1083
01:00:01,300 --> 01:00:03,600
然后有一些共性的方法

1084
01:00:04,066 --> 01:00:06,766
比如说这个allow status

1085
01:00:06,766 --> 01:00:09,066
这个方法我们放在这个里面

1086
01:00:09,166 --> 01:00:10,333
目前来说

1087
01:00:10,333 --> 01:00:13,099
我们还没有发现它有更多的啊

1088
01:00:13,100 --> 01:00:16,133
比如说get channel的方法

1089
01:00:16,466 --> 01:00:18,699
就是共性的方法放在这个里面

1090
01:00:18,766 --> 01:00:19,666
包括get late

1091
01:00:21,166 --> 01:00:22,766
然后不同的方法

1092
01:00:22,766 --> 01:00:23,366
我们可以看到

1093
01:00:23,366 --> 01:00:25,599
把它写成了abstract的方法

1094
01:00:25,800 --> 01:00:29,266
让它到纸类里头去实现

1095
01:00:29,466 --> 01:00:29,766
所以

1096
01:00:29,766 --> 01:00:35,299
纸类里头只实现了它各自不同的部分

1097
01:00:36,166 --> 01:00:37,099
这个是

1098
01:00:38,600 --> 01:00:39,866
多肽的设计啊

1099
01:00:40,000 --> 01:00:42,466
这是一个最简单的多肽的设计

1100
01:00:46,766 --> 01:00:47,766
间接的部分

1101
01:00:49,366 --> 01:00:51,599
啊间接的部分

1102
01:00:51,600 --> 01:00:54,533
我们在这里头有一个比较棘手的问题

1103
01:00:54,533 --> 01:00:56,333
就是支付模块里头

1104
01:00:56,333 --> 01:00:58,866
需要支持支付宝和微信

1105
01:00:59,700 --> 01:01:02,533
不仅仅支持支付宝和微信

1106
01:01:02,733 --> 01:01:05,599
还需要支持比如说未来的云闪付等等

1107
01:01:05,600 --> 01:01:07,066
各种不同的渠道

1108
01:01:07,100 --> 01:01:10,300
我们在表面上头那些API里头

1109
01:01:10,300 --> 01:01:11,666
有很多API

1110
01:01:11,900 --> 01:01:14,366
都需要调用对应的支付渠道

1111
01:01:14,900 --> 01:01:15,966
去完成的

1112
01:01:15,966 --> 01:01:18,266
那这个部分怎么去做设计

1113
01:01:18,333 --> 01:01:21,133
我们知道这个部分最大的问题在于说

1114
01:01:21,133 --> 01:01:22,599
支付渠道是多样

1115
01:01:23,000 --> 01:01:26,933
每一个支付渠道的API传过去的参数

1116
01:01:27,166 --> 01:01:29,499
返还的值都是不一样

1117
01:01:30,200 --> 01:01:32,766
那如果说我们在代码中间

1118
01:01:33,366 --> 01:01:37,599
去根据不同的API去写代码

1119
01:01:37,966 --> 01:01:39,799
这个其实是很难受的

1120
01:01:40,500 --> 01:01:42,566
那我们的想法来说

1121
01:01:42,566 --> 01:01:46,366
是把这部分多变的支付渠道的代码

1122
01:01:46,600 --> 01:01:49,366
和我们主体的代码隔离开

1123
01:01:49,866 --> 01:01:50,799
怎么隔离的呢

1124
01:01:50,800 --> 01:01:53,100
就是用的间接的方法

1125
01:01:53,133 --> 01:01:55,666
我并不直接去使用

1126
01:01:56,000 --> 01:01:57,933
这些支付渠道的代码

1127
01:01:58,100 --> 01:02:02,133
而通过我们所引入的一个间接的对象

1128
01:02:02,333 --> 01:02:05,333
去间接的使用这个支付渠道的代码

1129
01:02:05,966 --> 01:02:08,899
我们以一个例子来说签约支付渠道

1130
01:02:09,900 --> 01:02:12,100
签约支付渠道的这个API

1131
01:02:12,400 --> 01:02:13,933
是让顾客

1132
01:02:13,966 --> 01:02:17,533
是让商户填上你的支付渠道的

1133
01:02:17,533 --> 01:02:20,333
就是你先到支付宝或者微信去开个户

1134
01:02:20,766 --> 01:02:23,133
然后去得到他的相关的信息啊

1135
01:02:23,133 --> 01:02:24,299
当我们这里做了简化了

1136
01:02:24,300 --> 01:02:25,666
其实要填很多信息的

1137
01:02:25,666 --> 01:02:27,266
我们这些就只填了一个信息

1138
01:02:27,266 --> 01:02:27,699
这个信息

1139
01:02:27,700 --> 01:02:31,300
就是你从支付宝或者微信里面拿到的

1140
01:02:31,300 --> 01:02:32,466
你的商户号

1141
01:02:32,933 --> 01:02:34,299
把这个信息填到

1142
01:02:34,300 --> 01:02:35,166
我这里来

1143
01:02:35,200 --> 01:02:37,000
那不仅仅是填到我这里来

1144
01:02:37,000 --> 01:02:39,666
我还需要调对应的支付渠道

1145
01:02:39,933 --> 01:02:42,066
去把这一个商户号

1146
01:02:42,066 --> 01:02:44,266
和我平台的商户号

1147
01:02:45,066 --> 01:02:47,366
绑定一个分账关系

1148
01:02:47,733 --> 01:02:48,199
这样的话

1149
01:02:48,200 --> 01:02:52,066
我才能从这个商支付渠道的

1150
01:02:52,066 --> 01:02:54,199
这个商户里头的账里头

1151
01:02:54,200 --> 01:02:56,166
把钱分到我的平台来

1152
01:02:56,533 --> 01:02:57,766
所以这一个API

1153
01:02:57,766 --> 01:03:00,533
虽然看起来是一个就是增加一个

1154
01:03:00,866 --> 01:03:02,166
填一个信息的

1155
01:03:02,166 --> 01:03:04,766
但是其实在里头是要去调支付渠道

1156
01:03:04,933 --> 01:03:07,866
需要去建立在这个支付渠道上头

1157
01:03:08,100 --> 01:03:10,700
平台和这个商户的分账关系

1158
01:03:11,400 --> 01:03:12,800
这是这个API

1159
01:03:13,100 --> 01:03:13,933
那我们可以看一下

1160
01:03:13,933 --> 01:03:15,466
我们是怎么来设计的

1161
01:03:16,700 --> 01:03:20,266
从这个service层我们写了一个方法

1162
01:03:20,266 --> 01:03:21,966
叫做create shop channel

1163
01:03:22,366 --> 01:03:24,099
创建一个shop channel

1164
01:03:25,066 --> 01:03:25,766
然后呢

1165
01:03:25,766 --> 01:03:28,466
因为我们是要在某一个支付渠道上面

1166
01:03:28,466 --> 01:03:30,599
去创建这个channel

1167
01:03:30,600 --> 01:03:31,900
所以说大家可以看到

1168
01:03:31,900 --> 01:03:32,200
基本上

1169
01:03:32,200 --> 01:03:36,366
我们在收费层的第一个方法都是一样

1170
01:03:36,900 --> 01:03:39,666
就是我们从控制器程拿到的是ID

1171
01:03:40,166 --> 01:03:41,766
到收费时程的第一个方法

1172
01:03:41,766 --> 01:03:43,933
我们通常会把ID变成对象

1173
01:03:44,300 --> 01:03:47,133
所以我们把这个channel ID

1174
01:03:47,333 --> 01:03:49,866
用channel到把它变成了对象

1175
01:03:50,166 --> 01:03:51,866
变成了一个channel对象

1176
01:03:52,500 --> 01:03:56,600
然后我们是要在这个支付渠道上面

1177
01:03:56,600 --> 01:03:58,800
去创建一个商户的

1178
01:03:59,800 --> 01:04:02,200
商户的这个支付渠道的

1179
01:04:02,333 --> 01:04:04,333
我们在这里使用的是什么呢

1180
01:04:04,333 --> 01:04:07,933
使用的是创建者的原则

1181
01:04:08,600 --> 01:04:14,000
我们让渠道去创建商户的支付渠道

1182
01:04:14,100 --> 01:04:15,933
为什么会有创建者的原则

1183
01:04:15,933 --> 01:04:17,999
大家可以看到在对象模型中间

1184
01:04:18,766 --> 01:04:20,999
他和他是整体和局部的关系

1185
01:04:21,000 --> 01:04:22,333
是一个组合关系

1186
01:04:22,466 --> 01:04:24,499
任何一个商户的支付渠道

1187
01:04:24,500 --> 01:04:27,533
一定是属于我们平台的

1188
01:04:27,533 --> 01:04:28,699
某一个支付渠道的

1189
01:04:28,766 --> 01:04:30,166
而且我们平台的支付

1190
01:04:30,166 --> 01:04:32,533
渠道会影响到商户的支付渠道

1191
01:04:32,533 --> 01:04:33,733
比如说我们刚才看到的

1192
01:04:33,766 --> 01:04:35,899
我们如果关闭了平台的支付渠道

1193
01:04:35,900 --> 01:04:38,933
那所有商户的对应的支付渠道

1194
01:04:38,933 --> 01:04:40,899
也就全部都关闭了啊

1195
01:04:40,900 --> 01:04:41,966
全部都关闭了

1196
01:04:42,366 --> 01:04:44,866
那我们现在这个做法就是

1197
01:04:45,800 --> 01:04:48,066
因为它是一个整体和局部的关系

1198
01:04:48,066 --> 01:04:49,899
所以在第三步这个地方

1199
01:04:49,900 --> 01:04:52,700
我们用的是信息专家的原则

1200
01:04:52,700 --> 01:04:55,933
在这一步用的是信息专家的原则

1201
01:04:56,133 --> 01:05:01,199
把创建这个支付渠道的这个职责

1202
01:05:01,533 --> 01:05:04,133
分配给了channel对象

1203
01:05:04,333 --> 01:05:05,366
所以channel对象中间

1204
01:05:05,366 --> 01:05:07,899
就有一个create shop channel的方法

1205
01:05:08,200 --> 01:05:11,166
在create shop channel的方法里头

1206
01:05:11,166 --> 01:05:14,133
我们可以看到他做了两件事情

1207
01:05:15,766 --> 01:05:16,333
好这里好

1208
01:05:16,333 --> 01:05:17,199
我少画了

1209
01:05:17,300 --> 01:05:18,733
少画了一条线啊

1210
01:05:21,000 --> 01:05:21,733
好对

1211
01:05:21,733 --> 01:05:22,933
做了两件事情

1212
01:05:23,000 --> 01:05:24,133
一件事情是

1213
01:05:24,133 --> 01:05:28,199
我首先要到支付渠道上去登记

1214
01:05:28,200 --> 01:05:28,400
说

1215
01:05:28,400 --> 01:05:31,466
我的平台跟这个账号建立了分账关系

1216
01:05:31,966 --> 01:05:32,966
这个事情是怎么做的呢

1217
01:05:32,966 --> 01:05:34,899
我们并没有直接去掉

1218
01:05:34,900 --> 01:05:36,900
微信和支付宝的支付渠道

1219
01:05:37,266 --> 01:05:39,133
而是通过了一个对象

1220
01:05:39,133 --> 01:05:41,066
这个对象叫做pay Adapter

1221
01:05:41,800 --> 01:05:43,166
这就是间接的对象

1222
01:05:43,166 --> 01:05:45,933
我们把通过这个对象

1223
01:05:46,133 --> 01:05:48,966
去调支付宝或者微信的支付渠道

1224
01:05:49,200 --> 01:05:50,533
无论是调微信

1225
01:05:50,533 --> 01:05:53,366
还是调支付宝的支付渠道

1226
01:05:53,700 --> 01:05:55,700
我们都写成一样的方法

1227
01:05:55,700 --> 01:05:56,566
一样的参数

1228
01:05:56,566 --> 01:05:57,299
一样的返回值

1229
01:05:57,300 --> 01:05:59,200
当然里头写的肯定是不一样的

1230
01:05:59,333 --> 01:06:00,866
但是我们调这个对象的时候

1231
01:06:00,866 --> 01:06:01,733
都是一样的方法

1232
01:06:01,733 --> 01:06:03,066
所以我们create channel

1233
01:06:03,500 --> 01:06:05,500
把shop channel传给他

1234
01:06:05,500 --> 01:06:07,966
然后他里头会根据支付宝还是微信

1235
01:06:08,333 --> 01:06:09,666
去分开写啊

1236
01:06:09,666 --> 01:06:10,566
去分开写

1237
01:06:10,766 --> 01:06:13,666
那在支付渠道上创建完了以后

1238
01:06:13,666 --> 01:06:15,733
我们才会去调稻城的方法

1239
01:06:15,866 --> 01:06:17,766
把它插到数据库里去啊

1240
01:06:17,766 --> 01:06:19,066
把它插到数据库里去

1241
01:06:19,100 --> 01:06:21,500
我们看一下这部分的这个代码

1242
01:06:27,700 --> 01:06:28,900
还是在这个

1243
01:06:30,900 --> 01:06:31,700
这个

1244
01:06:36,933 --> 01:06:37,899
这个代码大家可以看到

1245
01:06:37,900 --> 01:06:39,100
跟图上画的是一样

1246
01:06:39,200 --> 01:06:39,866
进来以后

1247
01:06:39,866 --> 01:06:42,166
我们首先从ID找到channel对象

1248
01:06:42,200 --> 01:06:45,933
然后把创建商户的支付渠道的

1249
01:06:45,933 --> 01:06:46,866
这个职责

1250
01:06:46,966 --> 01:06:48,933
分配给了我们

1251
01:06:48,933 --> 01:06:50,299
找到了这个channel对象

1252
01:06:50,300 --> 01:06:53,466
这个就是用的创建者的原则

1253
01:06:53,466 --> 01:06:55,533
因为shop channel的对象

1254
01:06:55,533 --> 01:06:58,499
和channel对象是整体和局部的关系

1255
01:06:58,500 --> 01:07:00,366
所以我们让他去创建

1256
01:07:03,466 --> 01:07:05,066
创建的过程啊

1257
01:07:05,066 --> 01:07:06,166
大家可以看到

1258
01:07:06,200 --> 01:07:08,666
里头做的事情是

1259
01:07:09,966 --> 01:07:13,166
我们首先把需要创建出来的

1260
01:07:13,166 --> 01:07:13,733
这个shop Chan

1261
01:07:13,733 --> 01:07:15,333
专项设成了invalid

1262
01:07:15,333 --> 01:07:17,299
就是我们创建出来它是无效的啊

1263
01:07:17,300 --> 01:07:21,866
需要需要商户去把它手工变成有效

1264
01:07:22,333 --> 01:07:23,666
然后把他的channel ID

1265
01:07:23,866 --> 01:07:25,966
做成我们当前这个渠道channel ID

1266
01:07:26,100 --> 01:07:27,466
然后这就在图上画

1267
01:07:27,566 --> 01:07:30,699
我们去调pay Adapter去签约

1268
01:07:30,700 --> 01:07:34,800
这个就调支付渠道去签约

1269
01:07:34,800 --> 01:07:38,700
这个商户签约完成了以后

1270
01:07:38,700 --> 01:07:40,066
如果他没有出任何错

1271
01:07:40,100 --> 01:07:43,800
我们则把这个东西插到数据库里去

1272
01:07:43,900 --> 01:07:45,500
然后把它返还回来

1273
01:07:45,566 --> 01:07:48,933
这个就是我们在这部分的代码所写的

1274
01:07:49,000 --> 01:07:53,666
那这个背后第167行

1275
01:07:53,666 --> 01:07:55,933
背后其实还做了更多的事情

1276
01:07:55,933 --> 01:07:56,499
我们知道

1277
01:07:56,500 --> 01:08:00,600
这个部分我们做的有两个支付渠道

1278
01:08:01,066 --> 01:08:01,399
对吧

1279
01:08:01,400 --> 01:08:04,333
两个支付渠道是需要写不同的代码的

1280
01:08:06,600 --> 01:08:08,166
那这部分是怎么做的呢

1281
01:08:08,500 --> 01:08:10,100
我们看一下这个类图

1282
01:08:10,266 --> 01:08:12,399
我们看到的代码是在这个地方

1283
01:08:12,533 --> 01:08:13,533
pay Adapter

1284
01:08:14,000 --> 01:08:16,733
在pay Adapter上我们写了很多的方法

1285
01:08:16,733 --> 01:08:17,333
这些方法

1286
01:08:17,333 --> 01:08:21,366
其实不仅仅是用在签约渠道里头的

1287
01:08:21,866 --> 01:08:24,299
后面的很多的方法其实都会掉

1288
01:08:24,600 --> 01:08:28,766
这些方法去操作支付宝和微信

1289
01:08:29,133 --> 01:08:30,733
那这里头我们可以看到

1290
01:08:31,133 --> 01:08:33,366
这个东西我们定义的是一个接口

1291
01:08:33,500 --> 01:08:36,200
而不是实现里头没有任何的实现

1292
01:08:36,300 --> 01:08:38,700
因为实际上对于微信和支付宝

1293
01:08:38,700 --> 01:08:40,566
他的实现是完全不一样的

1294
01:08:40,600 --> 01:08:43,866
因为微信和支付宝的API

1295
01:08:44,000 --> 01:08:44,966
是完全不一样的

1296
01:08:44,966 --> 01:08:46,866
它的API我们定义在这个里头了

1297
01:08:47,800 --> 01:08:50,333
定义在这两个子类里头了啊

1298
01:08:50,333 --> 01:08:51,733
定义在这两个类里头了

1299
01:08:51,900 --> 01:08:55,733
那我们针对微信和支付宝的API

1300
01:08:55,766 --> 01:08:59,066
我们在这个接口下面去做了两个实现

1301
01:08:59,066 --> 01:09:00,766
一个是微配的Adapter

1302
01:09:00,966 --> 01:09:02,499
一个是阿里配的Adapter

1303
01:09:02,966 --> 01:09:06,166
其实就是把微信和支付宝的API

1304
01:09:06,466 --> 01:09:08,166
通过这两个Adapter

1305
01:09:08,300 --> 01:09:10,700
转化成为这个相同的接口

1306
01:09:11,400 --> 01:09:15,533
我们的代码使用的是这些Adapter

1307
01:09:16,766 --> 01:09:20,399
使用是这些Adapter来访问这个东西的

1308
01:09:20,500 --> 01:09:24,066
这个就是我们所说的间接的原则

1309
01:09:24,333 --> 01:09:26,499
就是我们并没有让我们的代码

1310
01:09:26,500 --> 01:09:29,500
去直接使用微信和支付宝的接口

1311
01:09:29,566 --> 01:09:30,866
而是让我们的代码

1312
01:09:30,966 --> 01:09:33,199
通过了这个东西去使用它

1313
01:09:33,566 --> 01:09:35,099
这里融合了使用

1314
01:09:35,100 --> 01:09:38,166
我们刚才所说的多肽和间接的原则

1315
01:09:38,266 --> 01:09:40,533
第一我们间接的去使用这些Adapter

1316
01:09:40,733 --> 01:09:42,466
第二我们让两个Adapter

1317
01:09:42,900 --> 01:09:45,100
去实现了相同的接口

1318
01:09:45,333 --> 01:09:47,199
从而我们在使用的时候

1319
01:09:47,200 --> 01:09:48,866
可以用多肽的方式

1320
01:09:48,866 --> 01:09:53,199
不加区分的去使用微信的Adapter

1321
01:09:53,266 --> 01:09:55,066
或者使用阿里paid Adapter

1322
01:09:55,266 --> 01:09:57,366
这就是两个设计

1323
01:09:57,366 --> 01:09:59,133
两个方法合起来

1324
01:09:59,133 --> 01:10:01,799
用多态和间接的方式

1325
01:10:01,800 --> 01:10:03,533
最后实现了这样的一个设计

1326
01:10:03,866 --> 01:10:05,733
这个设计的主要的目的是为了什么呢

1327
01:10:05,733 --> 01:10:06,799
主要的目的就是

1328
01:10:06,800 --> 01:10:08,966
希望我们在channel以上

1329
01:10:08,966 --> 01:10:10,899
就这个部分以上的代码

1330
01:10:11,566 --> 01:10:12,933
这个部分以外的代码

1331
01:10:13,166 --> 01:10:15,999
在使用具体的支付渠道的时候

1332
01:10:16,000 --> 01:10:17,166
是不加区分的

1333
01:10:17,766 --> 01:10:19,166
就他没有任何在使

1334
01:10:19,166 --> 01:10:21,699
用微信或者使用支付宝的痕迹

1335
01:10:21,700 --> 01:10:23,466
就是在使用支付渠道

1336
01:10:23,466 --> 01:10:25,266
我们把微信和支付宝的API

1337
01:10:25,266 --> 01:10:26,566
统一成了一左API

1338
01:10:27,166 --> 01:10:28,533
这时候你知道这个设计

1339
01:10:28,533 --> 01:10:30,866
如果当我们的第三个支付渠道

1340
01:10:30,866 --> 01:10:31,666
加上来的时候

1341
01:10:31,700 --> 01:10:34,066
比如云闪付加上的时候

1342
01:10:34,066 --> 01:10:35,399
他的代码怎么写法了

1343
01:10:36,266 --> 01:10:37,066
你们觉得

1344
01:10:39,000 --> 01:10:40,100
如果我们的云闪付

1345
01:10:40,100 --> 01:10:41,166
这个支付渠道加上来

1346
01:10:41,166 --> 01:10:42,399
他的代码会怎么写法

1347
01:10:43,533 --> 01:10:44,333
写在哪

1348
01:10:50,866 --> 01:10:52,266
对这里再写一套

1349
01:10:53,733 --> 01:10:54,533
再写一个

1350
01:10:54,766 --> 01:10:57,799
因为云闪付的APS完全不一样了

1351
01:10:57,900 --> 01:11:00,266
所以需要写一个它的调用

1352
01:11:00,466 --> 01:11:02,866
然后我们还需要写一个云闪付的Adapter

1353
01:11:03,200 --> 01:11:04,866
实现相同的接口

1354
01:11:05,200 --> 01:11:06,000
接上来

1355
01:11:06,166 --> 01:11:09,566
这一边的代码是完全没有动的

1356
01:11:09,700 --> 01:11:10,500
就这一部分

1357
01:11:10,500 --> 01:11:12,600
写好的代码是完全没有动的

1358
01:11:12,766 --> 01:11:16,333
这个就是这个设计的最主要的用途

1359
01:11:16,766 --> 01:11:18,266
当我们不断的

1360
01:11:18,266 --> 01:11:21,733
有新的支付渠道上来的时候

1361
01:11:21,733 --> 01:11:23,066
我们只需要在这边

1362
01:11:23,066 --> 01:11:25,799
不停的去加新的内容

1363
01:11:26,000 --> 01:11:26,800
就好了

1364
01:11:26,900 --> 01:11:28,533
为什么能达成这样的一个效果

1365
01:11:28,533 --> 01:11:29,966
就是因为我们用到了Graspler

1366
01:11:29,966 --> 01:11:33,466
中间的间接和多肽

1367
01:11:33,700 --> 01:11:38,466
把两个设计的方法合用到了一起

1368
01:11:38,566 --> 01:11:40,599
最后达成了这样的一个效果

1369
01:11:40,800 --> 01:11:43,300
我们看一下这个代码里头怎么写的啊

1370
01:11:47,533 --> 01:11:48,566
所以大家可以看到

1371
01:11:48,566 --> 01:11:53,299
在我们的这个所有的的代码上面

1372
01:11:53,300 --> 01:11:55,133
其实都看不到你是用的支付宝

1373
01:11:55,133 --> 01:11:56,333
还是用的是微信

1374
01:11:56,566 --> 01:11:59,799
那这一个东西是一个接口

1375
01:12:17,766 --> 01:12:20,299
大家可以看到它定义的是一个接口

1376
01:12:24,966 --> 01:12:26,299
是一个INTERFACE

1377
01:12:27,166 --> 01:12:30,199
这个interface我们目前写了两个实线

1378
01:12:40,366 --> 01:12:41,199
写了两个实线

1379
01:12:41,200 --> 01:12:43,000
一个是阿里配的Adapter

1380
01:12:43,100 --> 01:12:45,500
一个是微信的Adapter

1381
01:12:46,200 --> 01:12:47,366
我们可以看一下

1382
01:12:47,700 --> 01:12:49,266
这是阿里配的Adapter

1383
01:12:49,266 --> 01:12:50,733
它实现了这样的一个

1384
01:12:50,733 --> 01:12:53,999
接口所以在阿里配的Adapter中间

1385
01:12:54,000 --> 01:12:55,533
我们对应的这个方法

1386
01:13:00,533 --> 01:13:02,066
啊这方法没写啊

1387
01:13:02,100 --> 01:13:04,166
这方法好像空写了呢

1388
01:13:05,700 --> 01:13:08,166
我没写这是留待同学们去写的

1389
01:13:08,500 --> 01:13:11,266
空了哈但是有很多我去写了

1390
01:13:11,266 --> 01:13:14,799
比如说我们可以看这个方法

1391
01:13:14,800 --> 01:13:19,100
这是创造一个退款分账的方法

1392
01:13:19,500 --> 01:13:21,466
这个方法里头我们可以看到

1393
01:13:21,466 --> 01:13:23,799
我们会按照阿里的方式

1394
01:13:23,933 --> 01:13:26,066
去构造它的参数

1395
01:13:26,300 --> 01:13:28,400
然后去掉阿里佩的

1396
01:13:33,933 --> 01:13:34,733
去

1397
01:13:36,000 --> 01:13:38,133
完成这样的一个退款分账

1398
01:13:38,333 --> 01:13:40,299
这个部分用的是open FIN写的

1399
01:13:40,733 --> 01:13:43,566
这里用了一个在微服务中间的

1400
01:13:43,566 --> 01:13:44,566
open FIN的方式

1401
01:13:44,566 --> 01:13:46,599
因为我们现在这个Alipay的服务

1402
01:13:46,600 --> 01:13:49,500
并不是真正掉支付宝的

1403
01:13:49,500 --> 01:13:50,533
如果真正吊支付宝的

1404
01:13:50,533 --> 01:13:51,366
其实也可以这么吊

1405
01:13:51,366 --> 01:13:52,999
因为他是race for API的啊

1406
01:13:53,066 --> 01:13:55,266
他现在不是吊真正支付宝的

1407
01:13:55,366 --> 01:13:55,599
所以

1408
01:13:55,600 --> 01:13:59,300
我们会把这个部分做一个模拟的模块

1409
01:13:59,666 --> 01:14:01,966
然后去调用它

1410
01:14:02,466 --> 01:14:03,299
那调的方式

1411
01:14:03,300 --> 01:14:05,366
就是用的open friend的方式去调

1412
01:14:05,533 --> 01:14:08,099
所以我们会调他的这个API

1413
01:14:08,266 --> 01:14:11,133
然后通过微服务的方式啊

1414
01:14:11,133 --> 01:14:12,866
去调他的refund方法

1415
01:14:13,000 --> 01:14:15,566
这个模拟的所有的URL

1416
01:14:15,566 --> 01:14:17,799
写的跟真正的URL是完全一样

1417
01:14:18,100 --> 01:14:20,533
只是前面加了一个internal

1418
01:14:21,300 --> 01:14:22,800
其他的都是完全一模一样的

1419
01:14:22,800 --> 01:14:23,700
所以如果说

1420
01:14:23,700 --> 01:14:27,400
要切换到真正的阿迪佩德微服务的话

1421
01:14:27,533 --> 01:14:30,366
只是把这个IP改成它的网关

1422
01:14:30,466 --> 01:14:33,499
把前面这个部分给它拿掉就可以了

1423
01:14:33,500 --> 01:14:36,500
就能调到那个真正的接口了

1424
01:14:36,500 --> 01:14:37,266
但我们现在做的是

1425
01:14:37,266 --> 01:14:38,733
自己一个模拟的接口

1426
01:14:38,733 --> 01:14:40,533
没有真正去调它的东西

1427
01:14:41,100 --> 01:14:44,500
这是这样的一个设计啊

1428
01:14:46,100 --> 01:14:48,200
那其他的API之呃

1429
01:14:48,200 --> 01:14:49,800
微信那边我们就不看了

1430
01:14:49,800 --> 01:14:50,533
其实是一样的

1431
01:14:50,533 --> 01:14:51,466
就是因为它的

1432
01:14:51,466 --> 01:14:53,966
接口参数返回值都不一样

1433
01:14:54,200 --> 01:14:56,700
所以我们需要用这个Adapter

1434
01:14:56,700 --> 01:14:59,133
去把它变成一样

1435
01:14:59,300 --> 01:15:00,900
传进来的值都是一样的

1436
01:15:00,900 --> 01:15:02,700
但是变成每一个支付渠道

1437
01:15:02,700 --> 01:15:06,000
不同的参数传还的值是不一样的

1438
01:15:06,000 --> 01:15:08,400
我们把它统一成为相同的返回值啊

1439
01:15:08,400 --> 01:15:09,333
给它返回回来

1440
01:15:10,000 --> 01:15:11,133
这里就有一个问题

1441
01:15:11,133 --> 01:15:12,866
我们知道在channel的时候

1442
01:15:12,866 --> 01:15:13,899
他用的时候

1443
01:15:13,900 --> 01:15:15,866
他是要用不同的Adapter

1444
01:15:15,966 --> 01:15:18,199
如果我开的是微信的支付渠道

1445
01:15:18,200 --> 01:15:19,500
需要用这个Adapter

1446
01:15:19,600 --> 01:15:22,933
如果我开的是支付宝的支付渠道

1447
01:15:23,133 --> 01:15:24,566
用的是这个Adapter

1448
01:15:24,566 --> 01:15:27,799
我们在channel间放的是这个类型

1449
01:15:27,800 --> 01:15:28,900
接口类型

1450
01:15:29,366 --> 01:15:31,166
真正住进去的实力

1451
01:15:31,166 --> 01:15:33,933
放进去的关联的对象是这个对象

1452
01:15:33,933 --> 01:15:35,599
或者是这个对象

1453
01:15:35,933 --> 01:15:38,699
那到底是放这个对象还是放这个对象

1454
01:15:38,966 --> 01:15:41,766
关键要看那个channel到底是什么类型

1455
01:15:41,766 --> 01:15:43,799
如果我们的channel是支付宝

1456
01:15:44,066 --> 01:15:46,299
就放Alipay Adapter

1457
01:15:46,300 --> 01:15:48,933
如果这个channel是微信

1458
01:15:48,966 --> 01:15:51,366
就放微pay adapter

1459
01:15:51,733 --> 01:15:54,466
那问题在于说谁来做这个判断

1460
01:15:54,900 --> 01:15:57,800
我们不希望这一段代码

1461
01:15:58,166 --> 01:16:01,399
写死在这一段的逻辑

1462
01:16:01,400 --> 01:16:03,100
写死在代码中间

1463
01:16:03,466 --> 01:16:04,266
为啥

1464
01:16:04,800 --> 01:16:08,400
因为我们的支付渠道是会不断的增长

1465
01:16:08,733 --> 01:16:11,099
我们在增长支付渠道的时候

1466
01:16:11,100 --> 01:16:14,400
我们希望做到的原则是什么

1467
01:16:14,600 --> 01:16:17,566
就是只需要增加代码

1468
01:16:18,333 --> 01:16:21,966
而不改动现在所有写好的代码

1469
01:16:22,166 --> 01:16:23,733
我们的这个设计模就这个样子

1470
01:16:24,066 --> 01:16:25,333
只增加代码

1471
01:16:25,333 --> 01:16:26,766
你当你多了一个支付渠道

1472
01:16:26,766 --> 01:16:28,299
你肯定要增加一组代码

1473
01:16:28,566 --> 01:16:32,066
但是这一部分的所有的已有代码

1474
01:16:32,133 --> 01:16:34,199
我们希望一行都不改

1475
01:16:35,466 --> 01:16:36,999
所以在这个设计中间

1476
01:16:37,200 --> 01:16:40,700
我们又做了一个东西

1477
01:16:40,700 --> 01:16:44,000
这个东西叫做PD adapted factory

1478
01:16:44,566 --> 01:16:45,999
这个是什么设计方法呢

1479
01:16:46,000 --> 01:16:46,933
这个就是我们说的

1480
01:16:46,933 --> 01:16:48,499
创建者的设计方法

1481
01:16:48,600 --> 01:16:51,466
这个实际上就是对于一个channel

1482
01:16:51,600 --> 01:16:54,133
它要放一个adapted进去

1483
01:16:54,466 --> 01:16:57,299
但放哪个adapted进去呢

1484
01:16:58,366 --> 01:16:59,933
但放哪个Adapter进去了

1485
01:16:59,933 --> 01:17:01,499
这个这个逻辑

1486
01:17:01,533 --> 01:17:05,199
我们把它写到了这个里头

1487
01:17:05,866 --> 01:17:06,566
把它写到这里

1488
01:17:06,566 --> 01:17:09,199
就是本来的这个创建过程

1489
01:17:09,200 --> 01:17:11,266
是应该由他来创建的

1490
01:17:11,300 --> 01:17:14,266
但是我们希望这个创建过程不会

1491
01:17:14,266 --> 01:17:15,766
因为不同的Adapter不同

1492
01:17:16,000 --> 01:17:18,100
所以我们把它写到了这个里头

1493
01:17:18,400 --> 01:17:20,166
这个里头的代码是怎么写的啊

1494
01:17:20,166 --> 01:17:21,499
我们给大家看一下

1495
01:17:36,100 --> 01:17:37,933
我们写了一个类叫做

1496
01:17:39,300 --> 01:17:41,200
呃pay Adapter factory

1497
01:17:41,300 --> 01:17:43,466
这个类里头的方法其实就是一个

1498
01:17:43,466 --> 01:17:45,366
就是为了创建那个Adapter

1499
01:17:46,166 --> 01:17:47,399
就是为了创建Adapter

1500
01:17:47,466 --> 01:17:48,199
大家会发现

1501
01:17:48,200 --> 01:17:51,000
这个里头代码写的很看不懂

1502
01:17:51,000 --> 01:17:54,600
为什么这样就能够创建出来这个Adapter

1503
01:17:54,666 --> 01:17:56,299
我们从这个代码中间啊

1504
01:17:56,300 --> 01:17:57,166
其实可以看到

1505
01:17:57,166 --> 01:17:59,266
当我们写一个设计的时候

1506
01:17:59,566 --> 01:18:02,566
它不是单纯的靠语言写出来的

1507
01:18:02,866 --> 01:18:03,333
这个设计

1508
01:18:03,333 --> 01:18:05,599
一定是在一个特定的技术架构上

1509
01:18:05,600 --> 01:18:06,500
去实现的

1510
01:18:06,666 --> 01:18:07,133
所以

1511
01:18:07,133 --> 01:18:10,133
技术架构会为你做这样的一个设计

1512
01:18:10,133 --> 01:18:12,099
提供了各种可能性

1513
01:18:12,600 --> 01:18:16,666
这个实现利用的是spring框架的并对象

1514
01:18:17,100 --> 01:18:20,800
我们把我们在这张图上看到的

1515
01:18:25,400 --> 01:18:26,266
这个东西

1516
01:18:26,800 --> 01:18:27,666
这个对象

1517
01:18:28,300 --> 01:18:29,166
这个对象

1518
01:18:29,933 --> 01:18:31,666
都把它定义成为

1519
01:18:31,666 --> 01:18:33,299
在spring中间的并对象

1520
01:18:33,300 --> 01:18:34,200
所以大家可以看到

1521
01:18:34,200 --> 01:18:37,266
在stereotype中间都写了它是repository

1522
01:18:37,900 --> 01:18:41,166
那spring中间的冰对象有一个好处

1523
01:18:41,300 --> 01:18:42,100
这个好处就是

1524
01:18:42,100 --> 01:18:44,200
这个对象是由spring构造出来的

1525
01:18:44,366 --> 01:18:47,133
而且spring可以让你通过名字

1526
01:18:47,333 --> 01:18:49,999
去找到对应的冰对象

1527
01:18:50,533 --> 01:18:51,166
所以呢

1528
01:18:51,166 --> 01:18:54,533
在这个设计中间我们可以看到

1529
01:18:54,533 --> 01:18:58,099
当我们需要去拿到一个冰对象的时候

1530
01:18:58,333 --> 01:18:59,799
我们用了一个

1531
01:19:01,300 --> 01:19:03,100
create pay adapter的方法

1532
01:19:03,100 --> 01:19:04,600
写到了这个factory里头

1533
01:19:05,566 --> 01:19:08,199
这个方法里头其实就是一行是干嘛呢

1534
01:19:08,200 --> 01:19:12,733
就是从上下文里头去拿到这个冰对象

1535
01:19:12,900 --> 01:19:14,466
这个冰对象的名字是什么

1536
01:19:14,466 --> 01:19:17,066
是channel的being the name

1537
01:19:17,533 --> 01:19:19,199
所以在这里头啊

1538
01:19:19,700 --> 01:19:20,700
大家可以看一下

1539
01:19:20,700 --> 01:19:23,500
在lay的上面这个地方

1540
01:19:24,166 --> 01:19:26,566
我们这里有写了一个being name

1541
01:19:27,133 --> 01:19:28,266
在channel里头

1542
01:19:28,466 --> 01:19:30,066
所以这是存在数据库里的

1543
01:19:30,066 --> 01:19:33,733
如果他是支付宝的支付渠道

1544
01:19:33,800 --> 01:19:37,500
这个b name就是写实成为微pay Adapter

1545
01:19:37,800 --> 01:19:40,600
如果它是微信的支付渠道

1546
01:19:40,766 --> 01:19:43,766
这个b name写的就是阿里pay的Adapter

1547
01:19:44,166 --> 01:19:47,333
这个是需要写到数据库里的

1548
01:19:47,466 --> 01:19:49,099
那有了这个东西

1549
01:19:49,100 --> 01:19:52,533
我们利用spring框架的并对象

1550
01:19:52,533 --> 01:19:55,499
由名字找到对象的这样的一个方式

1551
01:19:55,700 --> 01:19:58,333
就可以把channel丢给他

1552
01:19:58,966 --> 01:20:00,266
他的这个方法中间

1553
01:20:00,266 --> 01:20:01,999
其实这个参数就是这个channel

1554
01:20:02,466 --> 01:20:04,666
然后通过他的这个名字

1555
01:20:04,666 --> 01:20:06,333
把这个并对象找到

1556
01:20:06,333 --> 01:20:09,133
然后设到他的属性上去

1557
01:20:09,133 --> 01:20:10,499
这个代码就是这么写的

1558
01:20:23,666 --> 01:20:24,733
啊这个单元就这么写的

1559
01:20:24,733 --> 01:20:27,966
可以看到这个contact是什么呢contact是

1560
01:20:30,333 --> 01:20:31,366
注入进来的

1561
01:20:31,366 --> 01:20:34,099
就是我们定义了一个BKT的上下文啊

1562
01:20:34,100 --> 01:20:34,966
在spin框架中间

1563
01:20:34,966 --> 01:20:37,466
应该讲到spin的框架呃

1564
01:20:37,466 --> 01:20:38,766
它构造一个冰对象

1565
01:20:38,766 --> 01:20:40,199
主要是通过两种方式

1566
01:20:40,200 --> 01:20:41,300
一个是上下文

1567
01:20:41,300 --> 01:20:43,600
一个是冰factory

1568
01:20:43,666 --> 01:20:45,899
那我们现在这里用的是上下文

1569
01:20:46,333 --> 01:20:48,766
所以我们让spin的框架

1570
01:20:48,766 --> 01:20:50,266
给我们的这个factory

1571
01:20:50,400 --> 01:20:52,166
注入了一个上下文

1572
01:20:52,533 --> 01:20:54,066
注入上下文以后啊

1573
01:20:54,100 --> 01:20:56,666
我们就可以利用它注进上这个上下文

1574
01:20:56,866 --> 01:20:58,866
根据名字找到这

1575
01:20:58,866 --> 01:20:59,499
个并对象

1576
01:20:59,500 --> 01:21:00,600
而这个名字

1577
01:21:00,600 --> 01:21:02,600
实际上是放到channel对象的属性里的

1578
01:21:02,966 --> 01:21:05,299
所以我们只要传进去一个channel对象

1579
01:21:05,366 --> 01:21:08,666
根据他的BNM就会找到对应的BN对象

1580
01:21:08,866 --> 01:21:10,799
那有了这个方式以后啊

1581
01:21:10,800 --> 01:21:11,700
所以可以看到

1582
01:21:11,700 --> 01:21:12,933
在我们的channel里头

1583
01:21:18,466 --> 01:21:19,066
在我们家里头

1584
01:21:19,066 --> 01:21:19,999
我们属性定义的

1585
01:21:20,000 --> 01:21:21,766
是我们最终要的那个Adapter

1586
01:21:21,766 --> 01:21:22,799
Willi pay Adapter

1587
01:21:22,800 --> 01:21:24,533
或者说是Alipay Adapter

1588
01:21:24,566 --> 01:21:24,799
但是

1589
01:21:24,800 --> 01:21:26,966
我们的类型写的是上面的这个参数

1590
01:21:27,466 --> 01:21:28,266
然后呢

1591
01:21:29,066 --> 01:21:29,899
这个是不要的啊

1592
01:21:29,900 --> 01:21:31,100
它是不能set的

1593
01:21:31,300 --> 01:21:33,466
然后我们给它定义了一个set的方法

1594
01:21:34,066 --> 01:21:35,599
这个set的方法

1595
01:21:36,200 --> 01:21:37,200
传的参数

1596
01:21:37,200 --> 01:21:40,466
不是正常的set方法的这个adapt对象

1597
01:21:40,466 --> 01:21:41,999
而是一个factory

1598
01:21:43,100 --> 01:21:44,666
而是传的是一个factory

1599
01:21:44,700 --> 01:21:45,500
这个factory呢

1600
01:21:45,500 --> 01:21:46,166
会干嘛呢

1601
01:21:46,166 --> 01:21:50,399
会根据当前的channel对象的属性

1602
01:21:50,600 --> 01:21:54,600
去把这个adapt对象给它构造出来

1603
01:21:54,666 --> 01:21:55,466
收回来

1604
01:21:55,766 --> 01:21:58,933
所以当我们在做这个代码的时候

1605
01:21:58,933 --> 01:22:00,999
我们其实看不到任何

1606
01:22:01,000 --> 01:22:03,100
这是微信还是支付宝

1607
01:22:03,533 --> 01:22:06,399
这个到底是微信还是支付宝

1608
01:22:07,066 --> 01:22:08,466
这个内容写在哪呢

1609
01:22:08,733 --> 01:22:10,299
没有写在代码中间

1610
01:22:10,466 --> 01:22:13,999
而写在了我们的这个属性名称里头

1611
01:22:15,366 --> 01:22:17,999
然后我们把这个对象交给他

1612
01:22:18,200 --> 01:22:20,933
由他根据我们的对象里头的属性

1613
01:22:21,166 --> 01:22:23,799
把我们对应的这个对象和这个对象

1614
01:22:23,800 --> 01:22:24,866
把它构造出来

1615
01:22:25,500 --> 01:22:26,533
这其实不是构造出来

1616
01:22:26,533 --> 01:22:27,333
是找出来

1617
01:22:27,333 --> 01:22:27,966
因为大家知道

1618
01:22:27,966 --> 01:22:29,099
在spin框架中间

1619
01:22:29,266 --> 01:22:30,866
这些对象并不是我们构造的

1620
01:22:30,866 --> 01:22:33,133
而是由spin的框架来创建的

1621
01:22:33,200 --> 01:22:33,466
所以

1622
01:22:33,466 --> 01:22:36,166
我们这里看起来是create一个pay Adapter

1623
01:22:36,466 --> 01:22:38,766
实际上是从spin的框架中间

1624
01:22:38,766 --> 01:22:40,866
把对应的这个对象给它找出来

1625
01:22:41,000 --> 01:22:42,100
给它返回回来

1626
01:22:42,100 --> 01:22:44,466
然后设到我们的这个对象上去

1627
01:22:44,733 --> 01:22:46,699
这就是我们这里所看到的这个

1628
01:22:47,666 --> 01:22:48,799
这个设计

1629
01:22:48,800 --> 01:22:52,466
做到做这个设计的主要的初衷

1630
01:22:52,600 --> 01:22:55,000
就是我们希望在我们的代码中间

1631
01:22:55,266 --> 01:22:56,933
没有一行代码

1632
01:22:57,000 --> 01:22:59,500
是跟微信和支付宝有关的

1633
01:22:59,500 --> 01:23:02,000
我是说的从这以上

1634
01:23:02,900 --> 01:23:05,533
从这以上的所有的代码中间

1635
01:23:05,733 --> 01:23:08,733
没有任何的痕迹是跟具体的支付宝

1636
01:23:09,100 --> 01:23:10,300
微信有关的

1637
01:23:10,566 --> 01:23:13,999
这个信息是写在了它的属性里头的

1638
01:23:14,133 --> 01:23:15,766
属性存在数据库里头的

1639
01:23:16,066 --> 01:23:17,499
这个东西的获取

1640
01:23:17,500 --> 01:23:20,766
是利用Supreme框架本身的技术特征

1641
01:23:21,000 --> 01:23:22,333
来实现的哈

1642
01:23:23,166 --> 01:23:23,599
所以

1643
01:23:23,600 --> 01:23:29,566
这里是我们所说的这个呃间接虚构

1644
01:23:29,666 --> 01:23:33,399
加上了呃间接和多肽的原则

1645
01:23:33,666 --> 01:23:38,966
加上了我们用的一个创建者的模式

1646
01:23:38,966 --> 01:23:41,333
啊最后形成了这样的一个方法

1647
01:23:42,200 --> 01:23:45,533
这是我们的这个设计

1648
01:23:46,933 --> 01:23:47,966
这个是有问题吗

1649
01:23:48,300 --> 01:23:49,900
可能比较难一点啊

1650
01:23:49,900 --> 01:23:51,933
因为前面都是讲的是孤立的

1651
01:23:52,133 --> 01:23:52,966
那到这里的话

1652
01:23:52,966 --> 01:23:57,199
我们就把两个三个方法融到一起去了

1653
01:23:57,366 --> 01:23:59,466
实际上在做的时候都是这样

1654
01:23:59,566 --> 01:24:02,466
因为设计不是简单的东西

1655
01:24:02,466 --> 01:24:04,299
简单东西是不需要做设计的

1656
01:24:04,566 --> 01:24:06,366
复杂的东西才需要做设计

1657
01:24:06,366 --> 01:24:07,199
那越复杂

1658
01:24:07,200 --> 01:24:09,300
意味着我们是没办法孤立地

1659
01:24:09,300 --> 01:24:10,966
使用一个设计方法

1660
01:24:11,100 --> 01:24:12,666
来达成我们的设计目的的

1661
01:24:12,666 --> 01:24:16,133
所以这里综合使用了三种设计的方式

1662
01:24:22,166 --> 01:24:24,933
好我们再看一个用它的解约

1663
01:24:25,866 --> 01:24:27,566
所以看到签约是怎么做的

1664
01:24:28,066 --> 01:24:29,966
解约就应该知道是怎么做的

1665
01:24:30,133 --> 01:24:31,133
对吧在解约里头

1666
01:24:31,133 --> 01:24:32,466
我们同样看不到

1667
01:24:32,766 --> 01:24:34,399
任何微信和支付宝的痕迹

1668
01:24:34,400 --> 01:24:34,600
但是

1669
01:24:34,600 --> 01:24:37,000
我们还是要去调他的支付渠道的API

1670
01:24:37,266 --> 01:24:41,133
去把商户的账户和我们平台解约掉

1671
01:24:41,133 --> 01:24:44,199
这样我们就不能去对它进行分账

1672
01:24:44,800 --> 01:24:45,533
这是这个

1673
01:24:45,533 --> 01:24:47,733
API啊所要做到的事情

1674
01:24:47,900 --> 01:24:49,000
但它的逻辑啊

1675
01:24:49,000 --> 01:24:49,566
大家可以看到

1676
01:24:49,566 --> 01:24:51,099
我们就不用看代码了

1677
01:24:52,200 --> 01:24:53,700
我们看到的就是

1678
01:24:55,166 --> 01:24:57,333
呃SOS层找到对象

1679
01:24:57,533 --> 01:24:59,499
然后把解约这个职责

1680
01:24:59,500 --> 01:25:01,166
分配给了这个对象

1681
01:25:01,266 --> 01:25:02,566
然后在这个对象中间呢

1682
01:25:02,566 --> 01:25:06,166
他会去掉支付渠道的cancer channel的方法

1683
01:25:07,200 --> 01:25:08,000
去取消它

1684
01:25:08,100 --> 01:25:10,500
那因为我们在设计

1685
01:25:10,500 --> 01:25:12,733
在注入这个pay Adapter的时候

1686
01:25:12,733 --> 01:25:15,066
会根据这个shop channel的不同类型

1687
01:25:15,066 --> 01:25:16,766
放进去不同的pay Adapter

1688
01:25:17,000 --> 01:25:18,400
所以他就会去调微信

1689
01:25:18,400 --> 01:25:20,400
或者是支付宝的control channel

1690
01:25:21,200 --> 01:25:23,000
去完成这样的一个解约过程

1691
01:25:23,000 --> 01:25:24,600
那解约完了以后

1692
01:25:24,600 --> 01:25:28,966
我们是真正的把这个顾客的账户信息

1693
01:25:29,133 --> 01:25:31,499
从数据库里给他删除掉

1694
01:25:31,900 --> 01:25:33,966
所以说是直接delete啊

1695
01:25:33,966 --> 01:25:35,199
给他删除掉

1696
01:25:35,566 --> 01:25:37,966
这就是我们的这个解约

1697
01:25:39,700 --> 01:25:40,466
这里头啊

1698
01:25:40,466 --> 01:25:42,066
我们其实看到了一个

1699
01:25:42,066 --> 01:25:45,066
我们设计的一个价值观

1700
01:25:45,533 --> 01:25:46,999
这个价值观是什么呢

1701
01:25:47,000 --> 01:25:50,400
是我们所说的高类距低有核

1702
01:25:50,666 --> 01:25:53,499
叫做low coppering和high coherence do

1703
01:25:53,866 --> 01:25:56,499
和所要解决的问题就是

1704
01:25:56,500 --> 01:25:58,400
我们知道我们在整个代码中间

1705
01:25:58,400 --> 01:26:01,200
是有一部分是会不断发生变化的

1706
01:26:01,666 --> 01:26:03,466
那我们在做设计的时候

1707
01:26:03,466 --> 01:26:04,866
我们的设计目标

1708
01:26:05,100 --> 01:26:07,300
是使得这部分会变化的

1709
01:26:07,300 --> 01:26:08,533
变动的内容

1710
01:26:08,800 --> 01:26:11,600
不会影响到我们的其他代码

1711
01:26:12,900 --> 01:26:14,066
那这样的话

1712
01:26:14,066 --> 01:26:14,799
就会使得将来

1713
01:26:14,800 --> 01:26:16,100
当这部分发生变化的时候

1714
01:26:16,100 --> 01:26:18,066
我们其他代码是不用去改动的

1715
01:26:18,133 --> 01:26:21,299
只需要去增加新的代码

1716
01:26:21,333 --> 01:26:23,533
而不会动到已有的代码

1717
01:26:23,666 --> 01:26:25,466
这就是我们所说的低有和

1718
01:26:25,733 --> 01:26:27,899
那高类距的部分

1719
01:26:27,900 --> 01:26:31,700
是我们对于整个代码中间的每一块

1720
01:26:32,266 --> 01:26:33,866
应该要去做什么

1721
01:26:33,866 --> 01:26:35,366
应该是有对聚性的

1722
01:26:35,366 --> 01:26:37,866
就是这一段代码应该写在什么地方

1723
01:26:38,300 --> 01:26:38,966
是应该好

1724
01:26:38,966 --> 01:26:39,766
理解的啊

1725
01:26:39,766 --> 01:26:40,499
好理解的

1726
01:26:40,500 --> 01:26:42,733
我们在这一部分的这个设计中间

1727
01:26:43,600 --> 01:26:45,166
在整体的这个设计中间

1728
01:26:45,333 --> 01:26:48,966
其实就体现了我们所说的高类距

1729
01:26:48,966 --> 01:26:49,799
低o和

1730
01:26:50,566 --> 01:26:51,399
它的do和

1731
01:26:51,400 --> 01:26:52,333
体现在哪呢

1732
01:26:52,333 --> 01:26:54,866
体现在我们这个设计的主要的目标

1733
01:26:55,000 --> 01:26:57,866
就是降低我们从这一部分代码

1734
01:26:59,166 --> 01:27:00,099
这部分代码

1735
01:27:00,100 --> 01:27:02,400
和会变动的支付渠道的

1736
01:27:02,400 --> 01:27:04,400
这部分代码的偶合性

1737
01:27:04,700 --> 01:27:05,900
所以大家刚刚可以看到

1738
01:27:05,900 --> 01:27:07,733
我们所有的设计目标都是

1739
01:27:07,733 --> 01:27:11,299
当我们增加一个支付渠道的时候

1740
01:27:11,500 --> 01:27:14,900
不要影响我们的这部分的所有的代码

1741
01:27:15,933 --> 01:27:17,299
不去影响他啊

1742
01:27:17,300 --> 01:27:19,333
所以这就是这个低偶和的设计

1743
01:27:19,600 --> 01:27:21,366
高类距的设计是什么呢

1744
01:27:21,366 --> 01:27:22,166
高类距设计

1745
01:27:22,166 --> 01:27:22,799
我们可以看到

1746
01:27:22,800 --> 01:27:25,200
针对每一个部分的增加的代码

1747
01:27:25,266 --> 01:27:25,933
你会发现

1748
01:27:25,933 --> 01:27:29,133
他不但不会影响到我们的

1749
01:27:29,166 --> 01:27:30,666
这部分的主体的代码

1750
01:27:30,666 --> 01:27:33,066
他甚至连这一部分的代码

1751
01:27:34,166 --> 01:27:35,266
都不会影响到

1752
01:27:35,300 --> 01:27:38,333
他只是在这里去加一个代码

1753
01:27:38,600 --> 01:27:41,366
所以能做到这一点的主要的原则

1754
01:27:41,366 --> 01:27:43,199
是因为我们在整个设计中间

1755
01:27:43,366 --> 01:27:44,333
这部分代码

1756
01:27:44,333 --> 01:27:45,299
这部分代码

1757
01:27:45,300 --> 01:27:47,333
这一部分代码上面的这部分代码

1758
01:27:47,333 --> 01:27:48,766
包括稻城的这部分代码

1759
01:27:48,966 --> 01:27:52,466
为什么这些代码会写在这个类里面

1760
01:27:53,266 --> 01:27:55,399
是有极强的原则的

1761
01:27:55,400 --> 01:27:57,066
这个原则就是类举行

1762
01:27:57,500 --> 01:28:01,100
就是你会用一个统一的原则

1763
01:28:01,333 --> 01:28:05,499
来决定说这个代码到底写在什么地方

1764
01:28:06,400 --> 01:28:07,066
我们可以看到

1765
01:28:07,066 --> 01:28:08,766
我们目前所用到的原则

1766
01:28:08,766 --> 01:28:11,066
主要会决定一段代码

1767
01:28:11,366 --> 01:28:13,199
是否写在这个类里头的

1768
01:28:13,200 --> 01:28:14,400
主要的原则

1769
01:28:14,666 --> 01:28:15,066
就是

1770
01:28:15,066 --> 01:28:18,999
体系结构的原则和面向对象的原则

1771
01:28:19,400 --> 01:28:20,333
体系结构的原则

1772
01:28:20,333 --> 01:28:22,399
决定了我们的稻城应该写什么样代码

1773
01:28:22,600 --> 01:28:24,300
在收费层应该写什么样代码

1774
01:28:24,466 --> 01:28:25,699
在控制器层应该写什么

1775
01:28:25,700 --> 01:28:27,933
样代码在map层应该写什么样代码

1776
01:28:28,200 --> 01:28:29,933
我们的面向对象的原则

1777
01:28:29,933 --> 01:28:31,366
决定了这些代码

1778
01:28:31,366 --> 01:28:35,599
到底是应该在哪一个类里面啊

1779
01:28:35,600 --> 01:28:39,066
所以你把这些原则给他用上去以后

1780
01:28:39,066 --> 01:28:40,299
我们的这个代码

1781
01:28:40,300 --> 01:28:43,866
自然就是一个类聚的啊

1782
01:28:43,866 --> 01:28:44,666
然后呢

1783
01:28:45,166 --> 01:28:48,166
因为我们会发现某部分的东西

1784
01:28:48,166 --> 01:28:49,999
它是会发生变化的

1785
01:28:50,100 --> 01:28:51,900
所以我们再想办法

1786
01:28:51,933 --> 01:28:53,466
让这部分的东西

1787
01:28:53,533 --> 01:28:55,666
跟我们的偶合度去降低啊

1788
01:28:55,666 --> 01:28:57,699
这就是我们说的高内距

1789
01:28:57,700 --> 01:29:00,066
Dior和no Carpet和海口飞行

1790
01:29:00,100 --> 01:29:00,900
这个我们说过

1791
01:29:00,900 --> 01:29:03,866
这个其实不是具体的设计方法

1792
01:29:04,366 --> 01:29:07,066
这是我们的设计的价值观

1793
01:29:07,533 --> 01:29:09,966
就是做面向对象的设计

1794
01:29:10,133 --> 01:29:12,166
最终所要达成的目的

1795
01:29:12,166 --> 01:29:14,199
就是每一段代码

1796
01:29:14,400 --> 01:29:16,966
都在最合适他待的地方

1797
01:29:18,166 --> 01:29:22,099
会变化的部分或者要扩展的部分

1798
01:29:22,300 --> 01:29:25,666
一定跟不变的部分是有切开的

1799
01:29:26,266 --> 01:29:27,566
是有低偶和的

1800
01:29:27,700 --> 01:29:29,400
这样当变化发生的时候

1801
01:29:29,400 --> 01:29:31,800
或者说当我们要去扩展的时候

1802
01:29:31,800 --> 01:29:34,900
我们才不会影响到现有的代码啊

1803
01:29:34,900 --> 01:29:37,133
这就是我们说的低偶和高类距

1804
01:29:37,266 --> 01:29:38,399
这是两个价值观

1805
01:29:40,166 --> 01:29:41,299
那最后的话

1806
01:29:41,300 --> 01:29:44,000
我们要把软件设计的7大原则

1807
01:29:44,000 --> 01:29:45,400
给大家先过一下

1808
01:29:45,400 --> 01:29:45,933
为什么呢

1809
01:29:45,933 --> 01:29:48,099
因为之后我们要讲更多的

1810
01:29:48,100 --> 01:29:50,000
在支付部分的设计

1811
01:29:50,333 --> 01:29:52,899
以及产品和商铺部分的设计

1812
01:29:53,000 --> 01:29:55,333
其实里头所用到的东西

1813
01:29:55,333 --> 01:29:58,266
小的原则是GRASP的创建者

1814
01:29:58,266 --> 01:30:00,533
信息专家间接的原则

1815
01:30:00,533 --> 01:30:04,866
多态的原则以及Dior和高类聚

1816
01:30:05,700 --> 01:30:06,666
大的原则

1817
01:30:06,666 --> 01:30:09,399
其实是我们这里要讲到的

1818
01:30:09,400 --> 01:30:10,666
软件设计的其他原则

1819
01:30:10,666 --> 01:30:13,066
这个实际上是从不同的角度

1820
01:30:13,266 --> 01:30:15,333
去讲同样的事情

1821
01:30:15,333 --> 01:30:17,499
我们前面讲的Grasp这些方法

1822
01:30:17,600 --> 01:30:19,066
其实是细节的方法

1823
01:30:19,566 --> 01:30:22,166
但是软件设计的原则其实是大的

1824
01:30:22,166 --> 01:30:22,599
原则

1825
01:30:22,600 --> 01:30:25,266
它并不是讲具体的设计的细的方法

1826
01:30:25,666 --> 01:30:27,966
那软件设计的7大原则

1827
01:30:27,966 --> 01:30:29,299
中间最重要的原则

1828
01:30:29,300 --> 01:30:31,133
我们按照它的这个重要性啊

1829
01:30:31,133 --> 01:30:33,499
从头从重要往次要来讲

1830
01:30:33,866 --> 01:30:36,333
最主要的原则就是开闭原则

1831
01:30:36,766 --> 01:30:38,899
开闭原则是由这个伯兰特梅耶啊

1832
01:30:38,900 --> 01:30:41,533
在88年的面相对象的构造这本书里

1833
01:30:41,533 --> 01:30:42,333
所提出来的

1834
01:30:42,600 --> 01:30:45,466
他认为说当我们设计一个软件的时候

1835
01:30:45,466 --> 01:30:48,599
我们应该对扩展是开放

1836
01:30:49,266 --> 01:30:51,866
对修改是关闭的

1837
01:30:52,266 --> 01:30:53,933
什么叫做扩展是开放的

1838
01:30:53,933 --> 01:30:56,866
就是可以增加新的内容

1839
01:30:58,666 --> 01:31:00,299
对于修改来说

1840
01:31:00,333 --> 01:31:02,966
就是对已有内容的修改来说

1841
01:31:03,100 --> 01:31:06,266
他应该是会被限制在一定的范围内的

1842
01:31:06,266 --> 01:31:09,366
我们可以看到这样的一个设计

1843
01:31:09,533 --> 01:31:12,999
就是开闭原则所体现的价值观是什么

1844
01:31:13,766 --> 01:31:17,199
就是我们刚刚说的低偶和高类句

1845
01:31:18,066 --> 01:31:20,533
前面对于扩展是开放的

1846
01:31:20,533 --> 01:31:21,566
就是我们的软件

1847
01:31:21,566 --> 01:31:23,099
是可以增加新的内容的

1848
01:31:23,400 --> 01:31:25,066
前提就是增加这些新的内容

1849
01:31:25,066 --> 01:31:26,466
不会影响现有的内容

1850
01:31:26,466 --> 01:31:28,499
这就是我们说的低偶和

1851
01:31:29,066 --> 01:31:31,933
我们的这个软件是可以对进行修改的

1852
01:31:31,966 --> 01:31:34,333
我们每修改一块地方

1853
01:31:34,333 --> 01:31:37,066
他应该只会影响那一个局部

1854
01:31:37,100 --> 01:31:39,200
而不会大面积的散播开

1855
01:31:40,000 --> 01:31:41,400
这个就是高类距

1856
01:31:41,533 --> 01:31:44,966
如果你做到了低有和高类距

1857
01:31:45,200 --> 01:31:47,966
你就达成了开闭原则

1858
01:31:48,300 --> 01:31:52,866
这是我们整个软件设计的最高原则

1859
01:31:52,966 --> 01:31:54,933
就是你在设计一个软件的时候

1860
01:31:54,966 --> 01:31:56,266
你时时刻刻要想着

1861
01:31:56,266 --> 01:31:58,666
这个软件是会增加新的功能的

1862
01:31:59,000 --> 01:32:01,100
这个软件的每一个地方

1863
01:32:01,266 --> 01:32:03,966
都是有可能在未来会被修改的

1864
01:32:04,133 --> 01:32:06,266
因为我们在最开始就讲过

1865
01:32:06,800 --> 01:32:10,266
复杂性是软件设计的本质

1866
01:32:10,733 --> 01:32:12,133
所以任何一个软件

1867
01:32:12,133 --> 01:32:14,199
从他设计开发之初

1868
01:32:14,200 --> 01:32:15,333
他就应该想到

1869
01:32:15,333 --> 01:32:17,199
他是会不断的增加新的功

1870
01:32:17,200 --> 01:32:19,366
能的他的每一行代码

1871
01:32:19,366 --> 01:32:22,966
在以后都是有可能会要改变的

1872
01:32:23,266 --> 01:32:25,199
所以你在整个设计的时候

1873
01:32:25,200 --> 01:32:30,466
就应该去做到调和和高类距啊

1874
01:32:30,466 --> 01:32:32,333
这是开闭原则

1875
01:32:34,400 --> 01:32:35,300
那开闭原则

1876
01:32:35,300 --> 01:32:37,166
是我们在面向对象

1877
01:32:37,166 --> 01:32:38,966
设计的一个终极目标

1878
01:32:39,200 --> 01:32:42,266
它会让整个的呃

1879
01:32:42,266 --> 01:32:44,899
软件具备适应性和灵活性

1880
01:32:45,133 --> 01:32:50,399
所以如果说符合开闭原则的软件

1881
01:32:50,900 --> 01:32:53,800
在开发和测试上面

1882
01:32:53,900 --> 01:32:55,500
都会变得更加的容易

1883
01:32:55,533 --> 01:32:56,899
首先对于测试上面啊

1884
01:32:56,900 --> 01:33:00,200
如果说我们在前面这个设计

1885
01:33:01,300 --> 01:33:02,966
这就是符合开币原则的

1886
01:33:03,333 --> 01:33:04,399
什么叫做开呢

1887
01:33:04,600 --> 01:33:07,066
当我们增加一个新的支付渠道的时候

1888
01:33:07,200 --> 01:33:08,066
我们这个代码

1889
01:33:08,066 --> 01:33:11,366
只是在这里增加一块小的部分

1890
01:33:11,766 --> 01:33:12,499
所以

1891
01:33:12,500 --> 01:33:15,766
当增加上来新的一个支付渠道以后

1892
01:33:15,766 --> 01:33:17,533
我们要做的测试是什么

1893
01:33:18,000 --> 01:33:18,800
我们要做的测试

1894
01:33:18,800 --> 01:33:21,266
不是再去对原来的微信和支付宝

1895
01:33:21,266 --> 01:33:22,133
去做测试

1896
01:33:22,166 --> 01:33:23,866
我们只需要针对

1897
01:33:23,866 --> 01:33:26,366
新增加上来的这个支付渠道

1898
01:33:26,733 --> 01:33:28,599
去做测试就好了

1899
01:33:28,800 --> 01:33:31,733
因为我们只需要保证说

1900
01:33:31,733 --> 01:33:32,899
原有的代码

1901
01:33:32,900 --> 01:33:35,800
如果在完全不改动的情况下头

1902
01:33:36,066 --> 01:33:39,299
在新增加上来的这个支付渠道的代码

1903
01:33:39,300 --> 01:33:39,533
上头

1904
01:33:39,533 --> 01:33:40,899
能够正常工作

1905
01:33:41,566 --> 01:33:43,466
那这个代码就是OK的

1906
01:33:43,733 --> 01:33:47,066
这就是我们说的对于扩展是开放的

1907
01:33:49,733 --> 01:33:51,699
这是对于测试来说啊

1908
01:33:51,700 --> 01:33:52,566
那同样的

1909
01:33:52,566 --> 01:33:53,899
增加类聚性

1910
01:33:53,900 --> 01:33:57,800
可以提高代码的可维护性和附用性

1911
01:33:57,966 --> 01:33:58,999
因为类聚性

1912
01:33:59,000 --> 01:33:59,733
其实是

1913
01:33:59,733 --> 01:34:02,533
我们为什么这块代码会写在这里的

1914
01:34:02,533 --> 01:34:04,066
这样的一个原则啊

1915
01:34:04,066 --> 01:34:07,099
所以低偶和高类聚

1916
01:34:07,133 --> 01:34:10,933
其实体现的就是我们的这个开闭原则

1917
01:34:11,266 --> 01:34:13,866
那具体怎么样去实现这个开闭原则

1918
01:34:13,866 --> 01:34:15,699
其实做法有很多啊

1919
01:34:15,700 --> 01:34:19,733
比如说有人通过这个抽象约束

1920
01:34:20,200 --> 01:34:21,300
封装变化啊

1921
01:34:21,300 --> 01:34:22,866
这个就相对比较抽象了啊

1922
01:34:22,866 --> 01:34:23,733
去实现它

1923
01:34:24,666 --> 01:34:25,499
这是第一个

1924
01:34:26,500 --> 01:34:27,666
这是最高原则啊

1925
01:34:27,666 --> 01:34:29,966
开闭原则那是一个

1926
01:34:30,000 --> 01:34:32,600
第二个原则叫做利斯口夫可替换原则

1927
01:34:33,000 --> 01:34:35,166
这是由麻省的利斯口夫

1928
01:34:35,166 --> 01:34:39,399
在87年 在OPSL上发表的一篇文章

1929
01:34:39,400 --> 01:34:41,466
中间所提出来的

1930
01:34:42,133 --> 01:34:43,599
呃这个利斯科夫

1931
01:34:43,600 --> 01:34:46,066
其实也是图灵奖的获得者啊

1932
01:34:46,366 --> 01:34:47,899
利斯科夫可替换原则

1933
01:34:47,900 --> 01:34:50,400
它是一个最基本的性质

1934
01:34:50,466 --> 01:34:53,699
就是面向对象中间所说的超类

1935
01:34:53,700 --> 01:34:55,266
所拥有的性质

1936
01:34:55,266 --> 01:34:58,766
在子类中间依然需要成立

1937
01:34:59,366 --> 01:35:01,699
我们知道在写继承的时候

1938
01:35:01,700 --> 01:35:03,566
子类会继承父类

1939
01:35:04,133 --> 01:35:05,999
子类不但会继承父类

1940
01:35:06,000 --> 01:35:09,066
还能去重写父类的一些行为

1941
01:35:09,466 --> 01:35:11,266
我们可以把复类的一些方法

1942
01:35:11,266 --> 01:35:13,333
去把它override掉

1943
01:35:13,333 --> 01:35:16,599
然后去写一些跟复类不同的行为

1944
01:35:16,800 --> 01:35:19,566
这你在写面相对象的代码的时候

1945
01:35:19,800 --> 01:35:21,333
技术上的是可行的

1946
01:35:21,766 --> 01:35:23,699
但是历史可符可替换原则

1947
01:35:23,700 --> 01:35:25,166
其实是在说这样的事情

1948
01:35:25,766 --> 01:35:27,799
虽然你的计算楼是可以这么做

1949
01:35:28,000 --> 01:35:29,900
但是你要保证

1950
01:35:30,300 --> 01:35:34,133
纸类中间所写的东西只是新的性质

1951
01:35:34,966 --> 01:35:37,366
所有父类中间的性质

1952
01:35:37,366 --> 01:35:40,266
在子类中间是不会被修改的

1953
01:35:40,500 --> 01:35:41,400
就换句话说

1954
01:35:41,400 --> 01:35:43,733
子类只能在父类上面增加新的东西

1955
01:35:44,000 --> 01:35:46,066
而不能改变在父类中间

1956
01:35:46,066 --> 01:35:47,599
已经定义的东西

1957
01:35:47,766 --> 01:35:49,999
这其实是跟我们面向对象的整个设计

1958
01:35:50,000 --> 01:35:51,166
加了一个枷锁

1959
01:35:51,333 --> 01:35:53,766
而不是让你任意在子类中间去

1960
01:35:54,566 --> 01:35:56,133
把附类中间想要的留下

1961
01:35:56,133 --> 01:35:58,133
不想要的把它拿掉是不行的啊

1962
01:35:58,133 --> 01:36:00,566
你只能把附类中间的所有的东西

1963
01:36:00,566 --> 01:36:01,566
全部继承下来

1964
01:36:01,733 --> 01:36:04,099
然后在这基础上头去增加新的东西

1965
01:36:04,200 --> 01:36:05,333
而且新的东西

1966
01:36:05,333 --> 01:36:07,499
必须跟附类的东西是不冲突的

1967
01:36:08,100 --> 01:36:11,366
这个特性会达成一个什么样的后果呢

1968
01:36:11,700 --> 01:36:13,466
这个特性就会达成

1969
01:36:13,466 --> 01:36:18,899
说负类的多个子类是可

1970
01:36:18,900 --> 01:36:20,500
以任意替换

1971
01:36:21,466 --> 01:36:23,866
就是我们在这个里头所看到的

1972
01:36:24,566 --> 01:36:25,366
这个效果

1973
01:36:27,400 --> 01:36:29,666
我们这个地方为什么说它是历史

1974
01:36:29,666 --> 01:36:31,333
可夫可替换原则

1975
01:36:31,600 --> 01:36:34,500
是因为我们所有的子类

1976
01:36:35,700 --> 01:36:37,700
没有去改变负类的行为

1977
01:36:38,500 --> 01:36:40,933
他只是实现了负类的所有的方法

1978
01:36:41,066 --> 01:36:41,699
这个东西

1979
01:36:41,700 --> 01:36:43,566
他为什么没有去改变

1980
01:36:43,566 --> 01:36:45,066
负类的所有的行为

1981
01:36:45,066 --> 01:36:46,766
这个最主要的原因

1982
01:36:46,966 --> 01:36:50,533
是因为我们负类里头没有行为

1983
01:36:50,766 --> 01:36:52,666
负类定义的是一个接口

1984
01:36:53,500 --> 01:36:56,566
每一个方法里头一行代码都没有

1985
01:36:56,933 --> 01:36:58,933
所以在这个定义中间

1986
01:36:58,933 --> 01:37:00,999
因为它使用了接口复列

1987
01:37:01,000 --> 01:37:02,466
中间是没有行为的

1988
01:37:02,933 --> 01:37:03,366
子类

1989
01:37:03,366 --> 01:37:06,699
只是去把负类中间所定义的那个接口

1990
01:37:07,066 --> 01:37:08,399
把它实现了

1991
01:37:08,466 --> 01:37:09,866
去写了行为

1992
01:37:10,100 --> 01:37:11,600
所以当你用一个接口

1993
01:37:11,600 --> 01:37:13,100
接口底下写实现的话

1994
01:37:13,333 --> 01:37:16,499
它必然满足disco可替换原则

1995
01:37:16,500 --> 01:37:18,466
因为接口里头是没有行为的

1996
01:37:19,166 --> 01:37:21,933
接口里头只有定义而没有行为

1997
01:37:22,000 --> 01:37:25,300
所以就不存在酯类的

1998
01:37:25,866 --> 01:37:29,399
这个行为是不满足附类的要求的

1999
01:37:29,400 --> 01:37:30,266
会改变附类

2000
01:37:30,266 --> 01:37:31,499
因为附类里头没东西

2001
01:37:32,300 --> 01:37:34,866
那因为他是用的接口和接口的实现

2002
01:37:34,866 --> 01:37:36,599
所以这一个东西

2003
01:37:36,600 --> 01:37:38,600
就是满足Disco复刻替换原则

2004
01:37:39,066 --> 01:37:40,366
满足Disco复刻替换原则

2005
01:37:40,366 --> 01:37:42,266
是什么效果啊

2006
01:37:42,266 --> 01:37:42,866
是什么效果

2007
01:37:42,866 --> 01:37:45,099
就是包括使用微信支付

2008
01:37:45,100 --> 01:37:48,200
或者使用阿里的支付的时候

2009
01:37:48,300 --> 01:37:50,866
我们在上面这部分的代码

2010
01:37:50,933 --> 01:37:51,899
是完全无感的

2011
01:37:51,900 --> 01:37:53,000
但因您看到了

2012
01:37:53,000 --> 01:37:55,066
是完全不知道说我在使用微信

2013
01:37:55,066 --> 01:37:56,066
还是使用支付宝

2014
01:37:56,800 --> 01:38:00,200
这就是因为使用微信和使用支付宝

2015
01:38:00,766 --> 01:38:01,733
他并没有改变

2016
01:38:01,733 --> 01:38:03,499
我们对于这个东西的定义

2017
01:38:03,600 --> 01:38:06,133
这个上面所定义的所有的方法

2018
01:38:06,200 --> 01:38:07,666
我们在里头可以看到

2019
01:38:07,666 --> 01:38:10,766
即算是有一些方法的参数

2020
01:38:10,766 --> 01:38:13,066
对于微信和支付宝是无意义的

2021
01:38:13,100 --> 01:38:16,466
他依然会去给出啊

2022
01:38:17,266 --> 01:38:19,399
就算是给个空子他也会给出啊

2023
01:38:19,400 --> 01:38:19,566
所以

2024
01:38:19,566 --> 01:38:22,333
他必须要满足我们在这个接口证件

2025
01:38:22,333 --> 01:38:22,899
所定义的

2026
01:38:22,900 --> 01:38:24,933
所有的参数和返回值的

2027
01:38:25,066 --> 01:38:26,166
这样的一个要求

2028
01:38:26,300 --> 01:38:28,566
这样就会使得我们的上面的代码

2029
01:38:28,700 --> 01:38:31,066
是完全不会受到他的影响的

2030
01:38:31,066 --> 01:38:33,866
就下面任意替换这个支付渠道

2031
01:38:33,866 --> 01:38:34,999
都不会受到他影响

2032
01:38:35,600 --> 01:38:36,266
换句话说

2033
01:38:36,266 --> 01:38:38,166
未来增加一个新的支付渠道的时候

2034
01:38:38,266 --> 01:38:41,099
也能做到在上面代码中间是不会驱动

2035
01:38:41,166 --> 01:38:42,466
不会去受到影响

2036
01:38:42,700 --> 01:38:44,866
这就是disco服可替换原则啊

2037
01:38:47,533 --> 01:38:48,966
这是两个最主要的原则

2038
01:38:48,966 --> 01:38:51,399
就是开闭原则和历史可复可替换原则

2039
01:38:51,400 --> 01:38:52,666
通常来说

2040
01:38:52,666 --> 01:38:54,999
历史可复可替换原则达成了以后

2041
01:38:55,300 --> 01:38:58,533
就能够达成这个开闭原则

2042
01:38:59,100 --> 01:38:59,966
第三个叫做什么呢

2043
01:38:59,966 --> 01:39:02,066
叫做依赖导致原则

2044
01:39:02,266 --> 01:39:02,999
依赖导致原则

2045
01:39:03,000 --> 01:39:05,600
是由这个罗伯特马丁在96年啊

2046
01:39:05,600 --> 01:39:08,166
在社交家reporter的杂志上发表的

2047
01:39:08,366 --> 01:39:10,099
它的主要的意思是

2048
01:39:10,100 --> 01:39:14,466
高层的模块不应该依赖于低层模块啊

2049
01:39:14,466 --> 01:39:16,499
而应该依赖于抽象

2050
01:39:17,866 --> 01:39:19,699
抽象不应该依赖于细节

2051
01:39:20,500 --> 01:39:21,966
细节应该依赖于抽象啊

2052
01:39:21,966 --> 01:39:24,866
这个看起来其实很很那个

2053
01:39:26,133 --> 01:39:29,199
不好懂它其实主要的意思是什么呢

2054
01:39:29,366 --> 01:39:30,699
主要的意思就是

2055
01:39:30,866 --> 01:39:33,766
我们在这里所看到的这个效果

2056
01:39:34,566 --> 01:39:36,766
就是我们在用的时候

2057
01:39:36,766 --> 01:39:38,333
我们在China用的时候

2058
01:39:38,333 --> 01:39:40,866
我们虽然用的是阿里pay Adapter

2059
01:39:41,133 --> 01:39:42,999
用的是微pay Adapter

2060
01:39:43,133 --> 01:39:45,933
但是我们用的那个类型

2061
01:39:45,933 --> 01:39:48,399
并不是阿里pay和微pay

2062
01:39:48,733 --> 01:39:50,199
用的是这个接口

2063
01:39:51,066 --> 01:39:53,266
就是我们定义的类型是pay Adapter

2064
01:39:53,266 --> 01:39:53,766
大家可以看到

2065
01:39:53,766 --> 01:39:57,299
在图里画的代码里写的都是pay Adapter

2066
01:39:57,366 --> 01:39:59,766
而不是具体的底下的这个东西

2067
01:40:01,066 --> 01:40:02,399
底下这个东西是

2068
01:40:02,400 --> 01:40:05,600
具体的Adapter上面的这个接口

2069
01:40:05,600 --> 01:40:07,266
是一个抽象的接口

2070
01:40:07,533 --> 01:40:09,666
所以当我们高层的东西

2071
01:40:09,666 --> 01:40:11,699
在使用低层的东西的时候

2072
01:40:11,766 --> 01:40:15,266
我们如果中间可以抽象出来一个接口

2073
01:40:15,866 --> 01:40:18,599
我们都应该使用抽象出来的东西

2074
01:40:18,733 --> 01:40:20,366
而不应该使用具体的东西

2075
01:40:20,366 --> 01:40:22,566
这叫做依赖导致原则

2076
01:40:22,700 --> 01:40:24,133
如果抽象不出来

2077
01:40:24,766 --> 01:40:27,133
那就没有必要去抽象啊

2078
01:40:27,166 --> 01:40:28,733
这是能抽象出来的时候

2079
01:40:28,733 --> 01:40:31,366
就尽量使用抽象出来的东西

2080
01:40:31,366 --> 01:40:33,166
而不是使用具体的东西

2081
01:40:34,800 --> 01:40:36,566
这就是依赖导致原则

2082
01:40:36,566 --> 01:40:38,499
所以我们刚才看到的这个设计里头

2083
01:40:38,500 --> 01:40:39,966
既满足开闭原则

2084
01:40:39,966 --> 01:40:41,899
满足disco复可替换原则

2085
01:40:41,900 --> 01:40:43,766
也满足导致原则

2086
01:40:44,533 --> 01:40:46,366
第三个是单一职责原则

2087
01:40:46,700 --> 01:40:48,500
单一职责原则是指

2088
01:40:48,500 --> 01:40:50,933
也是由波特马丁提出来的啊

2089
01:40:55,200 --> 01:40:56,133
任何一个类

2090
01:40:56,766 --> 01:40:59,099
应该只有一个会造成它变化的原因

2091
01:40:59,466 --> 01:41:01,133
这个有点苛刻了啊

2092
01:41:01,500 --> 01:41:03,933
我们知道它其实在说的就是

2093
01:41:03,933 --> 01:41:07,299
每一个类的职责应该单一

2094
01:41:08,166 --> 01:41:12,199
每一个类应该尽量包含少的内容

2095
01:41:12,666 --> 01:41:16,266
那当然你如果单纯的追求单一职责

2096
01:41:16,266 --> 01:41:18,799
所造成的结果就是类会碎片化

2097
01:41:19,200 --> 01:41:20,166
所以这一个

2098
01:41:20,166 --> 01:41:22,099
就我们越往后头的这些职责

2099
01:41:22,866 --> 01:41:24,133
啊越往后头这些原则

2100
01:41:24,133 --> 01:41:27,333
其实并不是我们一定会去遵循的原则

2101
01:41:27,333 --> 01:41:29,766
比如我们当前的这个设计

2102
01:41:29,766 --> 01:41:31,766
就我们现在目前看到的这个设计

2103
01:41:32,200 --> 01:41:35,666
其实我们并没有完全的遵照

2104
01:41:36,200 --> 01:41:37,733
单一职责的原则

2105
01:41:38,533 --> 01:41:42,866
就是我们做不到说一个类有且紧张

2106
01:41:42,866 --> 01:41:44,799
一个引起他变化的原因

2107
01:41:44,800 --> 01:41:45,600
做不到

2108
01:41:45,700 --> 01:41:49,100
因为我们类里头的属性太多了啊

2109
01:41:49,100 --> 01:41:51,900
所以说那里头因为属性多

2110
01:41:51,933 --> 01:41:53,299
职责负的就多

2111
01:41:53,300 --> 01:41:56,466
而我们给他属性的主要的原因是

2112
01:41:56,466 --> 01:41:57,866
我们从领域模型来的

2113
01:41:57,966 --> 01:42:00,933
我们并没有从单一职责的就

2114
01:42:00,933 --> 01:42:04,166
从职责的原则去把它分成不同的类

2115
01:42:04,266 --> 01:42:08,066
而仅仅是从领域模型的定义

2116
01:42:08,166 --> 01:42:10,133
变成了我们所说的对象模型

2117
01:42:10,133 --> 01:42:12,466
而没有考虑到单一指责的原则啊

2118
01:42:12,533 --> 01:42:15,466
所以我们讲这个原则还是要给大家讲

2119
01:42:15,566 --> 01:42:16,733
但是我们应该告诉大家说

2120
01:42:16,733 --> 01:42:18,333
我们现在目前设计里头

2121
01:42:18,333 --> 01:42:20,866
并没有考虑到单一指的原则

2122
01:42:20,866 --> 01:42:24,399
就是没有故意的把一些类给他切分成

2123
01:42:24,600 --> 01:42:26,600
因为他有不同的因素引起他的变化

2124
01:42:26,600 --> 01:42:28,300
给他切分成不同的类

2125
01:42:28,500 --> 01:42:29,500
没有这么去做

2126
01:42:31,533 --> 01:42:33,933
所以单一职责的关键的思想就是

2127
01:42:33,933 --> 01:42:38,266
他认为一个类的力度应该应该不大

2128
01:42:38,800 --> 01:42:43,666
应该把你职责负的很多的这个类切成

2129
01:42:43,666 --> 01:42:44,966
若按个小的类

2130
01:42:45,200 --> 01:42:47,466
然后增加他的类聚性啊

2131
01:42:47,600 --> 01:42:48,333
类聚性好了

2132
01:42:48,333 --> 01:42:50,666
他的可读性复杂性就会降低

2133
01:42:51,066 --> 01:42:52,799
这是单一职责的原则

2134
01:42:54,366 --> 01:42:55,999
啊接口隔离的原则

2135
01:42:56,000 --> 01:42:56,800
是指

2136
01:42:57,133 --> 01:42:59,599
客户端不应该依赖于他不使用的方法

2137
01:42:59,600 --> 01:43:01,366
一个类对另外一个类的依赖

2138
01:43:01,366 --> 01:43:03,399
应该建立在最小的接口上面

2139
01:43:03,500 --> 01:43:04,333
这个是指什么呢

2140
01:43:04,333 --> 01:43:05,499
这么还是回过来

2141
01:43:07,800 --> 01:43:08,766
就在这个里头啊

2142
01:43:08,766 --> 01:43:09,933
我们这里只有一个接口

2143
01:43:09,933 --> 01:43:10,866
就这个接口

2144
01:43:11,600 --> 01:43:15,800
我们这个接口里头定义了很多的方法

2145
01:43:16,200 --> 01:43:18,066
对吧那我们可以看到

2146
01:43:18,066 --> 01:43:19,099
我们的channel这个类

2147
01:43:19,100 --> 01:43:21,066
中间其实是用到了这个接口

2148
01:43:21,566 --> 01:43:23,133
那我们现在要问一个问题

2149
01:43:23,800 --> 01:43:25,366
China中间的这个类里头

2150
01:43:25,366 --> 01:43:26,266
用这个接口的话

2151
01:43:26,266 --> 01:43:28,299
它用到了这个接口的所有的方法吗

2152
01:43:29,933 --> 01:43:30,499
用到了吗

2153
01:43:30,500 --> 01:43:31,300
你们觉得

2154
01:43:33,700 --> 01:43:34,500
用到了没有

2155
01:43:35,066 --> 01:43:36,299
肯定是否定的

2156
01:43:36,300 --> 01:43:37,800
因为我们后面会看到

2157
01:43:37,800 --> 01:43:40,266
除了channel这个类用到这个接口以外

2158
01:43:41,133 --> 01:43:43,066
pay transaction的类也用到了它

2159
01:43:43,466 --> 01:43:44,566
所以不同的类

2160
01:43:44,566 --> 01:43:47,799
会用到这个接口里头的不同的方法

2161
01:43:48,100 --> 01:43:48,733
肯定的一

2162
01:43:48,733 --> 01:43:50,699
点是我们这个接口中定了这么多方法

2163
01:43:50,700 --> 01:43:51,133
这些方法

2164
01:43:51,133 --> 01:43:54,266
并没有全部在channel那个类里头用到

2165
01:43:54,466 --> 01:43:55,599
所以按照

2166
01:44:00,100 --> 01:44:01,500
接口隔离的原则

2167
01:44:02,000 --> 01:44:03,800
就是这个类里头

2168
01:44:03,800 --> 01:44:05,133
如果用到的接口里头

2169
01:44:05,133 --> 01:44:06,599
有他没有用到的方法

2170
01:44:06,766 --> 01:44:08,933
他应该把这个接口

2171
01:44:09,000 --> 01:44:11,166
切成若干个小的接口

2172
01:44:11,166 --> 01:44:12,599
就是我们这里所看到的这个设计

2173
01:44:12,600 --> 01:44:13,566
是一个接口

2174
01:44:13,766 --> 01:44:15,133
但是如果按照接口隔离原则

2175
01:44:15,133 --> 01:44:17,866
应该根据我们的不同的用的人

2176
01:44:18,200 --> 01:44:19,466
不同的用的类啊

2177
01:44:19,466 --> 01:44:21,566
切成若干个接口

2178
01:44:22,000 --> 01:44:23,700
我们同样没有做这个原则

2179
01:44:23,766 --> 01:44:25,733
因为这个会使得我们的pay adapt

2180
01:44:25,733 --> 01:44:26,299
那个接口

2181
01:44:26,300 --> 01:44:28,066
变成很多个接口

2182
01:44:28,533 --> 01:44:30,066
所以我们没有使用这个原则

2183
01:44:30,200 --> 01:44:32,100
这个原则所带来的好处啊

2184
01:44:32,100 --> 01:44:34,100
就是使得接口的改变

2185
01:44:34,100 --> 01:44:36,333
如果说我某一个接口的方法增加

2186
01:44:36,333 --> 01:44:37,466
或者改变了

2187
01:44:37,466 --> 01:44:39,266
不会影响其他的类

2188
01:44:39,366 --> 01:44:41,733
只会影响用到他的那个东西

2189
01:44:41,900 --> 01:44:43,766
但是我们没有遵循这个原则啊

2190
01:44:43,766 --> 01:44:45,066
我们今天先讲到这里

