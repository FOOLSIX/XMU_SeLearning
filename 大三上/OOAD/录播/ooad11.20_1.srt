1
00:00:20,300 --> 00:00:21,100
好

2
00:00:21,933 --> 00:00:25,333
今天我们讲软件设计的七大原则

3
00:00:25,733 --> 00:00:27,533
那讲完今天这个七大原则

4
00:00:27,533 --> 00:00:29,499
其实面向对象设计的主要的方法

5
00:00:29,500 --> 00:00:30,200
就讲完了

6
00:00:30,200 --> 00:00:32,333
就是它其实分为两个部分

7
00:00:32,566 --> 00:00:35,166
最基本的是Grasp的啊

8
00:00:35,166 --> 00:00:36,066
9种方式

9
00:00:36,066 --> 00:00:38,966
但我们在9种方中间选择讲了7种方式

10
00:00:38,966 --> 00:00:42,999
就是创建者信息专家啊

11
00:00:43,666 --> 00:00:49,499
多态间接虚构do和高雷聚这七种

12
00:00:49,533 --> 00:00:50,699
还有两种美甲

13
00:00:50,700 --> 00:00:51,800
一个是控制器

14
00:00:51,800 --> 00:00:52,266
因为我觉得

15
00:00:52,266 --> 00:00:54,299
控制器其实不属于软件设计的方法

16
00:00:54,300 --> 00:00:55,700
而是属于体系结构

17
00:00:55,766 --> 00:00:57,499
就是它的分层的

18
00:00:57,900 --> 00:01:00,666
分层的MVC的这样的一个体系结构

19
00:01:00,866 --> 00:01:01,466
另外一个呢

20
00:01:01,466 --> 00:01:02,333
其实它很抽象

21
00:01:02,333 --> 00:01:03,866
叫做protected variation

22
00:01:03,866 --> 00:01:05,466
叫做PV的方法

23
00:01:05,566 --> 00:01:07,466
那个就太抽象了

24
00:01:07,466 --> 00:01:09,199
其实呃

25
00:01:09,533 --> 00:01:10,199
具体用的时候

26
00:01:10,200 --> 00:01:11,733
跟面相对象没有太大的关系

27
00:01:11,933 --> 00:01:13,266
所以我们选择性的讲了

28
00:01:13,266 --> 00:01:15,733
Grasp中间的7种最基本的方法

29
00:01:16,300 --> 00:01:18,700
那这是最基本的设计方式

30
00:01:18,700 --> 00:01:21,800
但其实在用这7种设计方法的时候

31
00:01:25,333 --> 00:01:25,999
其实在用

32
00:01:26,000 --> 00:01:26,800
在讲说

33
00:01:26,800 --> 00:01:29,566
在用这七种最基本的设计方法的时候

34
00:01:30,066 --> 00:01:32,366
它其实都会体现了

35
00:01:32,366 --> 00:01:35,266
我们在软件设计的七大原则

36
00:01:36,333 --> 00:01:38,999
那首先我们第一个要讲的是开闭原则

37
00:01:39,200 --> 00:01:41,300
它是由这个伯兰特梅耶

38
00:01:41,300 --> 00:01:45,100
在88年的面向对象软件构造里头

39
00:01:45,100 --> 00:01:46,266
所提出来的

40
00:01:46,400 --> 00:01:49,966
那这个原则的中心的含义是讲

41
00:01:49,966 --> 00:01:53,166
说软件应该对于扩展是开放的

42
00:01:53,200 --> 00:01:55,000
对于修改是关闭的啊

43
00:01:55,466 --> 00:01:57,999
那什么叫做对扩展是开放的

44
00:01:58,000 --> 00:02:00,566
对于修改是关闭的啊

45
00:02:01,333 --> 00:02:03,499
韦伯特那个伯兰特梅耶

46
00:02:03,500 --> 00:02:05,566
伯兰特梅尔认为说

47
00:02:06,133 --> 00:02:07,733
我们一个理想的软件

48
00:02:07,900 --> 00:02:10,166
应该是可以不断的修改

49
00:02:10,566 --> 00:02:12,099
而且理想状态上头

50
00:02:12,100 --> 00:02:15,266
每一次的修改都不会动到已有的代码

51
00:02:15,733 --> 00:02:16,766
就是我已经写好了代

52
00:02:16,766 --> 00:02:17,766
码都不会动

53
00:02:18,200 --> 00:02:19,933
如果说我要增加新的功能

54
00:02:20,000 --> 00:02:22,166
那我就直接去写一块新的代码

55
00:02:22,933 --> 00:02:26,066
如果说我对于现有功能去做修改

56
00:02:26,366 --> 00:02:27,066
这个修改

57
00:02:27,066 --> 00:02:29,899
应该是控制在一个最小的范围内

58
00:02:30,000 --> 00:02:31,133
去改一点点

59
00:02:31,333 --> 00:02:34,266
就就是像做外科手术一样的

60
00:02:34,266 --> 00:02:36,599
精确的把一小块代码把它修改

61
00:02:36,733 --> 00:02:38,866
而不会影响到其他的代码

62
00:02:39,133 --> 00:02:40,899
如果你这样的一个软件

63
00:02:40,900 --> 00:02:41,900
具备这样一个特性

64
00:02:41,900 --> 00:02:43,300
就是要增加新的内容

65
00:02:43,300 --> 00:02:44,500
直接往上加不动

66
00:02:44,500 --> 00:02:45,300
现有的代码

67
00:02:45,466 --> 00:02:46,399
要修改的话

68
00:02:46,400 --> 00:02:48,366
只针对一小块的代码

69
00:02:48,366 --> 00:02:49,799
去像做外科手术一样的

70
00:02:49,800 --> 00:02:51,666
精准的把那一小块修改掉

71
00:02:52,500 --> 00:02:54,966
而不会影响到其他的部分的代码

72
00:02:55,300 --> 00:02:56,600
这个就是我们说的

73
00:02:56,733 --> 00:02:58,866
满足开币原则的代码

74
00:02:59,333 --> 00:03:00,099
大家可以看到

75
00:03:00,100 --> 00:03:00,966
开闭原则

76
00:03:00,966 --> 00:03:03,266
其实不是一种具体的设计方法

77
00:03:03,533 --> 00:03:06,533
而是我们想要让这个软件

78
00:03:07,133 --> 00:03:08,799
所要达到的一个目标

79
00:03:09,166 --> 00:03:10,933
所以我们说开闭原则

80
00:03:10,933 --> 00:03:12,799
其实是面向对象的

81
00:03:13,333 --> 00:03:15,299
这个设计的一个终极目标

82
00:03:15,900 --> 00:03:20,000
它会让整个的软件具备适应性

83
00:03:20,000 --> 00:03:23,200
灵活性而且还是相对稳定和延续的

84
00:03:23,333 --> 00:03:24,533
适应性和灵活性

85
00:03:24,533 --> 00:03:26,399
主要是指当它扩展的时候

86
00:03:26,400 --> 00:03:28,500
它可以直接往上加新的代码

87
00:03:28,500 --> 00:03:30,000
而不影响现有代码

88
00:03:30,466 --> 00:03:31,799
而灵活性的话呢

89
00:03:31,800 --> 00:03:33,900
这是这是适应性和灵活性

90
00:03:34,066 --> 00:03:35,399
而稳定性和延续性

91
00:03:35,400 --> 00:03:38,166
主要是针对所有写好的代码

92
00:03:38,266 --> 00:03:41,399
无论是在新增还是在修改的时候

93
00:03:41,533 --> 00:03:43,499
他的影响面是最小的

94
00:03:43,766 --> 00:03:45,099
那我们的理想上的三龙是

95
00:03:45,100 --> 00:03:47,400
新增完全不会影响现有代码

96
00:03:47,766 --> 00:03:48,499
修改的话

97
00:03:48,500 --> 00:03:50,933
只影响非常少的一小部分代码

98
00:03:51,333 --> 00:03:53,866
这就是他的这个终极的目标

99
00:03:54,700 --> 00:03:55,933
这个目标达到了以后

100
00:03:55,933 --> 00:03:57,499
就能得到很多的好处啊

101
00:03:57,500 --> 00:03:59,600
这我们其实不用去讲了

102
00:03:59,600 --> 00:04:00,133
大家知道

103
00:04:00,133 --> 00:04:02,266
如果说我在做任何一个新的东西

104
00:04:02,266 --> 00:04:03,899
或者修改已有的东西

105
00:04:03,900 --> 00:04:05,766
都只涉及到一小块代码

106
00:04:06,100 --> 00:04:10,066
那这个好处肯定是不不用不用去说的

107
00:04:10,333 --> 00:04:11,399
我们关心的是

108
00:04:11,400 --> 00:04:13,566
怎样去达到这样的一个状态

109
00:04:13,966 --> 00:04:15,866
就怎样让这个软件的设计

110
00:04:15,866 --> 00:04:18,499
去达到我们所说的开闭原则

111
00:04:19,066 --> 00:04:20,999
呃它的原文里头是说

112
00:04:21,000 --> 00:04:24,700
主要的方式是通过抽象约束

113
00:04:24,800 --> 00:04:26,900
封装变化来完成

114
00:04:27,300 --> 00:04:28,500
这个有点难理解

115
00:04:28,500 --> 00:04:30,500
其实这个两个东西

116
00:04:30,966 --> 00:04:32,999
就是我们所说的grasp

117
00:04:33,000 --> 00:04:34,266
本东西的两个原则

118
00:04:34,266 --> 00:04:36,966
抽象约束是指多肽

119
00:04:37,466 --> 00:04:39,466
封装变化是指什么

120
00:04:39,866 --> 00:04:40,799
是指间接

121
00:04:41,266 --> 00:04:41,666
也就是

122
00:04:41,666 --> 00:04:46,133
当我们去使用多态和间接的时候

123
00:04:46,466 --> 00:04:49,366
其实我们想要达成的目的

124
00:04:49,500 --> 00:04:51,200
就是这个开闭原则

125
00:04:51,466 --> 00:04:53,899
我们之前所看到的这个地方

126
00:04:53,900 --> 00:04:54,500
我们知道

127
00:04:54,500 --> 00:04:58,400
这个立中间我们使用了抽象和间接

128
00:04:58,666 --> 00:04:59,799
多态和间接

129
00:04:59,966 --> 00:05:02,199
用一个接口做了两个实线

130
00:05:02,200 --> 00:05:03,300
这是多态

131
00:05:03,366 --> 00:05:04,466
而这两个实线呢

132
00:05:04,466 --> 00:05:06,166
其实是间接的对象

133
00:05:06,300 --> 00:05:09,466
让他去访问支付宝

134
00:05:09,466 --> 00:05:10,799
或者微信的接口的时候

135
00:05:10,800 --> 00:05:12,133
不要直接去访问他

136
00:05:12,133 --> 00:05:14,333
而通过这两个东西来访问他

137
00:05:14,333 --> 00:05:16,099
但他是实现了同样的接口

138
00:05:16,166 --> 00:05:19,799
所以他是用抽象来进行约束

139
00:05:19,900 --> 00:05:21,966
用接口来约束

140
00:05:21,966 --> 00:05:23,099
这两个东西

141
00:05:23,366 --> 00:05:25,099
要实现的东西是一致的

142
00:05:25,666 --> 00:05:30,299
用封装来来实现这个变化的

143
00:05:30,400 --> 00:05:31,533
来约束这个变化

144
00:05:31,533 --> 00:05:33,966
也就是当这个东西发生改变的时候

145
00:05:33,966 --> 00:05:35,399
他是通过这个封装

146
00:05:35,933 --> 00:05:37,299
通过这个间接的对象

147
00:05:37,366 --> 00:05:38,366
能让他这个变化

148
00:05:38,366 --> 00:05:40,933
约束在这个范围之内的

149
00:05:41,200 --> 00:05:44,500
所以这样的一个主要的方式

150
00:05:44,500 --> 00:05:45,666
我们可以看到

151
00:05:45,666 --> 00:05:48,333
通过这个就我们说这两句话

152
00:05:50,166 --> 00:05:54,333
通过这个抽象的约束和变化的封装

153
00:05:54,333 --> 00:05:55,666
这两个东西

154
00:05:55,900 --> 00:05:56,866
能够实现

155
00:05:56,866 --> 00:06:01,599
我们在开闭原则中间的开和闭

156
00:06:02,100 --> 00:06:04,666
开是指当我们新增东西的时候

157
00:06:04,766 --> 00:06:06,733
它是不用修改现有代码

158
00:06:06,766 --> 00:06:07,666
靠的是什么

159
00:06:08,200 --> 00:06:11,666
靠的是这个抽象的约束

160
00:06:11,700 --> 00:06:12,966
也就是我们在多态中间

161
00:06:12,966 --> 00:06:15,466
用了这样的一个抽象的接口

162
00:06:16,100 --> 00:06:17,733
把所有的这个接口

163
00:06:17,733 --> 00:06:19,999
统一到了同样的一个接口上头

164
00:06:20,400 --> 00:06:21,566
那当我们新增一个

165
00:06:21,566 --> 00:06:22,999
新的支付渠道的时候

166
00:06:23,266 --> 00:06:26,399
同样都要在这个抽象的约束的下面

167
00:06:26,500 --> 00:06:30,866
去做一个新的新的一套这个东西

168
00:06:31,066 --> 00:06:33,133
这样使得说我们新的所有代码

169
00:06:33,133 --> 00:06:34,299
就包括这些代码

170
00:06:35,600 --> 00:06:38,300
在理想状态下头都是不会动的

171
00:06:38,300 --> 00:06:39,200
就能完成

172
00:06:39,200 --> 00:06:42,866
我们对于新增的开放

173
00:06:42,866 --> 00:06:44,533
对于扩展的开放

174
00:06:45,100 --> 00:06:46,900
那对于修改的封闭

175
00:06:46,900 --> 00:06:49,300
它靠的就是我们封装变化

176
00:06:49,400 --> 00:06:51,166
靠的是这个间接的对象

177
00:06:51,600 --> 00:06:53,933
如果说我们这个接口发生改变了

178
00:06:53,933 --> 00:06:56,199
我们通过这个间接的对象

179
00:06:56,733 --> 00:07:00,399
把这个改变约束在这个范畴之内

180
00:07:00,533 --> 00:07:02,133
这叫做封装变化

181
00:07:02,300 --> 00:07:04,200
所以抽象的约束

182
00:07:04,900 --> 00:07:06,133
封装的变化

183
00:07:06,333 --> 00:07:09,666
就会使得我们整体的系统满足

184
00:07:09,666 --> 00:07:12,366
当扩展的时候直接增加一个新的代码

185
00:07:12,566 --> 00:07:15,666
当修改的时候只会影响这个

186
00:07:15,733 --> 00:07:16,666
还有这个

187
00:07:17,166 --> 00:07:20,066
把这个修改封闭在这个范围之内

188
00:07:20,333 --> 00:07:22,533
来实现这个开闭的原则啊

189
00:07:23,666 --> 00:07:25,566
所以grasp的方法

190
00:07:25,600 --> 00:07:27,300
我们在讲grasp的方法的时候

191
00:07:27,300 --> 00:07:27,966
大家可以看到

192
00:07:27,966 --> 00:07:30,533
当你在使用这些方法的时候

193
00:07:30,533 --> 00:07:33,733
你自然就达到了面向对象的开闭原则

194
00:07:34,900 --> 00:07:36,100
那一个问题

195
00:07:36,733 --> 00:07:38,733
既然面向对象的设计的终极目标

196
00:07:38,733 --> 00:07:39,766
是开闭原则

197
00:07:39,966 --> 00:07:42,333
我们是否有必要在所有的地方

198
00:07:42,333 --> 00:07:44,333
都让他去满足开闭原则呢

199
00:07:45,066 --> 00:07:46,566
比如说在

200
00:07:47,966 --> 00:07:50,733
这些地方这些地方这些地方

201
00:07:52,533 --> 00:07:53,399
这些地方的设计

202
00:07:53,400 --> 00:07:55,100
其实是不满足开闭原则的

203
00:07:55,200 --> 00:07:55,800
大家应该知道

204
00:07:55,800 --> 00:07:57,533
我们既没有用抽象去封装

205
00:07:57,933 --> 00:07:58,533
既没有用抽

206
00:07:58,533 --> 00:07:59,366
象去约束啊

207
00:07:59,366 --> 00:08:01,199
也没有用那个间接对象

208
00:08:01,200 --> 00:08:02,300
去把它封装起来

209
00:08:02,466 --> 00:08:05,599
所以这一部分的设计就包括这个地方

210
00:08:06,366 --> 00:08:07,333
这一大部分的设计

211
00:08:07,333 --> 00:08:08,733
都是不满足开闭原则

212
00:08:09,166 --> 00:08:09,733
那为什么

213
00:08:09,733 --> 00:08:12,366
我们不在整个设计的这些地方

214
00:08:12,366 --> 00:08:14,333
都让他去满足开闭原则

215
00:08:15,133 --> 00:08:15,933
你们觉得

216
00:08:17,800 --> 00:08:19,766
这个就是你对于设计的判断

217
00:08:20,166 --> 00:08:21,266
我们说设计

218
00:08:21,266 --> 00:08:25,166
不是说你在整个代码的所有的地方

219
00:08:25,166 --> 00:08:26,666
都需要设计的

220
00:08:26,666 --> 00:08:28,199
我们为什么在这个地方

221
00:08:28,200 --> 00:08:29,766
会做这样的一个设计

222
00:08:30,166 --> 00:08:32,099
让他满足开闭原则

223
00:08:32,566 --> 00:08:34,199
为什么原因是什么

224
00:08:34,533 --> 00:08:35,866
原因是我们的判断是

225
00:08:35,866 --> 00:08:36,399
这个地方

226
00:08:36,400 --> 00:08:40,466
是整个系统的一个变化点和引进点

227
00:08:40,566 --> 00:08:43,399
变化点是因为外部的API发生变化

228
00:08:43,666 --> 00:08:44,266
引进点

229
00:08:44,266 --> 00:08:46,466
是因为我们还会要做新的支付渠道

230
00:08:47,100 --> 00:08:48,933
所以当我们做了这样的一个判断

231
00:08:48,933 --> 00:08:51,333
认为它是一个变化点和引进点的时候

232
00:08:51,333 --> 00:08:54,533
就使得我们要去采取一些设计的手段

233
00:08:55,000 --> 00:08:56,766
让这个变化封闭

234
00:08:57,366 --> 00:08:59,899
让这个眼镜是开放的

235
00:08:59,900 --> 00:09:01,366
就是扩展是开放的

236
00:09:01,400 --> 00:09:04,100
所以才会用间接和多态的方式

237
00:09:04,100 --> 00:09:07,566
在这里去用抽象约束了这个变化

238
00:09:07,866 --> 00:09:11,599
用这个封装把这个变化封装起来

239
00:09:11,600 --> 00:09:12,766
用抽象去做约束

240
00:09:12,766 --> 00:09:13,799
用封装来做

241
00:09:13,800 --> 00:09:16,400
来把变化给他封装起来

242
00:09:16,733 --> 00:09:18,266
才做了这样的一个设计啊

243
00:09:18,266 --> 00:09:21,366
所以开闭原则是我们的终极目标

244
00:09:21,366 --> 00:09:22,733
但是我们并不是

245
00:09:22,733 --> 00:09:25,499
要把整个系统的每一个地方

246
00:09:25,933 --> 00:09:27,199
都做成开闭的

247
00:09:27,200 --> 00:09:29,966
因为那样的话会让你付出很大的代价

248
00:09:30,600 --> 00:09:32,800
我们也称之为叫做过度的设计化

249
00:09:32,800 --> 00:09:34,100
叫做过度设计了

250
00:09:34,200 --> 00:09:36,733
我们要去在做任何一个设计的时候

251
00:09:36,733 --> 00:09:37,566
要去判断说

252
00:09:37,566 --> 00:09:38,866
这个地方值不值得

253
00:09:38,866 --> 00:09:41,599
去做这样的一个开闭原则的设计

254
00:09:42,000 --> 00:09:42,900
比如说这个地方我们觉

255
00:09:42,900 --> 00:09:44,166
得值得那我们就去做

256
00:09:44,300 --> 00:09:44,766
其他地方

257
00:09:44,766 --> 00:09:45,699
我们觉得不值得

258
00:09:45,700 --> 00:09:46,600
其实我们就没有去

259
00:09:46,600 --> 00:09:49,000
在里头去用开闭原则啊

260
00:09:49,000 --> 00:09:49,900
去做设计

261
00:09:50,533 --> 00:09:52,166
这是我们讲的第一个原则

262
00:09:52,166 --> 00:09:53,266
也是终极目标

263
00:09:53,266 --> 00:09:54,333
这个开闭原则

264
00:09:54,333 --> 00:09:54,966
大家应该知道

265
00:09:54,966 --> 00:09:56,766
这个并不是一个具体的设计方法

266
00:09:56,900 --> 00:09:58,700
我们前面所讲的设计方法

267
00:09:58,700 --> 00:10:00,733
其实所要达成的目标

268
00:10:00,733 --> 00:10:02,399
就是我们所说的这些原则

269
00:10:02,733 --> 00:10:04,133
那这是有前提的啊

270
00:10:04,133 --> 00:10:07,066
就是他会变化和引进

271
00:10:07,066 --> 00:10:07,966
所以我们在这个地方

272
00:10:07,966 --> 00:10:09,766
要让他满足开闭原则

273
00:10:11,366 --> 00:10:11,866
第二个原则

274
00:10:11,866 --> 00:10:13,866
我们要讲的是历史科夫可替换原则

275
00:10:13,866 --> 00:10:16,566
这是由麻省的那个历史科夫教授

276
00:10:16,566 --> 00:10:17,599
他是个女的啊

277
00:10:17,666 --> 00:10:18,733
在87年

278
00:10:18,733 --> 00:10:22,366
我们的面向对象的顶级会议叫做OOPSLA

279
00:10:22,900 --> 00:10:24,466
国内现在顶会发了很多

280
00:10:24,466 --> 00:10:26,566
但是真的能在程序设计的顶会上头

281
00:10:26,566 --> 00:10:27,599
去发论文的人

282
00:10:27,600 --> 00:10:28,733
少之又少

283
00:10:28,966 --> 00:10:30,499
大家比如说在CVPR

284
00:10:30,500 --> 00:10:31,666
在这些会议上头

285
00:10:32,000 --> 00:10:34,866
国内大概一年能够发个几百篇的论文

286
00:10:35,100 --> 00:10:37,600
但是在这个OPSLA上头

287
00:10:38,000 --> 00:10:40,400
可能一年国内大概能够发个

288
00:10:40,400 --> 00:10:41,333
大概知道多少篇

289
00:10:42,333 --> 00:10:44,499
一篇两篇或者是挂零

290
00:10:44,666 --> 00:10:45,299
就这样的

291
00:10:45,300 --> 00:10:47,666
就是在这种很基础的领域中间

292
00:10:47,666 --> 00:10:50,799
目前国内的计算机还是还是落后的

293
00:10:50,800 --> 00:10:52,666
不要看到现在在AI的这个部分上

294
00:10:52,666 --> 00:10:53,933
大家都热火朝天

295
00:10:54,166 --> 00:10:57,933
但其实在最基最基础的这些部分上头

296
00:10:58,266 --> 00:10:59,366
国内的这个还是落

297
00:10:59,366 --> 00:11:00,366
还是相对比较落后

298
00:11:00,366 --> 00:11:03,599
落后的那这个迪斯科夫可替换原则

299
00:11:03,600 --> 00:11:05,166
则是迪斯科夫教授

300
00:11:05,166 --> 00:11:05,733
他是个女的

301
00:11:05,733 --> 00:11:07,599
在87年OOPSLA

302
00:11:07,600 --> 00:11:10,100
上所发表的一篇论文叫做啊

303
00:11:10,100 --> 00:11:14,666
databstraction的海rike数据的抽象和层次

304
00:11:14,933 --> 00:11:15,499
这篇论文中

305
00:11:15,500 --> 00:11:16,700
它首次提到了

306
00:11:16,700 --> 00:11:20,600
说继承应该满足一定的特性

307
00:11:20,600 --> 00:11:23,166
这个特性是负类啊就

308
00:11:23,166 --> 00:11:26,733
是超类所拥有的性质

309
00:11:26,733 --> 00:11:28,899
在子类中间依然成立

310
00:11:28,900 --> 00:11:30,166
他为什么会讲这件事情

311
00:11:30,166 --> 00:11:31,999
是因为我们在用面向对象的语言

312
00:11:32,000 --> 00:11:33,500
去写代码的时候

313
00:11:33,500 --> 00:11:35,533
其实可以违背这个特性的

314
00:11:36,100 --> 00:11:36,966
比如说我们知道

315
00:11:36,966 --> 00:11:39,533
子类是可以overrated复类的方法的

316
00:11:39,700 --> 00:11:41,866
对吧那你overrated复类方法

317
00:11:41,866 --> 00:11:42,199
就意味着

318
00:11:42,200 --> 00:11:44,500
你可以把复类的方法的行为整个改掉

319
00:11:44,500 --> 00:11:46,400
去重新写一套这个行为

320
00:11:46,900 --> 00:11:48,766
那如果说你写出来的这个

321
00:11:48,866 --> 00:11:50,166
子类的这个方法

322
00:11:50,533 --> 00:11:52,466
跟附类的这个行为是不一致的

323
00:11:52,466 --> 00:11:53,133
就是附类中间

324
00:11:53,133 --> 00:11:55,066
他如果定义了这个行为是个什么样子

325
00:11:55,266 --> 00:11:56,666
子类你把它overrate了

326
00:11:56,666 --> 00:11:58,366
不是不在他的基础上去做扩展

327
00:11:58,466 --> 00:12:00,666
而是整个推翻了他的行为

328
00:12:01,133 --> 00:12:03,799
这样他就不满足意识口服可替换原则

329
00:12:04,466 --> 00:12:05,066
啊利斯科夫

330
00:12:05,066 --> 00:12:05,899
同样也是因为

331
00:12:05,900 --> 00:12:07,966
面向对象的方面的这个贡献

332
00:12:08,133 --> 00:12:09,599
获得了图灵奖

333
00:12:10,066 --> 00:12:10,533
大家知道

334
00:12:10,533 --> 00:12:13,166
图灵奖是计算机行业中间的若贝尔奖

335
00:12:13,166 --> 00:12:14,266
对吧因为计算机的科学家

336
00:12:14,266 --> 00:12:15,499
是没办法夺若贝尔奖的

337
00:12:15,566 --> 00:12:17,899
所以图灵奖已经是最高的荣誉了

338
00:12:18,400 --> 00:12:19,200
计算机领域中间

339
00:12:19,200 --> 00:12:23,066
这么多的这个这么多的科目

340
00:12:23,266 --> 00:12:25,999
每年的图灵奖只会颁给一个科目

341
00:12:26,366 --> 00:12:28,199
所以比如说在面向对象的这个设计

342
00:12:28,200 --> 00:12:28,766
就比如说程

343
00:12:28,766 --> 00:12:29,599
不要说面相对象吧

344
00:12:29,600 --> 00:12:30,700
整个程序设计

345
00:12:31,200 --> 00:12:33,366
程序的软件的设计这个领域

346
00:12:33,366 --> 00:12:36,399
中间图灵奖大概也就只能得到一个

347
00:12:36,400 --> 00:12:37,000
或者两个

348
00:12:37,000 --> 00:12:39,133
在这么几十年里头分下来

349
00:12:39,133 --> 00:12:41,399
你也大概就只能得到一两次

350
00:12:41,733 --> 00:12:42,766
这个图灵奖

351
00:12:42,800 --> 00:12:45,166
何况还有比如说像AI在那大热门

352
00:12:45,166 --> 00:12:47,133
他会得到多次图灵奖是吧

353
00:12:47,300 --> 00:12:48,866
所以像程序设计的这个领域

354
00:12:48,866 --> 00:12:51,299
中间其实能得到图灵奖的人少之又少

355
00:12:52,066 --> 00:12:53,499
而且迪斯科

356
00:12:53,500 --> 00:12:54,366
夫还是个女的

357
00:12:54,366 --> 00:12:55,466
大家知道图灵奖

358
00:12:55,566 --> 00:12:57,733
去看他历届的获奖人的头像

359
00:12:58,200 --> 00:12:59,600
男的占了90%

360
00:12:59,966 --> 00:13:01,499
女的只占10%啊

361
00:13:01,500 --> 00:13:02,900
所以这就是这个领域

362
00:13:02,900 --> 00:13:05,000
中间的性别的这个差异啊

363
00:13:05,000 --> 00:13:05,666
看我们卓越版

364
00:13:05,666 --> 00:13:08,266
好像在座的男生占据多啊

365
00:13:08,266 --> 00:13:09,899
女生就只有一个是吧

366
00:13:09,900 --> 00:13:10,166
是不是

367
00:13:10,166 --> 00:13:13,299
同样也是有这个性别的这个差异

368
00:13:13,300 --> 00:13:15,000
还是女生都都跳课去了

369
00:13:16,066 --> 00:13:17,266
这个顺便说一句啊

370
00:13:17,266 --> 00:13:21,133
因为从这一周开始到12月中旬

371
00:13:21,133 --> 00:13:24,066
大家知道是什么是教育部的检查周

372
00:13:24,066 --> 00:13:27,466
涉及到我们的第几次本科评估了啊

373
00:13:27,466 --> 00:13:28,533
我忘了好像第四次

374
00:13:28,533 --> 00:13:31,466
还是第五次本科本科评估了啊

375
00:13:31,566 --> 00:13:32,566
今年的这个评估

376
00:13:32,566 --> 00:13:34,466
大家辅导员跟你们说了吗

377
00:13:34,666 --> 00:13:35,733
技术更加的先进

378
00:13:35,733 --> 00:13:38,499
往年是直接到学校来去来听课

379
00:13:39,000 --> 00:13:39,733
现在我们的学校

380
00:13:39,733 --> 00:13:41,866
你看这个这个摄像头

381
00:13:41,866 --> 00:13:42,766
这个摄像头

382
00:13:43,300 --> 00:13:44,766
他完全不用到学校来

383
00:13:44,766 --> 00:13:47,999
直接在北京调摄像头

384
00:13:48,200 --> 00:13:51,266
来看任何一个教室里的情况

385
00:13:51,566 --> 00:13:53,099
所以学校应该给大家说了

386
00:13:53,400 --> 00:13:54,500
至少这两周啊

387
00:13:54,500 --> 00:13:55,666
到课一定要到

388
00:13:56,000 --> 00:13:58,133
因为那个教育部

389
00:13:58,133 --> 00:13:59,099
会随机的抽

390
00:13:59,100 --> 00:14:00,700
我们的任何一个家属的摄像头

391
00:14:00,700 --> 00:14:03,300
来看老师上课的情况

392
00:14:03,600 --> 00:14:05,766
学生听课的情况啊

393
00:14:06,266 --> 00:14:07,699
所以尽量的到

394
00:14:07,700 --> 00:14:09,800
如果说到课率不够

395
00:14:10,066 --> 00:14:10,699
会批老师

396
00:14:10,700 --> 00:14:11,566
也会批学生

397
00:14:11,733 --> 00:14:13,266
所以不仅仅是我的事情

398
00:14:13,266 --> 00:14:14,366
也是你们的事情

399
00:14:14,366 --> 00:14:15,399
那就会去查那天

400
00:14:15,400 --> 00:14:17,666
那天课到底多少人没有到啊

401
00:14:17,666 --> 00:14:18,766
万一被教育部抽到

402
00:14:18,766 --> 00:14:20,333
他要去看这天的教室

403
00:14:20,333 --> 00:14:22,099
然后教室又空空荡荡

404
00:14:22,100 --> 00:14:24,000
没有足够的人数啊

405
00:14:24,366 --> 00:14:25,266
所以都会有麻烦

406
00:14:25,266 --> 00:14:28,599
所以这两三个星期争取都要到克

407
00:14:30,000 --> 00:14:31,500
呃这个性子啊

408
00:14:31,500 --> 00:14:31,933
说回来

409
00:14:31,933 --> 00:14:34,966
这个历史可夫可替换原则的这个东西

410
00:14:34,966 --> 00:14:35,999
他其实就是

411
00:14:36,000 --> 00:14:37,733
在面向对象的程序设计的时候

412
00:14:37,733 --> 00:14:38,466
他告诉你说

413
00:14:38,466 --> 00:14:41,166
你去overrate复类方法的时候

414
00:14:41,166 --> 00:14:42,566
不能任意去overrate

415
00:14:43,200 --> 00:14:45,733
必须要让负类所具备的性质

416
00:14:45,733 --> 00:14:48,133
在子类中间依然成立

417
00:14:48,366 --> 00:14:49,999
那能成立的话

418
00:14:50,000 --> 00:14:52,300
会意味着会带来什么后果呢

419
00:14:52,466 --> 00:14:52,933
这个后果

420
00:14:52,933 --> 00:14:55,499
就是我们说的迪斯可夫可替换原则

421
00:14:55,500 --> 00:14:58,266
他就能做到子类对象任意替换

422
00:14:58,700 --> 00:15:01,466
负类的调用其实是不受到影响的

423
00:15:01,800 --> 00:15:04,400
因为此类并没有改变负类的行为

424
00:15:04,500 --> 00:15:07,266
只是在负类的行为上面去扩展

425
00:15:07,500 --> 00:15:09,300
那如果你在写代码上

426
00:15:09,300 --> 00:15:10,800
保证这样的一种方式

427
00:15:11,166 --> 00:15:13,899
就会使得说代码的这个正确性啊

428
00:15:14,400 --> 00:15:16,766
健壮啊都会得到提升

429
00:15:17,100 --> 00:15:20,000
那最主要的就会达成

430
00:15:20,000 --> 00:15:22,700
我们在前面所说的开闭原则

431
00:15:23,166 --> 00:15:25,499
也就是你满足Disco复刻替换原则

432
00:15:25,566 --> 00:15:27,766
必然就是满足开闭原则

433
00:15:28,000 --> 00:15:29,100
我们可以看到

434
00:15:29,100 --> 00:15:30,300
在这个例子中间

435
00:15:32,066 --> 00:15:33,366
我们在这个设计中间

436
00:15:34,333 --> 00:15:35,666
它是满足开闭原则

437
00:15:35,900 --> 00:15:38,000
但它满足开闭原则的原因

438
00:15:38,000 --> 00:15:38,366
是因为

439
00:15:38,366 --> 00:15:39,366
我们这个设计

440
00:15:39,600 --> 00:15:41,733
是满足历史可复刻替换原则的

441
00:15:42,333 --> 00:15:43,066
为什么我们说

442
00:15:43,066 --> 00:15:45,666
这个是满足历史客户可替换原则的

443
00:15:45,666 --> 00:15:46,466
我们在这里头

444
00:15:46,466 --> 00:15:49,266
这个负类或者超类是指的这个interface

445
00:15:49,533 --> 00:15:51,799
子类是指的下面这几个Adapter

446
00:15:52,000 --> 00:15:54,966
我们说子类中间所有定义的方法

447
00:15:55,133 --> 00:15:56,299
都不应该违背

448
00:15:56,300 --> 00:15:58,600
在负类中间所定义的行为

449
00:15:58,933 --> 00:16:00,766
就是父类中间所说的性质

450
00:16:00,933 --> 00:16:03,799
在子类中间应该是全部都有的

451
00:16:03,800 --> 00:16:05,800
然后子类可以加上自己的性质

452
00:16:05,800 --> 00:16:06,766
这个没有问题

453
00:16:06,900 --> 00:16:08,300
但是父类中间的所谓的定义

454
00:16:08,300 --> 00:16:09,900
你不能去违背它啊

455
00:16:09,900 --> 00:16:11,600
这就是说历史可复可替换原则

456
00:16:11,766 --> 00:16:12,599
我们为什么说

457
00:16:12,600 --> 00:16:15,566
它是符合历史可复可替换原则的

458
00:16:15,566 --> 00:16:16,666
非常简单

459
00:16:16,666 --> 00:16:17,566
简单在哪呢

460
00:16:17,566 --> 00:16:19,599
我们上面这个负累不是一个负累

461
00:16:19,600 --> 00:16:22,366
是一个什么是一个INTERFACE

462
00:16:22,800 --> 00:16:24,300
作为一个INTERFACE来说

463
00:16:24,300 --> 00:16:27,300
它在方法体里头是没有定义的

464
00:16:27,966 --> 00:16:28,866
INTERFACE是没有定义

465
00:16:28,866 --> 00:16:30,866
方法体的INTERFACE定义的是什么

466
00:16:31,333 --> 00:16:32,266
定义的是

467
00:16:33,766 --> 00:16:35,966
入口的参数和返回的值

468
00:16:36,400 --> 00:16:37,266
还有方法名

469
00:16:37,266 --> 00:16:38,466
是吧就三个东西嘛

470
00:16:38,566 --> 00:16:39,933
我传什么参过来

471
00:16:40,600 --> 00:16:41,800
我反什么值回去

472
00:16:41,800 --> 00:16:42,733
还有方法名

473
00:16:42,933 --> 00:16:45,333
所以当你的上面的东西

474
00:16:45,333 --> 00:16:46,733
定的是一个interface的时候

475
00:16:46,733 --> 00:16:49,999
它在方法的内部是没有任何定义的

476
00:16:50,466 --> 00:16:53,466
那当然所有的实现了这个方法的类

477
00:16:53,800 --> 00:16:55,166
他要实现这个方法

478
00:16:55,166 --> 00:16:55,399
所以

479
00:16:55,400 --> 00:16:58,300
他要接收这个切口所定义的那些参数

480
00:16:58,466 --> 00:17:00,799
他按照这个接口所定义的返回值

481
00:17:00,800 --> 00:17:02,000
把值返回回去

482
00:17:02,200 --> 00:17:02,400
所以

483
00:17:02,400 --> 00:17:05,333
他当然跟接口中间所定义的行为

484
00:17:05,566 --> 00:17:06,399
是一致的

485
00:17:06,733 --> 00:17:06,999
对吧

486
00:17:07,000 --> 00:17:08,400
因为接口中间没有定义其他的行为

487
00:17:08,400 --> 00:17:10,966
就只定义了一个输入的参数

488
00:17:10,966 --> 00:17:12,566
和输出的返回的值

489
00:17:12,700 --> 00:17:14,900
那所有实现这个接口的这些值类

490
00:17:14,900 --> 00:17:15,800
都要去实现

491
00:17:15,800 --> 00:17:16,366
在接口中间

492
00:17:16,366 --> 00:17:17,166
所有的方法

493
00:17:17,400 --> 00:17:20,166
都按照这个接口方法的参数定义

494
00:17:20,166 --> 00:17:21,166
去接收这些值

495
00:17:21,166 --> 00:17:23,133
都按照它的规定去返回那些值

496
00:17:23,400 --> 00:17:26,500
所以当我们的负类是一个接口的时候

497
00:17:27,366 --> 00:17:28,333
毫不犹豫

498
00:17:28,333 --> 00:17:31,366
它肯定是满足迪斯科夫可替换原则

499
00:17:31,866 --> 00:17:33,333
满足迪斯科夫可替换原则

500
00:17:33,333 --> 00:17:34,566
所以我们就能看到说

501
00:17:34,566 --> 00:17:35,866
当我们在channel中间

502
00:17:36,333 --> 00:17:37,333
通过这个接口

503
00:17:37,333 --> 00:17:39,699
去使用微配adapter的时候

504
00:17:40,300 --> 00:17:41,300
以及通过这个接口

505
00:17:41,300 --> 00:17:43,100
去使用Alipair adapt的时候

506
00:17:43,333 --> 00:17:44,799
其实是没有区分的

507
00:17:44,966 --> 00:17:45,766
为什么没有区分

508
00:17:45,766 --> 00:17:47,599
因为这两个子类

509
00:17:48,166 --> 00:17:51,199
都是满足接口的定义的

510
00:17:51,200 --> 00:17:53,166
而我们在使用的时候

511
00:17:53,266 --> 00:17:57,099
我们就是按照接口的定义去使用的

512
00:17:57,300 --> 00:17:59,200
我们不管这个接口做什么

513
00:17:59,200 --> 00:18:01,866
我们给的接口他要的参数要拿

514
00:18:01,866 --> 00:18:02,966
到接口的返回值

515
00:18:02,966 --> 00:18:04,299
至于接口要做什么

516
00:18:04,400 --> 00:18:05,533
那是接口的事情

517
00:18:05,533 --> 00:18:08,466
我们在这边是没有去做定义的

518
00:18:08,466 --> 00:18:10,599
同样接口本身也没定义他要做什么

519
00:18:11,200 --> 00:18:13,566
因为他只定义了参数和返回值

520
00:18:13,600 --> 00:18:16,733
要做什么全是靠在下面的东西去完成

521
00:18:17,133 --> 00:18:19,933
所以这样满足了历史科夫可替换原则

522
00:18:19,933 --> 00:18:20,266
所以

523
00:18:20,266 --> 00:18:24,599
我们这个设计就是满足开币原则

524
00:18:24,766 --> 00:18:26,199
所以历史可不可替换原则

525
00:18:26,200 --> 00:18:28,866
是满足开币原则的一个重要条件

526
00:18:29,500 --> 00:18:32,600
也是我们目前让整个系统

527
00:18:32,600 --> 00:18:34,800
去做到开币原则的一个重要手段

528
00:18:35,100 --> 00:18:37,500
就是如果在继承的这个角度上头

529
00:18:37,500 --> 00:18:41,000
你用继承的方式去实现开币的话

530
00:18:41,500 --> 00:18:43,733
那必然的解决方案

531
00:18:43,733 --> 00:18:45,599
就是靠历史恐怖推翻原则

532
00:18:45,600 --> 00:18:47,333
我们这里看到的开闭原则的定义

533
00:18:47,333 --> 00:18:48,599
其实都是靠继承的

534
00:18:49,133 --> 00:18:51,166
抽象约束封装变化

535
00:18:51,566 --> 00:18:54,333
能不能不靠继承去满足开闭原则

536
00:18:55,166 --> 00:18:56,533
其实也是可以的啊

537
00:18:56,533 --> 00:18:58,899
但是如果不靠继承去满足开闭原则

538
00:18:58,900 --> 00:19:02,266
其实就不需要Eastco复刻TY原则了啊

539
00:19:02,266 --> 00:19:03,133
因为Eastco复刻TY原则

540
00:19:03,133 --> 00:19:04,799
就是针对继承来说的

541
00:19:06,066 --> 00:19:08,899
这是我们讲的前两个设计方法

542
00:19:09,366 --> 00:19:10,399
那第三个设计方法

543
00:19:10,400 --> 00:19:12,200
叫做依赖导致的设计方法

544
00:19:12,200 --> 00:19:14,466
dependent inversion啊

545
00:19:15,100 --> 00:19:17,200
这个是在9996年啊

546
00:19:17,200 --> 00:19:19,700
大家可以看到这是在超面向对象的

547
00:19:19,700 --> 00:19:21,200
就是前面两个设计方法

548
00:19:21,200 --> 00:19:23,466
分别是在87年和88年

549
00:19:23,766 --> 00:19:25,933
那个基本上是在面向对象的

550
00:19:25,933 --> 00:19:28,766
这个设计方法已经趋向于成熟

551
00:19:29,333 --> 00:19:30,799
那时候C++已经有了

552
00:19:31,266 --> 00:19:32,766
加瓦语言还没有出现啊

553
00:19:32,766 --> 00:19:34,499
快出现了啊

554
00:19:34,500 --> 00:19:36,200
但是面向对象的设计方法

555
00:19:36,200 --> 00:19:38,333
已经被业界广泛的接受

556
00:19:38,333 --> 00:19:39,966
而且越来越多的人

557
00:19:39,966 --> 00:19:42,099
在用面向对象的方式去设计系统

558
00:19:42,200 --> 00:19:43,166
在那个年代

559
00:19:43,566 --> 00:19:44,499
那96年是个什

560
00:19:44,500 --> 00:19:44,866
么年代呢

561
00:19:44,866 --> 00:19:46,366
就是郊外语言已经出现了

562
00:19:46,566 --> 00:19:47,599
大家已经认识到

563
00:19:47,600 --> 00:19:48,666
说面向对象

564
00:19:48,700 --> 00:19:51,466
已经是一个很普遍的设计方法

565
00:19:51,466 --> 00:19:53,466
就是其实整个90年代

566
00:19:53,466 --> 00:19:55,166
是整个面向对象设计方法

567
00:19:55,400 --> 00:19:56,400
从实验室

568
00:19:56,400 --> 00:19:59,000
走向工业界的一个重要的十年

569
00:19:59,366 --> 00:20:02,799
80年代末到90年代中期啊

570
00:20:02,800 --> 00:20:05,400
基本上在整个行业内慢慢的接受了

571
00:20:05,400 --> 00:20:05,900
面向对象

572
00:20:05,900 --> 00:20:07,966
是我们当前的一种主要的设计方法

573
00:20:08,200 --> 00:20:09,900
那当他慢慢普及以后

574
00:20:09,900 --> 00:20:12,900
对于面向对象的设计的一些细节

575
00:20:13,000 --> 00:20:16,900
就会有人提出更多的一些原则

576
00:20:16,900 --> 00:20:20,400
比如说沃特马丁在96年提出来说

577
00:20:20,466 --> 00:20:22,866
高层的模块不应该依赖于低层模块

578
00:20:22,866 --> 00:20:24,999
两者都应该依赖于抽象

579
00:20:25,100 --> 00:20:26,133
这是什么意思呢

580
00:20:26,366 --> 00:20:27,666
所谓高层模块低层模块

581
00:20:27,666 --> 00:20:29,599
就是调用者和被调用者

582
00:20:29,933 --> 00:20:30,933
就是如果我要去调

583
00:20:30,933 --> 00:20:33,366
另外一个类的方法的时候

584
00:20:33,400 --> 00:20:35,000
我不应该依赖于什么呢

585
00:20:35,000 --> 00:20:36,333
不应该依赖于那个类

586
00:20:36,700 --> 00:20:38,166
应该依赖于抽象

587
00:20:38,566 --> 00:20:40,266
抽象不应该依赖于细节

588
00:20:40,266 --> 00:20:41,533
细节应该不应该抽象

589
00:20:41,533 --> 00:20:42,533
这听不太懂啊

590
00:20:42,533 --> 00:20:45,399
其实中性的意思就是要做接口

591
00:20:45,666 --> 00:20:48,099
不要去做实线的编程

592
00:20:48,333 --> 00:20:49,766
比如说我们在这个地方

593
00:20:51,700 --> 00:20:52,966
还是以这个例子来说

594
00:20:53,200 --> 00:20:54,266
我们知道啊

595
00:20:54,266 --> 00:20:54,966
在这些地方

596
00:20:54,966 --> 00:20:58,399
比如说channel会去调稻城的方法啊

597
00:20:58,400 --> 00:20:59,966
service会去调channel的方法

598
00:20:59,966 --> 00:21:01,466
也会去调稻城的方法

599
00:21:01,900 --> 00:21:03,533
那这些调用我们可以看到

600
00:21:03,533 --> 00:21:05,333
我们都没有使用接口

601
00:21:05,566 --> 00:21:07,533
而是直接把这个对象

602
00:21:07,600 --> 00:21:10,800
用spin的框架注入到service里头

603
00:21:10,800 --> 00:21:12,900
或者或者用build的方式

604
00:21:12,900 --> 00:21:16,133
把它build到这个啊bo对象中间

605
00:21:16,133 --> 00:21:17,399
然后就直接去掉了

606
00:21:18,000 --> 00:21:19,566
这个就是不满足什么呢

607
00:21:19,566 --> 00:21:22,199
不满足依赖导致原则的

608
00:21:22,466 --> 00:21:25,499
因为我们直接调了他的具体的实

609
00:21:25,500 --> 00:21:27,800
线而没有去调抽象

610
00:21:27,966 --> 00:21:30,199
按照依赖导致原则是

611
00:21:30,200 --> 00:21:31,600
我们在这里的这个道

612
00:21:32,200 --> 00:21:34,533
不应该直接被别人使用

613
00:21:34,733 --> 00:21:37,766
应该上面去做一个接口

614
00:21:38,133 --> 00:21:42,766
然后让他去通过接口来使用这个档

615
00:21:43,133 --> 00:21:44,666
这样就是叫什么

616
00:21:44,800 --> 00:21:48,600
这样就是叫做两者并不互相依赖

617
00:21:48,600 --> 00:21:50,600
两者依赖于他的抽象

618
00:21:50,600 --> 00:21:52,900
抽象并不依赖于细节

619
00:21:52,900 --> 00:21:54,766
通过抽象的接口去调他

620
00:21:54,866 --> 00:21:56,599
所以这叫做面向接口编程

621
00:21:56,600 --> 00:21:58,466
而不是面向线编程

622
00:21:58,500 --> 00:21:59,600
我们在这个设计中间

623
00:21:59,600 --> 00:22:00,066
我们知道

624
00:22:00,066 --> 00:22:01,166
我们这半部分

625
00:22:01,766 --> 00:22:04,333
是没有用依赖导致原则的

626
00:22:05,333 --> 00:22:06,133
为什么

627
00:22:06,566 --> 00:22:06,933
大家觉得

628
00:22:06,933 --> 00:22:08,799
为什么这半部分没有用意外导致原则

629
00:22:10,566 --> 00:22:11,366
思考一下啊

630
00:22:11,366 --> 00:22:11,766
为什么

631
00:22:11,766 --> 00:22:13,666
我们那半部分没有用意外导致原则

632
00:22:14,300 --> 00:22:14,566
罗伯特

633
00:22:14,566 --> 00:22:16,733
马丁不仅仅提出了意外导致原则

634
00:22:17,900 --> 00:22:19,100
他还提出了另外一个原则

635
00:22:19,100 --> 00:22:20,933
叫做单一职责原则

636
00:22:21,400 --> 00:22:22,733
单一职责原则呢

637
00:22:22,733 --> 00:22:24,066
他是在另外一本书

638
00:22:24,066 --> 00:22:27,733
叫做敏捷软件开发原则模式和实践

639
00:22:28,200 --> 00:22:29,166
啊软供应该讲过

640
00:22:29,166 --> 00:22:30,999
敏捷软件开发是从什么年代开始的

641
00:22:31,000 --> 00:22:31,866
刚才那本书

642
00:22:31,866 --> 00:22:35,466
那个呃音乐老师原则是在96年

643
00:22:35,533 --> 00:22:36,299
那敏捷

644
00:22:36,300 --> 00:22:38,100
可我没有查到这本书什么时候出版的

645
00:22:38,100 --> 00:22:39,300
但是敏捷软件开发

646
00:22:39,300 --> 00:22:41,166
是在2,000年以后才发生的事情

647
00:22:41,700 --> 00:22:44,200
大概2,000零几年的时候啊

648
00:22:44,200 --> 00:22:46,700
它开始有人提出敏捷软件开发

649
00:22:46,866 --> 00:22:49,366
所以这个单一组织原则

650
00:22:49,366 --> 00:22:49,966
大概率

651
00:22:49,966 --> 00:22:52,566
应该是在2,000年以后才提出来的

652
00:22:52,733 --> 00:22:54,499
它基本的想法是说

653
00:22:54,500 --> 00:22:56,000
任何一个类

654
00:22:56,200 --> 00:22:57,366
应该只有

655
00:22:57,366 --> 00:22:59,866
而且仅有一个引起它变化的原因

656
00:23:00,666 --> 00:23:01,466
否则的话

657
00:23:01,500 --> 00:23:03,533
这个类应该被切成两个类

658
00:23:03,966 --> 00:23:06,199
意思就是每一个类应该只有一个职责

659
00:23:06,366 --> 00:23:07,733
而不应该有两个职责

660
00:23:07,733 --> 00:23:09,933
因为这个职责发生了变化

661
00:23:09,933 --> 00:23:11,666
这个类就会发生变化

662
00:23:11,900 --> 00:23:13,333
但如果他有两个职责的话

663
00:23:13,333 --> 00:23:14,766
他就会有两个

664
00:23:14,866 --> 00:23:17,466
引起他去改代码的原因了

665
00:23:17,866 --> 00:23:20,999
所以这是罗伯特马丁的第二个言论

666
00:23:21,733 --> 00:23:22,799
这个原则

667
00:23:22,800 --> 00:23:24,566
还是对到我们这个设计上来说

668
00:23:25,566 --> 00:23:26,733
大家觉得我们这个设计

669
00:23:26,733 --> 00:23:31,366
符不符合罗伯特马丁的单一职责原则

670
00:23:33,000 --> 00:23:35,700
那大家要看守什么是职责

671
00:23:36,333 --> 00:23:37,266
在面向对象中间

672
00:23:37,266 --> 00:23:38,699
我们知道什么是职责

673
00:23:40,000 --> 00:23:42,400
我们的每一个业务的方法

674
00:23:42,466 --> 00:23:45,399
就这些方法就是一个职责

675
00:23:45,666 --> 00:23:47,966
为什么会有这个方法的出现

676
00:23:47,966 --> 00:23:50,299
是因为我们用职责分配的方式

677
00:23:50,300 --> 00:23:51,666
无论是用信息专家

678
00:23:51,866 --> 00:23:53,666
还是用创建者的方式

679
00:23:53,666 --> 00:23:55,733
把这个职责分配给了这个对象

680
00:23:56,066 --> 00:23:57,766
所以这个对象就会有一个方法

681
00:23:57,900 --> 00:23:58,800
所以反过来说

682
00:23:58,800 --> 00:23:59,500
当我们这里看到

683
00:23:59,500 --> 00:24:00,700
这里有这个四个方法的时候

684
00:24:00,700 --> 00:24:01,266
我们知道

685
00:24:01,266 --> 00:24:03,266
这个签约对象其实是有四个指责的

686
00:24:04,066 --> 00:24:05,399
对吧是有四个职责的

687
00:24:05,600 --> 00:24:08,300
如果按照单一职责的原则

688
00:24:08,666 --> 00:24:10,099
罗伯特马丁认为这个枪的对象

689
00:24:10,100 --> 00:24:11,200
这才应该变成四个

690
00:24:11,966 --> 00:24:13,066
因为他有四个职责

691
00:24:13,133 --> 00:24:15,333
所以每个对象每个类只能有一个职责

692
00:24:15,333 --> 00:24:18,066
那就应该变成四个对象

693
00:24:20,733 --> 00:24:23,199
大家觉得能做的出来吗

694
00:24:24,600 --> 00:24:29,733
所以通过罗伯特马丁的这三个言论啊

695
00:24:29,933 --> 00:24:32,066
包括他的第四这两个言论

696
00:24:32,066 --> 00:24:33,533
包括他的第三个言论

697
00:24:34,000 --> 00:24:35,400
接口隔离的原则

698
00:24:35,866 --> 00:24:36,466
就是

699
00:24:36,466 --> 00:24:39,066
客户端不应该依赖于他不使用的方法

700
00:24:39,066 --> 00:24:41,933
每一个类对于另外一个的一类依赖

701
00:24:41,933 --> 00:24:44,666
应该建立在最小接口上

702
00:24:44,966 --> 00:24:48,766
这叫做interface separation principle s i ISP

703
00:24:49,733 --> 00:24:50,599
这个同样可以看到

704
00:24:50,600 --> 00:24:51,400
我们在这个设计中间

705
00:24:51,400 --> 00:24:53,100
我们同样没有遵循

706
00:24:53,100 --> 00:24:54,600
它的接口隔离的原则

707
00:24:54,600 --> 00:24:56,733
为啥这是我们的接口

708
00:24:57,500 --> 00:24:58,766
这个接口都我们定义了

709
00:24:58,766 --> 00:25:00,699
所有的支付渠道的方法

710
00:25:00,700 --> 00:25:03,866
都在这但是在channel这个类中间

711
00:25:03,866 --> 00:25:06,199
它并没有用到它所有的方法

712
00:25:07,133 --> 00:25:10,466
他只用到他中间的这个签约和解约

713
00:25:10,666 --> 00:25:11,799
这两个API

714
00:25:12,066 --> 00:25:12,933
其他没用到

715
00:25:13,466 --> 00:25:15,666
如果按照接口隔离的原则

716
00:25:15,666 --> 00:25:17,566
我们应该把这个接口

717
00:25:17,566 --> 00:25:20,866
切分成若干个小切口

718
00:25:21,100 --> 00:25:22,733
比如说做一个接口

719
00:25:22,733 --> 00:25:24,266
专门为了channel用的

720
00:25:24,333 --> 00:25:26,533
这个channel里头只有两个方法

721
00:25:26,966 --> 00:25:28,966
然后呢别的类

722
00:25:28,966 --> 00:25:30,399
比如说那shopdown会用

723
00:25:30,400 --> 00:25:32,133
shop channel会用到它的一些方法

724
00:25:32,133 --> 00:25:33,999
那我们又把这些方法又做成一个接口

725
00:25:34,333 --> 00:25:35,666
给shop channel去用

726
00:25:35,666 --> 00:25:37,899
然后这两个类的对象

727
00:25:38,766 --> 00:25:40,733
实现了多个接口

728
00:25:40,733 --> 00:25:41,166
大家知道

729
00:25:41,166 --> 00:25:44,099
这教学是一个类可以实现多个接口的

730
00:25:44,266 --> 00:25:46,333
所以这个类就会实现多个接口

731
00:25:46,333 --> 00:25:49,133
而这个接口被切成了若干个

732
00:25:49,933 --> 00:25:50,766
跟类有关的

733
00:25:50,766 --> 00:25:53,399
跟他被使用者有关的这个小接口

734
00:25:53,533 --> 00:25:55,666
这叫做接口隔离的原则

735
00:25:56,266 --> 00:25:57,566
这三个原则用上去以后

736
00:25:57,566 --> 00:25:58,133
大家会发现

737
00:25:58,133 --> 00:25:59,466
我们这个大宝变成什么样子

738
00:26:01,933 --> 00:26:02,566
会变成什么样子

739
00:26:02,566 --> 00:26:03,366
你们觉得

740
00:26:06,100 --> 00:26:07,133
难以想象吧

741
00:26:08,000 --> 00:26:09,500
所有的调用都不能直接调了

742
00:26:09,500 --> 00:26:10,666
都要被形成接口

743
00:26:11,100 --> 00:26:13,700
所有的接口都必须要

744
00:26:13,700 --> 00:26:16,666
不包含他不用的那些方法

745
00:26:16,666 --> 00:26:18,766
所以每个接口被切成好多个

746
00:26:18,766 --> 00:26:20,599
你比如说在这里看到的这个channel

747
00:26:20,600 --> 00:26:21,666
调这个DOE

748
00:26:21,766 --> 00:26:24,533
这调它是会要定一个channel DOE的接口

749
00:26:24,533 --> 00:26:25,733
不要以为channel只调

750
00:26:25,733 --> 00:26:27,099
只会做一个接口哦

751
00:26:27,466 --> 00:26:28,666
我们那个社会是调

752
00:26:28,666 --> 00:26:30,299
它又需要再做一个接口

753
00:26:30,900 --> 00:26:33,500
然后这个在调查又需要做一个接口

754
00:26:33,500 --> 00:26:34,533
所以channel

755
00:26:34,600 --> 00:26:35,600
从这张图上来看

756
00:26:35,600 --> 00:26:37,900
我们就需要做3个channel的接口

757
00:26:38,000 --> 00:26:39,466
分别为了他来用的

758
00:26:39,466 --> 00:26:41,299
为了他来用的为了他来用的

759
00:26:41,466 --> 00:26:43,666
这样就满足了依赖导致

760
00:26:43,666 --> 00:26:46,066
原则和接口分离的原则

761
00:26:46,200 --> 00:26:48,266
然后呢channel不是有这么多方法吗

762
00:26:48,266 --> 00:26:49,066
不行

763
00:26:49,533 --> 00:26:50,866
切成若干个签到到

764
00:26:51,566 --> 00:26:52,599
每一个签到到

765
00:26:52,800 --> 00:26:55,600
去实现了中间的某些接口

766
00:26:55,966 --> 00:26:58,266
然后内拆成了多个

767
00:26:58,366 --> 00:26:59,999
接口拆成了多个

768
00:27:00,466 --> 00:27:02,666
整个这张类图你就完全就看不懂了

769
00:27:03,566 --> 00:27:06,766
所以我们为什么没有使用

770
00:27:07,100 --> 00:27:08,900
我们后面的第三个

771
00:27:08,900 --> 00:27:11,700
第四个第五个这个设计原则

772
00:27:12,866 --> 00:27:15,066
是因为我们认为依赖导致原则

773
00:27:15,066 --> 00:27:19,466
单一职责原则和接口隔离原则

774
00:27:19,766 --> 00:27:21,366
都是激进的原则

775
00:27:22,066 --> 00:27:22,299
就是

776
00:27:22,300 --> 00:27:24,900
你如果按照这种激进主义的这种原则

777
00:27:25,133 --> 00:27:26,566
去做这个设计的话

778
00:27:26,566 --> 00:27:28,799
你是没办法把那个设计做出来能看的

779
00:27:29,366 --> 00:27:32,533
所以这些原则我们就是采取了

780
00:27:32,866 --> 00:27:33,866
我们知道它

781
00:27:34,100 --> 00:27:36,133
但是我们会选择性的

782
00:27:36,133 --> 00:27:39,066
在某些地方才会用到它

783
00:27:39,266 --> 00:27:40,799
我们的选择性是在哪

784
00:27:41,500 --> 00:27:43,700
选择性就是跟前面的开闭原则一样

785
00:27:43,766 --> 00:27:46,099
我们认为这个部分是要做开闭的

786
00:27:46,400 --> 00:27:49,333
而且它的变化是非常频繁的

787
00:27:49,766 --> 00:27:52,566
那我们就不仅仅是在这个Disco

788
00:27:52,566 --> 00:27:53,966
复合替换原的基础上头

789
00:27:54,300 --> 00:27:57,200
会去融入它的依赖导致原则

790
00:27:57,200 --> 00:28:00,866
单一职责原则和这个接口原则

791
00:28:01,000 --> 00:28:02,600
所以在这个设计中间啊

792
00:28:04,000 --> 00:28:07,866
我们可以看到这边满足开闭原则

793
00:28:07,866 --> 00:28:09,066
满足历史可不可跳原则

794
00:28:09,066 --> 00:28:10,366
我们还满足了什么呢

795
00:28:10,533 --> 00:28:12,333
满足了依赖导致原则

796
00:28:12,333 --> 00:28:13,666
因为我们用的是接口

797
00:28:13,666 --> 00:28:15,199
而不是用的实际对象

798
00:28:15,533 --> 00:28:17,366
但是我们没有做什么呢

799
00:28:17,366 --> 00:28:20,266
没有做类的具体的再细分

800
00:28:20,700 --> 00:28:24,066
没有做接口的在细分

801
00:28:24,066 --> 00:28:26,066
所以我们没有用它的类的

802
00:28:26,066 --> 00:28:28,999
单一职责原则和接口隔离的原则

803
00:28:29,000 --> 00:28:32,866
但是用了123就是开闭原则

804
00:28:32,866 --> 00:28:35,599
Disco不可替换原则和依赖导致原则

805
00:28:36,500 --> 00:28:37,900
用了123以后啊

806
00:28:37,900 --> 00:28:38,600
你会发现他

807
00:28:38,600 --> 00:28:40,533
就已经基本上满足开闭原则

808
00:28:40,766 --> 00:28:41,499
但是

809
00:28:41,500 --> 00:28:45,100
因为没有去做他的接口隔离的原则

810
00:28:45,133 --> 00:28:46,766
会造成什么样的后果

811
00:28:47,100 --> 00:28:48,466
就是我没有做这个原则

812
00:28:48,466 --> 00:28:49,599
会造成什么样的后果

813
00:28:49,900 --> 00:28:53,133
假如说某一个接口的方法发生改变了

814
00:28:53,866 --> 00:28:56,333
其实我们从内图上头就会看到

815
00:28:56,333 --> 00:28:57,499
这个接口的方法

816
00:28:57,500 --> 00:28:59,333
其实会影响到很多的泪

817
00:29:00,466 --> 00:29:01,866
会影响到很多的泪

818
00:29:01,866 --> 00:29:02,366
这就是因为

819
00:29:02,366 --> 00:29:05,499
我们没有做接口隔离的原则

820
00:29:05,600 --> 00:29:07,600
如果做了接口隔离的原则

821
00:29:08,000 --> 00:29:09,566
某一个方法发生改变了

822
00:29:09,566 --> 00:29:10,933
它只会影响

823
00:29:11,300 --> 00:29:13,366
含有这个方法的那些接口的泪

824
00:29:14,066 --> 00:29:14,799
从而啊

825
00:29:14,800 --> 00:29:17,700
就是使用了含有这个方法的那些类

826
00:29:17,700 --> 00:29:19,166
而不会去影响其他的

827
00:29:19,166 --> 00:29:20,999
根本就没有用到这个方法的那些

828
00:29:21,166 --> 00:29:23,133
那些接口的定义啊所以

829
00:29:24,566 --> 00:29:27,066
坏处啊其实你不用这个原则

830
00:29:27,066 --> 00:29:29,499
你会知道他的弊病在哪

831
00:29:29,500 --> 00:29:30,466
但是用这个原则

832
00:29:30,466 --> 00:29:31,799
你也知道他的弊病在哪

833
00:29:31,800 --> 00:29:33,133
我们是没办法接受

834
00:29:33,133 --> 00:29:34,699
说把内控制到这么小

835
00:29:34,900 --> 00:29:38,200
也没办法接受把接口隔离层这么小

836
00:29:38,300 --> 00:29:39,866
这两个代价我们都接受不了

837
00:29:39,866 --> 00:29:41,699
所以我们就这两个原则

838
00:29:41,700 --> 00:29:42,966
我们没有去遵循他

839
00:29:44,733 --> 00:29:47,399
第六个原则啊

840
00:29:47,400 --> 00:29:48,866
是迪米特原则

841
00:29:49,166 --> 00:29:50,733
什么叫迪米特原则呢

842
00:29:50,933 --> 00:29:52,966
迪米特原则有一个很形象的说法

843
00:29:52,966 --> 00:29:55,366
叫做Don't talk to a stranger

844
00:29:55,366 --> 00:29:58,533
就talk only to your imitate friends

845
00:29:58,533 --> 00:29:59,666
not to a stranger

846
00:30:00,333 --> 00:30:02,299
就是不跟陌生人说话

847
00:30:02,766 --> 00:30:04,933
那什么叫做不跟陌生人说话啊

848
00:30:04,933 --> 00:30:06,399
我们可以看一个例子

849
00:30:06,400 --> 00:30:07,133
我们的代码中间

850
00:30:07,133 --> 00:30:09,499
其实大量是满足了迪米特原则

851
00:30:09,733 --> 00:30:12,133
但是有一些小的例子上

852
00:30:12,133 --> 00:30:14,566
都是没有做到满足迪米特原则的

853
00:30:39,066 --> 00:30:40,933
基本上大的部分都满足了啊

854
00:30:40,933 --> 00:30:45,533
但是这个就这些小的地方是没有满足

855
00:30:45,533 --> 00:30:46,499
Demeter原则的

856
00:30:46,500 --> 00:30:48,166
这个就是违背了Demeter原则

857
00:30:48,366 --> 00:30:50,566
Demeter原则说Don't talk to stranger

858
00:30:50,900 --> 00:30:53,000
对于我们现在写的这个类

859
00:30:53,000 --> 00:30:55,733
叫做we pay Adapter来说

860
00:30:57,533 --> 00:30:59,466
这个是他的friends

861
00:30:59,600 --> 00:31:02,500
因为他可以通过静态的方法名

862
00:31:02,866 --> 00:31:06,399
来得到这个里头的某一个

863
00:31:07,500 --> 00:31:09,500
这是他的某一个静态的属性

864
00:31:09,933 --> 00:31:10,799
可以得到他

865
00:31:11,166 --> 00:31:13,333
所以他是他的Mister FRIENDS

866
00:31:13,333 --> 00:31:15,599
你可以通过他得到他这个东西

867
00:31:15,866 --> 00:31:20,333
但是他的这个方法就是stranger

868
00:31:20,966 --> 00:31:22,766
所以这个方法

869
00:31:22,766 --> 00:31:25,099
对于我们的这个微pair doctor来说

870
00:31:25,100 --> 00:31:26,266
它就是stranger

871
00:31:26,600 --> 00:31:29,266
所以不应该这么来写代码

872
00:31:29,366 --> 00:31:30,399
应该怎么写呢

873
00:31:30,400 --> 00:31:34,966
应该是先用他得到一个他的这个对象

874
00:31:34,966 --> 00:31:37,899
再调写第二行来得到他的个特卖设计

875
00:31:37,900 --> 00:31:39,133
这就低迷这个原则

876
00:31:39,366 --> 00:31:40,299
但是我们可以看到

877
00:31:40,300 --> 00:31:41,600
在今天我们写代码的时候

878
00:31:41,600 --> 00:31:46,300
我们越来越没有遵循蒂米特原则

879
00:31:47,133 --> 00:31:49,166
在何况我们在之后

880
00:31:50,900 --> 00:31:51,933
写的代码中间

881
00:31:51,933 --> 00:31:52,966
大家可以看到

882
00:31:54,766 --> 00:31:55,566
这一段

883
00:32:00,266 --> 00:32:01,333
大家觉得上面一段代码

884
00:32:01,333 --> 00:32:02,766
跟迪米特原则有关系吗

885
00:32:03,500 --> 00:32:05,266
因为大家看迪米特原则就知道说

886
00:32:05,266 --> 00:32:06,933
他是有点点点点点的

887
00:32:07,000 --> 00:32:08,666
对吧点点点点的话

888
00:32:08,666 --> 00:32:11,599
意思表示说是这个对象的这个属性

889
00:32:11,600 --> 00:32:12,600
这时候可以用的

890
00:32:12,900 --> 00:32:14,666
这个属性的在他的方法

891
00:32:14,666 --> 00:32:16,366
或者他的在其他的属性

892
00:32:16,366 --> 00:32:17,799
我就不能再直接写了

893
00:32:17,800 --> 00:32:19,800
这是他的stranger

894
00:32:19,800 --> 00:32:21,466
所以说第一名特性都不允许这么写

895
00:32:21,600 --> 00:32:22,766
但是我们现在的方法中间

896
00:32:22,766 --> 00:32:25,099
其实有很多像上面看到的这样的代码

897
00:32:25,400 --> 00:32:27,533
大家会觉得这是跟第一名特性有关吗

898
00:32:31,900 --> 00:32:33,066
有关吗大家也知道

899
00:32:33,066 --> 00:32:35,399
这种写法是跟迪米特云的有关吗

900
00:32:38,266 --> 00:32:39,366
为什么可以这样写

901
00:32:39,466 --> 00:32:40,966
可以这么点点点点的写

902
00:32:42,133 --> 00:32:43,133
有同学知道吗

903
00:32:44,666 --> 00:32:47,566
这个就是函数式编程的克里化

904
00:32:47,766 --> 00:32:50,899
它其实并不是蒂米特编程里头的

905
00:32:51,100 --> 00:32:51,933
就是并不是说

906
00:32:51,933 --> 00:32:54,266
这个build底下再有一个方法叫做

907
00:32:55,400 --> 00:32:58,733
它不是build里头有一个方法叫做它

908
00:32:58,966 --> 00:33:01,333
也不是它这个方法里头叫做它

909
00:33:01,566 --> 00:33:04,799
这个就是用的函数编程的克里化

910
00:33:04,800 --> 00:33:05,666
叫做Corey

911
00:33:06,866 --> 00:33:09,333
啊所以看起来很像迪米特原则

912
00:33:09,333 --> 00:33:11,199
好很像违背的迪米特原则

913
00:33:11,266 --> 00:33:13,966
但是这个东西不是迪米特原则

914
00:33:13,966 --> 00:33:16,299
这是函数边程中间的克里函数

915
00:33:17,066 --> 00:33:18,899
它是逐步逐步的返回值的

916
00:33:18,900 --> 00:33:22,566
把函数边程中间的下一步的返回值

917
00:33:22,566 --> 00:33:24,133
作为上一步的输入值

918
00:33:24,133 --> 00:33:25,799
这么一个个带过去的

919
00:33:26,333 --> 00:33:27,066
所以在今天

920
00:33:27,066 --> 00:33:29,199
我们其实因为有克里化的存在

921
00:33:29,666 --> 00:33:30,966
所以迪米特原则

922
00:33:31,066 --> 00:33:34,133
已经越来越不受人待见了

923
00:33:35,366 --> 00:33:36,999
会把它放到靠后啊

924
00:33:37,366 --> 00:33:38,566
这就是低米特原则

925
00:33:38,566 --> 00:33:39,466
我们在代码中间

926
00:33:39,466 --> 00:33:41,933
其实有多处是没有遵循低米特原则的

927
00:33:42,666 --> 00:33:43,999
特别是在今天

928
00:33:44,000 --> 00:33:46,266
我们韩式这边成克里化横行如市的

929
00:33:46,266 --> 00:33:48,133
这种大量使用克里化的时候

930
00:33:48,333 --> 00:33:50,533
很容易就会看起来

931
00:33:50,533 --> 00:33:52,099
好像跟蒂米特是违背了啊

932
00:33:52,100 --> 00:33:53,933
所以说我们就属性就完全没有

933
00:33:53,933 --> 00:33:57,333
去去去管这个蒂米特原则

934
00:33:58,333 --> 00:33:59,133
最后一个啊

935
00:33:59,133 --> 00:34:00,599
是合成复用原则

936
00:34:01,000 --> 00:34:02,333
这个原则是讲什么呢

937
00:34:02,333 --> 00:34:03,933
是讲继承关系的

938
00:34:04,100 --> 00:34:05,566
我们知道在面向对象设计中间

939
00:34:05,566 --> 00:34:07,099
我们是有继承关系的

940
00:34:07,566 --> 00:34:09,299
那他认为说

941
00:34:09,733 --> 00:34:12,099
在写代码的时候不要用继承关系

942
00:34:13,066 --> 00:34:16,999
应该全部用组合或者聚合来实现

943
00:34:17,333 --> 00:34:18,499
大家会很好奇

944
00:34:18,500 --> 00:34:19,800
说组合和聚合

945
00:34:19,800 --> 00:34:20,466
怎么能实现

946
00:34:20,466 --> 00:34:23,466
一个原本由继承关系去实现的东西

947
00:34:23,966 --> 00:34:25,566
我们在之前

948
00:34:25,566 --> 00:34:27,733
是有一个简单的用聚

949
00:34:27,733 --> 00:34:29,666
聚合关系去实现的例子

950
00:34:30,533 --> 00:34:33,966
这个transaction有四个子类

951
00:34:35,300 --> 00:34:36,400
啊我

952
00:34:36,400 --> 00:34:37,533
们的四种交易

953
00:34:37,533 --> 00:34:39,099
是吧我们在之前代码中我们知道

954
00:34:39,100 --> 00:34:42,866
我们这次用用继承关系去实现啊

955
00:34:42,933 --> 00:34:44,266
这样的一个东西

956
00:34:44,366 --> 00:34:45,933
用组合方式去做

957
00:34:45,933 --> 00:34:47,733
我们把类图画到黑板上了

958
00:34:47,866 --> 00:34:48,899
是长这个样子

959
00:34:49,600 --> 00:34:51,266
这里做的就是transaction

960
00:34:51,266 --> 00:34:52,899
依然这个类是存在的

961
00:34:53,200 --> 00:34:56,600
但这个类不是那两那四个类的负类啊

962
00:34:56,600 --> 00:34:57,566
我只换了两个

963
00:34:57,566 --> 00:34:59,466
其实有4个不是他的负类

964
00:34:59,766 --> 00:35:02,266
而是让他们跟他建立了一个观念

965
00:35:02,900 --> 00:35:03,600
那我们知道

966
00:35:03,600 --> 00:35:06,666
我们在做子类和父类的关系的时候

967
00:35:06,666 --> 00:35:08,066
是有一个原则的

968
00:35:08,133 --> 00:35:10,699
就是在父类中间所定义的所有的东西

969
00:35:10,800 --> 00:35:12,566
如果子类没有去overwrite

970
00:35:12,733 --> 00:35:14,733
那它就依然会被继承下来

971
00:35:14,866 --> 00:35:18,533
对吧就不用去重复写这种方式

972
00:35:18,566 --> 00:35:21,733
如果在transaction中间所有定义的属性

973
00:35:22,200 --> 00:35:23,800
包括他的方法

974
00:35:24,200 --> 00:35:27,266
在子类中间要他这不叫子类了

975
00:35:27,266 --> 00:35:29,866
在关联的这个类中间要重复出现的话

976
00:35:29,866 --> 00:35:30,666
怎么办

977
00:35:31,466 --> 00:35:32,333
你们觉得怎么办

978
00:35:33,666 --> 00:35:35,699
比如说从属性来说

979
00:35:35,966 --> 00:35:37,333
我这边有一个

980
00:35:42,333 --> 00:35:43,666
get ID的方法

981
00:35:44,500 --> 00:35:46,900
对吧这个就真正的去得到它的ID

982
00:35:46,900 --> 00:35:48,400
因为它有个属性叫做ID

983
00:35:50,100 --> 00:35:51,400
对吧就得到他的ID

984
00:35:51,866 --> 00:35:52,366
这里头

985
00:35:52,366 --> 00:35:54,299
肯定是没有定义那个ID的属性的

986
00:35:54,300 --> 00:35:55,600
跟那个继承的方式一样

987
00:35:55,600 --> 00:35:56,600
我没有定义ID的属性

988
00:35:56,600 --> 00:35:59,666
我只定义了refund三个形的属性

989
00:35:59,666 --> 00:36:00,966
以及陪券的属性

990
00:36:01,400 --> 00:36:03,933
那为了体现出继承的概念

991
00:36:03,933 --> 00:36:06,066
我这里同样要写一个gate ID

992
00:36:08,566 --> 00:36:10,333
这边也要写一个get ID的方法

993
00:36:10,800 --> 00:36:12,600
但这个get ID的方法是干嘛呢

994
00:36:12,600 --> 00:36:18,500
是去调这个对象的get a d的方法

995
00:36:18,500 --> 00:36:20,366
去返回就是我们说的

996
00:36:20,366 --> 00:36:22,199
用组合或者聚合

997
00:36:22,666 --> 00:36:23,699
去实现

998
00:36:23,700 --> 00:36:26,966
原本面向对象所形成的继承的这种

999
00:36:26,966 --> 00:36:29,733
东西那这是一个get的方法

1000
00:36:29,733 --> 00:36:31,133
那如果说这边有个业务方法

1001
00:36:31,133 --> 00:36:32,066
我写在这边了

1002
00:36:32,466 --> 00:36:33,333
比如说hello

1003
00:36:34,800 --> 00:36:35,933
业务方法写在这边了

1004
00:36:36,700 --> 00:36:37,300
指类中间

1005
00:36:37,300 --> 00:36:39,533
我要同样的把这个业务方法继承下来

1006
00:36:39,533 --> 00:36:43,266
那同样这边写一个hello的方法去调它

1007
00:36:43,966 --> 00:36:46,166
那如果说要改变他的行为怎么办

1008
00:36:46,600 --> 00:36:46,966
我们说

1009
00:36:46,966 --> 00:36:49,799
子类不是可以重载他的负类的行为吗

1010
00:36:50,133 --> 00:36:51,299
要改变怎么办

1011
00:36:51,366 --> 00:36:52,933
这就是你要考虑说

1012
00:36:53,066 --> 00:36:55,266
你要满足历史可夫可替换原则

1013
00:36:55,533 --> 00:36:57,566
历史可夫可替换原则说的是

1014
00:36:57,566 --> 00:36:58,533
继承的时候

1015
00:36:58,533 --> 00:37:01,366
子类不会改变超类的行为

1016
00:37:01,900 --> 00:37:03,333
当我们用合成

1017
00:37:03,333 --> 00:37:05,499
和复用的方式去做的时候

1018
00:37:05,700 --> 00:37:08,866
如果你还要满足Disco复刻替换原则

1019
00:37:09,000 --> 00:37:10,700
就是它会去掉

1020
00:37:12,066 --> 00:37:12,933
他的方法

1021
00:37:13,400 --> 00:37:16,766
然后在他的调用之前和调用之后

1022
00:37:16,933 --> 00:37:18,666
可以去加上自己的行为

1023
00:37:18,800 --> 00:37:20,533
加上去的这些行为

1024
00:37:20,900 --> 00:37:22,733
同样不能改变

1025
00:37:23,200 --> 00:37:26,200
全三行所定义的那样的一个行为

1026
00:37:26,533 --> 00:37:27,399
这样的话啊

1027
00:37:27,400 --> 00:37:30,333
我们就可以让他满足

1028
00:37:30,333 --> 00:37:31,499
历史可复的天王原则

1029
00:37:31,500 --> 00:37:33,566
那历史可复的天王原则怎么用

1030
00:37:34,133 --> 00:37:35,999
约束用抽象去约束

1031
00:37:36,000 --> 00:37:38,533
他是在上面再去定一个interface

1032
00:37:45,533 --> 00:37:49,966
然后让他们去实现这个INTERFACE

1033
00:37:50,700 --> 00:37:53,200
把这个上头所定义的这些方法

1034
00:37:53,200 --> 00:37:55,100
把它变成一个INTERFACE

1035
00:37:55,266 --> 00:37:58,666
然后把原本由它的继承关系

1036
00:37:59,566 --> 00:38:01,599
把它变成组合关系

1037
00:38:01,600 --> 00:38:03,566
然后让他们去实现那个INTERFACE

1038
00:38:03,666 --> 00:38:05,766
然后再是所有的使用者

1039
00:38:05,766 --> 00:38:08,199
通过那个INTERFACE来使用这些对象

1040
00:38:08,200 --> 00:38:09,400
就是没有继承关系

1041
00:38:09,400 --> 00:38:11,600
只有INTERFACE的啊

1042
00:38:11,600 --> 00:38:12,533
实现关系

1043
00:38:12,700 --> 00:38:15,000
这样来实现这个

1044
00:38:17,400 --> 00:38:19,366
来实现这样的一个过程

1045
00:38:19,366 --> 00:38:22,333
这称之为合成复用的原则

1046
00:38:25,566 --> 00:38:28,533
你们觉得除了第一个原则以外

1047
00:38:28,700 --> 00:38:32,166
我们所说的软件设计的后面5个原则

1048
00:38:32,166 --> 00:38:35,666
是不是都是相对比较激进的是吧

1049
00:38:36,066 --> 00:38:37,466
依赖岛职业者只能用接口

1050
00:38:37,466 --> 00:38:38,533
不能直接掉类

1051
00:38:38,733 --> 00:38:39,666
单一职责的原则

1052
00:38:39,666 --> 00:38:41,733
每个类应该只有一个业务方法

1053
00:38:42,933 --> 00:38:44,133
接口隔离的原则

1054
00:38:44,200 --> 00:38:45,600
每个类使用的接口

1055
00:38:45,600 --> 00:38:46,933
就不应该有其他的方法

1056
00:38:46,933 --> 00:38:49,099
所以一个接口应该被切成好多个

1057
00:38:49,800 --> 00:38:50,866
在每一个使用的地方

1058
00:38:50,866 --> 00:38:52,133
都是一个独立的接口

1059
00:38:52,133 --> 00:38:54,799
然后那个底下实线内去实现很多接口

1060
00:38:55,100 --> 00:38:56,300
DPT选择严格的要求

1061
00:38:56,300 --> 00:39:00,066
你不能去用它的里头的属性的方法

1062
00:39:00,933 --> 00:39:02,799
只能用他的friends

1063
00:39:02,800 --> 00:39:04,600
他的直接关联的那个属性

1064
00:39:05,333 --> 00:39:06,399
对象的属性

1065
00:39:07,200 --> 00:39:07,966
合成复原则

1066
00:39:07,966 --> 00:39:09,866
干脆就把面向对象的继承关系

1067
00:39:09,866 --> 00:39:11,133
一脚踢走了

1068
00:39:11,533 --> 00:39:14,199
只能用组合关系和聚合关系来实现

1069
00:39:14,200 --> 00:39:15,900
而不能用继承关系来实现

1070
00:39:16,400 --> 00:39:19,200
都是很激进的这样的一种方式

1071
00:39:19,400 --> 00:39:21,366
所以当我们在使用一种

1072
00:39:21,666 --> 00:39:23,733
面向对象的语言的时候

1073
00:39:23,800 --> 00:39:26,266
其实我们对于后面这些激进的原则

1074
00:39:26,266 --> 00:39:28,266
是有选择的在使用

1075
00:39:28,533 --> 00:39:29,899
那其中我最后要说一下

1076
00:39:29,900 --> 00:39:31,400
这个合成和复用的原则

1077
00:39:31,666 --> 00:39:32,599
这个在早期时候

1078
00:39:32,600 --> 00:39:34,300
大家都认为是一个很激进的原则

1079
00:39:34,300 --> 00:39:36,166
面向对象最基本的特性就是继承

1080
00:39:36,666 --> 00:39:38,566
为什么在设计的时候

1081
00:39:38,566 --> 00:39:41,466
大家会说我们尽量少用继承

1082
00:39:41,466 --> 00:39:43,966
这个就是跟他的偶合有关系

1083
00:39:44,400 --> 00:39:44,933
大家知道

1084
00:39:44,933 --> 00:39:45,866
我们面对象之间的

1085
00:39:45,866 --> 00:39:47,366
所有代码之间的偶合度

1086
00:39:47,366 --> 00:39:48,533
是通过继承关系

1087
00:39:48,533 --> 00:39:49,966
关联关系和依赖关系

1088
00:39:50,333 --> 00:39:53,966
内图中间的三个关系来实现偶合的

1089
00:39:54,300 --> 00:39:54,533
其中

1090
00:39:54,533 --> 00:39:57,166
继承关系是偶合度最高的一种偶合

1091
00:39:57,500 --> 00:40:00,000
因为当你的负类发生改变以后

1092
00:40:00,000 --> 00:40:02,366
它所有的子类都会受到影响

1093
00:40:02,400 --> 00:40:04,600
所以说它是在偶合的程度上的

1094
00:40:04,600 --> 00:40:06,766
最高的一种偶合度

1095
00:40:07,133 --> 00:40:09,066
那当然有人就想说我能不能不

1096
00:40:09,066 --> 00:40:12,333
用继承关系同样能实现代码

1097
00:40:12,333 --> 00:40:14,666
所以就提出了合成复用的原则

1098
00:40:14,800 --> 00:40:15,466
这个原则

1099
00:40:15,466 --> 00:40:18,099
是在我们后面的5个激进原则

1100
00:40:18,100 --> 00:40:19,366
就是提得很激进的

1101
00:40:19,366 --> 00:40:23,266
这个原则里头唯一变成了实际的

1102
00:40:23,766 --> 00:40:24,566
大家知道

1103
00:40:24,733 --> 00:40:27,333
构语言里头是没有继承关系的

1104
00:40:27,533 --> 00:40:28,666
就是构语言的出现

1105
00:40:28,666 --> 00:40:30,399
其实比加瓦语言更晚

1106
00:40:30,866 --> 00:40:33,733
大概是2013年15年才出现的

1107
00:40:33,733 --> 00:40:34,533
这个新语言

1108
00:40:34,800 --> 00:40:37,400
其实它代表了未来这个程序语言的

1109
00:40:37,700 --> 00:40:40,300
就是从程序设计语言的这个发展趋势

1110
00:40:40,600 --> 00:40:42,766
购物语言中间就很激进的

1111
00:40:42,900 --> 00:40:45,500
把继承关系直接砍掉了

1112
00:40:45,500 --> 00:40:46,533
没有继承关系

1113
00:40:47,133 --> 00:40:49,299
所以你要在构与元的这个结构上的

1114
00:40:49,300 --> 00:40:51,100
去实现继承关系的话

1115
00:40:51,266 --> 00:40:54,399
就必须得要使用合成附庸原则

1116
00:40:54,700 --> 00:40:56,600
用组合和聚合去实现

1117
00:40:56,600 --> 00:40:58,966
他只有类和接口啊

1118
00:40:58,966 --> 00:40:59,966
它其实也没有类

1119
00:41:00,000 --> 00:41:02,533
它叫做那个struct和接口

1120
00:41:02,866 --> 00:41:04,966
有这两个基本的结构

1121
00:41:05,166 --> 00:41:07,099
那如果说struct

1122
00:41:07,100 --> 00:41:09,866
中间要去做类似于继承的东西

1123
00:41:09,866 --> 00:41:11,766
就必须得要用组合聚合

1124
00:41:12,100 --> 00:41:14,100
合成费用原则去实现啊

1125
00:41:14,300 --> 00:41:18,333
所以这个部分来说虽然很激进

1126
00:41:18,333 --> 00:41:19,566
但是大家可以看到

1127
00:41:19,566 --> 00:41:22,699
随着这个呃时代的发展

1128
00:41:22,933 --> 00:41:25,199
这些激进的这些原则

1129
00:41:25,200 --> 00:41:28,466
也会慢慢的被业界接受

1130
00:41:28,666 --> 00:41:33,099
最后甚至到最底层的程序语言里头

1131
00:41:33,200 --> 00:41:36,866
也把这些激进的的吸收进去啊

1132
00:41:36,866 --> 00:41:38,466
变成一个最基本的原则

1133
00:41:39,266 --> 00:41:41,399
这是我们要讲的软件七大原则

1134
00:41:41,400 --> 00:41:42,700
那最后大家可以看一下

1135
00:41:42,700 --> 00:41:46,966
我们做了一个这样的汇总啊

1136
00:41:46,966 --> 00:41:49,099
这里头的这个原则中间

1137
00:41:49,133 --> 00:41:50,866
开闭原则和历史可复替换原则

1138
00:41:50,866 --> 00:41:53,499
是最基本的原则啊

1139
00:41:53,500 --> 00:41:54,866
开闭原则和历史可复

1140
00:41:54,866 --> 00:41:56,099
特别是历史可复替换原则

1141
00:41:56,100 --> 00:41:57,933
它是基于继承体系的

1142
00:41:58,366 --> 00:41:59,899
但是大家知道

1143
00:41:59,900 --> 00:42:01,933
现在的新的编

1144
00:42:01,933 --> 00:42:03,599
程语言中也是没有继承体系的

1145
00:42:03,733 --> 00:42:05,299
所以在合成复用原则上头

1146
00:42:05,300 --> 00:42:07,166
同样也能达成历史可复可替换

1147
00:42:07,166 --> 00:42:09,266
但是这时候用的是接口啊

1148
00:42:09,266 --> 00:42:13,766
不是简单的是类和类之间的继承啊

1149
00:42:13,966 --> 00:42:14,933
总的来说

1150
00:42:15,200 --> 00:42:16,566
无论是历史可复可替换原则

1151
00:42:16,566 --> 00:42:17,533
还是合成分原则

1152
00:42:17,533 --> 00:42:19,966
大家可以看到它其实防止的都是继承

1153
00:42:20,700 --> 00:42:23,100
因为继承是偶活度最高的一种方式

1154
00:42:23,300 --> 00:42:24,900
所以Disco复合替换原则

1155
00:42:24,900 --> 00:42:28,366
限制了继承不能去修改负累的行为

1156
00:42:28,766 --> 00:42:29,899
而合作复原则

1157
00:42:29,900 --> 00:42:32,300
就完全把继承给他废弃掉

1158
00:42:32,366 --> 00:42:33,133
所以大家可以看到

1159
00:42:33,133 --> 00:42:36,333
继承其实是面对上的一个最基本特征

1160
00:42:36,333 --> 00:42:38,766
但是它也是一个最容易坏事的特征

1161
00:42:39,566 --> 00:42:40,333
用不好的话啊

1162
00:42:40,333 --> 00:42:42,599
他会使得整个代码的偶合度非常高

1163
00:42:43,166 --> 00:42:46,166
呃所以甚至就是有激进的人认为

1164
00:42:46,166 --> 00:42:47,333
干脆就不要用合成

1165
00:42:47,333 --> 00:42:48,299
不要用基层关系

1166
00:42:48,300 --> 00:42:49,933
用合成复用原则去做

1167
00:42:50,200 --> 00:42:52,600
那其他的这些单一职责

1168
00:42:53,266 --> 00:42:56,166
依赖导致单一职责和接口隔离迪米特

1169
00:42:56,166 --> 00:42:57,366
我们可以让单一职责

1170
00:42:57,366 --> 00:42:58,466
接口隔离和迪米特

1171
00:42:58,466 --> 00:43:00,466
目前其实大家还没有广泛的接受

1172
00:43:00,533 --> 00:43:03,499
因为如果按照这个原则去做的话呢

1173
00:43:03,500 --> 00:43:06,500
那基本上代码就变成很碎很碎

1174
00:43:06,966 --> 00:43:07,966
但是依赖导致原则

1175
00:43:07,966 --> 00:43:09,966
我们通常会跟这个

1176
00:43:10,066 --> 00:43:11,166
历史可不可替换原则

1177
00:43:11,166 --> 00:43:12,199
去混到一起

1178
00:43:12,366 --> 00:43:14,466
你觉得历史可不可替换原则

1179
00:43:14,466 --> 00:43:16,199
讲的是负类和超类

1180
00:43:16,566 --> 00:43:17,733
负类和子类

1181
00:43:18,400 --> 00:43:19,533
子类和负类啊

1182
00:43:19,533 --> 00:43:20,599
是讲这个关系

1183
00:43:20,733 --> 00:43:23,499
但是我们如果把Disco可替换原则

1184
00:43:23,500 --> 00:43:25,500
和这个依赖老则原则合在一起的话

1185
00:43:25,500 --> 00:43:27,933
其实就变成了接口和它的实现

1186
00:43:29,800 --> 00:43:30,766
那这样的话

1187
00:43:31,533 --> 00:43:33,699
其实所有在依赖导致上头

1188
00:43:33,700 --> 00:43:35,133
所做出来的这个结果

1189
00:43:35,133 --> 00:43:37,533
都是满足迪斯科复刻题化原则的

1190
00:43:37,533 --> 00:43:39,366
从而可以做开辟啊

1191
00:43:39,366 --> 00:43:42,133
这是我们的这7大原则

1192
00:43:42,900 --> 00:43:44,733
呃这个部分啊

1193
00:43:45,600 --> 00:43:48,266
是就是我们在10月份讲的

1194
00:43:48,266 --> 00:43:48,966
这两个部分

1195
00:43:48,966 --> 00:43:51,133
其实是考试的重点

1196
00:43:51,600 --> 00:43:54,733
呃前面的grasp的七种方法

1197
00:43:55,333 --> 00:43:57,599
后面的软件设计的七大原则

1198
00:43:57,800 --> 00:44:00,266
从这两周开始

1199
00:44:00,266 --> 00:44:01,399
我们其实就是不断的

1200
00:44:01,400 --> 00:44:03,166
在用各种各样的模块的例子

1201
00:44:03,166 --> 00:44:05,066
在重复讲这些东西

1202
00:44:05,266 --> 00:44:07,866
如果大家去看一下我们往年的考卷

1203
00:44:08,000 --> 00:44:11,366
我们往年考卷的卷面分的50%以上

1204
00:44:11,966 --> 00:44:14,066
都是在讲这个部分的内容

1205
00:44:14,066 --> 00:44:16,866
特别是考试中间的难的部分

1206
00:44:16,866 --> 00:44:19,666
因为我们考试是分为简单的30%

1207
00:44:19,666 --> 00:44:20,699
中等的30%

1208
00:44:20,700 --> 00:44:24,333
难的30% 特别是中等和难的部分的题目

1209
00:44:24,333 --> 00:44:26,933
全部是全部是这些内容里头的

1210
00:44:27,133 --> 00:44:29,966
所以大家在这个期末的时候

1211
00:44:29,966 --> 00:44:31,766
比如到12月份要复习的时候

1212
00:44:33,000 --> 00:44:34,066
一定要啊

1213
00:44:34,300 --> 00:44:37,700
把我们从上个星期开始的这些录课

1214
00:44:38,166 --> 00:44:39,566
完整的再看一遍

1215
00:44:40,066 --> 00:44:42,599
然后你才会知道考试怎么去做

1216
00:44:42,766 --> 00:44:45,266
因为我们考试内容不会考选中模块

1217
00:44:45,600 --> 00:44:49,866
只会考从上个星期开始到12月中旬

1218
00:44:49,866 --> 00:44:51,066
差不多这一个多月

1219
00:44:51,300 --> 00:44:54,466
8次课里头所讲的这些

1220
00:44:54,466 --> 00:44:56,333
各个模块的b种模块的设计

1221
00:44:56,600 --> 00:44:57,600
然后考题的话

1222
00:44:57,600 --> 00:44:59,000
主要是分成两种

1223
00:44:59,200 --> 00:45:00,733
一种是你的分析题

1224
00:45:00,733 --> 00:45:02,566
一种是你的主动设计题

1225
00:45:02,766 --> 00:45:03,533
那分析题的话

1226
00:45:03,533 --> 00:45:05,566
是我拿一个现有的设计给大家去看

1227
00:45:05,566 --> 00:45:06,466
说你去分析

1228
00:45:06,466 --> 00:45:08,466
说里头用了什么面对上的设计方法

1229
00:45:09,100 --> 00:45:10,366
那改进设计题呢

1230
00:45:10,366 --> 00:45:11,366
就是拿一个不好的设计

1231
00:45:11,366 --> 00:45:13,099
给大家去做改进

1232
00:45:13,166 --> 00:45:16,466
说你应该在这个设计中间去改成一个

1233
00:45:16,466 --> 00:45:17,733
用什么样的面向对象的方式

1234
00:45:17,733 --> 00:45:19,866
去把它改成一个新的设计啊

1235
00:45:19,866 --> 00:45:22,199
所以这一个月的这个录课

1236
00:45:22,200 --> 00:45:23,800
大家在复习之前一定要去看

1237
00:45:23,966 --> 00:45:24,699
否则的话

1238
00:45:24,700 --> 00:45:25,700
你在考试的时候

1239
00:45:25,700 --> 00:45:28,300
你就完全不知道说这个是什么

1240
00:45:28,300 --> 00:45:29,066
因为我们在考试时

1241
00:45:29,066 --> 00:45:30,399
不可能把这个设计的需求

1242
00:45:30,400 --> 00:45:31,600
给讲的非常清楚

1243
00:45:31,966 --> 00:45:34,133
是吧如果他把这个需求

1244
00:45:34,166 --> 00:45:35,099
什么东西都讲清楚的话

1245
00:45:35,100 --> 00:45:36,666
那个考卷会印的非常的差

1246
00:45:37,100 --> 00:45:38,333
那我们基本上给大家约定

1247
00:45:38,333 --> 00:45:40,799
就是我们从上个星期开始

1248
00:45:41,300 --> 00:45:43,533
到考试之前这一段时间

1249
00:45:43,533 --> 00:45:44,066
讲课里头

1250
00:45:44,066 --> 00:45:45,166
所有讲的案例

1251
00:45:45,466 --> 00:45:47,733
有可能会出现在我们的考试里头

1252
00:45:47,766 --> 00:45:49,666
所以你把所有案例给搞清楚

1253
00:45:49,666 --> 00:45:50,999
那考试里头看到出现啥

1254
00:45:51,000 --> 00:45:53,066
你就去照他做就好了

1255
00:45:53,133 --> 00:45:54,399
好我们先休息一会

1256
00:54:08,666 --> 00:54:09,466
好

1257
00:54:10,166 --> 00:54:11,733
这样我就讲完了

1258
00:54:12,266 --> 00:54:14,699
这个软件设计的7大原则啊

1259
00:54:16,733 --> 00:54:18,199
然后今天的第二节课

1260
00:54:18,200 --> 00:54:20,566
我们把支付模块的剩下的几个例子

1261
00:54:20,566 --> 00:54:21,599
再讲几个

1262
00:54:21,866 --> 00:54:23,699
然后从周三开始

1263
00:54:23,700 --> 00:54:26,666
我们就会逐步的讲这个产品模块

1264
00:54:26,800 --> 00:54:29,166
产品模块大概要讲两次课

1265
00:54:29,666 --> 00:54:31,933
然后商铺的模块

1266
00:54:32,300 --> 00:54:34,733
然后最后一个必做模块

1267
00:54:34,733 --> 00:54:35,533
物流的模块

1268
00:54:35,533 --> 00:54:38,366
则要靠同学们自己来设计来完成

1269
00:54:38,366 --> 00:54:39,699
然后呃

1270
00:54:39,700 --> 00:54:42,333
看同学们的设计造做成什么样子

1271
00:54:42,466 --> 00:54:43,599
然后我们来对比说

1272
00:54:43,600 --> 00:54:45,133
这个设计有什么样的问题

1273
00:54:45,533 --> 00:54:47,766
然后应该做成一个什么样更好的设计

1274
00:54:47,933 --> 00:54:48,966
啊来讲

1275
00:54:49,066 --> 00:54:52,099
所以我们在期末结束之前

1276
00:54:52,100 --> 00:54:54,166
就是所有的课堂上的内容

1277
00:54:54,566 --> 00:54:57,399
都是在讲必做模块的例子

1278
00:54:57,533 --> 00:55:00,666
然后这些例子都会用视频录课的方式

1279
00:55:00,666 --> 00:55:01,499
全部录下来

1280
00:55:01,766 --> 00:55:04,799
所以大家在最后一定要去看一下

1281
00:55:04,933 --> 00:55:05,499
这个

1282
00:55:05,500 --> 00:55:07,900
这一个多月就差不多从现在开始

1283
00:55:07,900 --> 00:55:08,866
现在是十八号

1284
00:55:08,966 --> 00:55:10,699
这个呃

1285
00:55:10,700 --> 00:55:13,800
11月中旬到12月中旬

1286
00:55:13,800 --> 00:55:15,600
这一段时间的这个录课

1287
00:55:15,800 --> 00:55:17,333
然后最后一次的讨论课

1288
00:55:17,333 --> 00:55:17,866
大家可以看到

1289
00:55:17,866 --> 00:55:19,899
安排在检查的之前的一周

1290
00:55:19,900 --> 00:55:22,300
因为我们最后的一周是检查就不会

1291
00:55:22,300 --> 00:55:23,100
再上课了

1292
00:55:23,200 --> 00:55:25,933
所以最后的一次的讨论课和作业

1293
00:55:25,933 --> 00:55:27,866
是安排在那个

1294
00:55:28,666 --> 00:55:30,899
呃那个之前的

1295
00:55:30,900 --> 00:55:31,700
这个主要原因就是

1296
00:55:31,700 --> 00:55:35,066
我们希望通过这么多次的

1297
00:55:35,066 --> 00:55:36,933
b种模块的这个讲

1298
00:55:36,933 --> 00:55:39,166
让大家在做选做模块的时候

1299
00:55:39,600 --> 00:55:43,100
能够用面向对象的方式

1300
00:55:43,100 --> 00:55:46,400
去设计和实现这样的一个选作模块

1301
00:55:46,400 --> 00:55:48,766
所以我们把那个最后一次讨论课

1302
00:55:49,100 --> 00:55:50,333
以及最后一次作业的时间

1303
00:55:50,333 --> 00:55:51,299
安排的比较晚

1304
00:55:51,533 --> 00:55:54,333
那最后的课程设计的成绩呢

1305
00:55:55,066 --> 00:55:55,299
啊

1306
00:55:55,300 --> 00:55:58,700
我们主要是靠同学们的必做的任务

1307
00:55:58,800 --> 00:56:02,566
还有你们及小组的身份的选做的任务

1308
00:56:02,600 --> 00:56:03,766
来完成的

1309
00:56:03,900 --> 00:56:05,900
必做任务我们会要求的比较严格一点

1310
00:56:05,900 --> 00:56:09,333
会要求完成不但是做设计做代码

1311
00:56:09,333 --> 00:56:11,399
还要能通过测试啊

1312
00:56:11,400 --> 00:56:13,300
选中部分我们就没做这个要求了

1313
00:56:13,300 --> 00:56:17,100
主要是大家自己能去设计去实现

1314
00:56:17,200 --> 00:56:18,200
然后去做测试啊

1315
00:56:18,200 --> 00:56:20,100
我们把集成分也都去掉了

1316
00:56:20,333 --> 00:56:22,399
所以最后的话就是大家知道

1317
00:56:22,400 --> 00:56:24,733
课程设计的分数是一半是必做

1318
00:56:24,966 --> 00:56:26,599
一半是选做

1319
00:56:26,733 --> 00:56:27,166
就是

1320
00:56:27,166 --> 00:56:30,099
所以所有的同学在这个月开始啊

1321
00:56:30,100 --> 00:56:31,100
要努力的去做

1322
00:56:31,100 --> 00:56:31,466
b做任务

1323
00:56:31,466 --> 00:56:31,999
我们b做任务

1324
00:56:32,000 --> 00:56:33,666
其实一共是四轮

1325
00:56:33,666 --> 00:56:35,133
加上一个自由轮

1326
00:56:35,466 --> 00:56:36,466
那四轮里头

1327
00:56:36,466 --> 00:56:39,099
我们都限制说每位同学只能做一个

1328
00:56:39,600 --> 00:56:41,000
自由轮没有做限制

1329
00:56:41,166 --> 00:56:43,899
就是如果说你总数不超过4个

1330
00:56:43,900 --> 00:56:47,266
如果你发现你在啊四轮任务中间

1331
00:56:47,900 --> 00:56:49,766
这个没有做够4个

1332
00:56:49,766 --> 00:56:50,866
还想拿更高的分

1333
00:56:50,866 --> 00:56:51,866
你们就去做选座的

1334
00:56:51,866 --> 00:56:52,999
选座不做限制的啊

1335
00:56:53,000 --> 00:56:54,200
选座有多少个放出来

1336
00:56:54,200 --> 00:56:56,100
你可以你四个都做选座的

1337
00:56:56,100 --> 00:56:58,766
都可以就是自由轮的都可以啊

1338
00:56:58,766 --> 00:57:01,299
就是那个选座那个自由的那个任务

1339
00:57:01,366 --> 00:57:03,799
当然自由任务会比较难一点啊

1340
00:57:03,800 --> 00:57:04,700
通常来说大家知

1341
00:57:04,700 --> 00:57:06,933
道我们这里所看到的那些例子

1342
00:57:06,933 --> 00:57:10,133
都是在自由任务中间出现的

1343
00:57:10,133 --> 00:57:12,366
就是实际上一个是比较难

1344
00:57:12,366 --> 00:57:13,766
再一个是其实放开

1345
00:57:13,766 --> 00:57:15,899
给同学们自己天马行空的机会

1346
00:57:15,900 --> 00:57:17,600
就是你觉得现在这个设计中间

1347
00:57:17,600 --> 00:57:18,500
有些什么东西

1348
00:57:18,500 --> 00:57:19,933
你可以去做一个改进

1349
00:57:20,066 --> 00:57:21,499
那就主动提出来

1350
00:57:21,500 --> 00:57:22,800
坐在自由任务中间

1351
00:57:23,400 --> 00:57:24,533
总数不超过4个啊

1352
00:57:24,533 --> 00:57:25,333
所以大家应该知道

1353
00:57:25,333 --> 00:57:26,799
在最后的这个课程设计分数中间

1354
00:57:26,800 --> 00:57:29,166
其实一半就是每位同学的

1355
00:57:29,166 --> 00:57:30,533
一半的分数是什么

1356
00:57:30,533 --> 00:57:31,666
是你们的必做任务

1357
00:57:32,000 --> 00:57:35,566
一半的分数是小组的任务

1358
00:57:35,566 --> 00:57:37,799
所以一定要去做必做任务

1359
00:57:37,800 --> 00:57:40,200
你才可能拿到更高的分数

1360
00:57:40,266 --> 00:57:40,933
否则的话

1361
00:57:40,933 --> 00:57:43,933
单纯靠小组的分数排位的时候

1362
00:57:43,933 --> 00:57:45,099
你知道你只有一半

1363
00:57:45,200 --> 00:57:47,400
就会排到很很后头去啊

1364
00:57:47,533 --> 00:57:50,066
这个一定要要要引起重视

1365
00:57:50,066 --> 00:57:51,599
其实就在这一个多月之内

1366
00:57:51,666 --> 00:57:52,366
大家可以看到

1367
00:57:52,366 --> 00:57:53,333
我们这些所谓的设计

1368
00:57:53,333 --> 00:57:54,599
就是在这一个多月之内

1369
00:57:54,933 --> 00:57:56,299
王健腾就这么做出来的

1370
00:57:56,900 --> 00:57:59,900
好那我们最后来讲一下支付模块的

1371
00:57:59,900 --> 00:58:02,100
剩下的挑了几个东西来讲

1372
00:58:02,700 --> 00:58:03,800
一个是支付

1373
00:58:04,166 --> 00:58:05,266
一个是退款

1374
00:58:05,600 --> 00:58:09,133
这是支付模块中间的两个关键任务

1375
00:58:09,566 --> 00:58:10,533
这两个关键任务呢

1376
00:58:10,533 --> 00:58:12,766
其实也涵盖了

1377
00:58:12,766 --> 00:58:13,999
我们在支付模块中间的

1378
00:58:14,000 --> 00:58:16,000
主要的这样的一个结构啊

1379
00:58:16,000 --> 00:58:17,200
实际上是怎么做的

1380
00:58:17,666 --> 00:58:20,166
支付呢相对来说比较特殊一点

1381
00:58:20,166 --> 00:58:20,966
因为我们知道

1382
00:58:20,966 --> 00:58:24,066
其实我们在后端是没办法完成支付的

1383
00:58:24,566 --> 00:58:27,099
支付都是在前端完成的

1384
00:58:27,100 --> 00:58:29,400
前端去掉微信和支付宝的APP

1385
00:58:29,733 --> 00:58:31,333
去完成这样的一个支付

1386
00:58:31,600 --> 00:58:35,266
但是在前端完成支付之前

1387
00:58:35,266 --> 00:58:36,733
他都需要调后端

1388
00:58:36,800 --> 00:58:38,500
调他的支付渠道

1389
00:58:38,733 --> 00:58:41,266
去做一个支付的登记过程

1390
00:58:41,566 --> 00:58:43,933
然后通过支付渠道所返回的那

1391
00:58:43,933 --> 00:58:47,666
个返回值去吊起前端的APP

1392
00:58:48,133 --> 00:58:49,733
那我们这里做了一些折中

1393
00:58:49,733 --> 00:58:52,099
就是它其实返回的值很复杂

1394
00:58:52,100 --> 00:58:53,866
而且还有还有加密

1395
00:58:54,100 --> 00:58:55,466
我们现在都把它低

1396
00:58:55,466 --> 00:58:57,499
把所有的加密都去掉了

1397
00:58:57,500 --> 00:59:00,733
就是全变成明码返回给前端

1398
00:59:01,066 --> 00:59:03,399
第二呢把里头一些相对比较复杂的

1399
00:59:03,400 --> 00:59:05,133
健全的东西把它去掉

1400
00:59:05,300 --> 00:59:07,333
所以我们指最后的返回值

1401
00:59:07,333 --> 00:59:08,266
大家可以看到

1402
00:59:08,400 --> 00:59:10,333
这是调用值啊

1403
00:59:10,333 --> 00:59:11,166
这是返回值

1404
00:59:11,166 --> 00:59:13,066
最后的返回值全是明码

1405
00:59:13,066 --> 00:59:14,999
而且是那个明码

1406
00:59:15,000 --> 00:59:17,300
中间一些最必要的值

1407
00:59:17,466 --> 00:59:19,366
我们在这个明码的这些值里头

1408
00:59:19,366 --> 00:59:19,866
可以看到

1409
00:59:19,866 --> 00:59:21,766
其实它被分成了两组

1410
00:59:22,100 --> 00:59:23,266
对于微信来说

1411
00:59:23,266 --> 00:59:24,533
其实它只需要这个返回值

1412
00:59:24,533 --> 00:59:25,599
就是prepare ID

1413
00:59:26,866 --> 00:59:27,966
对于支付宝来说

1414
00:59:27,966 --> 00:59:29,466
他需要这些字

1415
00:59:29,733 --> 00:59:30,733
剩下的4个字

1416
00:59:31,200 --> 00:59:32,700
所以这时我们可以看到

1417
00:59:32,700 --> 00:59:36,366
我们在做这个接口的时候的一个弱项

1418
00:59:36,466 --> 00:59:37,266
这个弱项在哪

1419
00:59:37,266 --> 00:59:38,999
我们现在只做了微信和支付宝

1420
00:59:39,200 --> 00:59:39,966
所以大家可以看到

1421
00:59:39,966 --> 00:59:40,699
在这个接口中间

1422
00:59:40,700 --> 00:59:41,800
其实只包含了

1423
00:59:41,800 --> 00:59:43,566
微信和支付宝所需要的字

1424
00:59:43,900 --> 00:59:45,533
如果雨伞付上来会怎么样

1425
00:59:47,400 --> 00:59:48,000
我们不知道

1426
00:59:48,000 --> 00:59:49,700
我们没有去看云闪付的API

1427
00:59:49,933 --> 00:59:52,166
如果云闪付在前端调起的APP

1428
00:59:52,166 --> 00:59:53,599
需要更多的值的话

1429
00:59:53,866 --> 00:59:57,266
我们则会在返回值里头去做增加

1430
00:59:57,566 --> 01:00:00,866
所以新增一个支付渠道

1431
01:00:00,933 --> 01:00:02,966
我们理想的状态是

1432
01:00:02,966 --> 01:00:06,099
不会动到除了他自己以外

1433
01:00:06,100 --> 01:00:07,100
其他的代码的

1434
01:00:07,566 --> 01:00:10,066
但现实中间我们其实做不到

1435
01:00:10,333 --> 01:00:12,599
因为我们其实在做这个设计的时候

1436
01:00:12,600 --> 01:00:15,566
我们没有去考虑到支付宝的APP

1437
01:00:15,800 --> 01:00:18,366
支付宝的前端在调取他的支付

1438
01:00:18,400 --> 01:00:20,733
呃云闪付的前端

1439
01:00:20,733 --> 01:00:22,933
在调取他的云闪付的APP的时候

1440
01:00:23,133 --> 01:00:24,333
需要传什么样的参数

1441
01:00:24,333 --> 01:00:25,399
所以这个返回记录是

1442
01:00:25,400 --> 01:00:29,166
不包含云闪付的就是4个是支付宝的

1443
01:00:29,166 --> 01:00:31,133
一个是微信的啊

1444
01:00:31,133 --> 01:00:34,566
这是理想和现实的差距啊

1445
01:00:34,566 --> 01:00:36,133
那我们现在没有把它做的很复杂

1446
01:00:36,133 --> 01:00:36,466
所以说

1447
01:00:36,466 --> 01:00:39,166
就只考虑了微信和支付宝的两个东西

1448
01:00:40,200 --> 01:00:41,700
传过去的词很简单

1449
01:00:41,700 --> 01:00:43,066
无论是微信还是支付宝

1450
01:00:43,066 --> 01:00:44,466
我们都传是一样的字

1451
01:00:44,533 --> 01:00:46,266
一个是它的内部交易号

1452
01:00:46,266 --> 01:00:46,966
这个通常是

1453
01:00:46,966 --> 01:00:49,333
我们为了写到支付渠道里头

1454
01:00:50,133 --> 01:00:50,866
去标识

1455
01:00:50,866 --> 01:00:52,999
说这个支付是一个什么样的支付

1456
01:00:53,000 --> 01:00:55,333
会写一个这个outtraction number

1457
01:00:55,700 --> 01:00:56,733
然后一个描述

1458
01:00:56,733 --> 01:00:58,166
然后一个开始时间

1459
01:00:58,166 --> 01:00:58,799
一个结束时间

1460
01:00:58,800 --> 01:01:00,366
就是支付的开始时间

1461
01:01:00,533 --> 01:01:02,299
和支付的过期时间

1462
01:01:02,533 --> 01:01:05,699
金额还有支付要分账的金额

1463
01:01:05,700 --> 01:01:08,400
其实都写在了这个传过去的这个里头

1464
01:01:08,733 --> 01:01:10,166
那这玩意是怎么做的呢

1465
01:01:10,166 --> 01:01:11,866
我们可以看到这个设计图

1466
01:01:12,066 --> 01:01:12,999
在顺序图上头

1467
01:01:13,000 --> 01:01:14,466
大家能够明显看到

1468
01:01:14,600 --> 01:01:16,500
跟其他的方法是一样的

1469
01:01:17,133 --> 01:01:19,066
就是进入到surface城以后

1470
01:01:19,066 --> 01:01:21,099
我们要做的事情就是

1471
01:01:21,100 --> 01:01:23,933
我们要在一个支付渠道上头去做支付

1472
01:01:24,366 --> 01:01:26,499
所以我们用支付渠道的ID

1473
01:01:26,500 --> 01:01:28,200
获得了支付渠道的对象

1474
01:01:28,933 --> 01:01:29,899
然后第二件事情就是

1475
01:01:29,900 --> 01:01:32,700
我们把这个职责分配给了支付渠道

1476
01:01:33,333 --> 01:01:34,199
那你为什么说

1477
01:01:34,200 --> 01:01:37,100
我们会把这个职责分配给支付渠道呢

1478
01:01:37,466 --> 01:01:39,566
是因为我们的这张图上头其实没有画

1479
01:01:39,566 --> 01:01:42,266
但是其实这张图上头应该能够看出来

1480
01:01:42,266 --> 01:01:43,066
说

1481
01:01:43,900 --> 01:01:45,400
应该把这张图的这个部分

1482
01:01:45,400 --> 01:01:47,133
改成一个实心的符号

1483
01:01:48,500 --> 01:01:50,800
为啥因为所有的支付交易

1484
01:01:50,800 --> 01:01:53,100
都是归属于一个支付渠道的

1485
01:01:53,500 --> 01:01:55,266
不可能有任何一个支付交易

1486
01:01:55,266 --> 01:01:56,766
是在两个支付渠道的

1487
01:01:56,766 --> 01:01:58,999
对吧他只可能归属于一个支付渠道

1488
01:01:59,133 --> 01:02:00,966
有支付渠道才有支付交易

1489
01:02:00,966 --> 01:02:01,766
没有支付渠道

1490
01:02:01,766 --> 01:02:02,999
就没有支付交易

1491
01:02:03,333 --> 01:02:05,333
所以所有的这四个东西啊

1492
01:02:05,333 --> 01:02:06,166
不止支付

1493
01:02:06,166 --> 01:02:07,166
包括退款

1494
01:02:07,166 --> 01:02:10,266
其实都是跟渠道是个什么关系呢

1495
01:02:10,500 --> 01:02:11,700
是一个组合关系

1496
01:02:11,800 --> 01:02:14,100
就是他是他的这个局部

1497
01:02:14,366 --> 01:02:16,999
他是依赖于这个渠道所存在的

1498
01:02:17,266 --> 01:02:19,699
正是因为是这样的一个组合关系

1499
01:02:19,700 --> 01:02:20,666
competition关系

1500
01:02:20,766 --> 01:02:22,099
所以我们在这里可以看到

1501
01:02:22,100 --> 01:02:26,533
这个设计所用的Graspler的方法

1502
01:02:29,133 --> 01:02:30,533
就是什么呢

1503
01:02:30,666 --> 01:02:32,799
就是创建者的方式

1504
01:02:32,933 --> 01:02:33,933
把这个职责

1505
01:02:33,933 --> 01:02:36,566
分配给了shop channel的这个对象

1506
01:02:36,900 --> 01:02:38,266
所以这里第三步

1507
01:02:38,266 --> 01:02:40,566
这里用的是创建者的设计方法

1508
01:02:40,766 --> 01:02:42,799
把这个职责给他分配过去了

1509
01:02:42,966 --> 01:02:43,866
分配过去以后

1510
01:02:43,866 --> 01:02:44,666
他做的事情

1511
01:02:44,666 --> 01:02:45,666
大家可以看到

1512
01:02:45,700 --> 01:02:47,566
基本上就是非面向对象的

1513
01:02:47,966 --> 01:02:48,866
干的事情主要是什么呢

1514
01:02:48,866 --> 01:02:49,499
干的对象是

1515
01:02:49,500 --> 01:02:52,133
第一我们把传进来的那个对象

1516
01:02:52,133 --> 01:02:53,399
给他插进去了

1517
01:02:53,500 --> 01:02:54,100
这个对象

1518
01:02:54,100 --> 01:02:56,500
其实是在最开始的时候传进来的

1519
01:02:56,766 --> 01:02:57,999
这时候这个对象

1520
01:02:58,000 --> 01:03:01,066
我们把它称之为直对象

1521
01:03:01,333 --> 01:03:03,533
专门给他一个名称叫做value object

1522
01:03:03,900 --> 01:03:05,066
什么叫做直对象

1523
01:03:05,133 --> 01:03:08,366
是跟我们的满血对象去区分开的

1524
01:03:08,600 --> 01:03:10,866
为什么我们称之为他是直对象

1525
01:03:10,866 --> 01:03:13,866
因为他其实就只有那些对象的直

1526
01:03:14,066 --> 01:03:15,133
还没有其他的

1527
01:03:15,166 --> 01:03:16,899
你去拿这个陪劝对象的

1528
01:03:16,900 --> 01:03:18,166
关联的那些对象

1529
01:03:18,266 --> 01:03:18,999
都拿不到

1530
01:03:19,000 --> 01:03:21,966
因为他没有把倒对象置进去

1531
01:03:22,100 --> 01:03:24,400
所以它只是一个用来传值的对象

1532
01:03:24,400 --> 01:03:25,366
我们称之为值对象

1533
01:03:25,366 --> 01:03:26,133
我们拿这个值对象

1534
01:03:26,133 --> 01:03:27,366
我们把它插到数据库里

1535
01:03:27,533 --> 01:03:28,299
插进去了

1536
01:03:28,300 --> 01:03:29,066
然后大家会发现

1537
01:03:29,066 --> 01:03:31,066
我们做了一件好像是废话的事情

1538
01:03:31,066 --> 01:03:32,366
就是又去数据库里

1539
01:03:32,366 --> 01:03:33,966
把刚才插进去那个对象

1540
01:03:34,200 --> 01:03:35,300
给它泛的出来了

1541
01:03:36,133 --> 01:03:38,333
为什么要做这样的一个find的过程

1542
01:03:38,333 --> 01:03:40,733
原因是因为我们需要一个满血

1543
01:03:40,733 --> 01:03:42,299
的对象我们知道

1544
01:03:42,300 --> 01:03:44,366
find不仅仅会在数据库里把它找出来

1545
01:03:44,366 --> 01:03:46,299
而且会用到的build方法

1546
01:03:46,300 --> 01:03:48,100
把它build成为一个满血的

1547
01:03:48,866 --> 01:03:49,799
这个对象

1548
01:03:49,800 --> 01:03:51,766
与他的所有的道都关联起来了

1549
01:03:51,766 --> 01:03:52,266
这样的话

1550
01:03:52,266 --> 01:03:54,466
我们通过这个满血的圈式对象

1551
01:03:54,566 --> 01:03:56,966
其实可以在刚才那张Bo图上头

1552
01:03:56,966 --> 01:03:58,799
拿到他所有关联的对象

1553
01:03:59,133 --> 01:04:01,566
所以插进去又把它找出来

1554
01:04:01,566 --> 01:04:03,299
但是插进之前是直对象

1555
01:04:03,300 --> 01:04:06,200
找出来之后是满血的Bo对象

1556
01:04:06,400 --> 01:04:08,600
我们要把这个满血的Bo对象

1557
01:04:08,933 --> 01:04:12,666
去交给我们的这个Adapter

1558
01:04:12,900 --> 01:04:14,800
去完成支付的过程

1559
01:04:14,800 --> 01:04:15,333
为什么是

1560
01:04:15,333 --> 01:04:17,933
因为这里头他会调到他所关联的对象

1561
01:04:17,933 --> 01:04:19,466
所以必须给他一个满血对象

1562
01:04:19,466 --> 01:04:20,199
就是我们第五步

1563
01:04:20,200 --> 01:04:22,566
必须要去做这个查询

1564
01:04:22,933 --> 01:04:25,899
得到这个支付渠道完成了以后

1565
01:04:26,066 --> 01:04:27,466
那我们就把它的返回值

1566
01:04:27,466 --> 01:04:29,533
要把它更新到这个对象中间去

1567
01:04:29,566 --> 01:04:30,399
所以大家可以看到

1568
01:04:30,400 --> 01:04:32,533
这一段都是把返回值拿出来

1569
01:04:32,566 --> 01:04:33,733
然后更新过去

1570
01:04:33,866 --> 01:04:36,266
所以整个这个设计过程中间

1571
01:04:36,333 --> 01:04:38,499
我们在考这道题的时候啊

1572
01:04:38,500 --> 01:04:39,866
这道题如果出的话

1573
01:04:41,100 --> 01:04:44,600
通常来说是一道中等难度的分析题

1574
01:04:44,766 --> 01:04:46,366
我们会给你一张设计图

1575
01:04:46,366 --> 01:04:47,566
对这张图给你

1576
01:04:47,900 --> 01:04:48,700
然后问你说

1577
01:04:48,700 --> 01:04:49,166
在这里头

1578
01:04:49,166 --> 01:04:50,899
到底用到了一些什么样的

1579
01:04:50,900 --> 01:04:52,166
面向对象的设计方法

1580
01:04:52,166 --> 01:04:52,733
因为我们考试

1581
01:04:52,733 --> 01:04:54,099
面向对象的分析与设计嘛

1582
01:04:54,366 --> 01:04:55,699
所以我们会问你说

1583
01:04:55,700 --> 01:04:56,733
这里头用到了哪些

1584
01:04:56,733 --> 01:04:58,966
面向对象的设计方法

1585
01:04:59,300 --> 01:05:00,333
其实很简单

1586
01:05:00,400 --> 01:05:02,566
其实就是我们说的Grasp的7种方式

1587
01:05:02,766 --> 01:05:06,066
软件设计原则的七大原则

1588
01:05:06,533 --> 01:05:07,733
就是指这个东西

1589
01:05:08,000 --> 01:05:09,966
那我刚才已经讲了一遍

1590
01:05:10,266 --> 01:05:12,333
现在如果占阳同学出这道题

1591
01:05:12,333 --> 01:05:13,099
给大家做的话

1592
01:05:13,100 --> 01:05:14,766
大家觉得这里从哪里用

1593
01:05:14,766 --> 01:05:15,699
到了面向对象

1594
01:05:17,733 --> 01:05:18,566
哪里用到了

1595
01:05:22,966 --> 01:05:24,399
第三步和第六步

1596
01:05:25,666 --> 01:05:27,599
第三步用了创建者的方式

1597
01:05:28,566 --> 01:05:30,533
那你在答这道题的时候

1598
01:05:30,533 --> 01:05:31,466
你要讲清楚说

1599
01:05:31,466 --> 01:05:33,366
为什么在这儿可以用创建者的方式

1600
01:05:33,366 --> 01:05:34,533
他的理由是什么

1601
01:05:35,066 --> 01:05:35,799
就是你第一

1602
01:05:35,800 --> 01:05:38,066
你要说这里用了创建者的方式

1603
01:05:38,266 --> 01:05:41,099
第二他为什么可以用创建者的方式

1604
01:05:41,500 --> 01:05:43,066
这是这个第一

1605
01:05:43,333 --> 01:05:44,933
第一啊这是第三步

1606
01:05:45,133 --> 01:05:46,266
第六步用了什么呢

1607
01:05:47,900 --> 01:05:48,166
对不

1608
01:05:48,166 --> 01:05:49,933
其实跟我们前面讲的都是一样的

1609
01:05:49,933 --> 01:05:52,899
他用了间接和多肽

1610
01:05:53,400 --> 01:05:55,600
那间接多肽用了以后

1611
01:05:55,600 --> 01:05:59,000
他又满足迪斯科夫可替换原则

1612
01:05:59,000 --> 01:06:01,466
所以最后达成了开闭原则

1613
01:06:01,566 --> 01:06:04,299
同样他也遵循依赖导致原则

1614
01:06:05,000 --> 01:06:06,333
对吧他不符合什么

1615
01:06:06,933 --> 01:06:08,799
不符合接口隔离原则

1616
01:06:09,166 --> 01:06:09,466
对吧

1617
01:06:09,466 --> 01:06:11,466
因为这个接口中间是有很多的方法的

1618
01:06:11,466 --> 01:06:14,299
并不仅仅是为了这个shop channel里头

1619
01:06:14,300 --> 01:06:18,666
去做的所以这道题通常来说

1620
01:06:18,666 --> 01:06:21,133
我们这种中等难度的题会给大家10分

1621
01:06:21,366 --> 01:06:23,733
这道10分的题就是你要指出来说

1622
01:06:23,733 --> 01:06:24,466
在这个设计中间

1623
01:06:24,466 --> 01:06:26,766
到底哪里用了面向对向的的方法

1624
01:06:27,133 --> 01:06:28,999
然后为什么在这里

1625
01:06:29,000 --> 01:06:30,266
用了这个面向对向的方法

1626
01:06:30,466 --> 01:06:31,966
他在哪里用这个面向对向的方法时

1627
01:06:31,966 --> 01:06:34,133
他不满足我们的哪些原则

1628
01:06:34,133 --> 01:06:35,166
特别是七大原则

1629
01:06:35,166 --> 01:06:37,199
后面的5个激进的原则

1630
01:06:37,933 --> 01:06:41,866
就是这个单一接口啊

1631
01:06:41,866 --> 01:06:42,533
接口隔离

1632
01:06:42,533 --> 01:06:44,299
单一的职责迪米特

1633
01:06:45,166 --> 01:06:47,999
然后啊合成和复用

1634
01:06:48,000 --> 01:06:49,666
依赖导致啊

1635
01:06:49,666 --> 01:06:51,899
其实依赖导致虽然说是激进的

1636
01:06:51,900 --> 01:06:52,533
但是我们在这里

1637
01:06:52,533 --> 01:06:54,599
其实在Crede payment那里

1638
01:06:54,733 --> 01:06:56,766
它其实用的是grasp的

1639
01:06:56,900 --> 01:06:58,600
间接和多态的方式

1640
01:06:58,866 --> 01:07:01,566
满足的是迪斯科复刻替换原则

1641
01:07:01,566 --> 01:07:02,466
和依赖打字原则

1642
01:07:02,466 --> 01:07:03,299
因为用了接口啊

1643
01:07:03,300 --> 01:07:04,700
没有直接去使用那些对象

1644
01:07:04,866 --> 01:07:05,899
最终达成了

1645
01:07:05,900 --> 01:07:06,800
他的终极目标

1646
01:07:06,800 --> 01:07:08,133
就是他的开辟原则

1647
01:07:08,300 --> 01:07:10,166
七个原则中间满足了三个

1648
01:07:10,166 --> 01:07:12,499
不满足后面的四个啊

1649
01:07:12,500 --> 01:07:13,366
不满后面4个

1650
01:07:13,366 --> 01:07:14,333
其实最后两个是没关系

1651
01:07:14,333 --> 01:07:15,766
那个对于跟地面推原则没关系

1652
01:07:15,766 --> 01:07:17,866
跟合成复用原则也没有关系

1653
01:07:18,366 --> 01:07:20,099
因为它不是负类和子类

1654
01:07:20,100 --> 01:07:22,966
它是接口和呃类的实现

1655
01:07:23,066 --> 01:07:23,933
所以主要不满足

1656
01:07:23,933 --> 01:07:26,899
就是单一职责原则和接口隔离原则

1657
01:07:27,066 --> 01:07:28,266
特别是接口隔离原则

1658
01:07:28,266 --> 01:07:29,566
它没有隔离那个接口

1659
01:07:29,600 --> 01:07:32,400
而是把所有的接口混写在一起了啊

1660
01:07:32,400 --> 01:07:35,933
所以分析题的考试的难度

1661
01:07:35,933 --> 01:07:37,733
其实就是大家去理解说

1662
01:07:37,733 --> 01:07:40,366
我们Grasp讲过的7种方法

1663
01:07:40,966 --> 01:07:43,466
和这个7个原则是什么

1664
01:07:43,500 --> 01:07:44,700
然后在这个设计中间

1665
01:07:44,700 --> 01:07:47,566
它到底体现了哪些Grasp的设计方法

1666
01:07:47,766 --> 01:07:48,933
和哪些设计原则

1667
01:07:48,933 --> 01:07:49,999
这个应该容易吧

1668
01:07:50,266 --> 01:07:50,999
这个通常来说

1669
01:07:51,000 --> 01:07:53,500
会给大家两个设计分析题

1670
01:07:53,566 --> 01:07:54,866
20分左右

1671
01:07:55,133 --> 01:07:56,999
教大家在这个设计中间指出来

1672
01:07:57,000 --> 01:07:58,966
说它的哪里用了

1673
01:07:58,966 --> 01:07:59,933
勉强推行设计

1674
01:08:00,600 --> 01:08:02,333
那比这个更难的题呢

1675
01:08:02,333 --> 01:08:04,866
就是给你一个不好的设计

1676
01:08:05,300 --> 01:08:08,766
然后你说这个不好设计是在哪

1677
01:08:09,333 --> 01:08:10,199
原因是什么

1678
01:08:10,200 --> 01:08:11,666
同样是用管手的方法

1679
01:08:11,666 --> 01:08:13,366
和面向对象的设的其他原则

1680
01:08:13,366 --> 01:08:14,966
说这个设计不好在哪

1681
01:08:15,200 --> 01:08:17,300
然后你给出一个更好的设计

1682
01:08:17,400 --> 01:08:20,100
通常这种难度更高的题

1683
01:08:20,100 --> 01:08:22,466
会整个就只有一道20分

1684
01:08:22,800 --> 01:08:25,266
所以我们整个卷面分里头

1685
01:08:26,300 --> 01:08:27,800
100分的卷面分里头

1686
01:08:27,966 --> 01:08:28,899
大家应该知道

1687
01:08:28,900 --> 01:08:31,700
我们在11月份开始讲的

1688
01:08:31,700 --> 01:08:33,666
这个部分的内容里头

1689
01:08:33,666 --> 01:08:35,866
至少会要出40分的题

1690
01:08:35,866 --> 01:08:37,266
两道分析题

1691
01:08:37,566 --> 01:08:39,466
一道分析

1692
01:08:39,466 --> 01:08:41,999
然后让你自己去写新设计的题

1693
01:08:42,166 --> 01:08:43,066
所以这两道题

1694
01:08:43,066 --> 01:08:46,466
这三道题就至少会占到 40分或者50分

1695
01:08:46,466 --> 01:08:48,499
有时候那个分析题是给的15分

1696
01:08:48,533 --> 01:08:49,599
那就是会占到50分

1697
01:08:49,600 --> 01:08:50,333
我就我就说

1698
01:08:50,333 --> 01:08:51,499
我们为什么说

1699
01:08:51,500 --> 01:08:53,700
这个卷面分会占到50%以上

1700
01:08:53,700 --> 01:08:54,500
就是这个原因

1701
01:08:54,800 --> 01:08:56,166
就特别是后面的难的题

1702
01:08:56,166 --> 01:08:58,666
都基本上是在这个后面

1703
01:08:58,900 --> 01:09:00,300
那20分的那个题

1704
01:09:00,300 --> 01:09:02,200
不仅仅要把分析做对

1705
01:09:02,600 --> 01:09:04,100
要把设计做对

1706
01:09:04,400 --> 01:09:05,966
还要把图画对啊

1707
01:09:05,966 --> 01:09:07,799
图没画对也是要扣分的

1708
01:09:08,500 --> 01:09:11,066
所以也要去了解

1709
01:09:11,066 --> 01:09:11,733
现在在考

1710
01:09:11,733 --> 01:09:11,899
你

1711
01:09:11,900 --> 01:09:14,766
说你对于这个面向对象的方法的了解

1712
01:09:15,566 --> 01:09:17,066
使用这个方法去解决问题

1713
01:09:17,066 --> 01:09:18,533
以及用图的方式

1714
01:09:18,533 --> 01:09:20,566
把你的解决问题的思路给他画出来

1715
01:09:20,733 --> 01:09:21,666
这三个层次

1716
01:09:21,666 --> 01:09:23,766
上头就是考在那个20分的题上

1717
01:09:23,766 --> 01:09:25,166
通常我们20分题就一道

1718
01:09:25,266 --> 01:09:27,499
因为这道题做起来非常消耗时间

1719
01:09:27,800 --> 01:09:29,466
就是往年我们的同学

1720
01:09:29,466 --> 01:09:31,099
基本上做最后一道题的时候

1721
01:09:31,333 --> 01:09:32,399
整个考试两个小时

1722
01:09:32,400 --> 01:09:34,266
最后一道题你至少要做到40分钟

1723
01:09:34,666 --> 01:09:36,266
因为你连写带画

1724
01:09:36,566 --> 01:09:38,499
大概要30-40分钟才能做完

1725
01:09:38,500 --> 01:09:39,733
所以你们在考试的时候

1726
01:09:39,733 --> 01:09:42,099
时间配比要要注意一下

1727
01:09:42,100 --> 01:09:42,866
就是通常来说

1728
01:09:42,866 --> 01:09:43,599
前面简单的题

1729
01:09:43,600 --> 01:09:46,466
应该在半个小时到40分钟之内做完

1730
01:09:46,466 --> 01:09:48,999
然后花个十几二十分钟做两道分析题

1731
01:09:49,266 --> 01:09:51,766
再花30分钟到40分钟去做最后那道题

1732
01:09:51,766 --> 01:09:53,099
这样才能做的完啊

1733
01:09:53,266 --> 01:09:56,066
有些时候很多同学最后都做不完

1734
01:09:56,100 --> 01:09:59,333
特别是特别是这个画图不熟练的同学

1735
01:09:59,333 --> 01:10:00,533
因为前面也有画图题

1736
01:10:00,533 --> 01:10:01,666
后面也有画图题

1737
01:10:01,700 --> 01:10:03,100
你画图不熟练的话

1738
01:10:03,733 --> 01:10:04,866
这个画的很乱

1739
01:10:04,866 --> 01:10:05,533
自己又不满意

1740
01:10:05,533 --> 01:10:06,466
又怕看不清楚

1741
01:10:06,466 --> 01:10:07,266
撕掉重画

1742
01:10:07,266 --> 01:10:09,166
这就非常非常浪费时间

1743
01:10:09,266 --> 01:10:11,533
要提高一次画图的成功率

1744
01:10:12,566 --> 01:10:14,966
那怎么提高一次画图的成功率

1745
01:10:15,133 --> 01:10:16,999
就是你平时从现在开始

1746
01:10:17,533 --> 01:10:20,599
在做设计的时候也要去画图

1747
01:10:20,800 --> 01:10:22,733
特别是这做讨论课的

1748
01:10:22,766 --> 01:10:23,533
交作业的时候

1749
01:10:23,533 --> 01:10:24,766
我不知道你们做的时候

1750
01:10:24,766 --> 01:10:26,299
是不是都分给同一个同学去做

1751
01:10:26,666 --> 01:10:27,866
每年都有这样情况

1752
01:10:27,866 --> 01:10:28,733
一个小组5个同学

1753
01:10:28,733 --> 01:10:29,666
只有一两个会画图

1754
01:10:29,666 --> 01:10:30,766
剩下3个不会画图

1755
01:10:30,766 --> 01:10:32,066
考试时就抓瞎了

1756
01:10:32,366 --> 01:10:34,466
完全不会画那些这些图啊

1757
01:10:34,666 --> 01:10:37,499
所以要均匀的分给小组里头的

1758
01:10:37,500 --> 01:10:38,133
所有同学

1759
01:10:38,133 --> 01:10:39,933
都要有机会去画图

1760
01:10:39,933 --> 01:10:40,933
因为考试的时候

1761
01:10:40,933 --> 01:10:43,366
我们是一个卷面画图的过程

1762
01:10:43,600 --> 01:10:44,200
这个过程

1763
01:10:44,200 --> 01:10:48,366
不仅仅考你对这些图的熟悉

1764
01:10:48,500 --> 01:10:50,900
会考你怎么用图表述自己

1765
01:10:51,300 --> 01:10:51,900
那更重要的是

1766
01:10:51,900 --> 01:10:52,900
你如果从来没画过

1767
01:10:52,900 --> 01:10:53,900
你是肯定画不出来

1768
01:10:53,966 --> 01:10:55,399
从来没在纸上画过

1769
01:10:55,800 --> 01:10:57,500
你画出来也会很慢

1770
01:10:57,500 --> 01:10:58,300
不是说你画不出来

1771
01:10:58,300 --> 01:10:59,766
你画出来也会很慢啊

1772
01:10:59,933 --> 01:11:03,499
我们这门考试是提前交卷的

1773
01:11:03,500 --> 01:11:04,800
同学都是不及格的

1774
01:11:05,300 --> 01:11:07,000
就是他直接选择了放弃

1775
01:11:07,000 --> 01:11:07,966
他不想画了

1776
01:11:08,066 --> 01:11:09,199
所以就可以提前交卷

1777
01:11:09,500 --> 01:11:10,600
所有及了格的同学

1778
01:11:10,600 --> 01:11:12,100
基本上就没人敢提前交卷

1779
01:11:12,100 --> 01:11:13,166
因为画到最后一刻

1780
01:11:13,166 --> 01:11:14,766
你都会觉得自己画的不满意

1781
01:11:15,200 --> 01:11:16,133
在不停的改啊

1782
01:11:16,133 --> 01:11:17,099
所以这个过程

1783
01:11:17,100 --> 01:11:18,466
在剩下这个月中间

1784
01:11:18,466 --> 01:11:20,366
就要去去慢慢的去练

1785
01:11:20,366 --> 01:11:23,333
一个是面向对象的方法去熟悉

1786
01:11:23,600 --> 01:11:24,366
面向对象的方法

1787
01:11:24,366 --> 01:11:25,799
怎么去设计去熟悉

1788
01:11:25,966 --> 01:11:27,599
怎么去画图去熟悉啊

1789
01:11:27,600 --> 01:11:30,300
这个到0到考试之前去报辅角

1790
01:11:30,300 --> 01:11:33,066
这个是短时间是比较痛苦的

1791
01:11:34,300 --> 01:11:35,300
这是第一个设计

1792
01:11:35,800 --> 01:11:37,300
那我们来看第二个设计

1793
01:11:41,666 --> 01:11:43,799
我们为什么从现在开始就要说考试

1794
01:11:43,800 --> 01:11:45,566
因为到考试之前再说考试

1795
01:11:45,566 --> 01:11:46,533
已经来不及了

1796
01:11:46,966 --> 01:11:48,066
所以从10月份开始

1797
01:11:48,066 --> 01:11:49,499
就要说这个考试的事情

1798
01:11:50,266 --> 01:11:51,899
就避免大家到考试之前

1799
01:11:51,900 --> 01:11:54,600
发现根本就来不及去去搞定这些

1800
01:11:54,600 --> 01:11:56,600
我们在讲之前就说我们会考这些内容

1801
01:11:56,800 --> 01:11:58,266
讲之前就会跟大家说

1802
01:11:58,266 --> 01:11:59,066
考试时你应该这么

1803
01:11:59,066 --> 01:12:01,099
去分析讲之前就跟大家说

1804
01:12:01,100 --> 01:12:01,800
这个画图

1805
01:12:01,800 --> 01:12:05,000
是有一定的需要熟能生巧的过程

1806
01:12:05,000 --> 01:12:06,500
不是你从来没画过

1807
01:12:06,500 --> 01:12:08,400
就能在考试的时候能把它画出来

1808
01:12:08,500 --> 01:12:09,966
一定要经常画

1809
01:12:10,466 --> 01:12:11,966
无论是在作业中间

1810
01:12:11,966 --> 01:12:13,399
还是你们在平时场中间

1811
01:12:13,400 --> 01:12:14,366
都经常去画

1812
01:12:14,466 --> 01:12:16,066
才会画的很熟练啊

1813
01:12:17,533 --> 01:12:19,766
呃get payment的这个方法相对比较简单

1814
01:12:19,866 --> 01:12:22,466
就是为了去查这个支付渠道的

1815
01:12:22,733 --> 01:12:23,733
查这个支付单的

1816
01:12:23,733 --> 01:12:24,566
强行的

1817
01:12:25,400 --> 01:12:26,700
我们看到这张图

1818
01:12:27,866 --> 01:12:30,099
如果把这张图让你去分析的话

1819
01:12:30,200 --> 01:12:31,000
你会觉得

1820
01:12:31,000 --> 01:12:32,533
我就不讲说这张图里头

1821
01:12:32,533 --> 01:12:33,799
哪些动用了面对象

1822
01:12:33,966 --> 01:12:35,533
你会觉得这张图里头

1823
01:12:35,533 --> 01:12:37,266
哪些动用了面对象的方法

1824
01:12:44,300 --> 01:12:45,666
哪些你们觉得

1825
01:12:46,266 --> 01:12:47,566
告诉你大家一个简单的办法

1826
01:12:47,566 --> 01:12:49,366
你就看上面这些对象里头有没有对象

1827
01:12:49,366 --> 01:12:50,166
嘛

1828
01:12:50,766 --> 01:12:52,499
就是上面这一6里头有没有对象

1829
01:12:52,933 --> 01:12:53,933
面向对象的方法

1830
01:12:53,933 --> 01:12:55,133
一定要有对象是吧

1831
01:12:56,066 --> 01:12:58,166
我们说到的这些对象其实都不是对象

1832
01:12:58,166 --> 01:13:01,066
设为store factory Adapter

1833
01:13:01,066 --> 01:13:03,133
其实都不是我们所说的Bo对象

1834
01:13:03,466 --> 01:13:04,999
对吧我们假面向对象

1835
01:13:05,000 --> 01:13:07,933
其实更多的是想把职责分配给Bo对象

1836
01:13:08,800 --> 01:13:10,766
这个设计你就看上面那16

1837
01:13:10,766 --> 01:13:12,699
你就知道他家没有Bo对象

1838
01:13:13,466 --> 01:13:15,466
没有把任何职责分给了Bo对象

1839
01:13:15,533 --> 01:13:17,133
所以说他的结果就是

1840
01:13:17,266 --> 01:13:18,666
所有的职责都在哪了

1841
01:13:19,266 --> 01:13:20,799
都在Serviceton

1842
01:13:21,866 --> 01:13:22,666
都在这里

1843
01:13:23,500 --> 01:13:24,900
所有代码都在这里

1844
01:13:25,133 --> 01:13:26,066
这个就是

1845
01:13:27,700 --> 01:13:30,866
一个主要是用非面向对象的方式

1846
01:13:30,866 --> 01:13:32,099
来实现的方法

1847
01:13:32,366 --> 01:13:34,066
其中你如果说一定用了面向对象

1848
01:13:34,066 --> 01:13:34,799
就跟前面一样

1849
01:13:34,800 --> 01:13:36,133
因为他用到了这个doctor

1850
01:13:37,133 --> 01:13:37,966
这个就是所有地方

1851
01:13:37,966 --> 01:13:38,699
只要用了这个w

1852
01:13:38,700 --> 01:13:41,566
你就知道它用了一个间接抽象

1853
01:13:42,266 --> 01:13:42,966
开闭原则

1854
01:13:42,966 --> 01:13:43,966
Disco可替换原则

1855
01:13:43,966 --> 01:13:45,466
依赖导致原则不满足

1856
01:13:45,766 --> 01:13:46,933
接口隔离原则

1857
01:13:46,933 --> 01:13:48,466
对吧这就是一套下来

1858
01:13:48,466 --> 01:13:49,999
因为这个跟前面那个是一样的

1859
01:13:50,200 --> 01:13:51,866
只是用了它的一个不同的方法

1860
01:13:51,933 --> 01:13:53,766
但是从整体上来说

1861
01:13:53,766 --> 01:13:55,466
它其实是没有任何面向对象的

1862
01:13:55,866 --> 01:13:58,399
所有的逻辑都在这个收费室

1863
01:13:58,733 --> 01:13:59,933
因为这个方法来说

1864
01:13:59,933 --> 01:14:01,333
他其实做了两件事情哈

1865
01:14:01,333 --> 01:14:03,066
就这个API里头

1866
01:14:03,066 --> 01:14:04,199
第一就是我们说的这个

1867
01:14:04,200 --> 01:14:05,700
他要查到一个支付单

1868
01:14:05,966 --> 01:14:07,566
所以我们的第二句就是

1869
01:14:07,566 --> 01:14:08,666
去查一个支付单

1870
01:14:09,066 --> 01:14:10,666
但他不仅仅在查支付单

1871
01:14:10,666 --> 01:14:11,333
他还在干嘛呢

1872
01:14:11,333 --> 01:14:12,133
他还在对账

1873
01:14:12,866 --> 01:14:14,399
所以当我去查一个支付单的时候

1874
01:14:14,400 --> 01:14:15,766
我查出来这个支付单

1875
01:14:16,300 --> 01:14:17,900
从这个图上大家应该能看出来说

1876
01:14:17,900 --> 01:14:18,533
他判断了

1877
01:14:18,533 --> 01:14:21,966
这个查出来的这个支付交易的状态

1878
01:14:21,966 --> 01:14:23,499
是不是6的状态

1879
01:14:24,200 --> 01:14:26,466
如果是6的状态

1880
01:14:26,500 --> 01:14:28,333
那他就会去查支付渠道

1881
01:14:28,566 --> 01:14:30,966
然后从支付渠道里查来的这个值

1882
01:14:31,666 --> 01:14:35,066
去跟他的在我们系统中间记的这个值

1883
01:14:35,066 --> 01:14:35,933
去做对比

1884
01:14:35,933 --> 01:14:38,366
去看他是不是有账目的差异

1885
01:14:38,866 --> 01:14:39,966
就是我们这里所看到的

1886
01:14:39,966 --> 01:14:41,499
这个check的这个差异

1887
01:14:41,800 --> 01:14:43,800
如果说有账目的差异

1888
01:14:43,866 --> 01:14:46,966
那他就会去做对账

1889
01:14:46,966 --> 01:14:48,499
去记录这个过程

1890
01:14:49,166 --> 01:14:50,133
整个的设计

1891
01:14:50,133 --> 01:14:53,166
主体上没有使用面向对象的设计方法

1892
01:14:55,333 --> 01:14:56,366
有问题吗觉得

1893
01:14:59,733 --> 01:15:03,199
这个就是我们说20分的题要考大家的

1894
01:15:03,300 --> 01:15:04,900
就这个设计到底有问题没有

1895
01:15:05,400 --> 01:15:06,666
有问题指出在哪

1896
01:15:07,100 --> 01:15:08,900
然后用面这样的方式去解决它

1897
01:15:12,266 --> 01:15:13,566
那能看出来问题在哪吗

1898
01:15:17,800 --> 01:15:19,666
问题在于他就没有做职责分配

1899
01:15:19,933 --> 01:15:22,466
那现在在社会层里做了这么多东西

1900
01:15:22,900 --> 01:15:24,200
能不能做职责分配

1901
01:15:24,933 --> 01:15:26,933
这就是你要所你要考虑的问题

1902
01:15:28,066 --> 01:15:29,066
能不能做职责分配

1903
01:15:29,066 --> 01:15:30,999
这个职责分配的理由是什么创

1904
01:15:31,000 --> 01:15:32,466
建者还是信息专家

1905
01:15:34,666 --> 01:15:35,999
然后分成是个什么样的

1906
01:15:37,966 --> 01:15:38,766
对吧

1907
01:15:39,166 --> 01:15:40,166
我们现在写的代码

1908
01:15:40,166 --> 01:15:41,366
也没有做组织分配啊

1909
01:15:41,366 --> 01:15:42,399
这不是那个

1910
01:15:42,400 --> 01:15:44,200
不是说我故意做的

1911
01:15:44,200 --> 01:15:46,766
我做的时候我就就这么做下来

1912
01:15:46,766 --> 01:15:47,299
这是去年

1913
01:15:47,300 --> 01:15:48,100
就这么呃

1914
01:15:48,100 --> 01:15:48,566
不是去年

1915
01:15:48,566 --> 01:15:49,966
这是我做的时候就这么做下来了

1916
01:15:49,966 --> 01:15:51,266
但是今天讲的时候

1917
01:15:51,266 --> 01:15:53,466
我就发现这个设计是有问题的

1918
01:15:53,466 --> 01:15:55,299
这个设计应该是可以做成面向对象的

1919
01:15:55,300 --> 01:15:56,133
但是没有做

1920
01:15:56,933 --> 01:15:58,533
所以大家可以去考虑一下

1921
01:15:58,533 --> 01:15:59,933
就拿这个作为例子去考虑下

1922
01:15:59,933 --> 01:16:00,699
那是20分的题

1923
01:16:00,700 --> 01:16:01,733
就是这种样子的

1924
01:16:02,100 --> 01:16:03,866
就是我们现在设计中间啊

1925
01:16:03,866 --> 01:16:05,399
不是说我故意做的

1926
01:16:05,400 --> 01:16:06,300
就是我们现在设计中间

1927
01:16:06,300 --> 01:16:07,266
其实还有很多东西

1928
01:16:07,266 --> 01:16:08,666
是可以把它做成面对下的

1929
01:16:08,700 --> 01:16:09,500
但是没有做

1930
01:16:10,200 --> 01:16:11,300
然后你去想说

1931
01:16:11,300 --> 01:16:13,333
这个东西是怎么可以做生命线对象

1932
01:16:13,800 --> 01:16:15,000
如果大家觉得

1933
01:16:15,000 --> 01:16:16,666
这个东西是可以做生命线对象的

1934
01:16:17,600 --> 01:16:20,200
提一个自由任务上来说

1935
01:16:20,200 --> 01:16:21,166
现有的这个东西

1936
01:16:21,166 --> 01:16:22,533
是可以做成面向对象的

1937
01:16:22,700 --> 01:16:24,100
就把它改成面向对象的

1938
01:16:24,500 --> 01:16:25,466
或者说啊

1939
01:16:25,466 --> 01:16:27,799
或者说负责做这个部分的同学

1940
01:16:27,800 --> 01:16:29,533
因为这个是b做任务中间一部分

1941
01:16:29,800 --> 01:16:31,700
或者说做b做任务的这个同学

1942
01:16:31,700 --> 01:16:33,766
把这个代码改成做面向对象

1943
01:16:34,533 --> 01:16:35,733
怎么面向对象去做设计

1944
01:16:35,733 --> 01:16:36,966
去把这个部分完成

1945
01:16:36,966 --> 01:16:37,799
现在这个设计啊

1946
01:16:37,800 --> 01:16:38,400
我跟大家说了

1947
01:16:38,400 --> 01:16:40,100
这是没有做成面向对象的

1948
01:16:42,166 --> 01:16:43,666
所以我就不讲说

1949
01:16:43,666 --> 01:16:44,899
怎么做成明显对象的啊

1950
01:16:44,900 --> 01:16:46,333
这个由大家自己去做

1951
01:16:46,400 --> 01:16:48,066
做必做任务的同学去把它完成

1952
01:16:48,066 --> 01:16:49,566
然后最后我们再来看一下

1953
01:16:49,933 --> 01:16:51,066
做这个部分的必做任务

1954
01:16:51,066 --> 01:16:53,266
到底做这个部分的必做任务同学

1955
01:16:53,266 --> 01:16:54,699
到底把它改成了一个什么样的

1956
01:16:54,700 --> 01:16:55,366
明显对象的设

1957
01:16:55,366 --> 01:16:57,333
计啊所以大家应该知道

1958
01:16:57,333 --> 01:17:00,399
这20分的这个题其实挺难的

1959
01:17:00,933 --> 01:17:02,733
就是你要知道问题在哪

1960
01:17:03,300 --> 01:17:05,100
然后知道怎么用面向对象的方式

1961
01:17:05,100 --> 01:17:06,466
去解决这个问题

1962
01:17:06,533 --> 01:17:08,266
然后还要用um的图

1963
01:17:08,266 --> 01:17:11,333
把这个你的解决方案给它画出来

1964
01:17:11,600 --> 01:17:12,766
然后画图的时候

1965
01:17:12,766 --> 01:17:14,666
你其实要有选择性的画

1966
01:17:14,666 --> 01:17:16,733
因为你不可能把所有的细节全画出来

1967
01:17:16,900 --> 01:17:17,866
所以你要知道说

1968
01:17:17,866 --> 01:17:19,066
当我要用这张图

1969
01:17:19,066 --> 01:17:20,666
去描述我的设计思想的时候

1970
01:17:20,733 --> 01:17:22,366
我怎么用最清晰

1971
01:17:22,366 --> 01:17:23,666
最简单的方式

1972
01:17:23,666 --> 01:17:25,366
把这个设计思想表现出来

1973
01:17:25,766 --> 01:17:27,399
然后让别人能看懂啊

1974
01:17:27,400 --> 01:17:29,766
所以这个都是这20分的题

1975
01:17:29,766 --> 01:17:31,666
所要去考验大家的过程

1976
01:17:33,400 --> 01:17:34,900
啊所以b做任务中间

1977
01:17:34,900 --> 01:17:36,066
如果大家去改代码的话

1978
01:17:36,066 --> 01:17:37,466
都需要给出设计方案来

1979
01:17:37,466 --> 01:17:37,933
就是说

1980
01:17:37,933 --> 01:17:40,333
你的这个设计方案为什么是这样的啊

1981
01:17:40,400 --> 01:17:41,866
为什么要改成这个样子

1982
01:17:43,600 --> 01:17:45,800
所以做这个b中文的同学应该知道说

1983
01:17:45,800 --> 01:17:46,800
他是可以改的

1984
01:17:46,866 --> 01:17:48,366
目前代码是没有去做成

1985
01:17:48,500 --> 01:17:50,066
并想对这样的设计方式的

1986
01:17:51,466 --> 01:17:54,466
这些代码为什么能做成这个

1987
01:17:54,466 --> 01:17:55,199
其实我们错了

1988
01:17:55,200 --> 01:17:56,666
他最关键的因素就是

1989
01:17:56,666 --> 01:17:58,499
我们把我们的bo对象

1990
01:17:58,500 --> 01:17:59,933
做成了一个满血对象

1991
01:17:59,966 --> 01:18:01,766
跟前面的所有的例子一样

1992
01:18:01,766 --> 01:18:03,333
我们的pay劝这个对象

1993
01:18:03,333 --> 01:18:05,466
也是有大量的这个盗对象

1994
01:18:05,966 --> 01:18:08,666
所以当他制作了大到对象以后啊

1995
01:18:08,666 --> 01:18:10,599
他就可以把它做成一个满血对象

1996
01:18:10,766 --> 01:18:13,133
从而使得我们把一切职责分配给他

1997
01:18:13,133 --> 01:18:13,866
让他去做

1998
01:18:13,866 --> 01:18:14,766
而不像这样子

1999
01:18:14,766 --> 01:18:16,799
把这些职责带到了这个社会室

2000
01:18:17,166 --> 01:18:19,099
我们主要的想法就是

2001
01:18:19,100 --> 01:18:20,800
不要把代码都带到社会上

2002
01:18:20,933 --> 01:18:23,699
而是把它分配给不同的对象去完成

2003
01:18:23,800 --> 01:18:25,333
所以当这张图摆出来的时候

2004
01:18:25,333 --> 01:18:25,899
你会发现这

2005
01:18:25,900 --> 01:18:28,500
张图里头没有把任何的职责分给对象

2006
01:18:28,966 --> 01:18:29,599
你就知道

2007
01:18:29,600 --> 01:18:31,500
这个设计是没有组成面对象的

2008
01:18:32,566 --> 01:18:33,366
那你就要想出

2009
01:18:33,366 --> 01:18:34,399
这里头做的这些东西

2010
01:18:34,400 --> 01:18:36,266
是不是能分给对象呢

2011
01:18:36,566 --> 01:18:37,933
他为什么不分出去呢

2012
01:18:38,300 --> 01:18:39,266
如果能分的话

2013
01:18:39,266 --> 01:18:40,166
他怎么分呢

2014
01:18:40,366 --> 01:18:43,366
对啊就是我们在这个设计中间

2015
01:18:43,366 --> 01:18:44,799
要去解决的问题啊

2016
01:18:46,800 --> 01:18:50,133
最后一个我们讲一下这个创建退款

2017
01:18:50,133 --> 01:18:51,699
这个是最麻烦的一个

2018
01:18:51,700 --> 01:18:54,133
因为大家知道支付在前

2019
01:18:54,133 --> 01:18:55,166
退款在后

2020
01:18:55,500 --> 01:18:56,166
那退款

2021
01:18:56,166 --> 01:18:58,933
其实要把支付的整个过程给反过来做

2022
01:18:58,933 --> 01:19:01,766
因为支付后台有分账啊

2023
01:19:01,766 --> 01:19:03,866
从API设计来说它是很简单的

2024
01:19:03,866 --> 01:19:05,166
它其实就是在说

2025
01:19:05,700 --> 01:19:07,266
我们看那个URL啊

2026
01:19:07,266 --> 01:19:10,066
它上面就是要说要退哪一个支付

2027
01:19:10,066 --> 01:19:11,599
所以他把要退哪个支付

2028
01:19:11,600 --> 01:19:13,166
写在了这个URL上面

2029
01:19:13,866 --> 01:19:15,799
然后在这个支付上要退多少钱

2030
01:19:15,800 --> 01:19:17,266
写在了他的body里头

2031
01:19:17,466 --> 01:19:20,199
然后他还要告诉我说要退多少分账

2032
01:19:20,766 --> 01:19:22,966
因为不仅要退多少钱

2033
01:19:22,966 --> 01:19:25,666
而且分账要退回来多少钱

2034
01:19:25,866 --> 01:19:28,599
他其实也要写在这个上面

2035
01:19:28,600 --> 01:19:29,566
因为不写在这个上面

2036
01:19:29,566 --> 01:19:32,799
他其实不知道说分账要退回多少钱啊

2037
01:19:32,800 --> 01:19:35,133
所以完全靠从前端从

2038
01:19:35,600 --> 01:19:36,366
这是个类目API

2039
01:19:36,366 --> 01:19:37,533
其实不是从用户里传的

2040
01:19:37,533 --> 01:19:39,766
它系统按照某种逻辑算出来

2041
01:19:39,766 --> 01:19:41,999
说我在这个支付上要退多少钱

2042
01:19:42,166 --> 01:19:44,499
其中多少钱是要从平台退给商户的

2043
01:19:44,766 --> 01:19:47,499
这上面这个amount是从商户退给顾客的

2044
01:19:47,666 --> 01:19:50,166
然后来完成这样的一个退款过程

2045
01:19:50,166 --> 01:19:50,566
返回值

2046
01:19:50,566 --> 01:19:53,899
就是一个完整的退款交易的返回值

2047
01:19:55,333 --> 01:19:56,799
我们来看一下这个设计

2048
01:19:56,800 --> 01:19:58,366
这个设计跟之前那个设计相比

2049
01:19:58,366 --> 01:19:59,266
大家应该知道

2050
01:19:59,266 --> 01:20:00,933
从上面这一溜看过来

2051
01:20:00,933 --> 01:20:05,066
有发现了这个Bo对象就知道干

2052
01:20:05,066 --> 01:20:05,899
了件什么事情

2053
01:20:05,900 --> 01:20:08,700
把职责从收费时层分给了Bo对象

2054
01:20:08,700 --> 01:20:10,333
前面那张图是完全没有Bo对象的

2055
01:20:10,333 --> 01:20:11,466
所以没有做分配

2056
01:20:11,800 --> 01:20:12,866
这张图就做了分配

2057
01:20:12,866 --> 01:20:13,333
做了分配以后

2058
01:20:13,333 --> 01:20:13,899
大家可以看到

2059
01:20:13,900 --> 01:20:16,800
收费时的这个线就少多了

2060
01:20:16,900 --> 01:20:17,966
是吧代码就少多了

2061
01:20:17,966 --> 01:20:19,499
因为他把代码移到后面去了

2062
01:20:19,966 --> 01:20:21,199
所以这个逻辑大家可以看到

2063
01:20:21,200 --> 01:20:22,866
我们首先是find by ID

2064
01:20:22,866 --> 01:20:23,333
因为什么呢

2065
01:20:23,333 --> 01:20:25,333
因为是它是对于支付交易的

2066
01:20:25,333 --> 01:20:27,299
退款从control层传过来的

2067
01:20:27,300 --> 01:20:29,200
是支付ID从路径上传过来的

2068
01:20:29,200 --> 01:20:30,800
是吧所以到收费层

2069
01:20:30,800 --> 01:20:32,500
第一件事情就是把ID变成对象

2070
01:20:33,100 --> 01:20:33,666
变成对象

2071
01:20:33,666 --> 01:20:34,199
为什么要变

2072
01:20:34,200 --> 01:20:35,000
他这个对象的

2073
01:20:35,000 --> 01:20:35,500
主要原因是

2074
01:20:35,500 --> 01:20:37,166
因为我没有把职责分配给他

2075
01:20:37,533 --> 01:20:41,166
所以我们认为创建一个退款做退款

2076
01:20:41,366 --> 01:20:43,933
实际上是一个创建者的模式

2077
01:20:43,966 --> 01:20:45,966
为什么因为他会产生一个退款交易

2078
01:20:46,466 --> 01:20:47,066
对吧

2079
01:20:47,066 --> 01:20:49,733
那回到这张图上来看这个退款交易

2080
01:20:50,366 --> 01:20:51,699
你会看到说

2081
01:20:56,100 --> 01:20:56,733
你会看到说

2082
01:20:56,733 --> 01:20:59,066
退款交易和支付交易之间

2083
01:20:59,066 --> 01:21:00,299
是一个组合关系

2084
01:21:00,733 --> 01:21:02,299
所以用创业者的模式

2085
01:21:02,300 --> 01:21:06,333
就把这个职责分配给了pay transaction

2086
01:21:06,533 --> 01:21:08,666
pay Trans这个对象

2087
01:21:08,900 --> 01:21:10,900
这就是做了一次面向对象的设计

2088
01:21:10,900 --> 01:21:12,466
职责分配啊

2089
01:21:12,466 --> 01:21:13,299
不是职责分配啊

2090
01:21:13,300 --> 01:21:16,400
是这个创建者的模式做了职责分配

2091
01:21:16,400 --> 01:21:19,866
把创建一个refund的对象的职责分给了

2092
01:21:21,000 --> 01:21:21,800
or

2093
01:21:33,866 --> 01:21:36,366
把创建一个退款对象的职责

2094
01:21:36,366 --> 01:21:38,966
分给了这个赔券的对象

2095
01:21:39,000 --> 01:21:39,900
所以赔券对象

2096
01:21:39,900 --> 01:21:42,466
首先去创建了一个退款的交易

2097
01:21:42,866 --> 01:21:45,899
创建退款交易的过程其实是很复杂

2098
01:21:45,900 --> 01:21:47,900
但我们没有画一张图去看

2099
01:21:48,166 --> 01:21:49,999
所以大家可以看一下我们的这个代码

2100
01:21:50,000 --> 01:21:51,933
中间的这个构造函数

2101
01:22:10,100 --> 01:22:12,300
我们是在把这个交易

2102
01:22:12,300 --> 01:22:14,400
付给了pay劝的对象啊

2103
01:22:14,400 --> 01:22:15,666
这个我们去找一下

2104
01:22:20,566 --> 01:22:24,366
pay劝对象的refund的方法

2105
01:22:24,933 --> 01:22:26,199
所以在refund的方法中间

2106
01:22:26,200 --> 01:22:28,600
我们可以看到我们其实多做了一步

2107
01:22:28,600 --> 01:22:29,466
这一步是什么呢

2108
01:22:29,466 --> 01:22:32,466
这一步是在图上没画

2109
01:22:33,000 --> 01:22:34,766
就是他首先去改了一下

2110
01:22:34,766 --> 01:22:40,499
page section的refund的一个属性

2111
01:22:40,500 --> 01:22:43,066
去把它设成了refunding的这个状态

2112
01:22:43,066 --> 01:22:44,599
这个状态其实是0和一

2113
01:22:44,733 --> 01:22:46,999
就是标识这个退款

2114
01:22:47,000 --> 01:22:49,466
这个支付交易是不是在退款中

2115
01:22:49,900 --> 01:22:50,933
如果退款完成了以后

2116
01:22:50,933 --> 01:22:52,199
他会把它再改回来

2117
01:22:52,400 --> 01:22:54,866
所以我们在进行退款之前

2118
01:22:55,333 --> 01:22:57,899
对这个记录做了一个修改

2119
01:22:57,900 --> 01:23:00,300
其实就在这198行去safe上

2120
01:23:00,933 --> 01:23:01,733
这是在干嘛

2121
01:23:01,733 --> 01:23:03,166
为什么要做这样的一个事情

2122
01:23:03,466 --> 01:23:05,199
是因为退款的过程中间

2123
01:23:05,200 --> 01:23:08,500
我们是不允许两笔退款同时做

2124
01:23:09,266 --> 01:23:10,266
因为我们现在写的

2125
01:23:10,266 --> 01:23:13,599
不是一个单线程的代码

2126
01:23:14,000 --> 01:23:17,900
实际上是会处理很多的请求发上来的

2127
01:23:18,066 --> 01:23:20,933
所以非常有可能对于同一笔支付交易

2128
01:23:21,333 --> 01:23:23,899
会有两个用户啊

2129
01:23:23,900 --> 01:23:26,566
会有一个用户同时发了两个请求了

2130
01:23:27,333 --> 01:23:28,999
我们并没有杜绝说

2131
01:23:29,000 --> 01:23:29,400
一个用户

2132
01:23:29,400 --> 01:23:31,800
不能同时对一笔支付交易

2133
01:23:31,800 --> 01:23:33,766
做两次退款的申请

2134
01:23:34,066 --> 01:23:36,266
特别是有一些爬虫

2135
01:23:36,266 --> 01:23:38,566
或者黑客类的这种软件

2136
01:23:38,900 --> 01:23:39,900
如果说

2137
01:23:39,900 --> 01:23:43,000
他对同一笔支付做两次退款的话

2138
01:23:43,266 --> 01:23:44,866
就有可能出现什么了

2139
01:23:45,600 --> 01:23:48,966
退的款大于支付的金额

2140
01:23:49,000 --> 01:23:50,666
就是每一笔退款来说

2141
01:23:50,800 --> 01:23:53,000
都是没有超过他的支付金额的

2142
01:23:53,000 --> 01:23:55,066
但是两笔退款同时申请

2143
01:23:55,266 --> 01:23:57,566
两笔退款的加起来的额度

2144
01:23:57,566 --> 01:23:59,199
就会超过他的支付金额

2145
01:23:59,600 --> 01:24:00,800
所以我们在这个设计中间

2146
01:24:00,800 --> 01:24:03,666
我们是要对退款的过程

2147
01:24:03,966 --> 01:24:06,333
要做关键区的保护的

2148
01:24:07,066 --> 01:24:07,466
大家应该知

2149
01:24:07,466 --> 01:24:09,766
道超系统讲的关键区的保护对吧

2150
01:24:10,100 --> 01:24:12,133
超系统的关键区保护是做一个信号量

2151
01:24:12,366 --> 01:24:14,899
让这段代码是不能过去

2152
01:24:15,100 --> 01:24:16,200
但是我们这里的做法来说

2153
01:24:16,200 --> 01:24:17,666
我们不是做了一个信号量

2154
01:24:17,800 --> 01:24:19,333
我们是利用数据库的记录

2155
01:24:19,333 --> 01:24:20,499
来做了一个信号量

2156
01:24:21,166 --> 01:24:21,899
就是信号量

2157
01:24:21,900 --> 01:24:24,066
作用就是你把那段做成关键区

2158
01:24:24,400 --> 01:24:25,600
信号量一为一的话

2159
01:24:25,600 --> 01:24:26,533
就只能一个进程

2160
01:24:26,533 --> 01:24:27,599
一个进程进去

2161
01:24:27,600 --> 01:24:28,700
其他的不能进去啊

2162
01:24:28,700 --> 01:24:30,933
但我们现在通常不是用进程来做

2163
01:24:30,933 --> 01:24:32,333
我不知道你们超系统是用进程来做

2164
01:24:32,333 --> 01:24:33,133
还是进程来做

2165
01:24:34,133 --> 01:24:34,699
用现场做

2166
01:24:34,700 --> 01:24:35,500
进程来做

2167
01:24:37,000 --> 01:24:38,166
用县城来做的是吧

2168
01:24:38,466 --> 01:24:39,699
应该是都用县城来做

2169
01:24:39,700 --> 01:24:40,166
就今天

2170
01:24:40,166 --> 01:24:42,099
今天我们更多的是用县城来做

2171
01:24:42,100 --> 01:24:43,533
所以只有一个县城能进去

2172
01:24:43,533 --> 01:24:44,799
我们这里同样的

2173
01:24:44,800 --> 01:24:45,166
就是

2174
01:24:45,166 --> 01:24:47,999
当对一笔支付交易进行退款的时候

2175
01:24:48,000 --> 01:24:49,733
只能用一个县城进去退款

2176
01:24:50,133 --> 01:24:51,699
这个县城退完了以后

2177
01:24:52,400 --> 01:24:54,266
第二个县城才能进去退款

2178
01:24:54,366 --> 01:24:55,399
但怎么做的呢

2179
01:24:55,733 --> 01:24:58,366
巧妙的利用了数据库的数

2180
01:24:59,366 --> 01:24:59,966
所以我们这里

2181
01:24:59,966 --> 01:25:00,666
为什么要去做

2182
01:25:00,666 --> 01:25:02,333
一个数据库的safe的动作

2183
01:25:02,500 --> 01:25:04,500
就是当这个动作做下去以后

2184
01:25:04,800 --> 01:25:06,766
如果这个事物没有提交

2185
01:25:07,366 --> 01:25:09,766
第二个进来了

2186
01:25:09,766 --> 01:25:12,933
要对同一个数据库的交易

2187
01:25:13,133 --> 01:25:14,699
来做退款的话

2188
01:25:15,066 --> 01:25:17,866
他会被卡在这个safe这个句话里的

2189
01:25:17,866 --> 01:25:19,399
就做safe这句话的时候

2190
01:25:19,400 --> 01:25:21,100
他会被挡在这

2191
01:25:21,333 --> 01:25:23,333
后面的这些话是没办法做的

2192
01:25:24,466 --> 01:25:26,366
后面的这些话是没办法做的

2193
01:25:26,466 --> 01:25:30,166
这个就是我们用数据库的锁的方式啊

2194
01:25:30,166 --> 01:25:31,466
去完成的

2195
01:25:31,533 --> 01:25:34,199
那当然这里头其实还是有一些bug

2196
01:25:34,200 --> 01:25:35,700
因为我们知道

2197
01:25:35,800 --> 01:25:38,100
如果要用这个锁的方式锁进来的话

2198
01:25:38,600 --> 01:25:40,200
他的事物的快照

2199
01:25:40,200 --> 01:25:41,866
是在之前就已经开始了

2200
01:25:41,900 --> 01:25:42,666
所以后面在读

2201
01:25:42,666 --> 01:25:43,133
数据库的时候

2202
01:25:43,133 --> 01:25:44,799
都是读的那个开始的快照

2203
01:25:44,933 --> 01:25:47,166
其实这个代码我们要把他的事故

2204
01:25:47,166 --> 01:25:48,999
数据库的隔离的级别

2205
01:25:49,533 --> 01:25:54,299
从这个read repeatable读改成read committed

2206
01:25:54,466 --> 01:25:56,299
得要把数据库的隔离级别给改掉

2207
01:25:56,300 --> 01:25:58,133
所以如果把数据库的隔离级别

2208
01:25:58,133 --> 01:25:59,466
给它改掉了以后

2209
01:25:59,566 --> 01:26:02,266
那第二个进来的这个事物

2210
01:26:02,266 --> 01:26:03,999
就会被挡死在这儿

2211
01:26:04,000 --> 01:26:05,066
它下不去

2212
01:26:05,200 --> 01:26:07,766
那当第一个退款交易完成了以后

2213
01:26:07,766 --> 01:26:10,599
它才可以去做下面的

2214
01:26:10,600 --> 01:26:11,800
继续来做退款啊

2215
01:26:11,800 --> 01:26:13,100
这个其实涉及到了

2216
01:26:13,133 --> 01:26:15,533
我们在spin的框架上面

2217
01:26:15,533 --> 01:26:17,399
是如何来做互斥的

2218
01:26:17,400 --> 01:26:18,200
其实是

2219
01:26:18,400 --> 01:26:21,866
这里是利用了数据库的这个写操作啊

2220
01:26:21,866 --> 01:26:23,333
来完成这个过程

2221
01:26:23,733 --> 01:26:27,333
所以在这里做了这个动作以后

2222
01:26:27,766 --> 01:26:29,299
使得后面的代码

2223
01:26:29,366 --> 01:26:31,266
一直到事务的结束之前

2224
01:26:31,500 --> 01:26:33,966
都只针对这条记录的退款交易

2225
01:26:33,966 --> 01:26:36,366
就只能有一个人去完成了

2226
01:26:36,733 --> 01:26:37,566
所以大家可以看到

2227
01:26:37,566 --> 01:26:40,933
我构造了一个这个退款对象

2228
01:26:41,100 --> 01:26:43,866
这个不是简单的一个构造函数

2229
01:26:43,900 --> 01:26:44,500
点进去看

2230
01:26:44,500 --> 01:26:47,000
我们给这个构造函数分配了一些职责

2231
01:26:51,666 --> 01:26:52,399
什么职责呢

2232
01:26:52,400 --> 01:26:54,000
就是他要能构造出来

2233
01:26:54,300 --> 01:26:56,766
传进来的参数是我们的支付交易

2234
01:26:56,866 --> 01:26:58,199
我们要退款的金额

2235
01:26:58,200 --> 01:27:00,100
我们要退款的分账金额

2236
01:27:00,100 --> 01:27:01,266
把这三个东西给了

2237
01:27:01,366 --> 01:27:01,999
那进来以后

2238
01:27:02,000 --> 01:27:04,500
我们首先要去判断一下这个退款交易

2239
01:27:04,500 --> 01:27:07,166
这个支付交易是不是能退款哦

2240
01:27:07,166 --> 01:27:08,933
如果说我们在其他的状态下

2241
01:27:08,933 --> 01:27:09,666
是不能退款的

2242
01:27:09,666 --> 01:27:11,699
只有在sex和DIY的这两个状态下

2243
01:27:11,700 --> 01:27:12,700
都是可以退款的

2244
01:27:12,900 --> 01:27:14,866
所以判断它是不是在这两个状态下头

2245
01:27:14,866 --> 01:27:16,066
然后它才能退款

2246
01:27:16,300 --> 01:27:17,733
第二我们要做的判断是

2247
01:27:17,733 --> 01:27:19,699
退款金额必须小于支付金额

2248
01:27:20,000 --> 01:27:22,300
退款的分账金额必须小于支付金额

2249
01:27:22,466 --> 01:27:23,799
所以这里会做了这个判断

2250
01:27:23,800 --> 01:27:24,666
就我们退款金额

2251
01:27:24,666 --> 01:27:26,366
加上他目前的这个支付交易的

2252
01:27:26,366 --> 01:27:27,499
所有的退款金额

2253
01:27:27,766 --> 01:27:30,533
是否说是大于他的这个金额的

2254
01:27:30,933 --> 01:27:31,866
大家知道啊

2255
01:27:31,866 --> 01:27:33,499
比如说这个函数里头

2256
01:27:33,500 --> 01:27:35,566
不是简单的去读读了属性

2257
01:27:35,566 --> 01:27:37,766
因为我们是一个满血的对象

2258
01:27:38,066 --> 01:27:39,533
这里大家再次可以看到

2259
01:27:39,533 --> 01:27:40,933
满血对象的作用

2260
01:27:41,000 --> 01:27:43,533
就是我们去get配transaction

2261
01:27:43,533 --> 01:27:45,133
get refund amount的时候

2262
01:27:45,600 --> 01:27:48,066
大家点进去看一下

2263
01:27:48,066 --> 01:27:49,999
其实他是有读了数据库的

2264
01:27:50,933 --> 01:27:54,299
他是有去调他的get amount的这个方法

2265
01:27:55,533 --> 01:27:57,699
呃是去调他的这个

2266
01:27:57,700 --> 01:27:58,500
get

2267
01:27:58,900 --> 01:28:00,200
一个支付交易的所有的

2268
01:28:00,200 --> 01:28:01,133
目前的退款交易

2269
01:28:01,133 --> 01:28:02,733
这个我怎会去读数据库的

2270
01:28:04,200 --> 01:28:05,200
再点进去看吧

2271
01:28:06,333 --> 01:28:08,366
那这个过程会去调这个倒对象

2272
01:28:08,366 --> 01:28:09,499
去读数据库的

2273
01:28:09,666 --> 01:28:12,066
所以当构造的这个过程中间

2274
01:28:16,966 --> 01:28:19,999
我们用了这个满血模型以后啊

2275
01:28:25,800 --> 01:28:27,666
我们用了这个满血模型以后

2276
01:28:31,133 --> 01:28:32,599
其实在这个构造过程中间

2277
01:28:32,600 --> 01:28:35,400
其实是做很多很复杂的事情所以

2278
01:28:36,933 --> 01:28:38,199
在这个过程中间

2279
01:28:38,266 --> 01:28:40,999
我们会去调他的这些

2280
01:28:42,166 --> 01:28:43,066
不断的做这个

2281
01:28:43,066 --> 01:28:44,866
这其实都是用的面向对象的

2282
01:28:45,166 --> 01:28:47,766
什么呢面向对象的信息专家的原则

2283
01:28:47,766 --> 01:28:50,099
把不同的职责分配给了不同的对象

2284
01:28:50,333 --> 01:28:52,866
然后去完成了这样的一个过程

2285
01:28:52,900 --> 01:28:54,166
做了这个判断以后

2286
01:28:54,166 --> 01:28:56,066
最后才能把这个值设过来

2287
01:28:56,266 --> 01:28:58,066
所以这个构造函数

2288
01:28:58,066 --> 01:29:00,733
之所以能最后把这个对象给他造出来

2289
01:29:00,733 --> 01:29:03,399
肯定是满足我们支付那些条件的

2290
01:29:03,566 --> 01:29:05,166
就是他要退的这个款

2291
01:29:05,700 --> 01:29:07,400
是小于这个支付交易的

2292
01:29:07,400 --> 01:29:09,100
目前的退款的总额的

2293
01:29:09,100 --> 01:29:11,966
就目前退款的总额加上这个要退的款

2294
01:29:12,133 --> 01:29:14,733
是小于他的支付金额的

2295
01:29:14,900 --> 01:29:19,933
他要退的这个分账是这个支付交易

2296
01:29:20,066 --> 01:29:23,399
目前所有的退款额的退款分账

2297
01:29:23,566 --> 01:29:24,499
加出来以后

2298
01:29:24,500 --> 01:29:26,933
是小于他的这个分

2299
01:29:26,933 --> 01:29:28,399
过去的那个分账金额的

2300
01:29:28,533 --> 01:29:29,499
满足两个条件

2301
01:29:29,500 --> 01:29:30,933
才能构造出这个退款交易

2302
01:29:30,933 --> 01:29:32,266
而这一部分的代码

2303
01:29:32,266 --> 01:29:34,099
全部用职责分配的原则

2304
01:29:34,100 --> 01:29:36,366
分到了refined圈三个形中间

2305
01:29:36,366 --> 01:29:39,533
再又分配到了pay圈的这三个形中间

2306
01:29:40,266 --> 01:29:42,966
形成了才去把它插到数据库里

2307
01:29:43,133 --> 01:29:44,333
然后呢同样的

2308
01:29:44,333 --> 01:29:45,666
这是个直对象啊

2309
01:29:45,800 --> 01:29:47,000
这是个直对象

2310
01:29:47,800 --> 01:29:49,933
他返回的并不是一个满血的对象

2311
01:29:50,333 --> 01:29:51,766
所以他只是用这个直对象

2312
01:29:51,766 --> 01:29:52,933
去把它插进去

2313
01:29:52,933 --> 01:29:54,699
然后我们再用他的范的

2314
01:29:54,700 --> 01:29:59,600
去找出他的这个满血的refund下面

2315
01:29:59,933 --> 01:30:01,199
然后找

2316
01:30:01,900 --> 01:30:02,800
然后第二件事情

2317
01:30:02,800 --> 01:30:03,366
就是

2318
01:30:03,366 --> 01:30:05,733
我们现在知道这个退款要退这么多了

2319
01:30:05,733 --> 01:30:07,166
对吧已经把它记进去了

2320
01:30:07,266 --> 01:30:10,066
那在真正把这个款退给顾客之前

2321
01:30:10,066 --> 01:30:10,666
我们要看

2322
01:30:10,666 --> 01:30:12,333
这个支付交易是不是有做分账

2323
01:30:12,866 --> 01:30:14,366
因为如果做了分账

2324
01:30:14,366 --> 01:30:18,499
就需要从平台退给这个商户

2325
01:30:18,666 --> 01:30:20,766
然后才能由商户退给顾客

2326
01:30:21,066 --> 01:30:21,933
所以大家可以看到

2327
01:30:21,933 --> 01:30:24,166
我们去看他是分账状态

2328
01:30:24,500 --> 01:30:26,366
然后去从他的分账状态中间

2329
01:30:26,366 --> 01:30:28,133
得到他所有的分账交易

2330
01:30:28,666 --> 01:30:29,866
然后呢退的过程

2331
01:30:29,866 --> 01:30:30,566
我们把这个职责

2332
01:30:30,566 --> 01:30:33,199
又分给了分账交易去完成

2333
01:30:33,400 --> 01:30:34,800
因为之前你做了判断

2334
01:30:34,800 --> 01:30:36,000
所以走到这个地方

2335
01:30:36,000 --> 01:30:38,266
应该知道所有的这个退款是合法的

2336
01:30:38,766 --> 01:30:40,899
所以我们在分账交易里头

2337
01:30:40,900 --> 01:30:42,400
就没有去重复做判断

2338
01:30:42,400 --> 01:30:44,500
就是直接去产生一个

2339
01:30:44,500 --> 01:30:45,966
分账交易的退款对象

2340
01:30:45,966 --> 01:30:49,933
然后去调他的呃渠道的API

2341
01:30:49,933 --> 01:30:52,199
去完成这个退款交易

2342
01:30:52,300 --> 01:30:54,600
分账的退款交易完成了以后

2343
01:30:54,666 --> 01:30:59,866
然后再去调从商户到平台的退款

2344
01:30:59,866 --> 01:31:01,733
然后把返回值把它写回来

2345
01:31:03,166 --> 01:31:05,366
把返回值把它重新更新到我

2346
01:31:05,366 --> 01:31:07,799
们的这个退款的交易对象上去

2347
01:31:07,900 --> 01:31:10,500
然后最后把它返回回去

2348
01:31:12,066 --> 01:31:13,399
最后把这个对象返回去

2349
01:31:13,566 --> 01:31:17,699
这个就是我们的这样的一个啊

2350
01:31:17,700 --> 01:31:19,800
退款对象的过程

2351
01:31:21,100 --> 01:31:23,266
现在这个返回的好像还是个直对象啊

2352
01:31:23,266 --> 01:31:24,333
这个好像是有问题

2353
01:31:24,333 --> 01:31:25,599
这个不能返回直对象

2354
01:31:25,933 --> 01:31:27,133
得要返回满血对象

2355
01:31:27,133 --> 01:31:31,066
因为前面还要去做查询的

2356
01:31:32,566 --> 01:31:35,866
所以这是我们这张图里头所看到的

2357
01:31:42,900 --> 01:31:44,133
所看到这个设计

2358
01:31:44,200 --> 01:31:45,066
这里头我们可以看到

2359
01:31:45,066 --> 01:31:49,366
我们用到了若干次的面向对象的设计

2360
01:31:49,600 --> 01:31:51,700
第一次这里用了创建者的方式

2361
01:31:52,400 --> 01:31:52,733
然后呢

2362
01:31:52,733 --> 01:31:54,999
这里又把他的职责用信息专家的原则

2363
01:31:55,000 --> 01:31:57,800
分配给了这个呃

2364
01:31:57,800 --> 01:31:58,966
refund圈对象

2365
01:31:58,966 --> 01:32:00,533
其实refund圈对象还有更细的

2366
01:32:00,533 --> 01:32:01,466
他又把职责分给了

2367
01:32:01,466 --> 01:32:03,266
他的Devite的这个对象

2368
01:32:03,500 --> 01:32:05,266
然后完成了以后

2369
01:32:05,266 --> 01:32:05,599
去判断

2370
01:32:05,600 --> 01:32:07,600
说这个支付交易是不是有退款交易

2371
01:32:07,600 --> 01:32:09,600
这里第二次使用了创业者的原则

2372
01:32:10,400 --> 01:32:14,466
把它的退款分账的这个职责分配给了

2373
01:32:15,133 --> 01:32:17,166
啊退款分账的这个职责啊

2374
01:32:17,166 --> 01:32:20,366
把它分配给了divide pay transaction

2375
01:32:21,566 --> 01:32:22,899
然后根据这个结果

2376
01:32:22,900 --> 01:32:24,366
最后把它返还回来

2377
01:32:26,066 --> 01:32:29,299
那这是他把它分给divide page transaction

2378
01:32:29,466 --> 01:32:30,733
的时候他是怎么做的

2379
01:32:30,733 --> 01:32:32,966
其实就是创建了这个对象啊

2380
01:32:32,966 --> 01:32:33,999
因为这里头已经做过判断

2381
01:32:34,000 --> 01:32:35,466
所以没去做重复判断

2382
01:32:35,466 --> 01:32:36,799
然后把它插入数据库里头

2383
01:32:36,800 --> 01:32:42,100
去调他的这个呃接口

2384
01:32:42,100 --> 01:32:45,100
然后去完成这样的一个退款的交易

2385
01:32:46,100 --> 01:32:48,800
这是做了做单次面向对象设计

2386
01:32:48,800 --> 01:32:49,466
以后的结果

2387
01:32:49,466 --> 01:32:50,499
所以大家可以看到

2388
01:32:50,500 --> 01:32:52,966
整个的职责被层层分配

2389
01:32:53,266 --> 01:32:54,733
就相当于层层转包

2390
01:32:54,733 --> 01:32:55,799
分到了不同对象中间

2391
01:32:55,800 --> 01:32:57,500
形成了各自不同的方法

2392
01:32:57,933 --> 01:32:59,733
如果说不做面向对象的设计

2393
01:32:59,733 --> 01:33:01,599
其实他的代码就是我们看到这个样子

2394
01:33:01,600 --> 01:33:02,766
这是去年的这个代码

2395
01:33:03,500 --> 01:33:04,400
当然我们考试时

2396
01:33:04,400 --> 01:33:06,200
不会拿这种题去考大家

2397
01:33:06,466 --> 01:33:07,766
这个太难了

2398
01:33:08,166 --> 01:33:10,533
这个给你40分钟你也画不出来

2399
01:33:10,800 --> 01:33:12,366
你相信给你40分钟

2400
01:33:12,566 --> 01:33:13,899
你要画出这么多图来

2401
01:33:13,900 --> 01:33:15,100
是不大现实的啊

2402
01:33:15,100 --> 01:33:15,966
所以我们考试时

2403
01:33:15,966 --> 01:33:19,133
不会考到如此难的题啊

2404
01:33:19,133 --> 01:33:21,566
但是讲的时候给大家讲一下

2405
01:33:22,200 --> 01:33:23,900
就是因为这工作量太大了

2406
01:33:24,066 --> 01:33:26,299
画图的工作量太大了啊

2407
01:33:26,300 --> 01:33:27,300
我们大概考的话

2408
01:33:27,300 --> 01:33:30,466
大概只会考到大概这个样子的

2409
01:33:30,466 --> 01:33:33,333
这个应该大家在二三十分钟之内

2410
01:33:33,333 --> 01:33:35,133
应该能够画的出来啊

2411
01:33:35,133 --> 01:33:37,199
所以会估量一下大家的这个时间

2412
01:33:37,500 --> 01:33:39,700
去决定说考什么样的题

2413
01:33:40,266 --> 01:33:41,933
但是这个分析的方法

2414
01:33:41,933 --> 01:33:43,066
大家还是应该看一下

2415
01:33:43,066 --> 01:33:45,299
这个最复杂的这个方法

2416
01:33:45,966 --> 01:33:46,799
但是肯定啊

2417
01:33:46,933 --> 01:33:48,166
这个题肯定不敢考

2418
01:33:48,166 --> 01:33:50,099
考了你你们一个小时也做不出来

2419
01:33:50,266 --> 01:33:51,599
一个小时也难以把

2420
01:33:51,600 --> 01:33:53,333
这次不是一张图能解决的

2421
01:33:53,333 --> 01:33:55,366
得要画好多张图才能解决

2422
01:33:55,366 --> 01:33:56,933
所以你们一个小时应该也做不完这

2423
01:33:56,933 --> 01:33:59,066
这个所以考试不会考这么难

2424
01:34:00,366 --> 01:34:02,699
好这就是我们今天要讲的内容

2425
01:34:02,733 --> 01:34:03,699
有什么问题吗

2426
01:34:06,300 --> 01:34:07,100
所以考试的时候

2427
01:34:07,100 --> 01:34:08,766
大家注意下我们讲的最复杂

2428
01:34:08,766 --> 01:34:10,099
最复杂的这些题

2429
01:34:10,966 --> 01:34:11,966
你应该知道

2430
01:34:11,966 --> 01:34:13,366
那是没办法考试时候考的

2431
01:34:13,366 --> 01:34:14,399
因为你时间不够

2432
01:34:14,600 --> 01:34:16,000
但是视频呢

2433
01:34:16,000 --> 01:34:16,866
还是要去看

2434
01:34:16,966 --> 01:34:18,799
因为你还是要去理解

2435
01:34:18,800 --> 01:34:21,100
说这个方法为什么会这么做啊

2436
01:34:21,100 --> 01:34:23,166
考的时候会考相对比较简单点的

2437
01:34:23,166 --> 01:34:25,599
这个分分析设计题啊

2438
01:34:25,600 --> 01:34:28,700
这样保证大家能在30分钟到40分钟之内

2439
01:34:29,066 --> 01:34:30,933
把这个问题分析出来

2440
01:34:30,933 --> 01:34:32,866
把设计给他做出来

2441
01:34:34,566 --> 01:34:35,366
有问题吗

2442
01:34:36,366 --> 01:34:37,266
好那没问题

2443
01:34:37,266 --> 01:34:38,299
我们今天课就到这里

