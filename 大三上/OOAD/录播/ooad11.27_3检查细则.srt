1
00:00:00,266 --> 00:00:02,133
那这个算法的Devite的方法

2
00:00:02,133 --> 00:00:04,599
就跟前面那个差别非常大

3
00:00:05,500 --> 00:00:08,266
它就完全是没有任何的共同点

4
00:00:10,333 --> 00:00:11,533
这是Devite方法

5
00:00:14,400 --> 00:00:17,166
它主要逻辑其实是在这个后面的部分

6
00:00:17,300 --> 00:00:18,200
s a pack

7
00:00:19,566 --> 00:00:23,066
按照费用最优的方式来做

8
00:00:23,133 --> 00:00:23,866
当然大家知道

9
00:00:23,866 --> 00:00:25,199
如果按照费用最优的方式

10
00:00:25,200 --> 00:00:26,666
其实是一个什么呢

11
00:00:26,766 --> 00:00:28,899
是一个NP的问题

12
00:00:28,900 --> 00:00:30,600
就是在有限的时间内

13
00:00:30,600 --> 00:00:32,566
是无法找到最优解的问题

14
00:00:32,766 --> 00:00:33,466
所以大家可以看到

15
00:00:33,466 --> 00:00:35,733
他用的是模拟退火的方法

16
00:00:36,366 --> 00:00:39,166
用的模拟退火的算法来做的分包

17
00:00:39,500 --> 00:00:41,166
大家知道模拟退火退火吗

18
00:00:42,000 --> 00:00:43,166
啊那知道就行啊

19
00:00:43,166 --> 00:00:44,866
我们这里重点不是讲这个算法

20
00:00:44,866 --> 00:00:46,666
就是他用了一种不同的方式

21
00:00:46,666 --> 00:00:49,799
完全重载了那个divide的方法

22
00:00:50,500 --> 00:00:52,566
所以他的这个跟

23
00:00:54,566 --> 00:00:55,366
这个一样

24
00:00:55,500 --> 00:00:57,066
把这个DIY的方法给重载

25
00:00:57,066 --> 00:00:59,399
同样不满足历史口福可替换原则

26
00:00:59,566 --> 00:01:02,133
所以它不能跟这边搭配使用

27
00:01:02,466 --> 00:01:03,499
所以大家可以看到

28
00:01:03,500 --> 00:01:04,466
当你不满足历史

29
00:01:04,466 --> 00:01:05,966
可符可替换原则的时候

30
00:01:06,000 --> 00:01:08,700
你其实改变了负类所定义的行为

31
00:01:08,866 --> 00:01:09,933
在负类中间说

32
00:01:09,933 --> 00:01:12,099
他这个要调正品的算法来做

33
00:01:12,400 --> 00:01:13,400
具体放什么东西

34
00:01:13,400 --> 00:01:15,366
但是这两个算法是没有这么做

35
00:01:15,966 --> 00:01:18,799
就是他既没有调这两个算法

36
00:01:18,800 --> 00:01:21,200
其实既没有调这个指令去得到

37
00:01:21,200 --> 00:01:23,400
调自己的指令去得到他用的什么size

38
00:01:23,466 --> 00:01:25,566
也没有调这个算法去怎么去分

39
00:01:25,566 --> 00:01:25,799
就是

40
00:01:25,800 --> 00:01:28,566
完全是在他自己的这个代码中间

41
00:01:28,566 --> 00:01:29,399
去完成的

42
00:01:29,400 --> 00:01:31,266
所以他不满足历史可复会听完原则

43
00:01:31,700 --> 00:01:33,200
就不能跟这边来组合

44
00:01:33,966 --> 00:01:35,399
那对于他来说

45
00:01:35,566 --> 00:01:37,333
从他的视角来看

46
00:01:37,766 --> 00:01:39,199
这些算法

47
00:01:40,500 --> 00:01:42,266
是满足历史和无可替换原则的吗

48
00:01:44,333 --> 00:01:45,599
从他的视角来看

49
00:01:45,933 --> 00:01:46,866
他的视角来看

50
00:01:46,866 --> 00:01:48,199
他看这个divide strategy

51
00:01:48,200 --> 00:01:49,200
其实他看到的视角都

52
00:01:49,200 --> 00:01:50,333
他有个divide的方法

53
00:01:50,400 --> 00:01:52,466
这个divide方法第一个参数传terminate

54
00:01:52,466 --> 00:01:55,066
第二个参数传所有的对象

55
00:01:55,133 --> 00:01:57,166
结果返回的是打包的结果

56
00:01:57,266 --> 00:02:00,299
所以从这个对象调用的角度来说

57
00:02:00,300 --> 00:02:01,933
他所关心的divided

58
00:02:01,933 --> 00:02:03,533
就是这个方法的定义

59
00:02:03,766 --> 00:02:05,966
而不是他里头怎么实现的

60
00:02:06,266 --> 00:02:08,366
所以无论是这个方法和这边的组合

61
00:02:08,366 --> 00:02:10,533
还是这个类自己的实现

62
00:02:10,766 --> 00:02:13,533
它都满足在debate strategy中间的

63
00:02:13,533 --> 00:02:14,066
所定义的

64
00:02:14,066 --> 00:02:15,066
这个debate方法

65
00:02:15,366 --> 00:02:16,866
就它虽然的逻辑不一样

66
00:02:17,100 --> 00:02:17,600
但是

67
00:02:17,600 --> 00:02:20,300
因为这边它调的只是它的这个方法

68
00:02:20,300 --> 00:02:22,066
而没有管理它的逻辑

69
00:02:22,266 --> 00:02:23,899
所以针对它来说

70
00:02:23,900 --> 00:02:25,733
这两个类

71
00:02:25,933 --> 00:02:28,166
又是满足历史可复可替换原则的

72
00:02:28,500 --> 00:02:30,700
所以你可以用历史可复可替换原则

73
00:02:30,700 --> 00:02:31,866
替换这两个东西

74
00:02:32,966 --> 00:02:35,366
替换这两个东西就能起效果

75
00:02:35,566 --> 00:02:38,999
但是他跟他们是不能替换的啊

76
00:02:39,400 --> 00:02:41,300
他替换他这边就没有效果

77
00:02:41,400 --> 00:02:43,566
所以说他们两个之间是可以相互换

78
00:02:43,866 --> 00:02:45,899
那这两个之间是可以相互换

79
00:02:46,333 --> 00:02:47,999
这两个之间是满足历史可夫替换原则

80
00:02:48,000 --> 00:02:49,400
这两个之间是满足历史可夫的

81
00:02:49,400 --> 00:02:50,200
除外原则

82
00:02:50,333 --> 00:02:52,533
所以对于他来说就是这样的一个效果

83
00:02:52,566 --> 00:02:55,566
所以力士可夫可替换原则

84
00:02:56,466 --> 00:02:58,199
可以是在这种复杂的情况

85
00:02:58,200 --> 00:02:59,800
是可以在一定范围内

86
00:03:00,000 --> 00:03:01,466
在一定的小范围内

87
00:03:01,533 --> 00:03:03,299
让它满足历史可复可替换原则

88
00:03:03,300 --> 00:03:05,266
所以使得我们的某些算法

89
00:03:05,400 --> 00:03:07,666
是可以做相互替换的啊

90
00:03:08,700 --> 00:03:10,066
这个是我们先看的

91
00:03:10,066 --> 00:03:12,166
最下面的这个Devite的这个方法

92
00:03:12,166 --> 00:03:15,566
那我们再依次往上头看过去

93
00:03:17,766 --> 00:03:19,766
我们现在看到的是device strategy

94
00:03:19,766 --> 00:03:21,533
中间的device的方法

95
00:03:22,366 --> 00:03:24,799
下面的两个子类继承了这个方法

96
00:03:24,800 --> 00:03:28,133
两个子类就完全重写了这个方法

97
00:03:28,500 --> 00:03:30,333
那第二用它这个device strict呢

98
00:03:30,333 --> 00:03:31,599
是我们的reading template

99
00:03:31,733 --> 00:03:34,366
所以我们看一下我们的reading template

100
00:03:36,666 --> 00:03:38,533
里头的calculate的方法

101
00:03:40,700 --> 00:03:42,066
我们看下这张图啊

102
00:03:42,066 --> 00:03:43,266
再回来看一下这张图

103
00:03:52,500 --> 00:03:53,933
这是我们的这张图啊

104
00:03:53,933 --> 00:03:55,866
region template的calculate的方法

105
00:03:55,866 --> 00:03:56,899
我们这张图上是说

106
00:03:56,900 --> 00:03:59,933
他首先会去调这个strategy的DIY的方法

107
00:03:59,933 --> 00:04:00,899
这个我们刚才已经讲了

108
00:04:00,900 --> 00:04:02,500
把它分成不同的包

109
00:04:02,666 --> 00:04:04,333
然后去算运费

110
00:04:04,566 --> 00:04:06,699
然后去创建

111
00:04:07,266 --> 00:04:09,466
根据这个结果去创建它的返回值啊

112
00:04:09,466 --> 00:04:10,499
是这样的一个逻辑

113
00:04:10,900 --> 00:04:12,466
但是我们去看代码的时候

114
00:04:12,466 --> 00:04:13,966
你会发现一个问题

115
00:04:14,333 --> 00:04:16,466
就这个代码看起来跟这张图啊

116
00:04:16,533 --> 00:04:18,366
真的相差的非常大

117
00:04:18,566 --> 00:04:20,799
我们图上都画了这么多

118
00:04:21,133 --> 00:04:23,933
但代码里头前半段没有画

119
00:04:23,933 --> 00:04:25,699
这是因为我们是在判断说

120
00:04:25,700 --> 00:04:29,100
这个分包的策略到底是在还是不在

121
00:04:30,200 --> 00:04:31,600
这一段没有画啊

122
00:04:32,366 --> 00:04:33,366
后面的这些个

123
00:04:33,366 --> 00:04:35,899
其实所有的图画的就是这一个部分

124
00:04:35,900 --> 00:04:38,066
而这个部分我们其实就是一行带

125
00:04:39,133 --> 00:04:40,466
那为什么我们的图

126
00:04:40,466 --> 00:04:42,266
和代码有这么大的差别

127
00:04:42,266 --> 00:04:44,199
我们还画了这张图给大家看

128
00:04:44,666 --> 00:04:46,933
原因是这张代码没办法画出图来

129
00:04:47,366 --> 00:04:49,166
为啥呢因为这张代码用的是什么

130
00:04:49,566 --> 00:04:51,899
用的是GR8的stream

131
00:04:51,900 --> 00:04:53,733
也就是我们说的流编程

132
00:04:53,933 --> 00:04:55,566
或者说是函数式编程

133
00:04:56,266 --> 00:04:58,933
这种编程技术是出现在UMA的

134
00:04:58,933 --> 00:05:00,366
UMA的标准之后

135
00:05:00,766 --> 00:05:02,199
就是当UMA标准出来之前

136
00:05:02,200 --> 00:05:04,066
UMA的这些画图的东西出来之前

137
00:05:04,333 --> 00:05:04,766
出来的时候

138
00:05:04,766 --> 00:05:07,266
还没有流边程函数式编程这种说法

139
00:05:07,500 --> 00:05:11,200
所以他就根本就无法描述这个流边程

140
00:05:11,200 --> 00:05:13,766
还是函数式编程的这种方式

141
00:05:14,266 --> 00:05:14,966
那现在的问题在

142
00:05:14,966 --> 00:05:16,199
于说我们今天的编程

143
00:05:16,200 --> 00:05:19,766
已经在方方面面的在使用

144
00:05:20,133 --> 00:05:21,666
流编程和函数式编程

145
00:05:21,766 --> 00:05:22,333
大家可以看到

146
00:05:22,333 --> 00:05:23,733
我们现在给大家看到代码中间

147
00:05:23,733 --> 00:05:26,566
其实但凡碰到是一个list

148
00:05:26,733 --> 00:05:27,933
或者是一个connection的

149
00:05:27,933 --> 00:05:29,399
这样的一个结构的话

150
00:05:29,500 --> 00:05:31,600
我们都会优先选择

151
00:05:31,600 --> 00:05:34,166
用流变成的方式去实现

152
00:05:34,600 --> 00:05:38,666
如果个别代码没有写成流变成的方式

153
00:05:38,733 --> 00:05:40,533
那是因为那些代码太早了

154
00:05:40,533 --> 00:05:41,466
因为我们现在这些代码

155
00:05:41,466 --> 00:05:44,166
其实已经是累积了2年到3年的代码

156
00:05:44,533 --> 00:05:47,533
两三年前可能大家同学们都不是特别

157
00:05:47,766 --> 00:05:48,333
包括我自己

158
00:05:48,333 --> 00:05:49,966
都不是特别熟悉这个刘斌成

159
00:05:49,966 --> 00:05:50,766
韩束刘斌成

160
00:05:50,766 --> 00:05:51,899
但是经过这两年

161
00:05:51,900 --> 00:05:53,900
我们不断的试图把所有大把德海成

162
00:05:53,900 --> 00:05:55,166
刘斌成的写法

163
00:05:55,166 --> 00:05:55,866
我们会发现

164
00:05:55,866 --> 00:05:59,366
这样的写法其实代码的健壮性更好

165
00:05:59,466 --> 00:06:01,933
因为他首先大家可以看到一个感觉是

166
00:06:02,000 --> 00:06:02,800
代码更少

167
00:06:02,900 --> 00:06:04,333
对吧代码更少

168
00:06:04,333 --> 00:06:05,399
大家知道代码更少

169
00:06:05,400 --> 00:06:06,200
错误更少

170
00:06:06,400 --> 00:06:08,500
那当然我们在讲后面韩式的编程中

171
00:06:08,500 --> 00:06:09,933
会讲知道为什么代码更少

172
00:06:10,533 --> 00:06:12,199
那我们在函数式编程中间会继续讨论

173
00:06:12,200 --> 00:06:13,600
它到底省掉了些什么东西

174
00:06:13,800 --> 00:06:16,133
会使得我们的代码变得如此的少

175
00:06:16,333 --> 00:06:18,366
那正是因为它有这样的一个特性啊

176
00:06:18,366 --> 00:06:19,599
所以我们今天可以看到

177
00:06:19,600 --> 00:06:21,733
我们大量使用的函数式编程

178
00:06:21,866 --> 00:06:22,866
或者是流编程

179
00:06:23,266 --> 00:06:24,533
但是类顺序图

180
00:06:24,533 --> 00:06:26,499
持续图画不出来怎么办呢

181
00:06:26,500 --> 00:06:28,866
我们虽然识序图画的就是一个示意啊

182
00:06:28,866 --> 00:06:30,933
不是这个真实的代码实现

183
00:06:31,166 --> 00:06:33,066
就是我想把这个东西画出来

184
00:06:33,066 --> 00:06:33,599
但我只能把

185
00:06:33,600 --> 00:06:36,100
这个意思就是相当于说意会啊

186
00:06:36,100 --> 00:06:39,100
不可能说跟他实现是画成一样

187
00:06:39,466 --> 00:06:39,799
呃

188
00:06:39,800 --> 00:06:42,733
我们希望优美的这个识趣图的部分

189
00:06:42,766 --> 00:06:44,333
在未来去引进看看

190
00:06:44,333 --> 00:06:45,333
怎么用识趣图

191
00:06:45,333 --> 00:06:47,566
去描述我们现在这个留边层的

192
00:06:47,866 --> 00:06:49,599
这样的一种一种方式

193
00:06:49,600 --> 00:06:52,100
但是目前好像还是做不到的啊

194
00:06:52,100 --> 00:06:52,333
所以

195
00:06:52,333 --> 00:06:54,866
就我们只能用这种议会的方式去说

196
00:06:55,133 --> 00:06:55,599
这里头啊

197
00:06:55,600 --> 00:06:57,966
我们看到这个carry the free的这个方法

198
00:06:57,966 --> 00:06:59,399
这就是一个抽象的方法

199
00:06:59,666 --> 00:07:00,266
我们刚才说了

200
00:07:00,266 --> 00:07:02,066
这里用了模板方法的方式

201
00:07:02,266 --> 00:07:04,699
就是因为我们既然是reading time是负类

202
00:07:05,000 --> 00:07:07,100
但是我们怎么算这个前

203
00:07:08,466 --> 00:07:10,899
计重模板和计件模板是不一样的

204
00:07:11,266 --> 00:07:13,399
所以它有两个不同的实现

205
00:07:13,966 --> 00:07:15,533
计件模板的算法是这样的

206
00:07:15,533 --> 00:07:17,766
我们不去讲仅存的一行行代码啊

207
00:07:17,766 --> 00:07:21,599
因为它的根据它那个结构有关而计重

208
00:07:26,600 --> 00:07:28,000
计重的算法是这样的

209
00:07:28,533 --> 00:07:30,099
对吧都还挺复杂啊

210
00:07:30,100 --> 00:07:30,800
这个代码

211
00:07:30,800 --> 00:07:32,933
一看就知道这是写的非常非常早的

212
00:07:32,933 --> 00:07:34,933
没有用牛编程还用复循环的

213
00:07:35,133 --> 00:07:36,533
这就是写的很早的代码啊

214
00:07:36,533 --> 00:07:38,866
这就是基本上是两年以前写的代码

215
00:07:38,900 --> 00:07:40,733
都是这样的呃

216
00:07:42,133 --> 00:07:45,133
所以两种不同的酯类

217
00:07:45,166 --> 00:07:46,899
这个correct Frit是不一样的

218
00:07:46,900 --> 00:07:47,933
那我们在这里

219
00:07:47,933 --> 00:07:48,799
其实在复类中间

220
00:07:48,800 --> 00:07:50,133
相当于是做了一个方法

221
00:07:50,133 --> 00:07:52,066
这就是模板方法做了一个填空题

222
00:07:52,066 --> 00:07:54,133
这个填空题是由指类去填上来的

223
00:07:54,200 --> 00:07:56,366
因为这个负类对象是没办法实际化的

224
00:07:56,533 --> 00:07:58,266
实际化出来必是指类对象

225
00:07:58,300 --> 00:08:00,266
所以这样的correct Frit就是不一样

226
00:08:00,766 --> 00:08:01,499
在我们这个例子呢

227
00:08:01,500 --> 00:08:03,533
我们其实多处用到了模板方法啊

228
00:08:03,533 --> 00:08:04,766
大家应该能看到说

229
00:08:04,766 --> 00:08:08,166
在继续grasp的多态的方法下面

230
00:08:08,166 --> 00:08:09,899
当我们要去重用代码的话

231
00:08:09,900 --> 00:08:13,600
模板方法会是一个优先选择的方式

232
00:08:14,700 --> 00:08:16,266
啊所以他就会把这个结果给他

233
00:08:16,266 --> 00:08:17,699
给他组回去了

234
00:08:17,700 --> 00:08:20,100
这是在呃reading template里头

235
00:08:20,566 --> 00:08:21,899
然后我们看一下service里头

236
00:08:21,900 --> 00:08:22,800
再往回看

237
00:08:24,366 --> 00:08:25,399
service里头

238
00:08:29,266 --> 00:08:30,599
在free service里头啊

239
00:08:30,600 --> 00:08:31,566
只有一个方法

240
00:08:31,600 --> 00:08:32,766
这就是用来算的

241
00:08:32,766 --> 00:08:34,366
我们图是从这个话题的传过来

242
00:08:34,366 --> 00:08:35,799
第一个参数是items

243
00:08:35,900 --> 00:08:38,133
第二个参数是呃

244
00:08:38,133 --> 00:08:40,066
temper ID第三个参数是reading ID

245
00:08:40,466 --> 00:08:41,799
然后呢我们

246
00:08:44,733 --> 00:08:46,866
首先是得到两个对象

247
00:08:47,333 --> 00:08:48,599
其中第一个是简单的

248
00:08:48,600 --> 00:08:49,600
就是从内存

249
00:08:49,933 --> 00:08:52,299
从缓存或者从数据库里拿到这个对象

250
00:08:52,400 --> 00:08:53,366
而第二个方法

251
00:08:53,366 --> 00:08:54,733
其实里头是有一定的逻辑的

252
00:08:54,733 --> 00:08:55,599
我们可以看一下

253
00:08:56,400 --> 00:08:57,366
这个逻辑就是

254
00:08:57,600 --> 00:08:59,333
他不是简单的拿到这个对象

255
00:08:59,333 --> 00:09:01,866
他首先去拿当前这个地址的对象

256
00:09:02,266 --> 00:09:04,399
如果当前这个地址对象没有的话呢

257
00:09:04,400 --> 00:09:07,866
他就去调他的上级对象列表

258
00:09:07,933 --> 00:09:10,666
如果上级对象列表里头有一个有的话

259
00:09:10,666 --> 00:09:12,099
他就会把他break出来

260
00:09:12,100 --> 00:09:14,900
然后就把他返回回去

261
00:09:14,933 --> 00:09:15,966
如果没有的话

262
00:09:15,966 --> 00:09:19,066
就会说这个地方是不存在

263
00:09:19,700 --> 00:09:20,966
如果说他是没有的话啊

264
00:09:20,966 --> 00:09:22,099
就这个地方是不存在

265
00:09:22,100 --> 00:09:24,300
这个呃运费模板

266
00:09:25,200 --> 00:09:28,133
那这就是我们的计算运费模板的

267
00:09:28,133 --> 00:09:29,933
这个前面两个方法

268
00:09:34,100 --> 00:09:36,300
所以当我们拿到两个对象以后

269
00:09:36,300 --> 00:09:39,733
我们就是把它交给了这个region tablet

270
00:09:39,733 --> 00:09:43,999
啊你们好习惯写个this region tablet的

271
00:09:48,533 --> 00:09:49,566
啊这不是这首

272
00:09:49,566 --> 00:09:50,866
这是拿出来的对象

273
00:09:51,900 --> 00:09:55,533
我们就会把region tablet交给他去计算

274
00:09:55,533 --> 00:09:56,933
它算回来以后

275
00:09:56,933 --> 00:09:58,399
它其实就是一个集合

276
00:09:58,400 --> 00:09:59,966
这个集合是一个两层的集合

277
00:09:59,966 --> 00:10:01,766
外层是外

278
00:10:01,766 --> 00:10:03,099
就是两个结合套在一起

279
00:10:03,100 --> 00:10:04,700
外层是包裹

280
00:10:04,800 --> 00:10:06,866
里层是每个包裹里头放什么

281
00:10:07,366 --> 00:10:09,966
所以我们可以看到它的第正义句就是

282
00:10:10,133 --> 00:10:12,566
它要算一下它的总运费是多少

283
00:10:12,700 --> 00:10:16,500
所以说这其实就是用这个时菌的

284
00:10:16,500 --> 00:10:18,666
变量把它加起来啊

285
00:10:18,666 --> 00:10:22,566
算它的总stream的这个东西

286
00:10:22,566 --> 00:10:23,133
把它算出来

287
00:10:23,133 --> 00:10:25,666
它的总运费是多少

288
00:10:25,866 --> 00:10:28,399
这个呢就是在主它返回的值

289
00:10:28,600 --> 00:10:31,566
因为它要把这是我们的product item对象

290
00:10:31,600 --> 00:10:33,066
要转成DTO对象

291
00:10:33,766 --> 00:10:36,733
然后这是在里层的DTO对象啊

292
00:10:36,733 --> 00:10:37,733
这是外层的

293
00:10:39,366 --> 00:10:41,266
所以把v和它的这个里头

294
00:10:41,266 --> 00:10:42,799
这个集合把它组成一个

295
00:10:42,800 --> 00:10:43,866
最后返回回去

296
00:10:43,966 --> 00:10:45,966
那最后在控制器层的代码中间

297
00:10:45,966 --> 00:10:47,699
大家可以看到它就是直接返回

298
00:10:49,500 --> 00:10:50,166
控制性能代码啊

299
00:10:50,166 --> 00:10:51,266
我们前面看到它是

300
00:10:51,266 --> 00:10:54,266
其实前面有做了一个把v o对象

301
00:10:54,266 --> 00:10:56,499
把它变成我们的b o对象的过程

302
00:10:56,733 --> 00:10:59,399
然后呢就直接调我们的设为死的方法

303
00:10:59,400 --> 00:11:01,800
然后返回的值就直接返回了

304
00:11:02,400 --> 00:11:03,600
这就是我们的

305
00:11:04,066 --> 00:11:05,933
关于怎么算运费的这个设计

306
00:11:06,066 --> 00:11:07,266
我最后再问一个问题

307
00:11:07,266 --> 00:11:09,999
在Swiss层的这个代码里头

308
00:11:10,000 --> 00:11:11,500
就这么几几行代码里头

309
00:11:11,900 --> 00:11:13,166
大家觉得有问题吗

310
00:11:17,466 --> 00:11:18,533
是为什么是代码中间

311
00:11:18,666 --> 00:11:19,599
就这么几行代码中间

312
00:11:19,600 --> 00:11:21,066
大家觉得这个设计有问题吗

313
00:11:32,733 --> 00:11:33,799
我之前说了啊

314
00:11:33,800 --> 00:11:35,566
就是我们的每一个模块

315
00:11:35,566 --> 00:11:36,599
随着后面去讲

316
00:11:36,600 --> 00:11:38,566
它的完成度会越来越低的

317
00:11:39,100 --> 00:11:41,200
那其中这个商铺模块的完成度

318
00:11:41,200 --> 00:11:45,300
大概是在 50%-60%之间

319
00:11:45,600 --> 00:11:47,333
即算是已经写好了代码

320
00:11:47,766 --> 00:11:50,266
我也没有完全把它改成正确的方式

321
00:11:50,300 --> 00:11:51,900
这段代码就是有错误的

322
00:11:51,900 --> 00:11:54,766
直接留在同学们去找他错误在哪

323
00:11:55,733 --> 00:11:56,766
你们觉得错误在哪

324
00:12:00,266 --> 00:12:01,366
不是逻辑错误

325
00:12:01,400 --> 00:12:02,400
是设计错误

326
00:12:02,600 --> 00:12:04,333
我们讲的是设计啊

327
00:12:04,966 --> 00:12:06,499
我当我在这上课讲的错误

328
00:12:06,500 --> 00:12:08,533
肯定不是指他的这个需求啊

329
00:12:09,166 --> 00:12:10,066
代码写错了

330
00:12:10,066 --> 00:12:11,066
变异通不过啊

331
00:12:11,066 --> 00:12:12,299
或者计算错了

332
00:12:12,300 --> 00:12:13,600
这我不会在上课去讲

333
00:12:13,900 --> 00:12:14,700
我讲的肯定

334
00:12:14,700 --> 00:12:16,200
是他的设计上有问题

335
00:12:16,200 --> 00:12:17,066
这样写代码

336
00:12:19,666 --> 00:12:20,666
它的问题在于

337
00:12:23,366 --> 00:12:26,066
这一行和这一行

338
00:12:30,566 --> 00:12:31,599
这两行有问题

339
00:12:33,700 --> 00:12:35,700
为什么我们说这两行代码有问题呢

340
00:12:39,166 --> 00:12:39,966
你们觉得

341
00:12:42,266 --> 00:12:45,333
因为这两行代码干的事情是主

342
00:12:45,333 --> 00:12:46,466
返回值

343
00:12:47,400 --> 00:12:50,300
就是我们在API里头

344
00:12:50,300 --> 00:12:51,966
那个返回值应该长什么样

345
00:12:52,900 --> 00:12:55,666
把它把算成算好的值

346
00:12:55,666 --> 00:12:56,966
变成返回值要的样子

347
00:12:56,966 --> 00:12:57,966
给它组起来

348
00:12:58,700 --> 00:13:00,166
这个值值应该在哪里完成

349
00:13:01,766 --> 00:13:03,666
啊这两行代码应该在哪里去写

350
00:13:05,100 --> 00:13:07,166
这两行代码应该在控制器层去写

351
00:13:07,200 --> 00:13:09,600
而不应该在service层去写

352
00:13:10,133 --> 00:13:12,466
我们这里头其实有非常多的代码

353
00:13:12,700 --> 00:13:13,866
不止这一个地方啊

354
00:13:13,866 --> 00:13:15,599
有非常多的地方

355
00:13:15,600 --> 00:13:18,000
其实就是同学们在写的时候

356
00:13:18,000 --> 00:13:21,066
对于就是切之前同学在写的时候

357
00:13:21,066 --> 00:13:22,899
对于他这个控制器层应该写什么

358
00:13:22,900 --> 00:13:23,800
收费层应该写什么

359
00:13:23,800 --> 00:13:24,966
盗层应该写什么

360
00:13:25,266 --> 00:13:26,566
是有问题的

361
00:13:26,566 --> 00:13:28,266
那其中在盗层会犯的问题

362
00:13:28,266 --> 00:13:29,466
我基本把它删光了

363
00:13:29,700 --> 00:13:31,000
所以现在大家可能犯的问题

364
00:13:31,000 --> 00:13:34,400
主要在收费层和控制器层

365
00:13:34,733 --> 00:13:36,533
会犯各种各样的问题

366
00:13:37,766 --> 00:13:39,266
switch层的最大的问题

367
00:13:39,266 --> 00:13:41,266
就是他的代码太臃肿

368
00:13:41,733 --> 00:13:43,933
本应该在Controller层去完成的事情

369
00:13:43,933 --> 00:13:45,333
他把它放到收费层去完成

370
00:13:45,533 --> 00:13:48,766
本应该分配给Bo对象去做的事情

371
00:13:48,766 --> 00:13:50,066
他放到收费层去完成

372
00:13:50,100 --> 00:13:53,666
调查成所有代码全部预集到收费时层

373
00:13:54,066 --> 00:13:54,399
那之前

374
00:13:54,400 --> 00:13:56,733
还有同学会把很多代码运用到稻城去

375
00:13:56,766 --> 00:14:00,199
那我在至少在商铺模块做清洁的时候

376
00:14:00,200 --> 00:14:02,166
你把稻城代码全部清理干净了

377
00:14:02,666 --> 00:14:05,666
然后把稻城的代码应该放到收费城的

378
00:14:05,666 --> 00:14:06,299
放到收费城

379
00:14:06,300 --> 00:14:08,000
应该放到了Bo的放到的Bo

380
00:14:08,466 --> 00:14:10,899
但是对于这些啊

381
00:14:11,066 --> 00:14:11,933
对于这些

382
00:14:11,933 --> 00:14:12,999
还有些很多小问题

383
00:14:13,000 --> 00:14:13,733
我们也去清理

384
00:14:13,733 --> 00:14:16,699
比如说这就是这就是这两行代码

385
00:14:17,100 --> 00:14:19,566
按照我们体系结构的规定来说

386
00:14:19,566 --> 00:14:21,166
它是应该在控制气层

387
00:14:21,333 --> 00:14:23,733
所以它不应该出现在收费层代码

388
00:14:23,900 --> 00:14:26,133
收费层代码就直接应该把返回的结果

389
00:14:26,133 --> 00:14:30,099
返回给返回给控制器层就好

390
00:14:30,133 --> 00:14:33,133
那如果说我们这里会有一个问题

391
00:14:33,333 --> 00:14:35,533
就是我们要返回的值其实是

392
00:14:36,866 --> 00:14:38,266
这个值和这个值

393
00:14:39,566 --> 00:14:41,266
和这两个值是要返回的值

394
00:14:41,266 --> 00:14:42,533
但是我们是加y语言

395
00:14:42,533 --> 00:14:44,799
加y语言没办法一次返回两个字

396
00:14:45,100 --> 00:14:45,533
大家知道

397
00:14:45,533 --> 00:14:46,299
更新的语言

398
00:14:46,300 --> 00:14:47,966
其实是可以一次返回两个字的

399
00:14:48,000 --> 00:14:49,000
比如说go语言

400
00:14:49,000 --> 00:14:50,100
比如说Python语言

401
00:14:50,100 --> 00:14:51,300
比如说rast语言

402
00:14:51,600 --> 00:14:53,133
都是可以一次反复两个字的

403
00:14:53,166 --> 00:14:55,099
但是像加2语言

404
00:14:55,100 --> 00:14:55,933
像c语言

405
00:14:55,933 --> 00:14:58,199
C++语言这些比较古老的语言

406
00:14:58,200 --> 00:14:59,866
其实没办法一次反复两个字的

407
00:15:00,266 --> 00:15:03,099
那我其实可以觉得

408
00:15:03,300 --> 00:15:07,300
连这一行都一起放到控制器层去

409
00:15:07,300 --> 00:15:08,266
都可以接受

410
00:15:08,466 --> 00:15:11,533
因为你可以认为算这个总价的过程

411
00:15:11,533 --> 00:15:13,733
其实这个总价的的内容

412
00:15:13,733 --> 00:15:15,733
已经包含在我的返回之里头了

413
00:15:16,000 --> 00:15:16,400
只是说

414
00:15:16,400 --> 00:15:18,666
因为我在返回这头需要一个总价

415
00:15:18,700 --> 00:15:20,266
所以我从现有返回子里头

416
00:15:20,266 --> 00:15:22,199
就是把这个总价给他算出来

417
00:15:22,366 --> 00:15:24,933
然后放到那个结果上去

418
00:15:24,966 --> 00:15:26,699
我觉得这也可以解释

419
00:15:26,900 --> 00:15:29,266
但是最低限度下头

420
00:15:30,133 --> 00:15:33,333
这两行是不应该出现在设备时层的

421
00:15:33,333 --> 00:15:34,466
应该是在控制基层

422
00:15:34,466 --> 00:15:38,699
这个就是我们在我们在写代码的时候

423
00:15:38,700 --> 00:15:39,966
对于体系结构

424
00:15:41,300 --> 00:15:42,666
这是错误啊所造成的

425
00:15:42,666 --> 00:15:43,366
我待会会讲

426
00:15:43,366 --> 00:15:44,499
说我们期末检查

427
00:15:44,500 --> 00:15:46,533
其实我去看同学们的代码的时候

428
00:15:46,666 --> 00:15:48,133
虽然没有具体的代码

429
00:15:48,200 --> 00:15:49,700
但是我去静态看你的代码时候

430
00:15:49,700 --> 00:15:50,766
如果看到类似于这

431
00:15:50,766 --> 00:15:53,533
种问题都是会扣分的啊

432
00:15:53,533 --> 00:15:54,333
都是会扣分

433
00:15:54,333 --> 00:15:55,866
就说明你对于体系结构

434
00:15:56,000 --> 00:15:58,266
在每一层上头应该去做什么样的事情

435
00:15:58,266 --> 00:15:59,499
不是很清晰啊

436
00:15:59,500 --> 00:16:00,600
会去扣分的啊

437
00:16:01,500 --> 00:16:03,200
所以这就是我们的商铺模块

438
00:16:03,800 --> 00:16:06,866
那商铺模块的部分来说我们在

439
00:16:08,700 --> 00:16:13,800
呃cos中间分出了若干个b座的任务

440
00:16:13,800 --> 00:16:15,100
分错了3个b座任务

441
00:16:15,100 --> 00:16:16,333
我们从今天开始

442
00:16:16,333 --> 00:16:17,199
就从现在开始

443
00:16:17,200 --> 00:16:17,933
我们的b座任务

444
00:16:17,933 --> 00:16:20,299
不再在课程网站上去更新了

445
00:16:20,300 --> 00:16:22,000
因为我们之后所有的开发

446
00:16:22,000 --> 00:16:23,733
都是就是b座任务的

447
00:16:23,766 --> 00:16:24,499
整个的过程

448
00:16:24,500 --> 00:16:26,666
都是基于华为的Codex来完成的

449
00:16:26,800 --> 00:16:28,100
然后软功课的助教

450
00:16:28,100 --> 00:16:30,466
应该会安排一次课

451
00:16:30,800 --> 00:16:32,600
专门讲codarch怎么去用

452
00:16:32,600 --> 00:16:34,333
因为软工那边会要求

453
00:16:34,533 --> 00:16:38,199
你们每一个小组在做自选模块的时候

454
00:16:38,200 --> 00:16:40,200
应该自己去建一个自选模块的

455
00:16:40,200 --> 00:16:42,300
codarch的这个项目

456
00:16:42,300 --> 00:16:43,933
然后自己去管的自选模块

457
00:16:43,933 --> 00:16:45,299
怎么去把它做出来

458
00:16:45,400 --> 00:16:47,166
那我们在b做模块的部分来说

459
00:16:47,166 --> 00:16:49,066
就是整个的b做模块

460
00:16:49,066 --> 00:16:49,766
几十个同学

461
00:16:49,766 --> 00:16:51,099
都是在华为的

462
00:16:51,100 --> 00:16:52,666
code 2尺的软件生产线里头

463
00:16:52,666 --> 00:16:53,566
去做管理的

464
00:16:53,733 --> 00:16:55,066
所以我们所有的b做任务

465
00:16:55,066 --> 00:16:57,099
也就是在code 2尺的生产线里头

466
00:16:57,100 --> 00:16:58,000
给它发出来

467
00:16:58,700 --> 00:17:00,766
在这个靠大尺的生产线里头啊

468
00:17:00,766 --> 00:17:01,566
大家可以看到

469
00:17:01,566 --> 00:17:04,799
我已经发出了最后两个第一批

470
00:17:04,800 --> 00:17:06,066
第二批次的任务

471
00:17:06,333 --> 00:17:10,299
也就是商铺的测试和改进

472
00:17:10,533 --> 00:17:12,199
我们对照这个图上来看啊

473
00:17:12,200 --> 00:17:13,666
这三个任务其实就是

474
00:17:18,300 --> 00:17:19,933
对这个图上看是最清晰的

475
00:17:20,366 --> 00:17:22,166
一个是跟他有关的资产改查

476
00:17:22,200 --> 00:17:23,266
所有的API

477
00:17:23,333 --> 00:17:24,733
没有写的去把它完成

478
00:17:24,733 --> 00:17:26,133
有写的要去测试

479
00:17:26,266 --> 00:17:27,666
看他有没有错啊

480
00:17:28,166 --> 00:17:30,199
一个是关于这一堆的正

481
00:17:30,200 --> 00:17:31,933
常改差这一堆正常改差

482
00:17:31,933 --> 00:17:33,566
大家知道我们其实正常看起来很多

483
00:17:33,566 --> 00:17:35,333
但是我们有从容的代码是吧

484
00:17:35,500 --> 00:17:36,466
所以我们的正常改差

485
00:17:36,466 --> 00:17:37,766
在这之前都是一样的

486
00:17:37,766 --> 00:17:39,499
只是这后面这几个是不一样的

487
00:17:39,666 --> 00:17:41,333
所以跟他有关的正常改差

488
00:17:41,700 --> 00:17:43,100
我们是一个任务

489
00:17:43,400 --> 00:17:45,533
那第三个任务就是我们最后讲的这个

490
00:17:46,100 --> 00:17:48,533
这一大堆律的算运费

491
00:17:48,600 --> 00:17:49,800
是独立的一个任务

492
00:17:49,800 --> 00:17:50,900
因为这个任务最复杂

493
00:17:51,200 --> 00:17:52,666
虽然看APR很少啊

494
00:17:52,666 --> 00:17:53,666
但这个任务最复杂

495
00:17:53,666 --> 00:17:56,299
因为这个任务你要我们做测试的

496
00:17:56,300 --> 00:17:57,166
主要的目的是

497
00:17:57,166 --> 00:17:59,599
第一要认证明这些代码是正确的

498
00:17:59,766 --> 00:18:02,333
第二是你要保证

499
00:18:02,333 --> 00:18:03,799
这里头所的写的代码

500
00:18:03,800 --> 00:18:05,700
大部分都有被测试过

501
00:18:05,700 --> 00:18:08,166
也就是我们说的白盒测试方法

502
00:18:08,200 --> 00:18:10,600
要去看你的代码的覆盖率啊

503
00:18:11,333 --> 00:18:13,766
所以在这里头我们可以看到

504
00:18:13,766 --> 00:18:16,799
这是第二批次任务的最后三个任务

505
00:18:18,133 --> 00:18:21,799
就是我们的007008009

506
00:18:21,933 --> 00:18:23,666
所以第二批次的任务里头

507
00:18:23,666 --> 00:18:26,166
我们只放出了9个任务

508
00:18:26,500 --> 00:18:28,466
第三批次任务我已经开始放出来了

509
00:18:28,500 --> 00:18:29,566
那甚至第四批次任务

510
00:18:29,566 --> 00:18:30,699
我也开始放出来了

511
00:18:30,700 --> 00:18:32,200
我们第三第四批次

512
00:18:32,200 --> 00:18:35,466
都会逐步的把它放出来啊

513
00:18:35,466 --> 00:18:36,733
我最后说一下

514
00:18:38,766 --> 00:18:40,533
我们的这个计分办法

515
00:18:40,533 --> 00:18:43,366
我在这个周末对于计分法有做了一些

516
00:18:43,800 --> 00:18:46,800
就按照今年的情况做了一些改定啊

517
00:18:47,200 --> 00:18:51,000
所以有些东西在就是剩下这一个月

518
00:18:51,000 --> 00:18:51,533
12月份

519
00:18:51,533 --> 00:18:53,933
应该是大家会忙于做课程设计的

520
00:18:53,933 --> 00:18:54,599
这个过程中间

521
00:18:54,600 --> 00:18:56,500
我提前先跟大家说清楚

522
00:18:58,400 --> 00:19:00,600
第一我们的b座模块的部分

523
00:19:00,600 --> 00:19:05,133
是需要呃做b座同学的

524
00:19:05,133 --> 00:19:07,999
用b座的这些同学协作来完成

525
00:19:08,100 --> 00:19:10,333
那往年来说我们通常都是四五十个

526
00:19:10,333 --> 00:19:11,066
甚至六七

527
00:19:11,066 --> 00:19:13,566
十个同学来协作完成这个黄色部分

528
00:19:13,933 --> 00:19:14,966
然后选中部分呢

529
00:19:14,966 --> 00:19:17,666
就是每个小组在二选一啊

530
00:19:17,666 --> 00:19:18,299
选中一个

531
00:19:18,300 --> 00:19:19,100
选中部分

532
00:19:19,733 --> 00:19:21,399
今天的这个检查方式

533
00:19:21,400 --> 00:19:22,300
计分方式啊

534
00:19:22,300 --> 00:19:23,400
大家应该知道

535
00:19:23,766 --> 00:19:25,199
讨论课占了20分

536
00:19:25,333 --> 00:19:27,299
然后克鲁斯记占了50分

537
00:19:27,466 --> 00:19:30,099
然后期末考试占了30分

538
00:19:30,666 --> 00:19:31,199
那期末考试

539
00:19:31,200 --> 00:19:33,566
考的是这个课程设计的内容

540
00:19:33,566 --> 00:19:34,999
这个我事先说好了啊

541
00:19:35,333 --> 00:19:37,266
然后课程这边大家特别注意一下

542
00:19:37,266 --> 00:19:39,733
大家可以看到我们的选做部分

543
00:19:39,733 --> 00:19:41,366
其实主要是这个黄色部分

544
00:19:41,366 --> 00:19:41,733
详细设计

545
00:19:41,733 --> 00:19:43,666
是指选做部分的详细设计啊

546
00:19:43,666 --> 00:19:45,333
不是说b做部分的详细设计

547
00:19:45,666 --> 00:19:47,933
选做部分的详细设计占了20分

548
00:19:49,266 --> 00:19:50,599
加上你如果是早早了的话

549
00:19:50,600 --> 00:19:51,366
就是提前

550
00:19:51,366 --> 00:19:52,466
正常提前一周

551
00:19:52,466 --> 00:19:54,933
我们正常是12月31号完成检查

552
00:19:55,066 --> 00:19:56,933
那你如果比正常的提前一周

553
00:19:56,933 --> 00:19:57,699
完成检查的话

554
00:19:57,700 --> 00:19:59,266
可以给你奖励5分

555
00:20:00,166 --> 00:20:02,399
那就是最多是25分

556
00:20:02,533 --> 00:20:04,099
这是选座部分的

557
00:20:04,800 --> 00:20:06,400
b座部分全是算到个人的

558
00:20:06,400 --> 00:20:09,100
上面b座部分有20分

559
00:20:09,166 --> 00:20:11,333
所以这两个部分加起来是45分

560
00:20:11,500 --> 00:20:13,766
当然还有一些奖励分啊

561
00:20:13,766 --> 00:20:15,266
还有一些个人的奖励分

562
00:20:15,500 --> 00:20:16,733
在这里加起来

563
00:20:17,200 --> 00:20:20,666
呃我们这个不用看

564
00:20:20,666 --> 00:20:22,299
这个总分加起来是多少分就多少分

565
00:20:22,300 --> 00:20:23,333
因为我们最后的总分

566
00:20:23,333 --> 00:20:26,599
是按照这个相对排位来算

567
00:20:26,933 --> 00:20:29,466
就是看最后每位同学

568
00:20:29,466 --> 00:20:30,533
不是每个小组啊

569
00:20:30,533 --> 00:20:31,533
每位同学

570
00:20:31,766 --> 00:20:32,199
每位同学

571
00:20:32,200 --> 00:20:33,700
就是你的小组的分数

572
00:20:33,866 --> 00:20:36,099
加上你的这个个人分

573
00:20:36,200 --> 00:20:37,866
最后组得到的总分数

574
00:20:38,000 --> 00:20:39,200
然后来排位

575
00:20:39,266 --> 00:20:41,066
来算出你是多少分

576
00:20:41,166 --> 00:20:42,499
这里特别注意

577
00:20:43,066 --> 00:20:44,933
如果说你虽然有个人分

578
00:20:44,933 --> 00:20:48,299
但是你整小组最后没有提交检查

579
00:20:48,500 --> 00:20:49,500
没有交代码

580
00:20:49,500 --> 00:20:50,600
没有交报告

581
00:20:50,600 --> 00:20:51,766
没有做口试

582
00:20:52,266 --> 00:20:54,333
都没干那这就是0分

583
00:20:54,333 --> 00:20:55,766
我不管你个人分是多少

584
00:20:56,333 --> 00:20:59,999
所以这个是要特别注意的

585
00:21:00,000 --> 00:21:01,166
虽然你个人做的再好

586
00:21:01,166 --> 00:21:01,966
但你整小组

587
00:21:01,966 --> 00:21:04,533
不交选做部分的任何报告的话

588
00:21:04,566 --> 00:21:05,499
你就是0分

589
00:21:06,066 --> 00:21:07,166
这个是0分意味着什么

590
00:21:07,166 --> 00:21:08,666
因为这门课你就会挂掉

591
00:21:09,333 --> 00:21:10,933
如果说你还选了加完一的课

592
00:21:10,933 --> 00:21:12,299
因为两门课都会挂掉

593
00:21:13,133 --> 00:21:14,499
这个一定要注意啊

594
00:21:14,500 --> 00:21:16,800
所以你不管再怎么样

595
00:21:17,300 --> 00:21:19,666
你也应该交一个报告上来

596
00:21:19,666 --> 00:21:20,999
然后来做口试

597
00:21:21,666 --> 00:21:22,733
只要你教了

598
00:21:23,333 --> 00:21:25,099
只要你做口试

599
00:21:25,700 --> 00:21:28,766
你就至少有25分

600
00:21:28,766 --> 00:21:31,899
就算你个人分一分都没有你垫底

601
00:21:32,766 --> 00:21:33,866
你也有25分

602
00:21:34,266 --> 00:21:35,666
所以如果你的作业

603
00:21:35,766 --> 00:21:37,799
或者说你的考试能够超常发挥一下

604
00:21:37,800 --> 00:21:39,866
你还是有可能能够及格的

605
00:21:39,933 --> 00:21:41,966
但是如果说你完全不教

606
00:21:42,000 --> 00:21:44,966
就是每年都会有个别小组完全躺平

607
00:21:44,966 --> 00:21:45,766
他就不教了

608
00:21:46,533 --> 00:21:48,466
不教了那这个后果就很严重

609
00:21:48,466 --> 00:21:50,866
因为全组5个人或者4个人

610
00:21:51,333 --> 00:21:52,733
就肯定挂了啊

611
00:21:52,733 --> 00:21:53,599
就肯定挂了

612
00:21:53,700 --> 00:21:55,600
所以克服任何困难

613
00:21:55,600 --> 00:21:56,666
只要你做的再难

614
00:21:56,666 --> 00:21:58,099
你也应该勇于面对

615
00:21:58,166 --> 00:22:00,566
来教一下这个课程设计啊

616
00:22:00,933 --> 00:22:02,166
那如果有交了的同学

617
00:22:02,166 --> 00:22:04,933
我们排位是以交了同学去排位的

618
00:22:05,200 --> 00:22:06,766
没交的同学不参加排位啊

619
00:22:06,766 --> 00:22:07,533
所以你交了以后

620
00:22:07,533 --> 00:22:08,366
不单你有25分

621
00:22:08,366 --> 00:22:10,666
还会让所有的同学的分数都往上提

622
00:22:10,766 --> 00:22:12,333
对吧大家都很开心

623
00:22:12,800 --> 00:22:14,300
但是如果你不教的话吗

624
00:22:14,300 --> 00:22:15,900
你不但你没有分

625
00:22:15,900 --> 00:22:18,266
而且所有同学都会往后头排啊

626
00:22:18,266 --> 00:22:20,499
所以无论如何都要教啊

627
00:22:20,800 --> 00:22:22,200
这个我先说了

628
00:22:22,733 --> 00:22:26,499
那如果想这是小组的部分

629
00:22:26,533 --> 00:22:29,699
如果说想在个人部分拿到更高的分数

630
00:22:29,700 --> 00:22:31,766
我们有20分是在b座部分

631
00:22:32,133 --> 00:22:32,933
b座部分我们说了

632
00:22:32,933 --> 00:22:34,333
分成四个批次的任务

633
00:22:34,333 --> 00:22:35,499
第一个批次已经完成了

634
00:22:35,500 --> 00:22:37,066
就是需求分析的部分

635
00:22:37,200 --> 00:22:37,566
那第

636
00:22:37,566 --> 00:22:39,333
二个批次的任务已经全部放出来了

637
00:22:39,333 --> 00:22:40,999
只有9个啊

638
00:22:41,000 --> 00:22:43,800
第二批次到第四批次全部都是写代码

639
00:22:43,800 --> 00:22:44,066
所以

640
00:22:44,066 --> 00:22:47,999
我们都会在华为code art里头去放出来

641
00:22:48,200 --> 00:22:48,933
大家会知道

642
00:22:48,933 --> 00:22:50,999
说其实后面的几个批次的任务里头

643
00:22:51,000 --> 00:22:54,266
其实是不能满足每个同学要做任务的

644
00:22:54,266 --> 00:22:55,799
这个要拿分数的这个心情的

645
00:22:55,800 --> 00:22:57,966
是吧所以我们还有自由批次

646
00:22:58,566 --> 00:23:00,266
自由批次呢就是不限制了

647
00:23:00,600 --> 00:23:01,900
我们在第一批次

648
00:23:01,900 --> 00:23:03,066
第二批次到第四批次

649
00:23:03,066 --> 00:23:04,899
其实都限制每个同学在一个批次

650
00:23:04,900 --> 00:23:05,933
同学只能做一个任务

651
00:23:05,933 --> 00:23:06,966
不能做两个

652
00:23:07,100 --> 00:23:07,933
但是自由批次

653
00:23:07,933 --> 00:23:09,733
是不限制同学们做多少个的

654
00:23:09,900 --> 00:23:11,733
你可以做到上限

655
00:23:11,733 --> 00:23:12,733
上限就是

656
00:23:12,866 --> 00:23:15,899
每位同学最多只能做4个任务

657
00:23:16,200 --> 00:23:17,966
不能做到4个以上啊

658
00:23:19,933 --> 00:23:22,599
呃这是这个批次那

659
00:23:25,066 --> 00:23:28,999
做设计的我要要怎么样才能完成啊

660
00:23:29,000 --> 00:23:30,466
这个我们这里有写的很清楚

661
00:23:30,466 --> 00:23:31,366
我们就不一一讲

662
00:23:31,366 --> 00:23:32,566
我特别讲一下

663
00:23:32,766 --> 00:23:34,366
我们还有一个自由PS

664
00:23:34,366 --> 00:23:35,699
里面的测试类的东西

665
00:23:35,900 --> 00:23:38,266
因为我们的这个b座模块

666
00:23:38,266 --> 00:23:40,699
不但要做单元测试

667
00:23:40,700 --> 00:23:41,866
就是白核测试

668
00:23:42,066 --> 00:23:43,966
还要做集成测试

669
00:23:44,666 --> 00:23:46,133
极限测试是黑核测试

670
00:23:46,133 --> 00:23:48,533
软功能电已经讲了如何做黑核测试

671
00:23:48,533 --> 00:23:49,333
是吧

672
00:23:50,100 --> 00:23:53,400
黑核测试主要的方式就是用极限

673
00:23:54,066 --> 00:23:56,799
用等加类这两种方式去设计

674
00:23:56,800 --> 00:23:57,733
你的测试用力

675
00:23:57,766 --> 00:23:59,799
我们的测试不是软工那样的

676
00:23:59,800 --> 00:24:01,266
写手工测试用力

677
00:24:01,266 --> 00:24:04,966
我们的方式是用代码写测试用力

678
00:24:05,200 --> 00:24:07,966
所以你用极限值的方式

679
00:24:07,966 --> 00:24:10,399
或者用啊等价类的方式

680
00:24:10,400 --> 00:24:10,766
决定你

681
00:24:10,766 --> 00:24:11,999
要应该用一个什么样的数

682
00:24:12,000 --> 00:24:13,066
来做测试的话

683
00:24:13,066 --> 00:24:14,599
用一个什么数据来做测试的话

684
00:24:14,966 --> 00:24:18,566
那就去把这个测试的用力写成代码

685
00:24:18,700 --> 00:24:20,200
然后把它提交上来

686
00:24:20,200 --> 00:24:21,533
我们的集成测试代码

687
00:24:21,533 --> 00:24:22,899
会是单独的一个工程

688
00:24:22,900 --> 00:24:24,133
我们往年是有的

689
00:24:24,166 --> 00:24:25,133
那我今年还没放上来

690
00:24:25,133 --> 00:24:27,599
我之后会把我们的地区模块

691
00:24:27,666 --> 00:24:29,099
那块是完整做完了的

692
00:24:29,100 --> 00:24:30,966
把那一块部分的集成测试代码

693
00:24:30,966 --> 00:24:31,899
给它放出来

694
00:24:32,000 --> 00:24:32,900
然后我们的平台

695
00:24:32,900 --> 00:24:34,966
其实是有会用华为的code 20

696
00:24:34,966 --> 00:24:38,166
去做这个自动的测试的

697
00:24:38,300 --> 00:24:40,133
无论是单侧还是极侧

698
00:24:40,133 --> 00:24:41,566
都会去做自动测试

699
00:24:41,966 --> 00:24:43,133
自动测试中间会发现

700
00:24:43,133 --> 00:24:44,699
你们的代码是有问题的啊

701
00:24:44,700 --> 00:24:46,000
就提供的代码是有问题的

702
00:24:46,000 --> 00:24:46,866
那我们要求说

703
00:24:46,866 --> 00:24:49,933
这个测试的bug应该在5天之内解决

704
00:24:50,200 --> 00:24:51,300
如果5天之内

705
00:24:51,500 --> 00:24:53,166
就是如果测试出现了bug

706
00:24:53,166 --> 00:24:54,699
5天之内不解决的话

707
00:24:54,700 --> 00:24:56,700
就会扣这位同学0.5分

708
00:24:56,866 --> 00:24:58,899
直到扣完必做的任务

709
00:24:59,266 --> 00:25:00,999
所以当你承担病毒任务之后

710
00:25:01,000 --> 00:25:01,966
会给你5分

711
00:25:01,966 --> 00:25:04,066
但是这个5分不是你拿到最后的

712
00:25:04,266 --> 00:25:05,299
这些东西要看说

713
00:25:05,300 --> 00:25:06,533
你要保证说

714
00:25:06,533 --> 00:25:09,866
这个东西不断的经过测试是OK的

715
00:25:09,900 --> 00:25:11,933
你自己写的测试肯定是要能过的

716
00:25:12,200 --> 00:25:15,500
然后集成的测试是要能过的

717
00:25:16,300 --> 00:25:17,066
集成式怎么来

718
00:25:17,066 --> 00:25:19,899
集成测试我们是发动所有同学自己写

719
00:25:20,800 --> 00:25:22,366
所以我们这里集成测试用力

720
00:25:22,366 --> 00:25:23,266
是由同学们来做的

721
00:25:23,266 --> 00:25:25,299
它属于自由批次的必做任务

722
00:25:25,333 --> 00:25:27,699
注意自由批次的必做任务

723
00:25:27,866 --> 00:25:29,766
自由批次是不做上限

724
00:25:29,866 --> 00:25:32,266
不做那个数目限定的

725
00:25:32,600 --> 00:25:34,066
我们认为每10个测试用力

726
00:25:34,066 --> 00:25:35,399
作为一个必做任务

727
00:25:35,600 --> 00:25:37,266
所以你写40个测试用力

728
00:25:37,733 --> 00:25:41,366
就把这个必做分拿满了

729
00:25:43,000 --> 00:25:45,066
但是40个测试用力必须要符合要求

730
00:25:45,066 --> 00:25:47,166
我要审过的就是你的

731
00:25:47,300 --> 00:25:49,733
无论是用等价类还是用极限的

732
00:25:49,733 --> 00:25:51,266
方法是已有的

733
00:25:51,266 --> 00:25:52,999
是没有这样的一个测试的

734
00:25:53,166 --> 00:25:53,933
就极限类

735
00:25:53,933 --> 00:25:54,666
你认为现有

736
00:25:54,666 --> 00:25:55,166
现有的这个

737
00:25:55,166 --> 00:25:56,733
东西有一个等价类没有划到

738
00:25:56,733 --> 00:25:58,933
所以你需要做一个新的测试数据

739
00:25:58,933 --> 00:26:01,099
测的这个等价类里头的这个情况

740
00:26:01,566 --> 00:26:04,299
还是说你认为有一个极限值没有测到

741
00:26:04,300 --> 00:26:06,166
你要去做一个极限值的测试

742
00:26:06,366 --> 00:26:07,133
做一个测试用力

743
00:26:07,133 --> 00:26:08,266
其实挺简单的

744
00:26:08,266 --> 00:26:09,133
比去做

745
00:26:09,600 --> 00:26:11,666
比去做一个必做任务要简单很多

746
00:26:12,000 --> 00:26:14,200
所以说我们把这个数目乘那个10

747
00:26:14,600 --> 00:26:16,166
做10个测试用力啊

748
00:26:16,800 --> 00:26:19,000
10个测试用力等于一个必做任务

749
00:26:19,900 --> 00:26:23,666
所以我们这个就不不取零取整了

750
00:26:23,966 --> 00:26:26,399
不不搞个什么啊

751
00:26:26,400 --> 00:26:27,666
我们还是给大家优惠点嘛

752
00:26:27,666 --> 00:26:28,866
给那取零取整吧

753
00:26:28,866 --> 00:26:30,966
就是10个算一个

754
00:26:30,966 --> 00:26:32,599
如果你做了5个的话

755
00:26:32,600 --> 00:26:33,733
给你算0.5个

756
00:26:34,000 --> 00:26:34,266
行吧

757
00:26:34,266 --> 00:26:36,933
反正测试用力的本身如果有bug的话

758
00:26:36,933 --> 00:26:37,866
也是需要改的

759
00:26:37,866 --> 00:26:39,266
那如果测试用力不改的话

760
00:26:39,266 --> 00:26:41,966
那就把这个测试用力0.1分给它扣掉啊

761
00:26:41,966 --> 00:26:44,099
按照这个逻辑来做

762
00:26:45,200 --> 00:26:46,000
检查细节

763
00:26:46,400 --> 00:26:47,666
我们在期末检查的时候

764
00:26:47,666 --> 00:26:49,099
其实主要检查的是什么呢

765
00:26:49,100 --> 00:26:50,166
就是选做部分

766
00:26:50,466 --> 00:26:52,199
选做部分大家要在网站上提交的

767
00:26:52,200 --> 00:26:53,500
就是详细设计代码

768
00:26:53,500 --> 00:26:54,933
和加Coco的测试报告

769
00:26:54,933 --> 00:26:55,533
这3个东西

770
00:26:55,533 --> 00:26:57,699
提交提交好了以后

771
00:26:57,700 --> 00:26:59,333
通过钉钉去预约口试

772
00:26:59,333 --> 00:27:01,966
我想大家应该在之前有有做过口试吗

773
00:27:03,000 --> 00:27:03,866
口试是什么呢

774
00:27:03,866 --> 00:27:04,399
口试就是

775
00:27:04,400 --> 00:27:07,100
我先去会看你提交的详细设计代码

776
00:27:07,100 --> 00:27:08,200
和测试报告

777
00:27:08,366 --> 00:27:10,799
然后我会问你们小组一系列的问题

778
00:27:11,666 --> 00:27:12,399
这一系列问题

779
00:27:12,400 --> 00:27:14,866
你们小组可以任选一个同学回答

780
00:27:14,866 --> 00:27:16,466
但是我要求是

781
00:27:16,466 --> 00:27:18,866
所有同学在整个考试工作页

782
00:27:19,100 --> 00:27:20,900
至少回答一个问题

783
00:27:21,333 --> 00:27:22,866
所以前面我问的问题

784
00:27:22,866 --> 00:27:24,699
你们可以自由选择有哪个同学回答

785
00:27:25,000 --> 00:27:25,966
最后全部答完了以后

786
00:27:25,966 --> 00:27:27,966
我发现有个同有个同学从头到尾没

787
00:27:27,966 --> 00:27:28,766
有张嘴

788
00:27:28,766 --> 00:27:31,066
那我就会要问这位同学到底做了什么

789
00:27:31,500 --> 00:27:33,300
然后他跟我说他做了什么以后

790
00:27:33,300 --> 00:27:37,366
我去看他这一部分的设计和代码

791
00:27:37,566 --> 00:27:38,733
然后针对这一部分

792
00:27:38,733 --> 00:27:40,766
去单独问这个同学问题

793
00:27:41,600 --> 00:27:42,700
知道这是为什么吗

794
00:27:43,533 --> 00:27:44,666
这就是告诉大家说

795
00:27:44,666 --> 00:27:48,333
每一位同学多多少少都要去做代码

796
00:27:49,333 --> 00:27:52,066
不能说因为我没选加瓦一一

797
00:27:52,066 --> 00:27:53,266
我就不做设计

798
00:27:53,266 --> 00:27:54,399
也不做代码

799
00:27:55,000 --> 00:27:57,166
都必须要做代码集算式

800
00:27:57,166 --> 00:28:00,399
你不会懂里头的很深的代码

801
00:28:00,733 --> 00:28:03,733
至少你可以做单元测试的代码

802
00:28:04,366 --> 00:28:06,066
至少可以做单元测试的代码

803
00:28:06,466 --> 00:28:07,533
这是最低限度啊

804
00:28:07,966 --> 00:28:09,466
至少可以做单元数的代码

805
00:28:09,600 --> 00:28:11,733
所以我都会要问到每一位同学

806
00:28:12,000 --> 00:28:12,733
我的分数

807
00:28:12,733 --> 00:28:13,133
是根据

808
00:28:13,133 --> 00:28:15,999
大家在这个详细设计代码和加库

809
00:28:16,000 --> 00:28:17,666
我报告所提出的这个东西

810
00:28:17,666 --> 00:28:18,766
会打一个基本分

811
00:28:19,466 --> 00:28:23,399
然后再通过这个口试去打一个主观分

812
00:28:23,600 --> 00:28:26,100
就是你口试你表述的非常的清楚

813
00:28:26,100 --> 00:28:27,400
那我主观分很高

814
00:28:27,733 --> 00:28:29,533
口试如果我发现问完了以后

815
00:28:29,533 --> 00:28:30,766
发现这有3个同学清楚

816
00:28:30,766 --> 00:28:31,933
剩下两个同学不清楚

817
00:28:32,066 --> 00:28:33,266
我就会开始扣分

818
00:28:33,666 --> 00:28:34,733
就是我要求是

819
00:28:34,733 --> 00:28:35,933
每一个同学

820
00:28:36,766 --> 00:28:39,099
都必须在里头做了一部分

821
00:28:39,166 --> 00:28:39,533
然后

822
00:28:39,533 --> 00:28:42,066
你至少应该对于你自己做的那个部分

823
00:28:42,133 --> 00:28:42,933
是清楚的

824
00:28:43,333 --> 00:28:44,599
如果你跟我说

825
00:28:44,600 --> 00:28:47,066
你整个学期这门课的课程设计

826
00:28:47,066 --> 00:28:48,133
我啥也没做

827
00:28:48,200 --> 00:28:49,733
我就是跟着别人来的

828
00:28:49,900 --> 00:28:52,166
那你的小组就要被扣分啊

829
00:28:52,333 --> 00:28:54,199
这个我在提前了一个月

830
00:28:54,700 --> 00:28:55,966
我先把这个这个

831
00:28:55,966 --> 00:28:57,999
我记分的这个标准给大家说清楚

832
00:28:58,266 --> 00:28:58,799
这个原因

833
00:28:58,800 --> 00:29:01,133
就是因为我们以小组方式来学习的话

834
00:29:01,133 --> 00:29:02,366
我们希望以小组方式

835
00:29:02,366 --> 00:29:03,966
来带动所有的同学

836
00:29:04,300 --> 00:29:07,133
让每一个同学多多少少会参与

837
00:29:07,133 --> 00:29:07,966
特别是你们那个组

838
00:29:07,966 --> 00:29:08,799
上次那个那个

839
00:29:08,800 --> 00:29:11,333
报告就是典型的没有沟通

840
00:29:11,333 --> 00:29:12,533
没有带动其他组啊

841
00:29:12,533 --> 00:29:13,999
所造成的这个结果

842
00:29:14,133 --> 00:29:15,666
那如果在最后检查是这样的话

843
00:29:15,666 --> 00:29:17,099
你会扣会被扣分的

844
00:29:17,400 --> 00:29:19,566
即算是你有两个同学

845
00:29:19,566 --> 00:29:21,299
3个同学把整个报告写的很好

846
00:29:21,700 --> 00:29:22,900
代码写的很好

847
00:29:22,966 --> 00:29:25,266
然后在中间我没看出任何问题来

848
00:29:25,266 --> 00:29:27,133
但是你们有同学完全没有做

849
00:29:27,333 --> 00:29:28,366
也会被扣分的啊

850
00:29:28,366 --> 00:29:31,266
我再次强调一遍啊

851
00:29:31,266 --> 00:29:32,199
我们的口试过程

852
00:29:32,200 --> 00:29:34,933
是用钉钉预约的在线的过程

853
00:29:34,933 --> 00:29:36,799
因为这样的话大家会比较轻松一点

854
00:29:37,100 --> 00:29:40,166
所以我们一般一个小组是半个小时

855
00:29:40,933 --> 00:29:42,766
所以在最后的一周

856
00:29:42,766 --> 00:29:44,199
我们基本上是不上课的

857
00:29:44,466 --> 00:29:47,066
这个不上课的这一周的任何时间内

858
00:29:47,066 --> 00:29:49,066
就是从早上8点到晚上8

859
00:29:49,066 --> 00:29:50,266
晚上9点10点

860
00:29:50,666 --> 00:29:51,366
任何时间内

861
00:29:51,366 --> 00:29:52,333
只要你们准备好了

862
00:29:52,333 --> 00:29:54,366
你就可以来约这个时间段

863
00:29:54,566 --> 00:29:55,999
我们会看到每个同学

864
00:29:56,000 --> 00:29:57,000
每个校组约的时间段

865
00:29:57,000 --> 00:29:58,366
你看那个半小时有没有空

866
00:29:58,866 --> 00:30:00,366
然后我们会约定一个时间段

867
00:30:00,366 --> 00:30:01,599
来做这个考试啊

868
00:30:01,600 --> 00:30:02,400
这样的话

869
00:30:02,933 --> 00:30:03,899
做考试时候

870
00:30:04,000 --> 00:30:05,900
同学们都只需要在线就好

871
00:30:06,466 --> 00:30:09,733
我们的截止日是2023年12月31号

872
00:30:10,333 --> 00:30:13,299
所以12月31号以后我也不想来做考试了

873
00:30:13,300 --> 00:30:15,333
我想你们也不想再来检查了

874
00:30:15,333 --> 00:30:19,133
因为已经进入到期末考试周了是吧

875
00:30:19,133 --> 00:30:20,366
所所以我们希望啊

876
00:30:20,366 --> 00:30:22,399
每个同学都尽早的结束这个过程

877
00:30:22,400 --> 00:30:23,500
最好大家都做早早了

878
00:30:23,500 --> 00:30:24,866
早早了没有名额限制

879
00:30:25,166 --> 00:30:25,999
所以如果说

880
00:30:26,000 --> 00:30:29,600
你们觉得你们的代码设计都做完了

881
00:30:29,966 --> 00:30:33,166
觉得能够提早在24号之前检查

882
00:30:33,166 --> 00:30:34,133
那是最好的

883
00:30:34,500 --> 00:30:35,700
早点看完早了事

884
00:30:35,700 --> 00:30:36,966
然后剩下的时间

885
00:30:36,966 --> 00:30:38,533
可以更多的时间去复习

886
00:30:38,533 --> 00:30:39,799
准备其他的课程

887
00:30:40,533 --> 00:30:44,133
这个是我们的这个成绩的计算办法

888
00:30:44,166 --> 00:30:45,333
这个有问题吗

889
00:30:45,866 --> 00:30:47,266
关于这个部分

890
00:30:51,466 --> 00:30:52,266
有问题吗

891
00:30:54,766 --> 00:30:55,799
OK那没问题

892
00:30:55,800 --> 00:30:58,166
我们今天要讲的内容

893
00:30:58,933 --> 00:30:59,866
对就这么多

894
00:31:05,600 --> 00:31:06,400
哦对对

895
00:31:06,766 --> 00:31:08,199
没讲完突然忘了

896
00:31:08,300 --> 00:31:10,266
我咋觉得会提早了10分钟呢

897
00:31:11,266 --> 00:31:12,199
还有一个内容

898
00:31:14,900 --> 00:31:15,800
稍等一下啊

899
00:31:21,766 --> 00:31:23,299
就是b座任务怎么做法

900
00:31:24,666 --> 00:31:25,666
因为有第一个同学

901
00:31:25,666 --> 00:31:27,199
已经提交了b座任务

902
00:31:27,766 --> 00:31:28,866
所以我给大家看一下

903
00:31:28,866 --> 00:31:30,733
他是怎么做完成这个b座任务的

904
00:31:30,733 --> 00:31:32,466
然后怎么样被我驳回的

905
00:31:35,500 --> 00:31:38,066
我们在上节课的交叉一啊

906
00:31:38,066 --> 00:31:38,766
上节交叉一

907
00:31:38,766 --> 00:31:39,533
如果没有选交叉一

908
00:31:39,533 --> 00:31:41,399
同学可以去看一下那个视频

909
00:31:41,700 --> 00:31:43,933
是怎么来做这个必做任务

910
00:31:45,300 --> 00:31:47,866
呃那这个周

911
00:31:47,866 --> 00:31:48,866
已经有第一个同学

912
00:31:48,866 --> 00:31:51,399
把他的必做任务在分支上做好

913
00:31:51,400 --> 00:31:52,700
然后提交到服务器上

914
00:31:52,700 --> 00:31:54,166
所以我们大家可以一起看一下

915
00:31:54,333 --> 00:31:55,299
是个什么样的

916
00:32:00,266 --> 00:32:01,299
它提交到服务器上

917
00:32:01,300 --> 00:32:02,600
其实所有同学都能看到

918
00:32:02,700 --> 00:32:02,933
这个

919
00:32:02,933 --> 00:32:05,399
就是我们为什么要做这个过程的原因

920
00:32:05,600 --> 00:32:06,400
因为

921
00:32:11,900 --> 00:32:13,933
做代码或者做设计的过程啊

922
00:32:13,933 --> 00:32:16,266
你不仅仅是要自己闷头去做

923
00:32:16,266 --> 00:32:18,299
其实你要去看人家是怎么做的

924
00:32:21,800 --> 00:32:23,066
需要去听到说

925
00:32:25,133 --> 00:32:25,933
这个

926
00:32:27,300 --> 00:32:28,766
需要改进的地方是什么

927
00:32:28,766 --> 00:32:29,599
大家可以看到啊

928
00:32:29,600 --> 00:32:30,400
这个就是他

929
00:32:30,400 --> 00:32:32,466
刚刚他上午被我关了

930
00:32:32,466 --> 00:32:34,766
下午又提交了这个合并的申请

931
00:32:35,166 --> 00:32:38,366
那他提交一个合并申请过来啊

932
00:32:38,366 --> 00:32:39,599
其实不仅我能看到

933
00:32:39,600 --> 00:32:40,700
所有同学都能看得到

934
00:32:40,700 --> 00:32:41,500
他已经把这个代码

935
00:32:41,500 --> 00:32:42,766
上交到服务器上去了

936
00:32:42,900 --> 00:32:43,666
所以你点过去

937
00:32:43,666 --> 00:32:45,533
可以看到他这个自由任务是改的

938
00:32:45,533 --> 00:32:46,366
那个copy from

939
00:32:46,566 --> 00:32:48,266
就把copy from扩展成为

940
00:32:48,266 --> 00:32:51,133
可以去掉一些呃类

941
00:32:51,166 --> 00:32:53,333
或者单独指定一些类的

942
00:32:53,733 --> 00:32:55,666
这里可以看到他主要改动的代码

943
00:32:55,666 --> 00:32:57,499
其实就是copy from的这个class

944
00:32:57,500 --> 00:32:59,133
还有copy from的这个

945
00:32:59,133 --> 00:33:02,199
Processor这个这两个代码这边

946
00:33:02,200 --> 00:33:02,866
你就能看到

947
00:33:02,866 --> 00:33:04,599
说他两边的这个关系

948
00:33:05,200 --> 00:33:06,400
就是这是原代码

949
00:33:06,733 --> 00:33:08,366
这是他新改的代码

950
00:33:08,500 --> 00:33:11,566
他到底把这个代码改动了什么地方啊

951
00:33:11,566 --> 00:33:13,466
这其实在这里就能一眼看得到

952
00:33:13,566 --> 00:33:14,899
那如果我在看的过程中间

953
00:33:14,900 --> 00:33:17,333
我发现他这个代码是有问题的

954
00:33:19,600 --> 00:33:21,866
比如说这段代码大家觉得什么问题

955
00:33:22,900 --> 00:33:24,533
你们觉得有什么问题看了

956
00:33:26,066 --> 00:33:26,966
我不用看

957
00:33:26,966 --> 00:33:27,766
这肯定有问题

958
00:33:27,766 --> 00:33:29,699
他们写测试对吧

959
00:33:29,700 --> 00:33:31,400
所有的都要写测试报告

960
00:33:31,866 --> 00:33:35,066
所以我直接就会把他把他

961
00:33:40,800 --> 00:33:41,733
把他打回去啊

962
00:33:41,733 --> 00:33:43,766
给他写说他应该要有测试报告

963
00:33:47,766 --> 00:33:49,366
所以我写一个意见写在这

964
00:34:19,366 --> 00:34:21,499
我会跟他说你怎么做单元测试

965
00:35:10,133 --> 00:35:12,666
所以因为他没有写这个测试啊

966
00:35:12,666 --> 00:35:13,933
所以他是致命的

967
00:35:13,933 --> 00:35:16,999
这个是不可以我就把这个意见写上去

968
00:35:17,000 --> 00:35:19,300
这个大家都能看到这个意见啊

969
00:35:19,800 --> 00:35:21,600
我会把这个请求把它关掉

970
00:35:21,966 --> 00:35:23,066
因为他没有写测试

971
00:35:23,066 --> 00:35:24,399
谁知道他是正确还是失败

972
00:35:24,400 --> 00:35:26,333
错的万一合进来这个东西

973
00:35:26,333 --> 00:35:28,733
会造成我们整个的代码全部都完蛋掉

974
00:35:29,366 --> 00:35:31,666
所以你们在看他的这个东西时候

975
00:35:31,666 --> 00:35:32,999
你其实在首页上就能看到

976
00:35:33,000 --> 00:35:34,266
我提出的这个意见

977
00:35:35,933 --> 00:35:37,499
如果说大家注意点

978
00:35:37,500 --> 00:35:40,466
如果说你们跟某一位同学有竞争关系

979
00:35:40,666 --> 00:35:41,799
做了同一个任务

980
00:35:42,066 --> 00:35:43,966
然后你看见他提交了

981
00:35:44,300 --> 00:35:45,800
然后你可以看看他提交的代码

982
00:35:45,800 --> 00:35:46,666
是怎么做的

983
00:35:46,733 --> 00:35:48,533
看看我对他提的意见是什么

984
00:35:48,533 --> 00:35:50,466
然后马上按照他的这个东西

985
00:35:50,466 --> 00:35:51,533
去改自己的

986
00:35:51,600 --> 00:35:52,600
然后再提交

987
00:35:52,600 --> 00:35:54,900
我的这个判断依据

988
00:35:55,100 --> 00:35:59,466
是以最更新的这个时间为依据的

989
00:35:59,900 --> 00:36:01,800
所以如果说你提交了

990
00:36:01,800 --> 00:36:03,100
你就要时刻警惕

991
00:36:03,100 --> 00:36:04,333
看我是不是有回复了你

992
00:36:04,333 --> 00:36:05,066
这个你是邮件应

993
00:36:05,066 --> 00:36:05,866
该能收到

994
00:36:05,866 --> 00:36:06,966
我有回复了你这个

995
00:36:06,966 --> 00:36:07,599
所以回复你这个

996
00:36:07,600 --> 00:36:08,333
你马上改

997
00:36:08,333 --> 00:36:09,866
马上改马上提交啊

998
00:36:10,000 --> 00:36:11,966
所以不要把这上面放时间放的太多

999
00:36:11,966 --> 00:36:12,999
放时间放的太长

1000
00:36:13,000 --> 00:36:15,300
其实会与其他做同样任务的同学看到

1001
00:36:15,300 --> 00:36:16,100
然后把它学习去了

1002
00:36:16,100 --> 00:36:17,066
然后把它改上来

1003
00:36:17,500 --> 00:36:20,166
我们是并不是禁止同学们

1004
00:36:20,166 --> 00:36:21,733
去参考其他的代码

1005
00:36:21,733 --> 00:36:22,899
去做这个任务的

1006
00:36:22,966 --> 00:36:24,299
前提就是每位同学

1007
00:36:24,300 --> 00:36:25,366
当你提交以后

1008
00:36:25,466 --> 00:36:26,799
最开始没有提交之前

1009
00:36:26,800 --> 00:36:28,000
你不要把它送到服务器上

1010
00:36:28,466 --> 00:36:29,099
提交上去以后

1011
00:36:29,100 --> 00:36:30,700
你应该尽快的完成这个

1012
00:36:30,933 --> 00:36:32,466
完成这个修改的过程

1013
00:36:32,466 --> 00:36:34,799
然后达到我的要求就会合进去啊

1014
00:36:34,800 --> 00:36:35,366
合进去以后

1015
00:36:35,366 --> 00:36:36,266
这个任务就关闭了

1016
00:36:36,266 --> 00:36:39,699
就其他同学就不能再做这个任务了

1017
00:36:39,700 --> 00:36:41,466
之后有问题也是由你来负责

1018
00:36:41,466 --> 00:36:43,166
如果你测试有问题

1019
00:36:43,533 --> 00:36:44,966
你不管那就会扣你的分

1020
00:36:44,966 --> 00:36:46,533
把你的5分一点一点的往下扣

1021
00:36:46,533 --> 00:36:47,933
扣到扣没为止啊

1022
00:36:48,133 --> 00:36:50,166
这个就是我们的必做任务

1023
00:36:50,166 --> 00:36:52,366
就是特别是从二阶段以后的必做任务

1024
00:36:52,366 --> 00:36:54,566
都是这么都是这么去完成的

1025
00:36:54,666 --> 00:36:56,666
如果大家觉得做这个代码的必做任务

1026
00:36:56,666 --> 00:36:57,499
有点困难

1027
00:36:57,566 --> 00:37:00,399
那就努力做测试的必做任务啊

1028
00:37:00,400 --> 00:37:02,166
我的这一周之类

1029
00:37:02,166 --> 00:37:03,599
会把第一个提升测试的

1030
00:37:03,600 --> 00:37:04,500
用力给他放上去

1031
00:37:04,500 --> 00:37:07,066
然后把整个提升测试的过程给他

1032
00:37:07,366 --> 00:37:09,133
给他啊调出来

1033
00:37:09,166 --> 00:37:09,366
然后

1034
00:37:09,366 --> 00:37:11,399
大家就能够在上面去做提升测试了

1035
00:37:12,133 --> 00:37:13,399
好吧有什么问题

1036
00:37:15,800 --> 00:37:17,366
OK没什么问题我们就下课了

