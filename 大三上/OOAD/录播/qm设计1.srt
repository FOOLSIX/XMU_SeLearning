1
00:00:49,666 --> 00:00:51,299
上周有交了作业

2
00:00:52,466 --> 00:00:54,599
那因为助教还没有改完啊

3
00:00:54,600 --> 00:00:56,133
因为助教改完以后

4
00:00:56,500 --> 00:00:58,766
我会根据学生同学们做的

5
00:00:58,766 --> 00:01:03,099
去讲我们在概要设计的后面的

6
00:01:03,933 --> 00:01:05,066
呃领域模型建模

7
00:01:05,066 --> 00:01:08,066
也就是选做部分的领域模型建模啊

8
00:01:08,066 --> 00:01:09,299
以及API的设计

9
00:01:09,366 --> 00:01:11,399
但是因为助教还没有改完

10
00:01:11,400 --> 00:01:14,666
所以我们就先把这个课的

11
00:01:14,700 --> 00:01:15,933
后面部分开始讲

12
00:01:15,933 --> 00:01:18,499
就是盖窑设计之后的详细设计

13
00:01:18,666 --> 00:01:20,533
然后估计周三的时候

14
00:01:20,533 --> 00:01:22,099
助教应该能够改完啊

15
00:01:22,100 --> 00:01:23,733
所以那我们再回过来

16
00:01:23,733 --> 00:01:26,933
周三去讲我们前面盖窑设计的

17
00:01:27,466 --> 00:01:29,133
选中部分的领域模型

18
00:01:30,900 --> 00:01:31,333
呃

19
00:01:31,333 --> 00:01:36,866
那我们这一周开始讲详细设计的部分

20
00:01:37,166 --> 00:01:38,766
详细设计的部分呢

21
00:01:38,766 --> 00:01:42,666
我们主要是分为这么几个部分的内容

22
00:01:42,666 --> 00:01:44,166
啊就是我们首先会讲

23
00:01:44,166 --> 00:01:47,066
说在面向对象中间啊

24
00:01:47,500 --> 00:01:48,533
这个详细设计

25
00:01:48,533 --> 00:01:50,299
做的是一个什么样的东西

26
00:01:50,300 --> 00:01:52,166
我们通常讲我们的软件设计

27
00:01:52,166 --> 00:01:54,733
或者我们的对象设计的目标是什么啊

28
00:01:54,733 --> 00:01:56,166
因为针对面向对象的设计的话

29
00:01:56,166 --> 00:01:59,766
其实最核心的内容就是对象设计

30
00:01:59,966 --> 00:02:00,933
然后我们会讲

31
00:02:00,933 --> 00:02:02,666
在详细设计这一个阶段中间

32
00:02:02,666 --> 00:02:04,933
我们会要用到的一些UML的图

33
00:02:04,933 --> 00:02:06,299
比如说UML的

34
00:02:06,533 --> 00:02:09,133
包括前面所讲过的UML的类图啊

35
00:02:09,133 --> 00:02:10,199
因为这个阶段的话

36
00:02:10,200 --> 00:02:14,300
类图会用的更加的更加的深入啊

37
00:02:14,300 --> 00:02:15,166
以及在这个阶段

38
00:02:15,166 --> 00:02:17,533
我们会讲如何去画顺序图

39
00:02:17,866 --> 00:02:21,266
还有状态基图啊等等这些

40
00:02:21,966 --> 00:02:22,499
第三个部分

41
00:02:22,500 --> 00:02:25,533
我们会讲它的设计啊

42
00:02:25,533 --> 00:02:27,733
就是怎么去做这个面向对象的设计

43
00:02:27,733 --> 00:02:30,499
我们主要是讲基于Grasp的方法

44
00:02:31,266 --> 00:02:34,299
来把一个功能如何做成

45
00:02:34,300 --> 00:02:36,600
由对象的协作来完成

46
00:02:36,866 --> 00:02:38,666
主要是在详细设计这个

47
00:02:38,933 --> 00:02:39,899
呃第一个部分

48
00:02:39,900 --> 00:02:40,966
我们主要是讲

49
00:02:41,000 --> 00:02:42,166
这三个内容

50
00:02:42,200 --> 00:02:43,866
那讲完了这个三个内容以后

51
00:02:43,866 --> 00:02:45,299
我们更多的会结合

52
00:02:45,300 --> 00:02:47,733
我们客人设计里头的必做模块

53
00:02:48,066 --> 00:02:49,999
去讲里头的这些设计

54
00:02:50,000 --> 00:02:52,466
是怎样用到这些东西啊

55
00:02:52,466 --> 00:02:53,766
这项知识来做的

56
00:02:54,100 --> 00:02:57,400
所以这是我们基本上从11月份

57
00:02:57,400 --> 00:03:00,400
就是从10月底11月份啊

58
00:03:00,400 --> 00:03:01,933
到12月份的上旬

59
00:03:01,933 --> 00:03:04,099
都是在讲详细设计的内容啊

60
00:03:04,100 --> 00:03:06,166
就是我们这课一半多的时间

61
00:03:06,166 --> 00:03:07,533
都在讲这个部分内容

62
00:03:08,000 --> 00:03:11,266
那我们首先从这个对象设计开始

63
00:03:11,866 --> 00:03:13,733
呃为什么要做软件设计

64
00:03:13,766 --> 00:03:17,533
其实我们在讲说怎样去设计之前

65
00:03:18,000 --> 00:03:20,966
是要说一下我们设计的目标是什么啊

66
00:03:20,966 --> 00:03:23,266
因为你不明确你要设计的目标

67
00:03:23,466 --> 00:03:24,399
你当然就不知道

68
00:03:24,400 --> 00:03:26,400
你怎样去做这样的一个设计

69
00:03:27,100 --> 00:03:29,266
怎样去为什么要做软件设计

70
00:03:29,266 --> 00:03:31,733
这是我们在做软件设计之前

71
00:03:31,733 --> 00:03:33,933
首先要问自己的问题

72
00:03:34,266 --> 00:03:36,199
你对于这个问题有答案

73
00:03:36,300 --> 00:03:37,366
你才知道说

74
00:03:37,366 --> 00:03:40,299
你后面的设计要朝哪个方向去努力

75
00:03:40,766 --> 00:03:43,333
那我们认为说为什么要做软件设计

76
00:03:44,333 --> 00:03:46,266
因为软件是复杂的

77
00:03:46,300 --> 00:03:48,666
我们知道针对任何一个东西

78
00:03:48,700 --> 00:03:49,500
复杂的东西

79
00:03:49,500 --> 00:03:51,766
你是不可能一动手就去做的

80
00:03:52,000 --> 00:03:54,266
所以势必是你要在做之前

81
00:03:54,400 --> 00:03:55,666
都要把它分解

82
00:03:55,800 --> 00:03:56,933
把它模块化

83
00:03:58,766 --> 00:04:01,666
才有可能把复杂的问题变成简单化

84
00:04:01,733 --> 00:04:02,733
比如说我们的前面

85
00:04:02,733 --> 00:04:06,099
可以看到我们的大的角度上头

86
00:04:06,100 --> 00:04:08,666
我们把整个我们所要面对的领域

87
00:04:08,666 --> 00:04:10,333
分成了若干个直领域

88
00:04:10,466 --> 00:04:13,199
在若干个直领域中间去做领域模型

89
00:04:13,200 --> 00:04:16,200
就比在整个领域中间去做领域模型

90
00:04:16,200 --> 00:04:17,266
要容易很多

91
00:04:18,300 --> 00:04:20,600
那后面的设计同样也是这样的

92
00:04:20,600 --> 00:04:22,733
我们不仅仅把大的设计

93
00:04:22,733 --> 00:04:24,599
变成模块的设计

94
00:04:24,800 --> 00:04:25,933
在模块内部

95
00:04:25,933 --> 00:04:28,933
会变成体系结构的层的设计

96
00:04:29,066 --> 00:04:30,133
在层的内部

97
00:04:30,133 --> 00:04:32,199
我们又会按照它的对象模型

98
00:04:32,200 --> 00:04:34,766
再去把它细分成为更小的部分

99
00:04:35,066 --> 00:04:35,933
只有这样啊

100
00:04:35,933 --> 00:04:37,699
我们才可能说

101
00:04:37,866 --> 00:04:41,266
去把一个复杂的繁复的业务

102
00:04:41,933 --> 00:04:44,399
把它用一个软件去实现出来

103
00:04:44,500 --> 00:04:47,200
这个就是我们做软件设计的

104
00:04:47,200 --> 00:04:48,166
第一个目的

105
00:04:48,400 --> 00:04:49,333
因为太复杂

106
00:04:49,333 --> 00:04:50,333
所以必须要分

107
00:04:50,900 --> 00:04:52,700
分了以后才能够解决

108
00:04:53,100 --> 00:04:55,133
所以这个是啊

109
00:04:55,133 --> 00:04:56,099
我们说第一个目的

110
00:04:56,100 --> 00:04:56,700
那第二个

111
00:04:56,700 --> 00:04:58,666
因为他太复复杂

112
00:04:58,766 --> 00:04:59,699
内容很多

113
00:04:59,800 --> 00:05:01,300
我们需要团队协作

114
00:05:01,500 --> 00:05:04,066
所以这也只能再把它分了以后

115
00:05:04,066 --> 00:05:05,966
才能再去做团队协作

116
00:05:06,133 --> 00:05:07,099
这两个啊

117
00:05:07,100 --> 00:05:10,000
其实都是因为软件复杂性所造成

118
00:05:10,600 --> 00:05:12,533
那这是一个必要条件

119
00:05:12,966 --> 00:05:14,899
那从另外一个角度上来说

120
00:05:15,100 --> 00:05:17,333
我们开发软件是为了盈利的

121
00:05:17,900 --> 00:05:20,366
开发软件的主要的目标是

122
00:05:20,366 --> 00:05:24,733
我们要用软件去解决现实的需求

123
00:05:25,133 --> 00:05:26,699
当然要解决这个需求

124
00:05:26,700 --> 00:05:28,200
我们是需要付出成本的

125
00:05:28,566 --> 00:05:29,599
那这个成本

126
00:05:30,000 --> 00:05:32,000
是我们在开发软件的过程中间

127
00:05:32,000 --> 00:05:33,600
必须要考虑的一个问题

128
00:05:34,000 --> 00:05:36,866
所以做软件设计的第二个目标

129
00:05:36,933 --> 00:05:38,566
它的目的是为什么

130
00:05:38,666 --> 00:05:40,966
就是为了降低我们的开发成本

131
00:05:41,066 --> 00:05:43,166
提升我们的软件质量

132
00:05:43,800 --> 00:05:45,733
为什么说做了设计

133
00:05:45,733 --> 00:05:47,933
可以降低它的开发成本

134
00:05:47,933 --> 00:05:49,499
和提升它的质量

135
00:05:49,700 --> 00:05:53,600
其实主要是从提升软件的从用性

136
00:05:54,133 --> 00:05:56,966
以及增强软件的扩展性

137
00:05:56,966 --> 00:05:58,866
这两个角度去实现

138
00:05:59,100 --> 00:05:59,700
我们知道

139
00:05:59,700 --> 00:06:01,600
如果软件的从用性越高

140
00:06:01,700 --> 00:06:04,400
我们所开发的代码的数量也就越少

141
00:06:04,800 --> 00:06:05,966
开发的数量越少

142
00:06:05,966 --> 00:06:07,466
他犯的错误也就越少

143
00:06:07,466 --> 00:06:10,466
我们所付出的工作量也就越少啊

144
00:06:10,466 --> 00:06:14,333
所以从用性是降低我们的这个成本

145
00:06:14,333 --> 00:06:16,299
提高质量的一个重要手段

146
00:06:16,400 --> 00:06:18,400
那当然还有一部分成本是什么呢

147
00:06:18,400 --> 00:06:20,700
还有一部分成本就是我们说软件的

148
00:06:20,766 --> 00:06:23,466
这个变化是他内在的因素

149
00:06:23,933 --> 00:06:27,899
所以你如果只针对当前来做设计

150
00:06:27,900 --> 00:06:30,266
而不考虑他未来的扩展性

151
00:06:30,600 --> 00:06:32,766
这个成本虽然你现在没有付

152
00:06:32,766 --> 00:06:34,566
但将来可能会付的更多

153
00:06:35,200 --> 00:06:38,166
所以提升重用性和增强扩展性

154
00:06:38,166 --> 00:06:41,566
是我们软件设计的第二个目标

155
00:06:41,866 --> 00:06:42,999
所以记住两个目标

156
00:06:43,000 --> 00:06:45,333
我们后面所有的这些设计

157
00:06:45,666 --> 00:06:48,899
都是从这两个目标来出发的

158
00:06:50,700 --> 00:06:52,733
啊我引用那个

159
00:06:52,733 --> 00:06:55,166
罗翔在圆圈正义里的这一句话啊

160
00:06:55,166 --> 00:06:58,266
虽然我们无法找到一个绝对理想的圆

161
00:06:58,533 --> 00:07:01,299
但不妨碍我们理解什么是圆

162
00:07:01,966 --> 00:07:03,933
也就是虽然我们不可能做出一个

163
00:07:03,933 --> 00:07:06,333
完全能达到我们上面所说的

164
00:07:06,333 --> 00:07:08,266
这两个目标的软件设计

165
00:07:08,500 --> 00:07:11,500
但是我们要理解说

166
00:07:11,500 --> 00:07:13,933
这个软件设计的目标是什么

167
00:07:13,966 --> 00:07:19,533
我们才有可能画一个尽量近近视

168
00:07:19,533 --> 00:07:22,266
接近他的这样的一个圆啊

169
00:07:22,700 --> 00:07:25,266
这个不是罗翔的原文啊

170
00:07:25,266 --> 00:07:28,333
因为罗翔大家应该知道他是教法学的

171
00:07:28,333 --> 00:07:29,466
他实际上讲的是什么

172
00:07:29,466 --> 00:07:31,533
就是那个名字叫做圆圈正义

173
00:07:32,066 --> 00:07:35,133
也就是法律不可能追求绝对的正义

174
00:07:35,533 --> 00:07:37,699
但是你必须要通过法律的手段

175
00:07:37,700 --> 00:07:42,200
去追求一个接无限接近正义的结果啊

176
00:07:42,200 --> 00:07:43,366
当然我们放在这来说

177
00:07:43,366 --> 00:07:45,733
就是指我们的这个软件设计

178
00:07:45,733 --> 00:07:45,999
其实

179
00:07:46,000 --> 00:07:49,366
你是不可能达成一个完美的目标的

180
00:07:49,766 --> 00:07:52,366
就是既降低了复杂性

181
00:07:53,366 --> 00:07:55,799
又有重用性和扩展性

182
00:07:55,933 --> 00:07:57,899
但是这不妨碍我们去理解说

183
00:07:57,900 --> 00:07:59,566
我们为什么要做到这一点

184
00:07:59,566 --> 00:08:02,999
所以我把它原文是又为又改了一下

185
00:08:06,766 --> 00:08:07,666
那回顾一下

186
00:08:07,666 --> 00:08:10,166
我们在前面做的体系结构的设计

187
00:08:10,166 --> 00:08:13,966
我们是有我们在课程设计中间啊

188
00:08:13,966 --> 00:08:16,533
我们采用了这样一个分层的体系结构

189
00:08:16,533 --> 00:08:19,399
就是把它分成了控制器层服务层

190
00:08:20,133 --> 00:08:22,966
呃数据访问层和映射层

191
00:08:23,966 --> 00:08:26,666
我们在这些若干层里头

192
00:08:26,666 --> 00:08:29,499
其实都分布着我们设计的对象

193
00:08:29,700 --> 00:08:33,100
我们在控制器层主要是两类对象

194
00:08:33,100 --> 00:08:35,200
一类对象叫做Bo对象

195
00:08:35,533 --> 00:08:36,666
这一类对象

196
00:08:36,666 --> 00:08:40,333
它是用来接收从前端传过来的数据

197
00:08:40,866 --> 00:08:43,999
所以前端的用户会输入什么样的数据

198
00:08:44,333 --> 00:08:46,466
他就会原封不动的

199
00:08:46,466 --> 00:08:48,599
传到我们的控制器层

200
00:08:48,800 --> 00:08:50,500
那这个部分大家知道

201
00:08:50,500 --> 00:08:55,166
VO的对象是要做输入的合法性验证的

202
00:08:55,500 --> 00:08:59,466
所以VO的对象其它的目的就两个

203
00:08:59,466 --> 00:09:01,666
第一个接收从前端过来的数据

204
00:09:01,666 --> 00:09:03,099
原样接收啊

205
00:09:03,166 --> 00:09:04,666
就前端怎么输入进来的

206
00:09:04,666 --> 00:09:05,933
我就怎样把它接收

207
00:09:06,133 --> 00:09:06,533
第二

208
00:09:06,533 --> 00:09:09,733
对于前端输入的数据做合法性的认证

209
00:09:10,000 --> 00:09:11,133
这是第一类对象

210
00:09:11,966 --> 00:09:13,299
在控制继承的第二类对象

211
00:09:13,300 --> 00:09:15,133
我们把它称之为DTO对象啊

212
00:09:15,133 --> 00:09:16,066
这个DTO对象

213
00:09:16,066 --> 00:09:17,866
其实如果官方的定义来说

214
00:09:17,866 --> 00:09:20,399
其实比这个含义更加的广泛

215
00:09:21,100 --> 00:09:22,333
但是因为我们这里

216
00:09:22,333 --> 00:09:24,666
其实极少有网络的通讯部分

217
00:09:24,666 --> 00:09:27,066
我们极最多的交互

218
00:09:27,066 --> 00:09:30,266
就是传输给前端的数据

219
00:09:30,566 --> 00:09:32,133
所以我们用DTO这个名字

220
00:09:32,133 --> 00:09:34,133
去描述那些在控制器层

221
00:09:34,133 --> 00:09:38,333
需要把数据送回前端的那些对象

222
00:09:38,333 --> 00:09:40,699
我们称之为data transfer object啊

223
00:09:40,700 --> 00:09:41,800
叫做DTO对象

224
00:09:41,900 --> 00:09:43,100
这些对象长什么样

225
00:09:43,100 --> 00:09:43,400
这个对象

226
00:09:43,400 --> 00:09:45,700
就是前端想要看到一个什么样

227
00:09:45,933 --> 00:09:47,733
那就是一个什么样子啊

228
00:09:47,733 --> 00:09:50,099
所以VO对象是前端的输入

229
00:09:50,400 --> 00:09:53,366
DTO对象是输出给前端的数据

230
00:09:53,800 --> 00:09:55,333
这是我们在控制气层

231
00:09:55,333 --> 00:09:57,866
会看到的两类的对象

232
00:09:58,466 --> 00:10:01,766
那在下面的服务层和道层

233
00:10:01,766 --> 00:10:04,666
我们会看到一类对象叫做Bo对象

234
00:10:04,700 --> 00:10:06,533
那今天这个Bo对象

235
00:10:06,533 --> 00:10:10,066
更多的被叫做do对象啊

236
00:10:10,066 --> 00:10:11,666
do对象叫做business object

237
00:10:11,766 --> 00:10:13,533
那今天我们可能更多的

238
00:10:13,533 --> 00:10:15,899
特别是滴滴滴的这种啊

239
00:10:15,900 --> 00:10:17,400
被大家广泛的接受啊

240
00:10:17,400 --> 00:10:18,500
所以这个do对象

241
00:10:18,500 --> 00:10:20,600
今天已经更多的变成叫做do对象啊

242
00:10:20,600 --> 00:10:21,800
叫Doman object

243
00:10:22,266 --> 00:10:24,366
就是跟着领域建模来的啊

244
00:10:24,366 --> 00:10:25,333
Dorman object

245
00:10:25,500 --> 00:10:26,966
但以前啊

246
00:10:26,966 --> 00:10:28,066
叫Bo对象

247
00:10:28,066 --> 00:10:29,199
我们目前在代码中间

248
00:10:29,200 --> 00:10:30,866
还是沿用着以前的叫法

249
00:10:30,866 --> 00:10:32,399
叫做business object啊

250
00:10:32,400 --> 00:10:34,600
大家应该知道这两个是划等号的啊

251
00:10:34,600 --> 00:10:36,666
只是这个不同的名字

252
00:10:36,966 --> 00:10:37,933
这一个部分

253
00:10:37,933 --> 00:10:40,299
是我们在软件设计的核心的部分

254
00:10:40,800 --> 00:10:42,800
也就是我们在前面辛辛苦苦做的

255
00:10:42,800 --> 00:10:43,966
领域模型的建模

256
00:10:44,200 --> 00:10:47,133
最终会演化成为我们的Bo对象

257
00:10:47,133 --> 00:10:48,133
和do对象

258
00:10:48,533 --> 00:10:51,899
所有的面向对象的设计的方法

259
00:10:51,900 --> 00:10:53,000
设计的技巧

260
00:10:53,500 --> 00:10:57,666
都是用在设计这些Bo对象和do对象的

261
00:10:57,966 --> 00:11:00,266
啊这是我们在service城和稻城

262
00:11:00,266 --> 00:11:01,899
会看到的这一类对象

263
00:11:02,400 --> 00:11:05,566
那最后一类对象是在mapton number称

264
00:11:05,566 --> 00:11:07,099
被称之为Po对象

265
00:11:07,100 --> 00:11:08,600
叫做persistent object

266
00:11:09,166 --> 00:11:10,099
这一类对象

267
00:11:10,100 --> 00:11:12,500
就是跟我们存储的数据格式

268
00:11:12,500 --> 00:11:13,800
是完全一样的

269
00:11:14,133 --> 00:11:14,499
假如说

270
00:11:14,500 --> 00:11:16,366
我们的数据最快存到关系数据库里去

271
00:11:16,366 --> 00:11:17,866
Po对象等于数据表

272
00:11:18,266 --> 00:11:20,699
就是一张数据表就是一个PO对象

273
00:11:20,933 --> 00:11:22,733
那如果说我们的数据师称

274
00:11:22,900 --> 00:11:25,500
存在面向对象的一个结构里头

275
00:11:25,900 --> 00:11:28,333
那PU对象就等于那个面向对象的结构

276
00:11:28,333 --> 00:11:30,166
就PU对象会等于PU对象

277
00:11:30,533 --> 00:11:32,733
这完全就看我们后面的

278
00:11:32,733 --> 00:11:35,699
就是map层下面的那个存储的部分

279
00:11:35,966 --> 00:11:37,133
是一个什么东西

280
00:11:37,400 --> 00:11:38,766
它如果是个数据库的话

281
00:11:38,766 --> 00:11:40,733
PU就是表

282
00:11:40,733 --> 00:11:42,299
如果它是一个面向对象的话

283
00:11:42,300 --> 00:11:43,800
它就是对象

284
00:11:44,133 --> 00:11:44,866
我们在科

285
00:11:44,866 --> 00:11:47,599
特车型中间其实会用到两种数据库

286
00:11:47,600 --> 00:11:49,333
一种是面向关系的数据库

287
00:11:49,333 --> 00:11:52,799
一种是我们称之为no c口的数据库

288
00:11:52,800 --> 00:11:54,166
而这种no c口数据库

289
00:11:54,166 --> 00:11:54,966
是支持

290
00:11:54,966 --> 00:11:57,366
我们直接把对象存到数据库里去的

291
00:11:57,933 --> 00:11:59,366
啊所以量数都会用到

292
00:11:59,366 --> 00:12:01,966
所以我们会用两种不同的map层啊

293
00:12:01,966 --> 00:12:02,899
大家可以看到

294
00:12:02,900 --> 00:12:05,700
这两种不同的数据的存储方式

295
00:12:05,966 --> 00:12:08,499
对于我们要存的时候的这个Po对象

296
00:12:08,500 --> 00:12:10,533
其实是有很大的影响的

297
00:12:11,266 --> 00:12:13,366
所以这样的一个对象模型的设计

298
00:12:13,366 --> 00:12:15,933
大家可以看到它其实存在的一个关系

299
00:12:15,933 --> 00:12:20,266
就是从用户的前端送过来的数据

300
00:12:20,266 --> 00:12:22,066
用VO对象去接收

301
00:12:22,666 --> 00:12:25,366
VO对象会把我们的系统需要

302
00:12:25,366 --> 00:12:27,599
把VO对象变成我们的do对象

303
00:12:27,600 --> 00:12:28,500
或者do对象

304
00:12:28,500 --> 00:12:30,800
然后在do对象和do对象上头

305
00:12:30,966 --> 00:12:32,766
去完成它所要的功能

306
00:12:32,900 --> 00:12:34,800
如果它需要存储数据库的话

307
00:12:34,800 --> 00:12:36,866
它就会把do对象或者do对象

308
00:12:36,866 --> 00:12:39,266
再变成Po对象

309
00:12:39,266 --> 00:12:40,533
把它存到数据库里

310
00:12:40,533 --> 00:12:42,299
或者存到Nosecre数据库里

311
00:12:42,600 --> 00:12:44,300
如果从数据库里读数据

312
00:12:44,400 --> 00:12:45,366
或者从我

313
00:12:45,366 --> 00:12:47,333
或者我们的业务是基于数据库

314
00:12:47,933 --> 00:12:49,199
你读数据而来的

315
00:12:49,200 --> 00:12:50,933
这个过程就是反向的

316
00:12:50,933 --> 00:12:52,699
就是从数据库里读出来的数据

317
00:12:52,700 --> 00:12:53,766
变成PO对象

318
00:12:53,966 --> 00:12:56,966
要把PO对象变成b o对象或者DTO对象

319
00:12:56,966 --> 00:12:59,499
然后在DTO对象呢去完成我们的功能

320
00:13:00,133 --> 00:13:00,866
我们的所有功能

321
00:13:00,866 --> 00:13:02,799
都是在do对象上头去完成的

322
00:13:02,966 --> 00:13:04,266
do对象去完成的啊

323
00:13:04,266 --> 00:13:05,966
do或者do对象去完成的

324
00:13:06,200 --> 00:13:07,500
完成以后

325
00:13:07,500 --> 00:13:10,700
如果这个东西需要显示给前端的话

326
00:13:10,766 --> 00:13:13,466
那么还需要把do对象和do对象

327
00:13:13,466 --> 00:13:15,199
把它变成do对象

328
00:13:15,366 --> 00:13:17,499
再给它送给前端啊

329
00:13:17,500 --> 00:13:20,866
所以我们在我们的整个系统中间

330
00:13:20,866 --> 00:13:22,733
就是这三类

331
00:13:22,800 --> 00:13:27,466
四种对象分别在三个层次上头

332
00:13:27,566 --> 00:13:29,099
VO DTO在控制器层

333
00:13:29,100 --> 00:13:31,066
PU在映射层

334
00:13:31,266 --> 00:13:35,166
而Bo和DTO是在服务层和稻层

335
00:13:35,800 --> 00:13:38,733
那b o和DTO在服务层和稻城

336
00:13:38,733 --> 00:13:39,933
它到底是在干嘛

337
00:13:40,366 --> 00:13:42,299
我们的DTO的主要的目的

338
00:13:42,300 --> 00:13:43,466
就是DTO的数据访问程

339
00:13:43,466 --> 00:13:44,299
这个主要的目的

340
00:13:44,300 --> 00:13:47,133
就是把b o对象和d o对象

341
00:13:47,133 --> 00:13:48,299
把它构造出来

342
00:13:48,666 --> 00:13:50,999
就是把整个的对象模型给它构造出来

343
00:13:51,300 --> 00:13:52,800
而收费层的目的是为什么

344
00:13:52,800 --> 00:13:54,300
就是临门一脚

345
00:13:54,366 --> 00:13:55,766
我们要做的功能

346
00:13:56,266 --> 00:13:59,566
最后是怎样调用到Bo和DTO对象的

347
00:13:59,566 --> 00:14:01,166
就是这一角

348
00:14:01,166 --> 00:14:03,499
是在这个service层去完成的

349
00:14:03,666 --> 00:14:05,966
这就是我们把对象模型

350
00:14:05,966 --> 00:14:07,299
和我们前面所说的

351
00:14:07,300 --> 00:14:09,933
分层的体系结构结合起来

352
00:14:10,200 --> 00:14:11,466
在我们的坑设计中间

353
00:14:11,466 --> 00:14:12,599
就是这样的一个设计

354
00:14:13,300 --> 00:14:15,466
存在着不同类型的对象

355
00:14:15,733 --> 00:14:16,966
每一个层

356
00:14:17,066 --> 00:14:20,899
都是负责对这些对象进行加工

357
00:14:21,600 --> 00:14:24,300
比如说控制器层负责接收bo对象

358
00:14:24,500 --> 00:14:26,500
把bo对象变成bo对象

359
00:14:27,000 --> 00:14:28,700
服务层是决定说

360
00:14:28,700 --> 00:14:32,000
我现在这个要调bo对象的哪个方法

361
00:14:32,200 --> 00:14:33,166
而DTO层

362
00:14:33,166 --> 00:14:36,533
是把这个bo对象整个构造出来

363
00:14:36,533 --> 00:14:37,666
因为b o对象不是孤立的

364
00:14:37,666 --> 00:14:39,499
它是跟很多东西是有联系的

365
00:14:39,500 --> 00:14:41,533
所以你需要把这个联系给构造出来

366
00:14:41,900 --> 00:14:45,800
那MA MA层则是把b o对象变成p o对象

367
00:14:45,800 --> 00:14:47,300
把它存到数据库里去

368
00:14:47,666 --> 00:14:48,766
就是这样的一个

369
00:14:49,133 --> 00:14:51,699
就是这样的一个分层体系结构啊

370
00:14:51,700 --> 00:14:52,333
和对象模型

371
00:14:52,333 --> 00:14:53,399
可能大家不是特别理解

372
00:14:53,400 --> 00:14:54,800
但是大家以后看代码的时候

373
00:14:54,800 --> 00:14:56,000
我们目前的代码

374
00:14:56,000 --> 00:14:58,000
是严格按照这样的一种规范

375
00:14:58,300 --> 00:14:59,500
这样的一种设计思想啊

376
00:14:59,500 --> 00:15:00,266
不是规范

377
00:15:00,266 --> 00:15:03,933
因为不同的公司或者不同的项目

378
00:15:03,933 --> 00:15:05,866
他的设计的思想是不一样的

379
00:15:05,866 --> 00:15:08,466
我们只针对我们的欧莫来说

380
00:15:08,466 --> 00:15:09,199
他的设计思想

381
00:15:09,200 --> 00:15:10,666
就是这样的一个设计思想

382
00:15:11,200 --> 00:15:11,933
就是这

383
00:15:11,933 --> 00:15:14,599
基于这样的一个设计思想啊来实现的

384
00:15:16,000 --> 00:15:19,600
这就是我们所说的Bo对象和DTO对象

385
00:15:19,733 --> 00:15:22,099
在我们的

386
00:15:23,766 --> 00:15:24,999
产品模块里头

387
00:15:25,000 --> 00:15:27,733
我们的产品模块对应着

388
00:15:27,733 --> 00:15:30,766
我们前面的产品

389
00:15:30,766 --> 00:15:32,166
指领域啊

390
00:15:32,400 --> 00:15:36,700
那在产品模块中间的对象模型

391
00:15:37,266 --> 00:15:38,366
他的设计

392
00:15:38,666 --> 00:15:42,466
和领域模型是有一定的关系的啊

393
00:15:42,466 --> 00:15:43,866
不知道大家还记不记得领域模型

394
00:15:43,866 --> 00:15:45,499
我们把领域模型打开给大家看一下

395
00:15:45,500 --> 00:15:47,866
但我们今天并不打算详细讲

396
00:15:47,866 --> 00:15:49,699
这个设计的过程是什么样子

397
00:15:50,200 --> 00:15:51,566
只是给大家看一下

398
00:15:54,666 --> 00:15:56,733
我们前面的概要设计中间

399
00:15:59,066 --> 00:16:00,699
这个还要还要还要下一下

400
00:16:00,700 --> 00:16:01,766
那我就不仔细讲

401
00:16:04,066 --> 00:16:06,699
这个对象模型跟领域模型是不一样

402
00:16:07,166 --> 00:16:09,366
并不是领域模型中间的每一个概念

403
00:16:09,366 --> 00:16:12,499
都会变成我们这里头的一个类啊

404
00:16:12,500 --> 00:16:12,966
从

405
00:16:12,966 --> 00:16:14,666
如果大家记得我们讲的领域模型的话

406
00:16:14,666 --> 00:16:15,933
大家应该直观的感受是

407
00:16:15,933 --> 00:16:17,999
这里的类比领域模型更多

408
00:16:18,900 --> 00:16:21,766
或者说他在某些部分比领域模型更少

409
00:16:21,900 --> 00:16:24,100
他既有多的地方也有少的地方啊

410
00:16:24,133 --> 00:16:25,933
那我们所有的逻辑

411
00:16:25,933 --> 00:16:27,966
都是基于这样的一个对象模型

412
00:16:28,266 --> 00:16:29,199
来完成的

413
00:16:29,400 --> 00:16:30,700
我们打算在周三的时候

414
00:16:30,700 --> 00:16:32,166
把所有的领域模型整理完

415
00:16:32,166 --> 00:16:35,599
再讲所有的领域模型对应的对象模型

416
00:16:35,600 --> 00:16:37,400
特别是d座模块的领域模型

417
00:16:37,400 --> 00:16:39,966
对应的这个对象模型

418
00:16:40,400 --> 00:16:41,700
选中部分的领域模型

419
00:16:41,700 --> 00:16:42,500
对应对象模型呢

420
00:16:42,500 --> 00:16:44,100
就要你们自己去设计了啊

421
00:16:44,800 --> 00:16:46,533
啊所以我们到周三再来讲

422
00:16:46,533 --> 00:16:48,199
这个对应关系什么样的

423
00:16:48,666 --> 00:16:49,899
那这个对象模型

424
00:16:49,900 --> 00:16:52,533
最终会变成我们的数据库的设计

425
00:16:52,533 --> 00:16:54,933
就是如果说你要变成Po对象的话

426
00:16:55,366 --> 00:16:56,899
要存到关系数据库里的话

427
00:16:56,900 --> 00:16:58,300
你需要把对象模型

428
00:16:58,300 --> 00:16:59,533
把它变成数据库

429
00:16:59,733 --> 00:17:02,366
我们在这里用的这个数据库的设计

430
00:17:02,366 --> 00:17:03,999
我们直接就是写的什么呢

431
00:17:04,000 --> 00:17:06,066
写的是类

432
00:17:06,066 --> 00:17:08,066
为啥因为我们就是用Po对象

433
00:17:08,066 --> 00:17:10,133
对应着我们的数据库表的

434
00:17:10,200 --> 00:17:11,100
所以大家可以看到

435
00:17:11,100 --> 00:17:13,533
这里头的每一个类

436
00:17:13,533 --> 00:17:17,166
其实就是我们的每一个Po对象啊

437
00:17:17,166 --> 00:17:18,166
然后它也对应着

438
00:17:18,166 --> 00:17:20,166
我们在数据库里头的一张表啊

439
00:17:20,166 --> 00:17:26,733
一张表这是我们的这个对象模型

440
00:17:26,733 --> 00:17:28,933
和数据库的设计

441
00:17:28,933 --> 00:17:30,099
这个我们就不仔细讲了

442
00:17:30,100 --> 00:17:32,100
到周三再去仔细的讲

443
00:17:33,300 --> 00:17:37,133
那我们来讲说我们在整个模块里头

444
00:17:37,133 --> 00:17:38,933
就整个这个系统中间

445
00:17:38,933 --> 00:17:40,399
其实最主要的

446
00:17:40,400 --> 00:17:42,566
就是我们在这里所说的这个对象模型

447
00:17:43,366 --> 00:17:46,166
对象模型目前在业内的做法

448
00:17:46,166 --> 00:17:48,199
其实主要是有两类做法

449
00:17:48,366 --> 00:17:51,066
一类被称之为贫血模型

450
00:17:51,266 --> 00:17:54,666
啊叫做animic model啊

451
00:17:54,800 --> 00:17:56,266
什么叫做评选模型呢

452
00:17:56,266 --> 00:17:59,566
就是在这样的一个类的设计中间

453
00:18:00,000 --> 00:18:03,800
所有的类里头只有get和set的方法

454
00:18:04,400 --> 00:18:06,200
而没有任何业务的方法

455
00:18:06,466 --> 00:18:08,933
也就是说这个对象模型中间是没血的

456
00:18:09,133 --> 00:18:10,866
他没有任何的领域知识

457
00:18:10,866 --> 00:18:13,499
被灌输到对象模型中间

458
00:18:13,800 --> 00:18:18,300
所有的这个这里头的每一个类里头

459
00:18:18,300 --> 00:18:19,533
都只有get的方法

460
00:18:19,533 --> 00:18:20,733
为了得到它的属性

461
00:18:20,800 --> 00:18:22,133
那他的业务在哪呢

462
00:18:22,466 --> 00:18:25,733
他的业务在service城和稻城

463
00:18:26,466 --> 00:18:28,566
service城和稻城用get

464
00:18:28,566 --> 00:18:30,699
和set的方法去访问对象模型

465
00:18:30,700 --> 00:18:31,600
但是所有的业务

466
00:18:31,600 --> 00:18:34,333
都是写在设vis城和稻城的

467
00:18:34,600 --> 00:18:35,933
目前在市面上

468
00:18:35,933 --> 00:18:38,966
大家看到的90%以上的代码

469
00:18:39,000 --> 00:18:39,866
都是这么写的

470
00:18:40,200 --> 00:18:41,666
其实我们以前也是这么写的啊

471
00:18:41,666 --> 00:18:44,099
在前十年都是这么写代码

472
00:18:45,000 --> 00:18:48,000
呃给大家看一下2011年

473
00:18:48,266 --> 00:18:50,899
我们的取消团购的这个做法

474
00:18:51,133 --> 00:18:53,066
这是2011年的代码

475
00:18:53,300 --> 00:18:56,266
这个代码就是完全是评选模型

476
00:18:56,733 --> 00:18:58,699
这是我们的对象模型

477
00:18:58,700 --> 00:19:01,366
中间的团购的活动

478
00:19:02,800 --> 00:19:04,733
团是我们的团购活动

479
00:19:04,733 --> 00:19:05,666
大家可以看到这个

480
00:19:05,666 --> 00:19:07,699
我把它完整代码卡这里了

481
00:19:07,933 --> 00:19:11,166
在这个团购活动的这个对象模型的内

482
00:19:11,166 --> 00:19:14,666
里头是没有任何的业务方法的

483
00:19:14,666 --> 00:19:16,266
它只有get和say的方法

484
00:19:16,266 --> 00:19:18,199
因为我们使用了number的插件

485
00:19:18,200 --> 00:19:20,366
所以连get say的方法都不需要写

486
00:19:20,600 --> 00:19:23,766
前面加了一个这个标

487
00:19:24,300 --> 00:19:25,166
这个标签啊

488
00:19:25,166 --> 00:19:25,999
hard data

489
00:19:27,166 --> 00:19:28,733
这是因为使用了nonbook的

490
00:19:28,733 --> 00:19:30,966
nonbook的这个插件的原因

491
00:19:31,200 --> 00:19:33,200
所以就会使得nonbook的插件

492
00:19:33,200 --> 00:19:36,666
在这一端代码被编译之前

493
00:19:37,333 --> 00:19:42,299
先生成它所有的get和shit的方法啊

494
00:19:42,300 --> 00:19:44,400
所以这就连get设置方法都不需要写

495
00:19:44,400 --> 00:19:45,766
但实际上它是有的啊

496
00:19:45,900 --> 00:19:47,166
这就是评选模型

497
00:19:47,166 --> 00:19:48,399
那所有的代码在哪呢

498
00:19:48,400 --> 00:19:50,966
所有代码就在社会审的方法中间

499
00:19:51,400 --> 00:19:53,133
比如说在收费层的方法中间

500
00:19:53,133 --> 00:19:54,666
我们要取消团购

501
00:19:54,666 --> 00:19:55,966
在收费层有一个方法

502
00:19:55,966 --> 00:19:58,699
叫做offline group on activity

503
00:19:58,900 --> 00:20:02,500
然后里头就写了洋洋洒洒的这些代码

504
00:20:02,733 --> 00:20:03,499
这里还不够

505
00:20:03,500 --> 00:20:05,366
因为收费层里头还有一部分的逻辑

506
00:20:05,366 --> 00:20:07,166
会去调稻城的代码

507
00:20:07,533 --> 00:20:08,699
所以这是他调用的

508
00:20:08,700 --> 00:20:11,133
这个稻城的两个方法

509
00:20:11,133 --> 00:20:13,499
一个是gate Groupon activity一

510
00:20:13,500 --> 00:20:14,800
个是modify Groupon activity

511
00:20:14,800 --> 00:20:16,200
我们把逻辑带给大家梳理一下

512
00:20:16,200 --> 00:20:17,766
大家应该能看到啊

513
00:20:17,766 --> 00:20:20,566
其实调下线一个团购啊

514
00:20:20,566 --> 00:20:21,533
其实比较简单

515
00:20:21,533 --> 00:20:23,599
第一是它需要

516
00:20:25,300 --> 00:20:28,066
呃把当前的这个团

517
00:20:28,333 --> 00:20:29,899
首先要得到这个团购对象

518
00:20:29,900 --> 00:20:30,766
所以大家可以看到

519
00:20:30,766 --> 00:20:32,866
在Offline的第一行

520
00:20:32,866 --> 00:20:34,766
是得到了这个团购的对象

521
00:20:34,900 --> 00:20:36,933
那要判断这个团购对象的状态

522
00:20:36,933 --> 00:20:38,466
是不是能够下线的

523
00:20:38,533 --> 00:20:40,399
所以有一堆的这个判断

524
00:20:40,700 --> 00:20:42,266
如果判断他是能够下线的

525
00:20:42,266 --> 00:20:42,866
然后他就这样

526
00:20:42,866 --> 00:20:44,699
就是把这个团购对象的属性

527
00:20:44,700 --> 00:20:46,966
把它改成一个下线的属性

528
00:20:47,166 --> 00:20:51,466
然后把它modify去做这个下限

529
00:20:51,533 --> 00:20:55,366
当然团购仅仅团购下限是不够的啊

530
00:20:55,366 --> 00:20:57,199
因为那只是一个活动下限

531
00:20:57,500 --> 00:21:00,800
团购下限会造成他所有的团购的销售

532
00:21:00,800 --> 00:21:02,933
都不能在在卖了

533
00:21:02,933 --> 00:21:03,466
是吧

534
00:21:03,466 --> 00:21:06,299
而且会造成他已有的团购全部去退款

535
00:21:06,533 --> 00:21:08,966
所以这一堆就是已有的团购销售

536
00:21:08,966 --> 00:21:09,933
全部都不能卖了

537
00:21:09,933 --> 00:21:13,699
以及所有的团购订单全部去退款的

538
00:21:13,700 --> 00:21:14,333
这部分逻辑

539
00:21:14,333 --> 00:21:17,133
写在了这个good service的offline Excel

540
00:21:17,133 --> 00:21:19,499
因为2011年的时候

541
00:21:19,500 --> 00:21:21,766
我们把团购和商品的部分

542
00:21:21,766 --> 00:21:24,066
是把它分在两个模块里头的

543
00:21:24,266 --> 00:21:26,499
就是专门有个团购的模块啊

544
00:21:26,500 --> 00:21:27,566
有一个活动的模块

545
00:21:27,566 --> 00:21:29,266
包括团购和优惠活动

546
00:21:29,366 --> 00:21:31,399
然后有一个商品的基本模块啊

547
00:21:31,400 --> 00:21:34,700
所以这里是去调商品的基本模块

548
00:21:35,133 --> 00:21:35,866
就三个事情

549
00:21:35,866 --> 00:21:37,733
第一达到当前的团购

550
00:21:37,733 --> 00:21:40,099
判断当前团购是不是能够下线

551
00:21:40,200 --> 00:21:41,333
如果可以下线

552
00:21:41,333 --> 00:21:42,766
把当前的团购下线

553
00:21:42,766 --> 00:21:44,466
然后去调用商品模块

554
00:21:44,733 --> 00:21:46,799
去把他所有的销售

555
00:21:46,800 --> 00:21:49,200
也都把他停止掉啊

556
00:21:49,200 --> 00:21:50,066
不能再卖了

557
00:21:50,066 --> 00:21:51,866
然后把所有的这个订单

558
00:21:52,066 --> 00:21:53,599
去把它全部取消掉啊

559
00:21:53,600 --> 00:21:54,500
然后去退款

560
00:21:54,533 --> 00:21:54,799
所以

561
00:21:54,800 --> 00:21:57,400
这个商品模块的下线销售的时候

562
00:21:57,400 --> 00:22:00,366
就会把他所有的订单在一起去做完

563
00:22:00,733 --> 00:22:03,533
这是在社会层啊所做的

564
00:22:03,533 --> 00:22:04,733
这个逻辑其实也很简单

565
00:22:04,733 --> 00:22:06,099
就是三个这个逻辑

566
00:22:06,733 --> 00:22:07,999
那在稻城的话

567
00:22:08,000 --> 00:22:08,600
大家可以看到

568
00:22:08,600 --> 00:22:09,966
因为我们要去修改

569
00:22:10,966 --> 00:22:12,599
要去拿到当前的

570
00:22:14,200 --> 00:22:15,300
这个团购活动

571
00:22:15,300 --> 00:22:17,000
要去修改当前的团购活动

572
00:22:17,000 --> 00:22:18,700
所以各写了两个方法

573
00:22:18,866 --> 00:22:20,999
一个是拿到团购的活动

574
00:22:21,000 --> 00:22:22,333
一个是修改团购的活动

575
00:22:22,333 --> 00:22:23,599
大家可以看到

576
00:22:23,800 --> 00:22:26,333
在这里的收费指层和稻城的区分

577
00:22:26,333 --> 00:22:27,599
是已经能够看出来了

578
00:22:28,000 --> 00:22:30,466
稻城是针对对象模型的操作

579
00:22:30,466 --> 00:22:33,166
所以比如说我们最基本的新增啊

580
00:22:33,166 --> 00:22:34,399
修改啊这些操作

581
00:22:34,400 --> 00:22:35,366
会写的稻城

582
00:22:35,533 --> 00:22:37,199
但是Server层做的是什么呢

583
00:22:37,200 --> 00:22:38,133
做的是业务

584
00:22:38,133 --> 00:22:39,866
就是我们要下线一个

585
00:22:40,266 --> 00:22:41,199
下线一个

586
00:22:41,200 --> 00:22:43,300
团购活动的这些业务的代码

587
00:22:43,300 --> 00:22:44,933
他先要去拿到当前团购

588
00:22:44,933 --> 00:22:47,466
判断判当前团购能不能下线

589
00:22:47,666 --> 00:22:50,266
然后去修改这个团购的相关的信息

590
00:22:50,266 --> 00:22:52,799
然后去让商品的对应的也下线

591
00:22:53,200 --> 00:22:55,133
这一些业务是写的收费时成的

592
00:22:55,133 --> 00:22:56,899
就是我们在2010年的时候

593
00:22:57,100 --> 00:23:00,166
用评选模型这个分成的这个概念啊

594
00:23:00,166 --> 00:23:02,966
这个职责其实是有把它分得很清楚的

595
00:23:03,400 --> 00:23:05,066
所以这是它的收费时成

596
00:23:05,900 --> 00:23:08,333
这是它的这个稻城的代码

597
00:23:08,533 --> 00:23:11,499
那这是我们在另外一个模块的

598
00:23:11,700 --> 00:23:13,133
Goodle service里头

599
00:23:13,133 --> 00:23:14,599
下线商品的代码

600
00:23:15,266 --> 00:23:17,366
就是他要把所有的当前的销售

601
00:23:17,366 --> 00:23:19,066
跟团购有关的销售啊

602
00:23:19,066 --> 00:23:20,266
全部把它下线掉

603
00:23:20,366 --> 00:23:21,333
但这里还没有写

604
00:23:21,333 --> 00:23:23,299
说他要把所有的订单给他取消掉啊

605
00:23:23,300 --> 00:23:24,766
因为那时候并没有做的这么完善

606
00:23:24,766 --> 00:23:27,799
就仅仅是把所有的销售把它取消掉

607
00:23:28,800 --> 00:23:32,400
这是2零1一二零二一年写的这些代码

608
00:23:32,400 --> 00:23:33,400
中间大家可以看到

609
00:23:33,400 --> 00:23:36,133
我们为什么称它为评选模型

610
00:23:36,133 --> 00:23:39,133
是因为它所有的代码都在service层

611
00:23:39,133 --> 00:23:39,933
造成

612
00:23:40,400 --> 00:23:43,566
啊我们的bo对象或者do对象

613
00:23:43,600 --> 00:23:46,166
是只有get和shit方法的

614
00:23:46,266 --> 00:23:48,266
我们说这样的一种设计

615
00:23:49,133 --> 00:23:51,199
不是面向对象的设计

616
00:23:51,533 --> 00:23:56,366
为啥呢因为他完全没有用到任何的

617
00:23:56,366 --> 00:23:58,533
面向对象的设计的方法

618
00:23:58,666 --> 00:23:59,966
虽然用了加瓦语言

619
00:24:00,200 --> 00:24:01,566
虽然用了视频框架

620
00:24:01,566 --> 00:24:03,199
加瓦语言是面向对象的语言

621
00:24:03,200 --> 00:24:04,900
视频框架是面向对象的框架

622
00:24:05,266 --> 00:24:07,566
但是不见得你用了加瓦语言

623
00:24:07,566 --> 00:24:08,899
用了面向对象的框架

624
00:24:08,900 --> 00:24:10,166
你做出来的设计

625
00:24:10,533 --> 00:24:12,299
就是一个面向对象的设计

626
00:24:12,300 --> 00:24:15,166
因为这是完全是面向功能的设计

627
00:24:15,600 --> 00:24:19,000
就大家都很很容易理解的这个做法

628
00:24:19,166 --> 00:24:21,333
我们的b o对象就是数据

629
00:24:21,500 --> 00:24:23,400
我们的业务是分开的

630
00:24:23,400 --> 00:24:24,900
业务是写在service层

631
00:24:24,900 --> 00:24:26,000
写在稻城的

632
00:24:26,466 --> 00:24:28,533
所以b o对象被作为了

633
00:24:28,533 --> 00:24:29,866
我们在设置层

634
00:24:29,866 --> 00:24:31,533
和稻城的这些方法的参数

635
00:24:31,533 --> 00:24:32,199
传了进去

636
00:24:32,200 --> 00:24:33,600
然后用他的get收藏方法

637
00:24:33,600 --> 00:24:34,766
去得到他的数据

638
00:24:34,933 --> 00:24:36,566
业务写在了设费层和稻城

639
00:24:36,566 --> 00:24:38,766
哈这是2021年

640
00:24:39,333 --> 00:24:42,066
那经过了2022年和2023年

641
00:24:42,066 --> 00:24:42,399
就今年

642
00:24:42,400 --> 00:24:45,666
我其实把代码进行了2产品模块啊

643
00:24:45,666 --> 00:24:48,699
把2022年代码进行了完全部的重构

644
00:24:48,700 --> 00:24:49,666
全部改了一遍

645
00:24:50,466 --> 00:24:51,566
改完了以后啊

646
00:24:51,666 --> 00:24:52,533
我还没统计

647
00:24:52,533 --> 00:24:53,266
但是我估计

648
00:24:53,266 --> 00:24:55,966
我比原有代码减少了1/3以上

649
00:24:56,200 --> 00:24:56,933
就是我们说的

650
00:24:56,933 --> 00:25:00,899
设计的第一的目的就是要提高重用性

651
00:25:00,900 --> 00:25:03,800
你可以以比原来少1/3以上的代码

652
00:25:04,133 --> 00:25:06,133
实现比原来更强的功能

653
00:25:06,466 --> 00:25:08,133
这就是你软件设计的目的

654
00:25:08,133 --> 00:25:09,966
我们最后我把它最后全部调试通了

655
00:25:09,966 --> 00:25:10,999
以后会做一个对比

656
00:25:11,366 --> 00:25:13,499
跟去年的代码啊做一个对比

657
00:25:13,500 --> 00:25:13,866
那其

658
00:25:13,866 --> 00:25:16,499
实去年代码已经比前年代码少了1/3了

659
00:25:16,666 --> 00:25:16,999
所以

660
00:25:17,000 --> 00:25:19,533
现在的代码应该只有2021年代码的3

661
00:25:20,200 --> 00:25:22,533
总体代码的少于50%

662
00:25:22,600 --> 00:25:25,700
而做到比2021年代码更强大的功能

663
00:25:25,700 --> 00:25:28,866
这个就是我们软件设计的这个目的啊

664
00:25:29,500 --> 00:25:30,400
那今年的代码

665
00:25:30,400 --> 00:25:33,600
我们应把它完全改变成为充血模型

666
00:25:33,900 --> 00:25:35,466
也叫做fat model

667
00:25:36,000 --> 00:25:37,100
什么叫充血模型

668
00:25:37,100 --> 00:25:39,533
就是面向对象的一个最基本的概念

669
00:25:40,066 --> 00:25:42,866
数据和业务是不能分开的

670
00:25:43,466 --> 00:25:46,166
因为评选模型业务是写在service层

671
00:25:46,166 --> 00:25:47,166
写在稻城的

672
00:25:47,566 --> 00:25:51,133
数据是在bo对象里头的数

673
00:25:51,466 --> 00:25:53,266
数据和业务是分开的

674
00:25:53,366 --> 00:25:53,999
那我们知道

675
00:25:54,000 --> 00:25:54,933
面向对象的

676
00:25:54,966 --> 00:25:58,166
所有的设计的一个最基本的要求

677
00:25:58,600 --> 00:26:00,466
就是业务都要跟数据在一起

678
00:26:01,200 --> 00:26:02,966
业务都要封装数据

679
00:26:03,100 --> 00:26:05,166
然后你才能在业务上头去做

680
00:26:05,166 --> 00:26:07,999
很多的面向对象的这些设计

681
00:26:08,000 --> 00:26:10,766
比如说继承啊多态啊等等

682
00:26:10,900 --> 00:26:13,000
如果面向对象的东西

683
00:26:13,000 --> 00:26:14,500
就是一个get和set

684
00:26:14,766 --> 00:26:17,399
所有的继承多态就没有太大的意义

685
00:26:17,700 --> 00:26:18,700
我们说的多肽

686
00:26:18,700 --> 00:26:21,700
主要是指针对业务的扩展和变化

687
00:26:22,133 --> 00:26:23,699
那为了做到这一点

688
00:26:23,733 --> 00:26:28,133
我们就必须把业务通通的塞到Bo对象

689
00:26:28,166 --> 00:26:30,066
或者do对象里头来

690
00:26:30,733 --> 00:26:34,499
这个就是我们所说的充血模型

691
00:26:34,866 --> 00:26:35,366
当然

692
00:26:35,366 --> 00:26:38,299
因为受制于我们的整个的技术架构

693
00:26:38,366 --> 00:26:43,333
我们是没有办法把逻辑全部塞到Bo

694
00:26:43,466 --> 00:26:45,499
和或者do对象

695
00:26:45,733 --> 00:26:47,333
我们目前做的方式

696
00:26:47,333 --> 00:26:50,566
就是尽量把当前的逻辑

697
00:26:50,566 --> 00:26:55,166
从server层和稻城移到Bo对象里头去

698
00:26:55,900 --> 00:26:56,933
做完这一个

699
00:26:56,933 --> 00:26:58,366
就是这样的一个设计目标啊

700
00:26:58,366 --> 00:27:00,566
这其实是我们的设一个一个设计目标

701
00:27:00,566 --> 00:27:02,266
为了提高它的从用性

702
00:27:02,266 --> 00:27:03,866
为了提高它的扩展性

703
00:27:04,066 --> 00:27:06,166
所以我们把整个的设计

704
00:27:06,166 --> 00:27:08,066
做成了一个充血模型

705
00:27:08,600 --> 00:27:09,766
做完以后的效果是什么

706
00:27:09,766 --> 00:27:10,933
大家可以做一个对比

707
00:27:11,366 --> 00:27:16,266
这是我们的收费时辰的取消三行代码

708
00:27:17,333 --> 00:27:19,299
原来的收费值层的取消多少层代码

709
00:27:19,300 --> 00:27:20,200
大家可以看一下

710
00:27:20,866 --> 00:27:21,566
这不用数了吧

711
00:27:21,566 --> 00:27:24,899
一平我说减原来代码减少了50%

712
00:27:24,900 --> 00:27:26,666
都是很客气的

713
00:27:26,800 --> 00:27:29,166
但收费值层的代码减少的是更多

714
00:27:29,166 --> 00:27:32,533
大概只有原来的 1/5或者1/6

715
00:27:32,533 --> 00:27:33,566
甚至更少啊

716
00:27:33,566 --> 00:27:34,666
甚至更少的代码

717
00:27:34,766 --> 00:27:37,099
而且收藏的代码其实很清晰

718
00:27:37,933 --> 00:27:39,533
取消取消是要干嘛

719
00:27:39,533 --> 00:27:41,066
跟原来的逻辑是一样的

720
00:27:41,200 --> 00:27:41,466
第一

721
00:27:41,466 --> 00:27:43,766
我们首先要知道这个活动在不在

722
00:27:44,166 --> 00:27:46,566
所以我第一个第一行语句是

723
00:27:46,566 --> 00:27:48,466
去找到一个活动

724
00:27:48,466 --> 00:27:50,166
因为你说你要取消一个活动嘛

725
00:27:50,300 --> 00:27:51,333
这个活动首先要在

726
00:27:51,333 --> 00:27:52,799
是吧如果他不在的话

727
00:27:52,800 --> 00:27:54,700
他就不能取消

728
00:27:54,900 --> 00:27:56,166
其实这个第一行单码

729
00:27:56,166 --> 00:27:57,333
中间做了两件事情

730
00:27:57,333 --> 00:27:58,766
第一个是看到他在不在

731
00:27:58,966 --> 00:28:00,699
第二个是看你能不能取消

732
00:28:00,733 --> 00:28:02,799
比如说这是a商铺的活动

733
00:28:02,800 --> 00:28:03,533
b商铺的人

734
00:28:03,533 --> 00:28:05,199
是不能取消a商铺的活动的

735
00:28:05,366 --> 00:28:07,899
所以在翻的白ID这个方法中间

736
00:28:07,900 --> 00:28:09,300
他第一能找到这个东西

737
00:28:09,300 --> 00:28:10,333
第二他其实有判断

738
00:28:10,333 --> 00:28:12,166
说你能不能操作这个东西

739
00:28:12,766 --> 00:28:14,733
那如果说找到了这个东西

740
00:28:14,733 --> 00:28:16,599
在这个东西你也能操作

741
00:28:16,600 --> 00:28:17,900
那第二次你就简单了

742
00:28:17,933 --> 00:28:18,899
取消它就好了

743
00:28:19,466 --> 00:28:21,133
所以大家可以看到逻辑到哪去了

744
00:28:22,066 --> 00:28:24,299
逻辑到了activity里去了

745
00:28:24,900 --> 00:28:28,700
就是原本在身份证上写的

746
00:28:28,900 --> 00:28:30,266
洋洋洒洒的代码

747
00:28:30,600 --> 00:28:32,333
全部跑到了

748
00:28:32,500 --> 00:28:35,500
我们说的Bo和DTO对象中间去了

749
00:28:35,700 --> 00:28:38,700
就是在activity的Concel里头

750
00:28:39,166 --> 00:28:41,299
去把它取消就好了啊

751
00:28:41,300 --> 00:28:42,366
所以取消完了以后

752
00:28:42,366 --> 00:28:43,899
因为他把一切东西取消完了以后

753
00:28:43,900 --> 00:28:46,200
他需要返回一个什么呢

754
00:28:46,200 --> 00:28:48,166
返回我们的release里头缓存的对象

755
00:28:48,166 --> 00:28:50,099
因为我们的数据不仅仅存在数据库里

756
00:28:50,166 --> 00:28:52,366
我们还把数据缓存在内存里头

757
00:28:52,533 --> 00:28:54,966
这样的话人家在读的时候就会很快

758
00:28:55,133 --> 00:28:56,499
不用直接去读数据库

759
00:28:56,800 --> 00:28:58,933
所以这时候他实际上是会返回说

760
00:28:58,933 --> 00:28:59,999
他因为这次取消

761
00:29:00,000 --> 00:29:03,700
所造成的对于Radis数据的改变啊

762
00:29:03,700 --> 00:29:06,466
所以他会返回一个list的key

763
00:29:06,533 --> 00:29:09,099
然后我们把RES中间这些key全部删掉

764
00:29:09,100 --> 00:29:11,500
啊改变我们RES中间呃

765
00:29:11,500 --> 00:29:13,166
交叉交叉一直还没讲啊

766
00:29:13,166 --> 00:29:15,099
我们改变的时候我们不是去直接改

767
00:29:15,266 --> 00:29:17,399
而是把这些key全部给它删掉啊

768
00:29:17,400 --> 00:29:19,000
就完了三行代码

769
00:29:19,366 --> 00:29:20,466
大家已经能看到说

770
00:29:20,466 --> 00:29:21,733
这三行代码做的事情

771
00:29:21,733 --> 00:29:25,366
已经比我们在2021年的时已经更多了

772
00:29:25,500 --> 00:29:28,066
2021年完全没有考虑到缓存的问题啊

773
00:29:28,066 --> 00:29:29,699
这个其实我们已经做了缓存

774
00:29:30,100 --> 00:29:32,566
所以取消以后就把它全部删掉

775
00:29:33,600 --> 00:29:34,500
那所以这里头

776
00:29:34,500 --> 00:29:36,600
其实要看的代码就两个方法

777
00:29:36,600 --> 00:29:38,133
一个是find the BYD

778
00:29:38,500 --> 00:29:41,166
一个是activity是怎样取消的

779
00:29:41,466 --> 00:29:43,966
我们首先看一下它这个find the BYD

780
00:29:44,266 --> 00:29:46,299
find the BYD是一个重用的代码

781
00:29:47,133 --> 00:29:48,699
在2021年的时候

782
00:29:48,800 --> 00:29:51,300
我们的稻城是分开的

783
00:29:51,566 --> 00:29:54,766
比如说优惠活动和团购活动

784
00:29:55,300 --> 00:29:56,800
是完全两套代码

785
00:29:56,800 --> 00:29:58,933
因为是两个不同的Bo

786
00:29:59,500 --> 00:30:02,900
但是在今年我们把它做了重构

787
00:30:03,300 --> 00:30:05,966
把两个代码合到了一起

788
00:30:06,200 --> 00:30:07,866
而且把我们中间说的

789
00:30:07,866 --> 00:30:09,566
关于这个东西存不存在

790
00:30:10,766 --> 00:30:12,466
这个东西是不是能操作

791
00:30:12,566 --> 00:30:14,933
这两个判断写在这个里头了

792
00:30:15,166 --> 00:30:16,766
所以在所有的地方

793
00:30:16,766 --> 00:30:18,666
当你要去拿到一个活动的时候

794
00:30:18,666 --> 00:30:19,499
他都会告诉你说

795
00:30:19,500 --> 00:30:21,666
这个活动是你能不能操作的

796
00:30:22,000 --> 00:30:24,766
这个活动是这个活动对象是不是在

797
00:30:24,933 --> 00:30:25,299
那这里

798
00:30:25,300 --> 00:30:26,700
为什么分成了两批啊

799
00:30:26,700 --> 00:30:28,300
大家可以看到分成了两部分

800
00:30:28,466 --> 00:30:30,199
原因是因为这个里头

801
00:30:30,200 --> 00:30:31,666
我们去拿一个东西的时候

802
00:30:31,666 --> 00:30:33,466
他有可能从缓存里拿

803
00:30:33,866 --> 00:30:34,999
有可能缓存里没有

804
00:30:35,000 --> 00:30:35,866
就从数据库里拿

805
00:30:35,866 --> 00:30:37,799
数据库拿完以后再放到缓存里头

806
00:30:37,933 --> 00:30:40,299
所以上半段是直接在缓存里找到了它

807
00:30:40,300 --> 00:30:41,400
所以就把它拿出来了

808
00:30:42,000 --> 00:30:43,333
拿出来以后啊

809
00:30:43,966 --> 00:30:45,866
拿出来以后就直接返回了

810
00:30:46,066 --> 00:30:46,866
下半段是什么呢

811
00:30:46,866 --> 00:30:47,599
是缓存里没有

812
00:30:47,600 --> 00:30:48,933
那么就去数据库里去找

813
00:30:49,166 --> 00:30:52,099
如果数据库里能找到啊

814
00:30:52,100 --> 00:30:53,866
那就把数据库里拿出来

815
00:30:53,933 --> 00:30:54,999
再放到缓存里

816
00:30:55,000 --> 00:30:57,366
所以大家可以看到整体的代码啊

817
00:30:57,366 --> 00:30:58,466
把它分成了

818
00:30:59,000 --> 00:31:00,566
分成了两个部分啊

819
00:31:00,566 --> 00:31:01,733
分成了两个部分

820
00:31:02,900 --> 00:31:05,866
这是我们的find by ID啊

821
00:31:05,866 --> 00:31:07,599
就是用ID找到这个对象

822
00:31:07,600 --> 00:31:09,133
大家注意看这个方法中间

823
00:31:09,133 --> 00:31:09,933
其实我们的这里头

824
00:31:09,933 --> 00:31:13,333
Java里头呃应该用到的加瓦知识

825
00:31:13,333 --> 00:31:14,799
是目前大家能看到的

826
00:31:14,933 --> 00:31:16,599
基本上所有的加瓦知识都用到了

827
00:31:16,600 --> 00:31:17,600
这是一个什么呢

828
00:31:17,766 --> 00:31:19,166
这是个模板方法

829
00:31:19,366 --> 00:31:22,533
就是他是定义了他的返回值

830
00:31:22,533 --> 00:31:24,066
是一个模板

831
00:31:24,533 --> 00:31:27,199
就是可以是activity的一个酯类

832
00:31:27,500 --> 00:31:29,333
所以我们其实有若干个酯类

833
00:31:29,333 --> 00:31:32,066
都可以用同样的这一组方法去完成啊

834
00:31:33,400 --> 00:31:34,933
这是它的find吧ID

835
00:31:35,066 --> 00:31:37,666
那这是它的这个取消

836
00:31:38,133 --> 00:31:38,799
大家会发现

837
00:31:38,800 --> 00:31:41,933
在这里这取消变得很简单

838
00:31:42,266 --> 00:31:45,766
我要取消一个团购活动啊

839
00:31:46,066 --> 00:31:49,299
所以我首先去拿到当前这个团购活动

840
00:31:49,300 --> 00:31:50,866
所有的销售

841
00:31:50,866 --> 00:31:52,799
因为我们可以有多个东西

842
00:31:53,166 --> 00:31:54,499
在一个活动中间

843
00:31:54,500 --> 00:31:55,700
所以第一行代码是

844
00:31:55,733 --> 00:31:58,866
把所有的销售全部拿到

845
00:31:59,100 --> 00:32:02,600
然后得到当前的时间啊得

846
00:32:02,600 --> 00:32:03,366
到那个时间怎么办

847
00:32:03,366 --> 00:32:04,999
就把这些所有的销售

848
00:32:05,133 --> 00:32:06,799
一个一个的去取消

849
00:32:06,800 --> 00:32:09,600
代就这行代码是循环

850
00:32:09,600 --> 00:32:11,166
这个拿到的所有销售

851
00:32:11,200 --> 00:32:15,066
一个一个的去取消这些销售啊

852
00:32:15,066 --> 00:32:18,499
所以所有的销售都取消了以后

853
00:32:18,766 --> 00:32:23,133
然后把取消这些销售所造成的redisk

854
00:32:23,133 --> 00:32:24,766
key的影响

855
00:32:24,766 --> 00:32:26,199
把它放到一个列表中间

856
00:32:26,200 --> 00:32:28,100
然后把这个列表返回去就好了

857
00:32:28,500 --> 00:32:31,333
这个就是我们所说的取消

858
00:32:32,300 --> 00:32:33,300
大家可以看到

859
00:32:33,300 --> 00:32:34,333
我们这里头的代码

860
00:32:34,333 --> 00:32:37,366
又没有平面的写在了取消里头

861
00:32:37,366 --> 00:32:39,799
我们把它分成了我们的活动的取消

862
00:32:40,066 --> 00:32:42,266
就是本身自己的活动的取消

863
00:32:42,466 --> 00:32:44,966
和活活动相关的销售的取消

864
00:32:44,966 --> 00:32:45,999
分成两个事情

865
00:32:46,133 --> 00:32:48,933
而销售的取消又交给了销售去做

866
00:32:49,200 --> 00:32:50,000
所以

867
00:32:51,933 --> 00:32:52,733
这是

868
00:32:53,933 --> 00:32:56,599
这是这个on sell到的

869
00:32:56,866 --> 00:32:58,599
就是要找销售去做啊

870
00:32:58,600 --> 00:32:59,600
销售的这个取消

871
00:32:59,600 --> 00:33:01,366
我们这里就没有把代码截上来了

872
00:33:01,666 --> 00:33:02,899
但这里我们可以看到

873
00:33:02,900 --> 00:33:04,066
最后完成以后

874
00:33:04,066 --> 00:33:07,566
我们会把所有的销售都进行修改啊

875
00:33:07,566 --> 00:33:07,766
所以

876
00:33:07,766 --> 00:33:10,599
我们把销售的修改的方法也放到这了

877
00:33:10,666 --> 00:33:12,766
这就是稻城的最常用的方法

878
00:33:12,766 --> 00:33:13,566
就是正常改

879
00:33:13,566 --> 00:33:14,466
查对吧

880
00:33:14,466 --> 00:33:16,999
就针对我们对象模型的查的话

881
00:33:17,000 --> 00:33:18,000
把它构建出来

882
00:33:18,000 --> 00:33:20,900
其他的针和三啊和改

883
00:33:20,900 --> 00:33:22,133
这个大家都很理解

884
00:33:22,133 --> 00:33:23,866
这就是它的一个改的这个操作

885
00:33:23,866 --> 00:33:25,066
这个safe的操作

886
00:33:25,333 --> 00:33:27,066
当然它不是简单的改

887
00:33:28,066 --> 00:33:30,933
我们把一些的业务逻辑也放到稻城了

888
00:33:31,133 --> 00:33:33,133
当我们去修改一个销售的时候

889
00:33:33,133 --> 00:33:34,133
我们有个业务逻辑

890
00:33:34,133 --> 00:33:35,066
就这个销售

891
00:33:35,066 --> 00:33:38,366
同一个商品的销售时间是不能冲突的

892
00:33:38,700 --> 00:33:40,966
比如说我这个商品我卖这个手机

893
00:33:40,966 --> 00:33:41,899
卖这个手机

894
00:33:41,900 --> 00:33:42,700
这个商品

895
00:33:42,866 --> 00:33:45,533
我从十一月一号到十一月一号

896
00:33:45,533 --> 00:33:46,599
我卖一个价格

897
00:33:46,800 --> 00:33:47,566
那同一个

898
00:33:47,566 --> 00:33:48,099
时间

899
00:33:48,100 --> 00:33:51,766
我不能说从十月二十号到十一月五号

900
00:33:51,766 --> 00:33:52,866
又卖另外一个价格

901
00:33:52,866 --> 00:33:53,133
就是

902
00:33:53,133 --> 00:33:56,366
它会造成我这个商品的时间冲突了

903
00:33:56,366 --> 00:33:58,866
他不能在一个时间有两种价格

904
00:33:58,866 --> 00:34:00,066
两种销售方式

905
00:34:00,066 --> 00:34:01,866
这是我们系统的一个逻辑

906
00:34:02,133 --> 00:34:04,499
所以当我们要去存一个销售

907
00:34:04,500 --> 00:34:06,500
要去修改一个销售的时候

908
00:34:06,500 --> 00:34:10,133
这个方法被调用在我们的取消里头

909
00:34:10,133 --> 00:34:11,133
是因为我们取消的话

910
00:34:11,133 --> 00:34:13,133
会改那个销售的属性

911
00:34:13,333 --> 00:34:15,499
所以我们会调到成的save的方法

912
00:34:15,500 --> 00:34:16,800
去改它的属性

913
00:34:17,133 --> 00:34:18,166
在改它的属性的时候

914
00:34:18,166 --> 00:34:19,133
我们还要判断说

915
00:34:19,133 --> 00:34:21,899
这个属性会不会造成它的时间冲突

916
00:34:22,000 --> 00:34:23,933
所以我们写了一个private的方法

917
00:34:23,933 --> 00:34:26,766
在上面还是conflict on sale

918
00:34:26,800 --> 00:34:28,500
就是这改了以后的这个属性

919
00:34:28,500 --> 00:34:31,400
跟现有的on sale的对象是不是会冲突

920
00:34:31,400 --> 00:34:32,333
如果会冲突的话

921
00:34:32,333 --> 00:34:34,699
他就会抛出一个啊good on sale

922
00:34:34,700 --> 00:34:36,133
conflict的exception啊

923
00:34:36,133 --> 00:34:37,166
所以他就直接会跳出去

924
00:34:37,166 --> 00:34:37,966
就不能存

925
00:34:38,133 --> 00:34:39,466
如果没有冲突的话

926
00:34:39,466 --> 00:34:41,199
我们可以看到下面就是在改头的属性

927
00:34:41,700 --> 00:34:44,566
就是把它的属性把它改过来

928
00:34:44,666 --> 00:34:46,199
大家这里也能看到说

929
00:34:46,200 --> 00:34:48,766
我们是如何把一个Bo对象

930
00:34:49,200 --> 00:34:51,466
转化成为一个Po对象

931
00:34:51,500 --> 00:34:52,300
就这样的

932
00:34:52,966 --> 00:34:56,599
这个就是我们在上周四的时候讲到的

933
00:34:56,900 --> 00:34:58,466
去年陈一鸣同学所做的

934
00:34:58,466 --> 00:35:00,966
自动生成的cloud object copy

935
00:35:01,133 --> 00:35:02,266
这个代码不是手写的

936
00:35:02,266 --> 00:35:03,699
就这个copy是个方法

937
00:35:04,100 --> 00:35:07,100
整个cloud factory的这个类

938
00:35:07,100 --> 00:35:08,900
我们是不是我们写的

939
00:35:09,300 --> 00:35:11,500
就是由陈一鸣同学写的代码

940
00:35:11,566 --> 00:35:13,099
在我们的代码被编译之前

941
00:35:13,100 --> 00:35:14,100
他自动生成的

942
00:35:14,200 --> 00:35:16,766
所以他自动会生成cloud object的任意的

943
00:35:16,766 --> 00:35:18,199
你想要copy的东西

944
00:35:18,500 --> 00:35:19,666
然后我们在这儿我们

945
00:35:19,666 --> 00:35:20,866
在业务代码中间

946
00:35:20,866 --> 00:35:23,866
其实就很简单的去把一个b o对象

947
00:35:23,866 --> 00:35:25,099
RCL是一个b o对象

948
00:35:25,166 --> 00:35:26,999
我们实力画出一个PO对象

949
00:35:27,000 --> 00:35:29,400
把b o对象的属性考到PO对象

950
00:35:29,400 --> 00:35:31,500
然后把它返回变成PO对象

951
00:35:31,500 --> 00:35:33,200
然后PO对象用来到map中间

952
00:35:33,200 --> 00:35:34,266
去存数据库了

953
00:35:34,466 --> 00:35:36,499
因为在map中间

954
00:35:36,500 --> 00:35:37,800
Po对象对应的就是一张表

955
00:35:37,800 --> 00:35:39,666
所以map里头是没有代码的

956
00:35:39,766 --> 00:35:43,366
map如果说是用呃my betas的话

957
00:35:43,366 --> 00:35:44,266
自动生成的

958
00:35:44,600 --> 00:35:45,933
如果是用GPA的话

959
00:35:46,000 --> 00:35:47,266
它就一行代码都不要写

960
00:35:47,266 --> 00:35:48,966
因为它本身就已经做好做完了

961
00:35:49,100 --> 00:35:50,800
所以那个map中间是没有任何代码的

962
00:35:50,800 --> 00:35:52,133
就直接调头的方法刷

963
00:35:52,133 --> 00:35:53,866
就存到数据库里去了啊

964
00:35:53,866 --> 00:35:55,999
然后存了以后它会有返回一个值

965
00:35:56,000 --> 00:35:59,066
就是如果因为存的时候它是带ID的

966
00:35:59,100 --> 00:35:59,533
存的时候

967
00:35:59,533 --> 00:36:01,466
如果那个数据表里头没有那条记录

968
00:36:01,466 --> 00:36:04,366
它会返回一个Excel的non exist

969
00:36:04,600 --> 00:36:06,566
这表示说那原来的那个Excel是没有的

970
00:36:06,566 --> 00:36:07,666
所以它要跑到另外一个错误

971
00:36:07,666 --> 00:36:08,733
就是你存的时候

972
00:36:09,166 --> 00:36:10,466
这个对象是不存在的啊

973
00:36:10,466 --> 00:36:12,533
因为他的组件ID是没有的

974
00:36:12,533 --> 00:36:15,099
所以你去update他没有这条记录

975
00:36:15,100 --> 00:36:16,500
所以他现在是没有纯成功的

976
00:36:16,500 --> 00:36:17,766
要抛一个商品出来

977
00:36:18,266 --> 00:36:20,933
然后返回说他要删除的key是什么

978
00:36:20,933 --> 00:36:24,366
这就是我们的这个稻城的代码

979
00:36:25,666 --> 00:36:27,299
跟大家讲一下这个代码啊

980
00:36:27,300 --> 00:36:28,333
讲了这个代码以后

981
00:36:28,333 --> 00:36:31,199
大家应该对于我们前面这个领域模型

982
00:36:31,466 --> 00:36:34,399
应该有了一个初步的认识

983
00:36:34,500 --> 00:36:35,933
我们在刚才讲的代码中间

984
00:36:35,933 --> 00:36:37,866
其实涉及到了我们的service层

985
00:36:37,866 --> 00:36:38,933
涉及到了我们盗层

986
00:36:38,933 --> 00:36:40,166
涉及到我们的map层

987
00:36:40,566 --> 00:36:41,499
因为control指层

988
00:36:41,500 --> 00:36:43,600
其实是跟面向对象没什么关系的

989
00:36:43,666 --> 00:36:46,466
我们的面向对象最基本的起始的地方

990
00:36:46,466 --> 00:36:48,133
其实就在社会指层和稻城

991
00:36:48,666 --> 00:36:49,666
大家有看到说

992
00:36:49,666 --> 00:36:51,066
我们今年代码中间

993
00:36:51,566 --> 00:36:52,799
身份子层和稻层

994
00:36:52,800 --> 00:36:55,500
有了一个非常明显的区分

995
00:36:55,900 --> 00:36:58,333
身份子层是我们的起点

996
00:36:58,500 --> 00:37:00,866
稻层其实就是负责我们的对象的

997
00:37:00,866 --> 00:37:01,666
正常改查

998
00:37:02,133 --> 00:37:02,599
其实就这么简

999
00:37:02,600 --> 00:37:03,933
就对向的真三改查

1000
00:37:04,133 --> 00:37:08,399
当然真三改这个是相对比较固定的

1001
00:37:08,766 --> 00:37:11,566
查就会有各种各样不同的需求

1002
00:37:11,933 --> 00:37:13,966
所以真山改一般就是三个方法

1003
00:37:14,133 --> 00:37:16,333
但是查的话会有很多方法

1004
00:37:16,366 --> 00:37:17,666
因为我们上面的业务

1005
00:37:17,666 --> 00:37:18,799
会对我们的对象

1006
00:37:18,800 --> 00:37:22,200
有各种各样不同的查询的方请求

1007
00:37:22,400 --> 00:37:24,300
所以他就会产生很多的对象

1008
00:37:24,600 --> 00:37:27,600
无论是这个真山改还是查

1009
00:37:28,166 --> 00:37:31,166
里头都只有最基本的CRUD的业务

1010
00:37:31,400 --> 00:37:31,766
也就是说

1011
00:37:31,766 --> 00:37:33,899
如果我们的业务只是CRUD的话

1012
00:37:33,900 --> 00:37:35,333
收费城市完全没有代码的

1013
00:37:35,333 --> 00:37:37,999
就靠稻城的侦探改查就能完成

1014
00:37:38,333 --> 00:37:41,566
但是如果说我们的代码是有业务的

1015
00:37:41,766 --> 00:37:42,133
这时候

1016
00:37:42,133 --> 00:37:45,266
你能看到我们中间的Bo对象的作用了

1017
00:37:46,933 --> 00:37:50,899
我们的Bo对象就装满了我们的业务

1018
00:37:50,900 --> 00:37:51,600
我说的业务

1019
00:37:51,600 --> 00:37:54,166
就是除了正常改查以外的其他的业务

1020
00:37:54,166 --> 00:37:55,666
被装到了这个Bo对象

1021
00:37:55,666 --> 00:37:56,999
比如我刚才看到的取消

1022
00:37:57,566 --> 00:37:58,666
取消这里头

1023
00:37:58,666 --> 00:38:00,599
他涉及到了说他要取

1024
00:38:00,600 --> 00:38:02,066
看当前能不能取消

1025
00:38:02,300 --> 00:38:04,166
他要把他相关的销售去取消

1026
00:38:04,166 --> 00:38:05,533
这就是我们说的征山

1027
00:38:05,533 --> 00:38:07,933
改查以外的这些业务

1028
00:38:08,200 --> 00:38:10,133
就被放到了这些bo对象里头

1029
00:38:10,700 --> 00:38:13,166
这个就是我们今年所说的充血模型

1030
00:38:13,366 --> 00:38:17,866
就是你可以理解Bo对象不再是原来的

1031
00:38:17,866 --> 00:38:18,899
只有get和

1032
00:38:18,900 --> 00:38:19,700
say的方法

1033
00:38:19,866 --> 00:38:22,999
而是往里头打满了积雪的肥模型

1034
00:38:23,466 --> 00:38:26,999
我们所有的面向对象的设计的方法

1035
00:38:27,133 --> 00:38:31,733
都是基于一个充血的Bo对象来讲的

1036
00:38:32,000 --> 00:38:33,900
如果Bo对象不充血

1037
00:38:34,300 --> 00:38:36,400
那就没有面向对象设计

1038
00:38:36,600 --> 00:38:37,666
就换句话说

1039
00:38:37,933 --> 00:38:39,899
在我们的Supreme这个价格中间

1040
00:38:39,900 --> 00:38:42,700
其实已经存在了十多年了

1041
00:38:43,300 --> 00:38:44,533
为什么近三年

1042
00:38:44,533 --> 00:38:47,266
基于领域驱动的设计方法

1043
00:38:47,266 --> 00:38:51,066
会如此受到追捧因为

1044
00:38:52,466 --> 00:38:53,733
这个基于领域

1045
00:38:53,733 --> 00:38:55,366
就DAD的这种设计方法

1046
00:38:55,666 --> 00:38:58,533
第一次让我们的面向对象的设计

1047
00:38:58,666 --> 00:39:01,533
能够用到了Supreme的架构上

1048
00:39:01,733 --> 00:39:03,599
就是在这种控制器层

1049
00:39:03,600 --> 00:39:06,366
服务层到层和map层的这种架构上头

1050
00:39:07,366 --> 00:39:08,999
他第一次提出了说

1051
00:39:09,100 --> 00:39:10,866
我们的设计目标

1052
00:39:10,966 --> 00:39:14,999
是要做一个充满血的do对象

1053
00:39:15,166 --> 00:39:16,266
或者do对象

1054
00:39:16,333 --> 00:39:20,199
你只有把do对象或者do对象充满血了

1055
00:39:20,900 --> 00:39:23,666
所有的面向对象设计才能做得出来

1056
00:39:23,900 --> 00:39:25,533
要不然他就做不出来啊

1057
00:39:25,800 --> 00:39:28,666
所以这是我们的这个对象模型

1058
00:39:29,066 --> 00:39:31,366
评选模型和冲选模型

1059
00:39:31,600 --> 00:39:33,266
我先用代码给大家讲一下

1060
00:39:33,266 --> 00:39:35,366
让大家有一个基本的认识啊

1061
00:39:35,366 --> 00:39:36,333
但大家知道

1062
00:39:36,400 --> 00:39:39,800
我们的设计过程不是直接写代码的

1063
00:39:40,300 --> 00:39:41,200
大家可以看到

1064
00:39:41,300 --> 00:39:43,100
看到如此多的代码

1065
00:39:43,466 --> 00:39:44,933
你会想说在设计的时候

1066
00:39:44,933 --> 00:39:46,066
他需要画多少图

1067
00:39:47,100 --> 00:39:47,933
待会就能看到

1068
00:39:47,933 --> 00:39:52,199
我们把2023年的这个设计用图画出来

1069
00:39:53,266 --> 00:39:54,599
画图的过程啊

1070
00:39:54,600 --> 00:39:56,266
就是我们设计过程

1071
00:39:56,266 --> 00:40:00,533
其实分为静态建模和动态建模的过程

1072
00:40:00,866 --> 00:40:01,466
静态建模

1073
00:40:01,466 --> 00:40:04,066
其实我们之前已经看到过了

1074
00:40:04,066 --> 00:40:05,499
比如说我们知道类图

1075
00:40:05,533 --> 00:40:08,733
描述类和接口之间的关系

1076
00:40:09,000 --> 00:40:12,266
部署图组件图均属于静态建模

1077
00:40:12,466 --> 00:40:14,299
为什么叫静态建模

1078
00:40:14,300 --> 00:40:17,166
因为它不是系统跑起来时的逻

1079
00:40:17,166 --> 00:40:19,799
辑就是当你拿到一份代码

1080
00:40:19,900 --> 00:40:23,000
你看到了这份代码不是跑起来的状况

1081
00:40:23,200 --> 00:40:24,766
你看到的就是它有多少类

1082
00:40:24,766 --> 00:40:25,666
有多少接口

1083
00:40:25,666 --> 00:40:27,799
这些类和接口之间的关系

1084
00:40:28,133 --> 00:40:30,099
这个部分我们称之为静态介目

1085
00:40:30,266 --> 00:40:31,599
而另外一大半

1086
00:40:31,666 --> 00:40:33,399
应该说它的血肉

1087
00:40:34,066 --> 00:40:35,766
是我们说的动态建模

1088
00:40:35,933 --> 00:40:36,933
那这东西是什么呢

1089
00:40:36,933 --> 00:40:37,466
这东西就是

1090
00:40:37,466 --> 00:40:40,399
我们在每一个方法里头的内容

1091
00:40:40,933 --> 00:40:43,299
就是我们动态建模要做的事情

1092
00:40:43,566 --> 00:40:46,499
动态建模主要会用到我们说的两种图

1093
00:40:46,500 --> 00:40:48,366
一种是交互图

1094
00:40:48,400 --> 00:40:50,000
一种是状态基图

1095
00:40:50,000 --> 00:40:52,766
用来描述我们动态建模的设计

1096
00:40:53,166 --> 00:40:54,466
活动图也会用到

1097
00:40:54,466 --> 00:40:56,566
活动图我们在之前所看到的活动图

1098
00:40:56,566 --> 00:40:57,333
用的是什么呢

1099
00:40:57,333 --> 00:40:59,866
用的是业务流程建模

1100
00:41:00,400 --> 00:41:02,700
那如果说在动态建模中间

1101
00:41:02,700 --> 00:41:03,900
要用活动图的话

1102
00:41:03,900 --> 00:41:06,200
他描述的就大家非常熟悉的

1103
00:41:06,566 --> 00:41:08,299
程序流程图啊

1104
00:41:08,300 --> 00:41:10,200
这个我们在我们这么克里斯

1105
00:41:10,200 --> 00:41:12,200
就不去讲说活动图

1106
00:41:12,200 --> 00:41:14,100
怎么去画程序流程图了啊

1107
00:41:14,100 --> 00:41:18,266
我们主要是讲的交互图和状态图

1108
00:41:18,666 --> 00:41:20,366
因为我们强调什么呢

1109
00:41:20,366 --> 00:41:22,766
强调代码的制毒性

1110
00:41:23,200 --> 00:41:24,466
就是你代码写的好

1111
00:41:24,466 --> 00:41:27,333
你不需要再画一张流程图去描述

1112
00:41:27,333 --> 00:41:29,199
说那个代码是什么含义了

1113
00:41:29,333 --> 00:41:31,399
应该任何人一眼看那个代码

1114
00:41:31,400 --> 00:41:32,533
就应该很清楚

1115
00:41:32,666 --> 00:41:34,199
比如说我们给大家看到的

1116
00:41:34,200 --> 00:41:36,933
2021年所改过的代码

1117
00:41:37,300 --> 00:41:38,466
同样的逻辑

1118
00:41:38,766 --> 00:41:40,699
两份代码对比起来

1119
00:41:40,866 --> 00:41:42,499
大家应该能够感觉到说

1120
00:41:42,500 --> 00:41:45,266
2023年的这个代码的可读性更好

1121
00:41:45,366 --> 00:41:47,199
也就是他的每一个方法内部

1122
00:41:47,200 --> 00:41:50,966
其实是不需要去花很长时间去研读的

1123
00:41:51,600 --> 00:41:53,533
一个特征就是每一个方法都很短

1124
00:41:53,533 --> 00:41:54,599
大家可以看到没有

1125
00:41:54,600 --> 00:41:56,333
每一个方法基本上都在10行

1126
00:41:56,333 --> 00:41:57,866
或者20行以内

1127
00:41:58,066 --> 00:42:01,266
所以基本上你一眼看这个方法大概5

1128
00:42:01,266 --> 00:42:01,933
秒到6秒

1129
00:42:01,933 --> 00:42:02,733
你就会知道啊

1130
00:42:02,733 --> 00:42:04,366
这个方法是做了些主要的

1131
00:42:04,366 --> 00:42:05,733
是一些什么样的事情

1132
00:42:05,900 --> 00:42:10,366
但是你可以看到在2021年的时候

1133
00:42:10,366 --> 00:42:13,466
这个代码其实就没有在2023年这么好读

1134
00:42:13,766 --> 00:42:14,933
代码越长

1135
00:42:14,933 --> 00:42:18,166
你就越需要程序流程图

1136
00:42:18,400 --> 00:42:19,200
去描述

1137
00:42:19,200 --> 00:42:22,300
这一个方法里头的流程是什么

1138
00:42:22,666 --> 00:42:23,099
所以

1139
00:42:23,100 --> 00:42:25,700
因为我们的面向对象的设计的目标

1140
00:42:25,700 --> 00:42:27,733
就是追求短方法

1141
00:42:28,200 --> 00:42:30,333
所以我们在动态建模中间

1142
00:42:30,666 --> 00:42:33,199
也就不提倡大家用活动图

1143
00:42:33,200 --> 00:42:37,200
去描述一个方法里头的程序流程

1144
00:42:37,200 --> 00:42:38,266
那个没有必要

1145
00:42:38,300 --> 00:42:41,800
我们追求的是一个方法里头的代码

1146
00:42:42,266 --> 00:42:43,166
不需要画图

1147
00:42:43,166 --> 00:42:45,699
一眼就能看懂它是什么样的含义

1148
00:42:45,933 --> 00:42:47,266
所以我们主要就讲

1149
00:42:47,266 --> 00:42:50,799
我们的交互图和状态基图

1150
00:42:51,766 --> 00:42:52,999
啊快下课了

1151
00:42:54,400 --> 00:42:55,600
给他最后看一下吧

1152
00:42:55,933 --> 00:42:58,966
这个就是我们的那边的是动态芥末

1153
00:42:59,100 --> 00:43:00,533
这边的是静态芥末

1154
00:43:00,666 --> 00:43:02,966
动态芥末和静态芥末没有先后

1155
00:43:03,933 --> 00:43:04,866
是一起干的

1156
00:43:05,266 --> 00:43:08,733
就是大家现在看到的我们的这个模型

1157
00:43:08,800 --> 00:43:11,266
是我先给大家看到了我们的静态芥末

1158
00:43:11,266 --> 00:43:13,533
然后我再给大家看动态芥末大

1159
00:43:13,533 --> 00:43:16,099
但大家在做的时候其实是没有先后的

1160
00:43:16,100 --> 00:43:19,966
因为你会有一个粗略的静态模型

1161
00:43:20,133 --> 00:43:21,899
然后你会去做他的动态建模

1162
00:43:21,900 --> 00:43:22,866
做的过程中间

1163
00:43:22,866 --> 00:43:23,999
每一个方法做的过程中间

1164
00:43:24,000 --> 00:43:25,700
发现这个东西是有问题的

1165
00:43:25,733 --> 00:43:26,999
就会不断的修改它

1166
00:43:27,466 --> 00:43:29,866
所以我们在实际做的时候啊

1167
00:43:29,866 --> 00:43:31,733
就是实际在做设计的时候

1168
00:43:31,733 --> 00:43:33,099
我们会用很多的屏幕

1169
00:43:33,100 --> 00:43:33,866
如果没有屏幕

1170
00:43:33,866 --> 00:43:34,933
就用很多张纸

1171
00:43:35,333 --> 00:43:36,466
或者用大黑板

1172
00:43:36,700 --> 00:43:39,966
把所有的模型全部贴在那个指

1173
00:43:40,266 --> 00:43:41,199
那个墙上

1174
00:43:41,566 --> 00:43:44,466
然后去动态的去做修改啊

1175
00:43:44,466 --> 00:43:47,066
所以这是我们的这样的一个建模过程

1176
00:43:47,066 --> 00:43:48,766
当然现在大家更多的看到都是用

1177
00:43:48,800 --> 00:43:49,600
软件化的

1178
00:43:49,800 --> 00:43:52,566
所以干这个事情就是要屏幕多啊

1179
00:43:52,566 --> 00:43:54,266
就是你最好有三块屏幕

1180
00:43:54,266 --> 00:43:54,733
四块屏幕

1181
00:43:54,733 --> 00:43:55,533
五块屏幕

1182
00:43:55,866 --> 00:43:57,499
每一张图放在不同的屏幕上头

1183
00:43:57,500 --> 00:43:59,866
然后你就可以建模时候

1184
00:43:59,866 --> 00:44:01,266
就可以并行来做啊

1185
00:44:01,466 --> 00:44:03,966
一个屏幕干起来确实挺辛苦的

1186
00:44:04,000 --> 00:44:05,300
好我们先休息一会

