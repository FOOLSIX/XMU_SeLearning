1
00:01:20,566 --> 00:01:21,266
呃上周

2
00:01:21,266 --> 00:01:25,299
我们有在周三讲了他的对象模型啊

3
00:01:25,300 --> 00:01:27,166
但是没有讲完

4
00:01:27,400 --> 00:01:29,066
那我呃

5
00:01:29,066 --> 00:01:29,766
在讲完之后

6
00:01:29,766 --> 00:01:31,199
其实对这个对象模型

7
00:01:31,200 --> 00:01:33,766
有了一定的更新啊

8
00:01:33,766 --> 00:01:35,566
我又为简要的讲一下

9
00:01:35,566 --> 00:01:39,699
这个跟上周三讲的版本的差异啊

10
00:01:39,966 --> 00:01:41,333
第一是产品模型

11
00:01:41,666 --> 00:01:44,599
产品的概念模型中间加入了草稿产品

12
00:01:45,133 --> 00:01:46,499
这个原因是因为

13
00:01:46,500 --> 00:01:51,366
对于这些产品的新增和修改

14
00:01:51,366 --> 00:01:53,299
是不能直接改到这个上面的

15
00:01:53,300 --> 00:01:56,666
是需要说先由平台管理员审核

16
00:01:57,300 --> 00:01:58,166
审核通过了

17
00:01:58,166 --> 00:02:00,499
才会把这个产品把它放上去

18
00:02:00,733 --> 00:02:02,566
所以特别是在修改的时候啊

19
00:02:02,566 --> 00:02:04,599
他其实是把要修改的东西

20
00:02:04,600 --> 00:02:05,800
放到这个概念里头

21
00:02:05,800 --> 00:02:07,366
这就是他要修改的东西

22
00:02:07,566 --> 00:02:09,666
然后经过审核以后才能过去

23
00:02:09,666 --> 00:02:11,333
那既然修改是这么做的

24
00:02:11,333 --> 00:02:12,499
新增也就是这样的

25
00:02:12,500 --> 00:02:13,766
所以新增的时候

26
00:02:14,366 --> 00:02:15,533
新增加一个商品时候

27
00:02:15,533 --> 00:02:16,766
也是放在这个里面

28
00:02:16,766 --> 00:02:17,933
然后通过了啊

29
00:02:17,933 --> 00:02:20,099
才能到这个产品里去

30
00:02:20,366 --> 00:02:22,866
所以在领域模型和对象模型当中

31
00:02:22,866 --> 00:02:24,666
都增加了这样的一个概念

32
00:02:25,133 --> 00:02:26,866
然后在状态基图里头

33
00:02:26,866 --> 00:02:28,399
原来我们的最初始状态

34
00:02:28,400 --> 00:02:29,933
我是没有写动作的

35
00:02:29,933 --> 00:02:32,299
就是没有写事件啊

36
00:02:32,300 --> 00:02:33,400
在这一版里头

37
00:02:33,400 --> 00:02:35,800
把他的所有的初始动作

38
00:02:35,800 --> 00:02:38,200
都把事件把它补上去了

39
00:02:38,333 --> 00:02:39,933
这样的话就会更加清晰一点

40
00:02:39,933 --> 00:02:41,199
比如说我们说活动

41
00:02:41,200 --> 00:02:42,800
活动什么时候会到新建态

42
00:02:42,800 --> 00:02:44,766
就是当店铺的管理员

43
00:02:44,766 --> 00:02:46,066
新建一个活动的时候

44
00:02:46,066 --> 00:02:48,566
这个活动就是处于新建的状态啊

45
00:02:48,566 --> 00:02:53,966
所以把他的初始的这个事件

46
00:02:53,966 --> 00:02:55,133
给他写上去了

47
00:02:57,766 --> 00:02:58,333
呃

48
00:02:58,333 --> 00:03:02,999
商铺模块没有什么太太大的改动啊

49
00:03:03,000 --> 00:03:04,366
支付模块也没有

50
00:03:05,200 --> 00:03:06,900
然后物流模块啊

51
00:03:06,933 --> 00:03:09,333
上周是有放出了三个

52
00:03:09,966 --> 00:03:11,466
第二轮的b座任务

53
00:03:12,000 --> 00:03:14,200
呃我其中看完了两个

54
00:03:14,200 --> 00:03:16,500
一个是对象模型和数据库模型

55
00:03:17,933 --> 00:03:18,866
对象模型啊

56
00:03:18,866 --> 00:03:19,799
选用了这位同学的

57
00:03:19,800 --> 00:03:20,966
好像叫徐申

58
00:03:22,466 --> 00:03:23,599
淼还是谁啊

59
00:03:23,600 --> 00:03:25,466
记不太清楚了那

60
00:03:27,166 --> 00:03:28,599
他的这个模型呢

61
00:03:28,900 --> 00:03:30,700
呃基本上从他这个模型改过来的啊

62
00:03:30,700 --> 00:03:31,800
因为做了点修改

63
00:03:31,933 --> 00:03:32,933
所以我们对照

64
00:03:32,933 --> 00:03:35,399
之前我们说在物流指领域中间

65
00:03:35,400 --> 00:03:36,700
我们想要做什么

66
00:03:36,866 --> 00:03:40,066
我们想要做的事情是要描述一个仓库

67
00:03:40,066 --> 00:03:42,599
一个商铺的东西从哪发出去

68
00:03:43,166 --> 00:03:43,699
对吧

69
00:03:43,700 --> 00:03:47,166
再一个是描述说整个过程中间啊

70
00:03:47,166 --> 00:03:48,799
不知只仓库

71
00:03:48,800 --> 00:03:50,600
在订单发货的时候

72
00:03:50,933 --> 00:03:52,966
包括在退货的时候啊

73
00:03:52,966 --> 00:03:54,699
都会产生这个物流

74
00:03:54,700 --> 00:03:57,300
所以所有的物流都在这个模块里头

75
00:03:57,500 --> 00:03:59,666
有同学在问说啊

76
00:04:00,800 --> 00:04:01,566
仓库系统

77
00:04:01,566 --> 00:04:03,599
我们在前面在做边界的时候

78
00:04:03,600 --> 00:04:05,666
实际上把仓库系统给他划出去了

79
00:04:05,766 --> 00:04:08,066
那为什么我们在物流之领域中间

80
00:04:08,066 --> 00:04:09,866
要把仓库去建模

81
00:04:09,866 --> 00:04:11,399
建到他的领域模型中间

82
00:04:11,700 --> 00:04:13,533
这个原因是因为说

83
00:04:13,533 --> 00:04:15,899
我们虽然把仓库系统划出去了

84
00:04:16,066 --> 00:04:18,566
但是我们整个的这个电商平台

85
00:04:18,566 --> 00:04:21,133
还是支持商户

86
00:04:21,133 --> 00:04:23,766
如果他没有独立的仓库系统的话

87
00:04:23,800 --> 00:04:25,533
他依然能够把整个的

88
00:04:25,533 --> 00:04:27,133
订单的这个流程啊

89
00:04:27,133 --> 00:04:27,999
给他走完

90
00:04:28,300 --> 00:04:29,733
是基于这样的一个考虑

91
00:04:29,933 --> 00:04:32,266
所以我们这里所建立的这个仓库

92
00:04:32,566 --> 00:04:35,599
是指那些没有仓库系统的商铺

93
00:04:36,100 --> 00:04:38,100
他如果需要发货的话啊

94
00:04:38,100 --> 00:04:39,800
他可以通过这个东西去发

95
00:04:40,066 --> 00:04:42,899
那如果说有仓库系统的

96
00:04:42,900 --> 00:04:45,166
有独立仓库系统的商铺

97
00:04:45,666 --> 00:04:47,266
他其实也需要知道说

98
00:04:47,266 --> 00:04:49,066
他的仓库在什么地方

99
00:04:49,066 --> 00:04:50,666
那这个地部分来说

100
00:04:50,666 --> 00:04:54,133
就不会通过我们这个系统来发货了

101
00:04:54,133 --> 00:04:56,733
而是通过独立的仓库系统去发货了

102
00:04:56,900 --> 00:04:58,733
所以因为我们这个

103
00:04:58,733 --> 00:04:59,666
是要为

104
00:04:59,666 --> 00:05:03,399
那些没有独立仓库系统的商户啊

105
00:05:03,400 --> 00:05:04,166
就那些小商

106
00:05:04,166 --> 00:05:06,366
户也能把货发出去啊

107
00:05:06,366 --> 00:05:07,566
所以就建立了这样的

108
00:05:07,566 --> 00:05:10,866
一个关于仓库的领域模型

109
00:05:13,200 --> 00:05:13,900
这个里头啊

110
00:05:13,900 --> 00:05:14,666
我们注意一下

111
00:05:14,666 --> 00:05:15,366
在你运动中间

112
00:05:15,366 --> 00:05:18,966
其实是有多处这个多对多的关系的

113
00:05:18,966 --> 00:05:22,866
比如说我们说物流和仓库之间

114
00:05:23,733 --> 00:05:25,999
一个仓库会用多个物流去发货

115
00:05:26,000 --> 00:05:28,500
那针对于这个商铺的这个物流来说

116
00:05:28,500 --> 00:05:30,666
其实他被很多仓库都会用到

117
00:05:30,700 --> 00:05:32,066
这是个多与多的关系

118
00:05:32,600 --> 00:05:33,666
另外一个多对多的关系呢

119
00:05:33,666 --> 00:05:35,699
是仓库和地区之间啊

120
00:05:35,700 --> 00:05:38,500
每一个仓库他要负责往哪些地区发货

121
00:05:38,800 --> 00:05:40,366
当然对于那一个地区来说

122
00:05:40,366 --> 00:05:42,599
因为不同的商户是有不同的仓库的

123
00:05:42,733 --> 00:05:44,566
所以这也是一个多对多的关系

124
00:05:44,700 --> 00:05:46,900
还有一个就是他的不可达

125
00:05:47,133 --> 00:05:50,466
我们可以给仓某些物流公司去设定

126
00:05:50,466 --> 00:05:52,399
说哪些区域是不可达的

127
00:05:53,466 --> 00:05:54,899
那从区域这边来说

128
00:05:54,900 --> 00:05:56,500
因为会有很多的商户啊

129
00:05:56,500 --> 00:05:57,966
所以他其实是被会设定

130
00:05:57,966 --> 00:06:00,366
很多地方的商户的物流

131
00:06:00,366 --> 00:06:01,499
都是不可达的啊

132
00:06:01,500 --> 00:06:03,700
所以这三个就是我们看到这里的

133
00:06:03,700 --> 00:06:05,400
这个三个的三角关系

134
00:06:05,866 --> 00:06:07,099
是一个多对多的关系

135
00:06:07,600 --> 00:06:09,966
在对象领域建模的时候呢

136
00:06:09,966 --> 00:06:12,699
多对多的关系其实是有两个选择的

137
00:06:12,800 --> 00:06:13,533
一个选择呢

138
00:06:13,533 --> 00:06:15,099
就是直接把多对多的关系

139
00:06:15,100 --> 00:06:16,533
建立在对象模型上头

140
00:06:16,866 --> 00:06:18,599
然后后面在数据库建模的时候

141
00:06:18,600 --> 00:06:19,900
其实是要拆开的啊

142
00:06:19,900 --> 00:06:21,533
因为大家知道在数据库建模之后

143
00:06:21,533 --> 00:06:23,766
其实是没办法在关系数据库里

144
00:06:23,766 --> 00:06:25,299
去描述多乐多的关系

145
00:06:25,400 --> 00:06:26,600
所以他还得想办法

146
00:06:26,600 --> 00:06:28,166
但在对象建模的时候

147
00:06:28,166 --> 00:06:29,666
其实是可以把多乐多的关系

148
00:06:29,666 --> 00:06:31,299
直接接到对象模型当中去的

149
00:06:32,266 --> 00:06:35,099
那什么时候会直接在对象模型中间

150
00:06:35,100 --> 00:06:36,933
建立这个多与多的关系

151
00:06:36,933 --> 00:06:38,566
什么时候不会这个

152
00:06:38,566 --> 00:06:40,199
就是关键要看说

153
00:06:40,200 --> 00:06:41,900
这样的一个多与多的关系上面

154
00:06:41,900 --> 00:06:43,766
是不是有附加了属性

155
00:06:44,366 --> 00:06:46,699
又附加了一些别的东西啊

156
00:06:47,066 --> 00:06:47,766
在这里啊

157
00:06:47,766 --> 00:06:48,366
我们可以看到

158
00:06:48,366 --> 00:06:50,899
这位同学所做的这个选择

159
00:06:51,133 --> 00:06:52,299
是把我们看到的

160
00:06:52,300 --> 00:06:55,000
这个三角形的多对多的关系

161
00:06:55,300 --> 00:06:58,866
全部把它列解成为了一对多的关系

162
00:06:59,133 --> 00:07:00,299
把它做了这样的一个对应

163
00:07:00,300 --> 00:07:02,600
我们原来仓库和物流之间

164
00:07:02,600 --> 00:07:03,700
是多得多的关系

165
00:07:03,700 --> 00:07:04,466
大家可以看到

166
00:07:04,466 --> 00:07:07,466
它加入了一个Warehouse nostalgic

167
00:07:07,533 --> 00:07:08,666
这样的一个

168
00:07:09,600 --> 00:07:10,600
这样的一个对象啊

169
00:07:10,600 --> 00:07:11,466
这样的一个类

170
00:07:11,600 --> 00:07:14,000
那他为什么会要在中间加入一个东西

171
00:07:14,000 --> 00:07:16,533
是因为我们在这个多维度的光线上呢

172
00:07:16,533 --> 00:07:18,133
需要加以属性

173
00:07:18,133 --> 00:07:19,166
这个属性就是

174
00:07:19,566 --> 00:07:22,399
这个仓库使用这个物流

175
00:07:22,500 --> 00:07:23,966
是从什么时间开始

176
00:07:23,966 --> 00:07:25,266
到什么时间结束的

177
00:07:25,866 --> 00:07:27,366
这个需求的来源

178
00:07:27,366 --> 00:07:28,599
就是因为实际上

179
00:07:28,600 --> 00:07:29,400
仓库

180
00:07:29,400 --> 00:07:31,966
在使用某一个物流公司的配送的时候

181
00:07:31,966 --> 00:07:34,899
其实都是签有月结合同的

182
00:07:34,900 --> 00:07:38,733
月结合同是有一个起始的截止日的

183
00:07:39,100 --> 00:07:39,900
所以

184
00:07:40,600 --> 00:07:42,600
我们当使用一个物流公司的时候

185
00:07:42,600 --> 00:07:45,200
并不是说使用它就永远会使用它

186
00:07:45,266 --> 00:07:47,133
所以我们需要给这样的一个使用

187
00:07:47,133 --> 00:07:48,533
这家物流公司的物流

188
00:07:48,733 --> 00:07:51,099
定义一个开始时间和结束时间

189
00:07:51,266 --> 00:07:51,966
那正是因为

190
00:07:51,966 --> 00:07:53,799
在这样一个多对多的关系上面

191
00:07:53,800 --> 00:07:55,933
就是一个仓库和物流公司的

192
00:07:55,933 --> 00:07:56,499
这样一个关系

193
00:07:56,500 --> 00:07:58,566
上面是有附加属性的

194
00:07:58,900 --> 00:07:59,933
这样在对象建模的时候

195
00:07:59,933 --> 00:08:00,899
就没有办法

196
00:08:00,900 --> 00:08:02,766
简单的把它描述成为一个

197
00:08:02,766 --> 00:08:03,799
多与多的关系

198
00:08:03,933 --> 00:08:05,399
我们在前面的

199
00:08:06,766 --> 00:08:07,733
商品里头啊

200
00:08:07,733 --> 00:08:09,933
其实是有一个例子是多与多的关系

201
00:08:09,933 --> 00:08:12,333
但是我们把它简单的描述成为了

202
00:08:13,066 --> 00:08:13,799
多与多的关系

203
00:08:13,800 --> 00:08:17,500
就这个地方销售和活动

204
00:08:17,866 --> 00:08:20,566
我们把它因为这上头没有附加属性

205
00:08:20,700 --> 00:08:21,666
所以我们在对象模型当中

206
00:08:21,666 --> 00:08:23,299
就直接把它描述成为了

207
00:08:23,300 --> 00:08:24,466
一个多肉的关系

208
00:08:25,166 --> 00:08:26,899
在后面的数据库设计的时候

209
00:08:28,900 --> 00:08:29,666
这个多对多关系

210
00:08:29,666 --> 00:08:31,766
其实是被列解成为了两个一

211
00:08:31,766 --> 00:08:32,399
多多的关系

212
00:08:32,400 --> 00:08:33,166
因为数据库设计

213
00:08:33,166 --> 00:08:35,999
是没有办法去描述多对多关系的

214
00:08:36,000 --> 00:08:38,166
所以必须要用第三张表去完成

215
00:08:38,166 --> 00:08:41,166
这样一个多对多的的对象之间的关系

216
00:08:41,366 --> 00:08:44,133
变成一个中间表的这样的一个方式

217
00:08:44,966 --> 00:08:46,166
但是在这个地方

218
00:08:47,133 --> 00:08:50,066
在我们的物流这个部分来说

219
00:08:50,066 --> 00:08:51,599
因为在这个多肉观象头

220
00:08:51,600 --> 00:08:52,766
是有附加属性的

221
00:08:52,766 --> 00:08:55,299
所以我们4BR这里加入第三个对象

222
00:08:55,400 --> 00:08:57,466
这个对象实际上去描述说

223
00:08:57,533 --> 00:09:00,099
我们的仓库和物流之间的这个关系

224
00:09:00,133 --> 00:09:01,666
是什么东西啊

225
00:09:01,800 --> 00:09:03,866
那它就有它的开始时间和结束时间

226
00:09:04,333 --> 00:09:06,933
呃仓库的配送地区

227
00:09:06,933 --> 00:09:08,966
同样也有这样的一个问题

228
00:09:09,266 --> 00:09:11,166
就是我们定义这个仓库的配送地区

229
00:09:11,166 --> 00:09:12,699
其实它也有一个起止日

230
00:09:12,700 --> 00:09:14,866
就是从什么时间到什么时间止

231
00:09:14,866 --> 00:09:17,466
这个仓库会配送这一区域的货

232
00:09:18,166 --> 00:09:19,766
所以正是因为有这样的一个特性

233
00:09:19,766 --> 00:09:20,466
所以大家可以看到

234
00:09:20,466 --> 00:09:20,666
这边

235
00:09:20,666 --> 00:09:24,299
它也列解成为了一个一对多的关系

236
00:09:24,366 --> 00:09:25,766
这里要注意一下

237
00:09:25,766 --> 00:09:26,999
这边这个多的关系

238
00:09:27,000 --> 00:09:29,900
它列解成为了一个一对多一对多

239
00:09:30,066 --> 00:09:32,199
而这边这样的一个关系呢

240
00:09:32,200 --> 00:09:34,800
它把它列解成为了一个一对多

241
00:09:34,800 --> 00:09:35,866
和一对1

242
00:09:36,466 --> 00:09:37,166
你在对项目上呢

243
00:09:37,166 --> 00:09:39,399
他没有选择去描述说

244
00:09:39,400 --> 00:09:41,866
一个物流到底有多少个仓库

245
00:09:41,966 --> 00:09:43,799
而是只选择描述了

246
00:09:43,800 --> 00:09:45,933
一个仓库到底会在什么时间

247
00:09:45,933 --> 00:09:47,099
使用哪个物流

248
00:09:47,533 --> 00:09:48,933
这个就是在

249
00:09:50,333 --> 00:09:51,066
领域模型中间

250
00:09:51,066 --> 00:09:52,866
我们说所有的关系都是双向的

251
00:09:52,866 --> 00:09:54,066
但在对向模型上头

252
00:09:54,066 --> 00:09:55,666
我们会去考虑

253
00:09:55,666 --> 00:09:57,899
把双向的变成单向的

254
00:09:57,966 --> 00:09:59,799
那为什么会这样去做

255
00:10:00,300 --> 00:10:03,466
这个主要的原因就是因为什么

256
00:10:03,466 --> 00:10:05,166
因为我们在上面是有业务的

257
00:10:05,533 --> 00:10:07,366
如果这上面没有业务的话

258
00:10:07,600 --> 00:10:09,366
其实你是没有必要

259
00:10:09,366 --> 00:10:11,099
去给他建立这样一个关系的

260
00:10:11,366 --> 00:10:13,966
那我们现在后面代码没有写啊

261
00:10:14,000 --> 00:10:15,566
那暂时暂时

262
00:10:15,566 --> 00:10:16,533
我们在这个阶段

263
00:10:16,533 --> 00:10:17,799
我们认为说

264
00:10:17,900 --> 00:10:19,133
仓库和物流之间

265
00:10:19,133 --> 00:10:21,199
是没必要建立双向的关系的

266
00:10:21,200 --> 00:10:22,666
所以建立了一个单向的

267
00:10:22,666 --> 00:10:24,299
从仓库到物流的关系

268
00:10:24,900 --> 00:10:26,766
从仓库到地区

269
00:10:26,766 --> 00:10:27,199
同样的

270
00:10:27,200 --> 00:10:29,466
我们没必要建立从地区到仓库的关系

271
00:10:29,466 --> 00:10:33,299
建立的是从仓库到地区的关系

272
00:10:33,600 --> 00:10:36,066
这是一个仓库到地区的关系啊

273
00:10:36,500 --> 00:10:37,766
和这样的一个关系

274
00:10:38,000 --> 00:10:40,533
这个这个信号其实要去掉啊

275
00:10:40,700 --> 00:10:43,733
是仓库到地区的关系啊

276
00:10:43,733 --> 00:10:45,366
不可达同样的

277
00:10:45,566 --> 00:10:47,699
我们原来的是这个这个

278
00:10:47,700 --> 00:10:51,066
这个三者之间是多对多的关系

279
00:10:51,400 --> 00:10:53,600
不可达同样也有一个属性

280
00:10:53,600 --> 00:10:54,966
就是开始时间和结束时间

281
00:10:54,966 --> 00:10:57,333
所以这里又引入了第三个的对象

282
00:10:57,333 --> 00:11:00,533
而且把它的方向变成了物流到地区的

283
00:11:00,533 --> 00:11:01,899
从地区不到物流的

284
00:11:01,900 --> 00:11:03,466
变成这样的一个单向的

285
00:11:04,366 --> 00:11:05,133
一对多

286
00:11:05,133 --> 00:11:08,499
然后一对一的这样的一个关系

287
00:11:08,900 --> 00:11:10,400
其他的没有动

288
00:11:10,600 --> 00:11:12,066
其他只是把它的双向关系

289
00:11:12,066 --> 00:11:13,766
把它定义成为单向的

290
00:11:14,666 --> 00:11:16,799
所以在对象模型里头啊

291
00:11:16,800 --> 00:11:19,000
这个其实里头就会做

292
00:11:19,000 --> 00:11:21,400
我们可以看到只要会做两件事情

293
00:11:21,600 --> 00:11:22,133
第一件事情

294
00:11:22,133 --> 00:11:26,533
就是概念跟我们对项目中间的类

295
00:11:26,533 --> 00:11:27,666
之间的对应关系

296
00:11:27,666 --> 00:11:31,333
我们到目前为止看到的有一对多的

297
00:11:31,366 --> 00:11:33,099
有没有去描述的

298
00:11:33,100 --> 00:11:34,900
还有这里看到的是一对一的

299
00:11:35,300 --> 00:11:37,666
第二个就是概念和概念之间的关系

300
00:11:37,666 --> 00:11:40,299
怎么去确定概念和概念之间的关系

301
00:11:40,366 --> 00:11:41,199
在领域模型

302
00:11:41,200 --> 00:11:42,400
中间是双向的

303
00:11:42,500 --> 00:11:45,600
在对向模型中间一般都是单向的

304
00:11:45,700 --> 00:11:47,366
一般啊我只能说是一般

305
00:11:47,500 --> 00:11:48,466
在某些特定情况下

306
00:11:48,466 --> 00:11:49,766
我们会建立双向的

307
00:11:50,000 --> 00:11:50,733
那再有一个就是

308
00:11:50,733 --> 00:11:52,766
如果这个关相楼是有附加属性的

309
00:11:52,766 --> 00:11:53,966
这意味着我们的对相门中间

310
00:11:53,966 --> 00:11:55,699
可能要出现新的类

311
00:11:55,900 --> 00:11:57,400
或者新的对象啊

312
00:11:57,400 --> 00:12:01,533
去描述这个在依附在关系上面的属性

313
00:12:03,566 --> 00:12:05,266
呃他的数据表的

314
00:12:05,933 --> 00:12:07,199
数据表的这个设计

315
00:12:07,200 --> 00:12:09,300
就基本上跟着对象模型来的啊

316
00:12:09,300 --> 00:12:10,100
因为对象模型中间

317
00:12:10,100 --> 00:12:12,000
我们已经基本上把多与多的关系

318
00:12:12,000 --> 00:12:12,966
全部给他

319
00:12:14,000 --> 00:12:15,066
把它干掉了

320
00:12:15,066 --> 00:12:16,399
就没有多余多的关系了

321
00:12:16,600 --> 00:12:17,733
所以数据表中

322
00:12:17,733 --> 00:12:20,133
在对上面中间只有一对一和一对多

323
00:12:20,333 --> 00:12:22,666
那数据表就跟它是一对应的

324
00:12:22,766 --> 00:12:24,366
基本上跟对上面是一对应的

325
00:12:24,500 --> 00:12:25,500
这样的一种方式

326
00:12:25,500 --> 00:12:28,666
就是我们把一对多的方向

327
00:12:28,866 --> 00:12:29,899
在数据表中间

328
00:12:29,900 --> 00:12:32,966
都统一描述成为从多到1

329
00:12:33,066 --> 00:12:34,133
就数据表中间

330
00:12:34,566 --> 00:12:36,999
我们的方向都是从多到1啊

331
00:12:37,000 --> 00:12:39,133
从多到1的好处在于说

332
00:12:39,533 --> 00:12:41,766
不用引入第三张表啊

333
00:12:41,766 --> 00:12:42,199
所以说

334
00:12:42,200 --> 00:12:45,100
这是我们在数据表的这个部分的设计

335
00:12:46,333 --> 00:12:49,166
啊地区模块我们之前有

336
00:12:49,166 --> 00:12:49,766
因为看一下

337
00:12:49,766 --> 00:12:50,666
其实它很简单

338
00:12:50,666 --> 00:12:52,133
就是一个概念地区

339
00:12:52,133 --> 00:12:54,466
然后这个地区跟它的上级地区

340
00:12:54,466 --> 00:12:57,099
之间存在着一个关系啊

341
00:12:58,866 --> 00:13:00,066
领域模型就没话了啊

342
00:13:00,066 --> 00:13:02,333
对象模型其实就是一个对象数据库嘛

343
00:13:02,333 --> 00:13:03,266
就是一张表

344
00:13:03,266 --> 00:13:04,866
然后一张表里头自己有

345
00:13:04,866 --> 00:13:06,199
跟自己有一个关联

346
00:13:06,200 --> 00:13:07,766
就是这样的一个数据库的设计

347
00:13:08,266 --> 00:13:09,666
它的状态的话

348
00:13:09,666 --> 00:13:11,299
其实主要是有效状态

349
00:13:11,300 --> 00:13:12,566
就是我们有效的地区

350
00:13:12,600 --> 00:13:16,933
还有部分地区可能是会暂时停用的

351
00:13:17,100 --> 00:13:19,566
就是不能选择网在任何地方

352
00:13:19,566 --> 00:13:22,099
这不是指配送在任何时候都不能

353
00:13:22,100 --> 00:13:23,333
选择这些地区了啊

354
00:13:23,333 --> 00:13:24,766
这是可能初恋某种原因

355
00:13:24,900 --> 00:13:26,533
那还有就是这个地区会废弃

356
00:13:26,533 --> 00:13:29,599
所以我们在有效和废弃之间

357
00:13:29,600 --> 00:13:30,800
加入了一个中间状态

358
00:13:30,800 --> 00:13:31,966
叫做停用

359
00:13:32,600 --> 00:13:32,700
啊

360
00:13:32,700 --> 00:13:37,533
就是暂时可能这个地区要做区划调整

361
00:13:37,733 --> 00:13:39,999
那我就暂时不允许所有的用户

362
00:13:40,300 --> 00:13:41,166
在使用的时候

363
00:13:41,166 --> 00:13:42,499
再选择比如说他的地址

364
00:13:42,500 --> 00:13:43,533
选择这个地区

365
00:13:43,800 --> 00:13:46,766
比如说他的这个呃

366
00:13:47,666 --> 00:13:48,566
在所有选地区的时候

367
00:13:48,566 --> 00:13:49,799
都必须选择这个地区了

368
00:13:49,800 --> 00:13:52,100
那真正被被调整了以后

369
00:13:52,100 --> 00:13:53,800
就把把它改成废弃的状态

370
00:13:54,066 --> 00:13:55,566
是这样的一个定义

371
00:13:57,900 --> 00:13:59,400
呃订单

372
00:14:00,533 --> 00:14:02,999
订单的领域模型呢

373
00:14:03,000 --> 00:14:05,133
相对来说比较简单

374
00:14:05,133 --> 00:14:07,366
它里头最核心的两个概念就是

375
00:14:07,366 --> 00:14:10,399
一个是商品啊

376
00:14:10,400 --> 00:14:11,333
一个是订单

377
00:14:11,366 --> 00:14:13,066
一个是订单的明细

378
00:14:13,266 --> 00:14:16,166
订单就是指我们所说的那个

379
00:14:16,800 --> 00:14:20,766
我们所说的这个下的一个订单

380
00:14:20,766 --> 00:14:24,066
我们针对订单这个概念的内涵

381
00:14:24,266 --> 00:14:27,133
定义的是这个订单是一个商铺的订单

382
00:14:27,533 --> 00:14:29,166
就是我们不允许说

383
00:14:30,100 --> 00:14:32,300
你买两个商铺的东西

384
00:14:32,300 --> 00:14:34,000
放在一个订单里

385
00:14:34,200 --> 00:14:35,300
是不允许这样子的

386
00:14:35,333 --> 00:14:38,166
所以我们对于订单的这个内涵的定义

387
00:14:38,166 --> 00:14:40,599
是指一个商铺的订单

388
00:14:40,800 --> 00:14:43,766
所以如果顾客在买东西的时候

389
00:14:45,200 --> 00:14:46,966
选了两个商铺的东西

390
00:14:47,366 --> 00:14:49,699
在我们的信用中间会变成两个订单

391
00:14:50,166 --> 00:14:52,566
然后订单的内涵

392
00:14:52,566 --> 00:14:55,066
除了说他是一个商铺的订单以外

393
00:14:55,066 --> 00:14:58,499
我们定义说支付是针对订单来的

394
00:14:59,166 --> 00:15:01,899
就是我们只能一次支付一个订单

395
00:15:01,900 --> 00:15:03,900
而不允许合并支付

396
00:15:04,133 --> 00:15:04,666
大家知道

397
00:15:04,666 --> 00:15:06,799
在支付宝里头是允许合并支付的

398
00:15:06,866 --> 00:15:07,466
就支付宝里头

399
00:15:07,466 --> 00:15:09,199
你可以选两个商铺的东西

400
00:15:09,500 --> 00:15:11,733
就淘宝里头可以选两个商铺的东西

401
00:15:11,866 --> 00:15:12,933
然后一起支付

402
00:15:12,933 --> 00:15:14,733
然后再分给两个订单

403
00:15:15,166 --> 00:15:16,199
我们这里的概念

404
00:15:16,200 --> 00:15:18,866
是支付只是针对一个订单来的

405
00:15:18,866 --> 00:15:21,366
不能对两个订单来

406
00:15:21,600 --> 00:15:22,800
所以这样的一个领域模型

407
00:15:22,800 --> 00:15:24,266
其实就是描述了这样一个事情

408
00:15:24,266 --> 00:15:28,366
当一个顾客在选择多个东西

409
00:15:28,366 --> 00:15:30,133
放到一个订单里的时候

410
00:15:30,933 --> 00:15:32,599
啊选择多个东西去购买的时候啊

411
00:15:32,600 --> 00:15:33,700
不是放在一个订单的时候

412
00:15:33,700 --> 00:15:34,866
他会根据这些东西

413
00:15:34,866 --> 00:15:36,566
是不是属于同一个商铺的

414
00:15:36,733 --> 00:15:39,133
来把它分成若干个订单

415
00:15:39,200 --> 00:15:41,333
在每个订单里头的这个order item

416
00:15:41,333 --> 00:15:41,966
这个概念

417
00:15:41,966 --> 00:15:44,733
描述的就是在这个订单里头放的东西

418
00:15:45,300 --> 00:15:45,966
支付的时候

419
00:15:45,966 --> 00:15:49,366
是针对每一个商铺的订单去做支付的

420
00:15:49,533 --> 00:15:52,366
所以我们可以看到支付对象啊

421
00:15:52,366 --> 00:15:55,099
支付的这个概念和他之间是存在着

422
00:15:55,600 --> 00:15:57,466
为了他付款啊

423
00:15:57,466 --> 00:15:59,266
当然有支付就有退款

424
00:15:59,333 --> 00:16:01,066
所以如果发生退款的话

425
00:16:01,066 --> 00:16:04,133
这个退款的也是跟订单关联在一起的

426
00:16:04,200 --> 00:16:06,066
而且这是个一对多的

427
00:16:06,066 --> 00:16:07,599
因为订单里头

428
00:16:07,600 --> 00:16:09,700
是有可能是有多个商品的

429
00:16:10,000 --> 00:16:13,866
所以他是要针对多个商品去做付款

430
00:16:13,866 --> 00:16:14,933
去做退款的啊

431
00:16:14,933 --> 00:16:15,733
去做退款

432
00:16:19,566 --> 00:16:21,333
这里的退款的金额

433
00:16:21,333 --> 00:16:23,299
其实是有一定的限制的啊

434
00:16:23,300 --> 00:16:27,200
退款金额是必须要少于支付金额

435
00:16:27,666 --> 00:16:29,799
减去快递费

436
00:16:30,900 --> 00:16:31,800
要少于啊

437
00:16:31,800 --> 00:16:35,266
就总的退款金额要少于支付金额

438
00:16:35,266 --> 00:16:36,899
减去快递费啊

439
00:16:36,900 --> 00:16:40,400
这是我们对于退款的这个定义啊

440
00:16:40,400 --> 00:16:41,600
所以time的订单明细

441
00:16:41,600 --> 00:16:45,000
就是我们所说的订单里头的东西

442
00:16:45,500 --> 00:16:47,466
如果订单中有多个东西的话啊

443
00:16:47,466 --> 00:16:49,299
他就会放在这个里面

444
00:16:49,600 --> 00:16:50,700
那这边这个呢

445
00:16:50,700 --> 00:16:52,133
是我们描述的商品

446
00:16:52,133 --> 00:16:53,099
我们可以看到

447
00:16:53,100 --> 00:16:54,800
我们在这里所看到的商品

448
00:16:55,000 --> 00:16:56,933
和我们在领域模型中间

449
00:16:56,933 --> 00:16:57,999
所看到的商品

450
00:16:58,000 --> 00:16:59,166
是不一样的东西

451
00:16:59,366 --> 00:17:00,799
我们在领域中间看到的商品

452
00:17:00,800 --> 00:17:01,666
中间是没有价格

453
00:17:01,666 --> 00:17:03,599
的因为价格是在他的销售上头的

454
00:17:03,700 --> 00:17:05,300
但是在订单中间看到的商品

455
00:17:05,300 --> 00:17:06,533
其实是有价格的

456
00:17:06,733 --> 00:17:09,199
这个就是我们针对同一个东西

457
00:17:09,200 --> 00:17:10,966
在不同子领域中间

458
00:17:11,866 --> 00:17:14,366
他的视角是不一样

459
00:17:15,100 --> 00:17:17,566
我们把它画成若干直女以后

460
00:17:17,800 --> 00:17:19,300
就会使得我们允许说

461
00:17:19,300 --> 00:17:20,766
在不同的直女中间

462
00:17:20,766 --> 00:17:22,199
对于同一个东西

463
00:17:22,600 --> 00:17:24,600
所描述的视角可以是不一样的

464
00:17:24,600 --> 00:17:25,800
比如说在订单领域中间

465
00:17:25,800 --> 00:17:26,600
我们看到的商品

466
00:17:26,600 --> 00:17:29,500
就是认认为他是应该有价格的

467
00:17:29,500 --> 00:17:30,966
因为订单中间所有买的商品

468
00:17:30,966 --> 00:17:31,733
都是有价格的

469
00:17:31,733 --> 00:17:33,599
没有价格他是不能买的

470
00:17:33,966 --> 00:17:34,199
所以

471
00:17:34,200 --> 00:17:35,900
我们在订单中间看到的这个商品啊

472
00:17:35,900 --> 00:17:37,100
就是他都是有价格的

473
00:17:37,166 --> 00:17:38,266
这个价格是什么呢

474
00:17:38,266 --> 00:17:40,333
这个价格是他当时买的这个价格

475
00:17:40,333 --> 00:17:40,733
注意啊

476
00:17:40,733 --> 00:17:42,733
不是这个商品的现在有下价格

477
00:17:42,766 --> 00:17:44,766
而是我在下这个订单的时候

478
00:17:45,266 --> 00:17:46,999
这个商品的价格是什么

479
00:17:47,000 --> 00:17:49,666
就是我们所看到的这个商品

480
00:17:49,900 --> 00:17:53,533
所以这是我们在订单子女中间

481
00:17:53,533 --> 00:17:55,166
所描述的这个商品

482
00:17:55,166 --> 00:17:56,199
概念的内涵

483
00:17:56,200 --> 00:17:59,600
就是下订单的时候那个商品的状况

484
00:17:59,966 --> 00:18:01,266
那个时候的样子啊

485
00:18:01,266 --> 00:18:02,066
就是这个

486
00:18:02,900 --> 00:18:04,766
这里头在写属性的时候注意下

487
00:18:04,766 --> 00:18:06,466
我们有两个属性写的很特别

488
00:18:06,666 --> 00:18:08,933
一个是折扣钱的金额

489
00:18:08,933 --> 00:18:10,999
一个是折扣金额

490
00:18:11,400 --> 00:18:14,733
这两个属性前面我们画了一个斜杠

491
00:18:15,066 --> 00:18:15,899
这表示什么呢

492
00:18:15,900 --> 00:18:19,200
这表示这两个属性是可以计算得来的

493
00:18:19,400 --> 00:18:21,400
大家应该知道为什么可以计算得来

494
00:18:21,933 --> 00:18:26,066
是因为它可以从这个里头啊

495
00:18:26,166 --> 00:18:27,366
去把它计算了

496
00:18:28,300 --> 00:18:30,266
就是我们从订单明细里头

497
00:18:30,266 --> 00:18:31,599
可以计算到

498
00:18:32,100 --> 00:18:35,400
订单的这个折扣前的金额

499
00:18:35,400 --> 00:18:36,666
和折扣后的金额

500
00:18:36,800 --> 00:18:38,266
在订单的每一个明细中间

501
00:18:38,266 --> 00:18:40,133
我们都需要记到他是什么商品

502
00:18:40,133 --> 00:18:41,133
他买了多少

503
00:18:41,466 --> 00:18:44,966
需要知道他折扣后的折扣的单价

504
00:18:46,666 --> 00:18:48,099
以及折扣的祭典

505
00:18:48,100 --> 00:18:51,066
因为我们是可以允许用祭典支付的

506
00:18:51,966 --> 00:18:53,666
祭典就相当于说是

507
00:18:53,800 --> 00:18:55,333
比如说某种原因啊

508
00:18:55,333 --> 00:18:57,333
我们这边没有别的方式转祭典了

509
00:18:57,333 --> 00:18:58,933
我们就是某种原因

510
00:18:59,366 --> 00:19:03,166
这个平台给商给顾客一定的补偿

511
00:19:03,166 --> 00:19:04,766
这个补偿是不可以折现的

512
00:19:04,800 --> 00:19:06,533
但是可以用来买东西的啊

513
00:19:06,533 --> 00:19:08,266
就这就是这个祭典

514
00:19:08,500 --> 00:19:10,700
所以他如果有了这样的一个补偿

515
00:19:10,866 --> 00:19:11,533
比如说啊

516
00:19:11,533 --> 00:19:13,133
比如说他是VIP会员

517
00:19:13,533 --> 00:19:14,766
他的VI我们都知道

518
00:19:14,766 --> 00:19:17,799
就是在京东里头集那个金豆子啊

519
00:19:17,800 --> 00:19:19,666
你买了一定数量的东西

520
00:19:19,666 --> 00:19:20,799
你就会有金豆子啊

521
00:19:20,800 --> 00:19:21,966
我们这里没用金豆

522
00:19:21,966 --> 00:19:23,599
那个用的是祭点

523
00:19:23,600 --> 00:19:24,200
买了一点东西

524
00:19:24,200 --> 00:19:25,200
他就会给你返点

525
00:19:25,533 --> 00:19:26,366
返完点以后呢

526
00:19:26,366 --> 00:19:27,733
你可以用那东西去支付

527
00:19:27,733 --> 00:19:29,099
但是那个东西是不能提现

528
00:19:29,466 --> 00:19:29,733
所以

529
00:19:29,733 --> 00:19:32,199
正是因为有这样的一个支付的东西

530
00:19:32,200 --> 00:19:34,566
所以我们每一个明细中介都需要记录

531
00:19:34,566 --> 00:19:36,499
说他的支付的祭点是什么

532
00:19:36,666 --> 00:19:38,366
以及他支付的单价是什么

533
00:19:38,700 --> 00:19:39,933
其实不仅仅这个啊

534
00:19:39,966 --> 00:19:40,766
还有一个是

535
00:19:40,766 --> 00:19:42,799
其实我们周围这个东西是要分账的

536
00:19:43,100 --> 00:19:44,300
所以我们在每一个民族里面

537
00:19:44,300 --> 00:19:45,666
还需要记住什么呢

538
00:19:45,666 --> 00:19:47,899
需要记住他的分账金额

539
00:19:48,300 --> 00:19:49,933
就是分给了平台多少钱

540
00:19:50,266 --> 00:19:51,366
为什么要记在这里

541
00:19:51,366 --> 00:19:52,333
因为不记在这里

542
00:19:52,333 --> 00:19:54,799
就没有别的地方可以可以记住了

543
00:19:54,800 --> 00:19:57,533
我们万一在未来退款的时候

544
00:19:57,533 --> 00:19:58,966
退了某一个商品

545
00:19:59,533 --> 00:19:59,999
这个商品

546
00:20:00,000 --> 00:20:02,666
到底从平台应该退多少给商户

547
00:20:03,333 --> 00:20:05,566
商户应该退多少给顾客

548
00:20:05,700 --> 00:20:08,100
都是依赖于我们在这个order

549
00:20:08,100 --> 00:20:10,266
it这个概念中间所描述的属性啊

550
00:20:10,266 --> 00:20:11,966
才能算得出来的

551
00:20:12,400 --> 00:20:14,800
这是我们的订单的模块

552
00:20:15,700 --> 00:20:16,666
那数据库我们

553
00:20:16,666 --> 00:20:17,466
就不说了

554
00:20:18,733 --> 00:20:19,766
顾客的部分来说

555
00:20:19,766 --> 00:20:21,699
我们对于顾客的定义来说

556
00:20:21,700 --> 00:20:23,166
所描述的就是顾客

557
00:20:23,266 --> 00:20:24,399
顾客的购物车

558
00:20:24,400 --> 00:20:26,600
顾客的地址和顾客的优惠券

559
00:20:26,800 --> 00:20:28,466
所以大家可以看到这里四个概念

560
00:20:28,466 --> 00:20:29,866
顾客顾客的购物车

561
00:20:29,866 --> 00:20:32,733
顾客的地址和顾客的啊优惠券

562
00:20:32,733 --> 00:20:34,399
我们在定义顾客的属性的时候

563
00:20:34,400 --> 00:20:35,200
其实并没有

564
00:20:35,300 --> 00:20:36,866
并没有真正的像真正系统那样

565
00:20:36,866 --> 00:20:37,799
定义那么多属性

566
00:20:37,800 --> 00:20:39,700
因为有很多属性其实就是为了看

567
00:20:40,000 --> 00:20:42,366
那为了减少我们写代码的工作量啊

568
00:20:42,366 --> 00:20:44,999
所以我们只定义里头最基本的属性

569
00:20:45,566 --> 00:20:45,766
就是

570
00:20:45,766 --> 00:20:48,133
并不是需要把他所有的顾客的属性

571
00:20:48,400 --> 00:20:50,100
全部记进去啊

572
00:20:50,600 --> 00:20:52,066
那购物车的话

573
00:20:52,066 --> 00:20:54,733
是顾客当时把他放进去的这个东西

574
00:20:55,200 --> 00:20:56,100
放进去的商品

575
00:20:56,100 --> 00:20:57,900
我们在这里没有做收藏啊

576
00:20:57,900 --> 00:20:58,533
其实大家知道

577
00:20:58,533 --> 00:21:00,799
现在很多的很多的里头

578
00:21:00,800 --> 00:21:02,100
其实都没有收藏

579
00:21:02,300 --> 00:21:04,733
为啥因为其实大家不爱去收藏商品

580
00:21:04,800 --> 00:21:08,200
而是愿意用购物车来当做收藏夹

581
00:21:08,300 --> 00:21:09,533
所以你要买一个东西的时候

582
00:21:09,533 --> 00:21:11,366
你其实就是先把它放到购物车里

583
00:21:11,500 --> 00:21:13,166
然后以后再买啊

584
00:21:13,166 --> 00:21:14,866
那购物车的主要作用呢

585
00:21:15,166 --> 00:21:17,899
是要记住放进去了多少

586
00:21:19,066 --> 00:21:22,466
记住当时放进去的价格是多少

587
00:21:22,666 --> 00:21:23,099
大家知道

588
00:21:23,100 --> 00:21:25,133
我们在购物车界面上都会要去显示

589
00:21:25,133 --> 00:21:28,166
说这个东西比当时放进去涨了多少钱

590
00:21:28,200 --> 00:21:29,966
或者跌了多少钱

591
00:21:30,100 --> 00:21:31,500
对吧那就要知道说

592
00:21:31,500 --> 00:21:33,466
这个东西当时放进去的价格是多少

593
00:21:34,066 --> 00:21:35,566
购物车里放的是商品

594
00:21:36,600 --> 00:21:37,400
这个注意

595
00:21:37,666 --> 00:21:39,333
这个跟我们之前这个领域

596
00:21:39,333 --> 00:21:42,099
目前所描述的商品是不是同一个概念

597
00:21:42,533 --> 00:21:48,299
这个商品的内涵是订单当时买的商品

598
00:21:49,266 --> 00:21:51,466
而这个领域中间

599
00:21:51,466 --> 00:21:53,533
我们所说的商品的内涵是什么

600
00:21:53,533 --> 00:21:55,666
就是商品

601
00:21:55,766 --> 00:21:56,566
就是我们

602
00:21:56,566 --> 00:21:58,766
在产品这个

603
00:21:58,766 --> 00:22:00,799
指领域中间所说的那个东西

604
00:22:00,866 --> 00:22:01,999
它是没有价格的

605
00:22:02,900 --> 00:22:04,400
他是没有价格的啊

606
00:22:04,533 --> 00:22:06,133
所以我们可以看到

607
00:22:06,133 --> 00:22:08,799
当时这个东西放到购物车里的价格

608
00:22:08,800 --> 00:22:10,533
是作为购物车的属性

609
00:22:10,533 --> 00:22:11,999
而我们所关联的这个商品

610
00:22:12,000 --> 00:22:13,700
其实是没有价格的啊

611
00:22:13,700 --> 00:22:15,933
其实是没有价格的啊

612
00:22:15,933 --> 00:22:18,966
这是顾客购物车和商品

613
00:22:18,966 --> 00:22:20,666
那地址和优惠券

614
00:22:20,666 --> 00:22:23,133
这个地址没什么好说的啊

615
00:22:23,266 --> 00:22:24,599
优惠券我大概说一下

616
00:22:25,666 --> 00:22:26,799
优惠卷是个什么概念呢

617
00:22:26,800 --> 00:22:27,800
优惠卷大家都知道

618
00:22:27,800 --> 00:22:29,900
我们可以优惠卷来打折是吧

619
00:22:30,166 --> 00:22:30,466
但是

620
00:22:30,466 --> 00:22:32,333
我们在这里描述这个优惠卷的时候

621
00:22:32,333 --> 00:22:34,199
其实我们把它分成了两个概念

622
00:22:34,400 --> 00:22:38,000
一个概念是优惠卷就是仅指那张卷

623
00:22:38,966 --> 00:22:40,066
另外一个概念是什么呢

624
00:22:40,066 --> 00:22:41,333
另外一个概念是怎么打折

625
00:22:41,533 --> 00:22:43,599
就是我们说的优惠活动

626
00:22:44,100 --> 00:22:44,500
所以

627
00:22:44,500 --> 00:22:48,700
我们的优惠券是依赖于优惠活动的

628
00:22:49,066 --> 00:22:50,066
你拿到一张卷

629
00:22:50,200 --> 00:22:53,100
就说明你有资格参加这个打折的活动

630
00:22:53,166 --> 00:22:54,266
你没有这张卷

631
00:22:54,266 --> 00:22:56,766
你就没有资格参加这个打折的活动啊

632
00:22:56,766 --> 00:22:58,399
实际上是起个这样的作用

633
00:22:58,566 --> 00:22:59,533
所以大家可以看到

634
00:22:59,533 --> 00:23:00,566
在我们这里头

635
00:23:00,766 --> 00:23:01,966
除了它的属性以外

636
00:23:01,966 --> 00:23:02,866
最主要的是

637
00:23:02,866 --> 00:23:05,966
它会关联我们的优惠活动啊

638
00:23:05,966 --> 00:23:07,366
会关联我们的优惠活动

639
00:23:07,400 --> 00:23:08,400
所以在优惠券里头

640
00:23:08,400 --> 00:23:10,266
其实是没有怎么去打折的

641
00:23:10,500 --> 00:23:12,533
这个要看这个优惠券是什么

642
00:23:12,533 --> 00:23:13,766
优惠活动的

643
00:23:13,766 --> 00:23:16,499
优惠券这就是我们在领域模型中间

644
00:23:16,500 --> 00:23:19,600
把优惠券和优惠券的打折

645
00:23:19,600 --> 00:23:21,933
把它用了两个概念去描述

646
00:23:22,133 --> 00:23:23,499
关于它怎么打折的这个部分

647
00:23:23,500 --> 00:23:25,566
其实是在产品那个

648
00:23:25,566 --> 00:23:27,366
你知那个商品

649
00:23:27,366 --> 00:23:29,899
那个产品指领域中间去描述的啊

650
00:23:29,900 --> 00:23:32,066
我们就是直接用了在产品

651
00:23:32,066 --> 00:23:33,866
指领域中间所用到的那个优

652
00:23:33,866 --> 00:23:36,166
惠活动这里其实他要描述的

653
00:23:36,166 --> 00:23:37,899
其实只需要知道他的名字就好了

654
00:23:37,900 --> 00:23:39,366
其他都是在那边去描述

655
00:23:40,733 --> 00:23:43,666
这是顾客的子领域的模型啊

656
00:23:43,666 --> 00:23:45,999
那数据库我们就不说了

657
00:23:47,766 --> 00:23:49,366
呃售后的子女

658
00:23:50,266 --> 00:23:51,266
售后的子女

659
00:23:51,266 --> 00:23:52,733
中间其实主要就是两个事情

660
00:23:52,733 --> 00:23:53,666
一个是售后

661
00:23:53,733 --> 00:23:55,066
一个是仲裁

662
00:23:55,566 --> 00:23:56,333
所以我们可以看到

663
00:23:56,333 --> 00:23:59,166
它最核心的概念是这个售后的概念

664
00:23:59,766 --> 00:24:02,066
售后呢他会发出一系列的快递

665
00:24:02,133 --> 00:24:02,733
就是快递

666
00:24:02,733 --> 00:24:04,366
是我们物流中间的那个质概念

667
00:24:04,366 --> 00:24:06,299
但是他这里只关心说他的快递单号

668
00:24:06,300 --> 00:24:07,800
其他的都不关心啊

669
00:24:07,800 --> 00:24:08,966
其他的都不关心

670
00:24:09,533 --> 00:24:13,466
所以所有跟这个售后有关的快递

671
00:24:13,466 --> 00:24:15,199
全部是跟快递单

672
00:24:15,866 --> 00:24:16,899
跟快递啊

673
00:24:16,900 --> 00:24:17,700
售后单

674
00:24:18,466 --> 00:24:19,933
所有跟这个社会有关的快递

675
00:24:19,933 --> 00:24:21,199
全是跟这个售后啊

676
00:24:21,200 --> 00:24:22,300
关联到一起的

677
00:24:22,366 --> 00:24:24,366
那售后是从何而来的

678
00:24:24,366 --> 00:24:26,766
售后是从什么呢

679
00:24:26,766 --> 00:24:28,099
是从订单来的

680
00:24:29,100 --> 00:24:31,666
一个订单可以产生多次售后

681
00:24:31,800 --> 00:24:35,566
但是一个售后一定是属于一个订单的

682
00:24:35,566 --> 00:24:37,166
这个其实应该严格来说

683
00:24:37,166 --> 00:24:39,333
应该把它写成conversation关系啊

684
00:24:39,333 --> 00:24:40,733
有订单才有售后

685
00:24:40,733 --> 00:24:43,066
没有订单就没有售后

686
00:24:43,066 --> 00:24:44,533
但订单不会消亡啊

687
00:24:44,533 --> 00:24:44,999
这个单

688
00:24:45,000 --> 00:24:46,866
这个是一个严格的conversation关系

689
00:24:46,866 --> 00:24:47,999
这个应该把它画出来

690
00:24:49,400 --> 00:24:51,866
这个订单所来的这个售后

691
00:24:51,866 --> 00:24:53,666
订单明细所来的这个售后

692
00:24:53,666 --> 00:24:56,566
他里头要说这个是什么样的商品

693
00:24:56,800 --> 00:24:59,200
虽然我们在这里头也描述了这个商品

694
00:24:59,200 --> 00:25:00,933
但是我们把这个商品

695
00:25:01,066 --> 00:25:04,766
就是售后跟商品之间的关系

696
00:25:05,866 --> 00:25:07,533
直接把它描述出来

697
00:25:07,533 --> 00:25:10,066
而不是通过他再来描述

698
00:25:10,066 --> 00:25:11,799
其实通过他是可以再来描述

699
00:25:11,800 --> 00:25:13,300
但是我们会觉得比较麻烦

700
00:25:13,500 --> 00:25:15,133
所以我们在领目中心就直接把

701
00:25:15,366 --> 00:25:17,099
其实就是把这个东西

702
00:25:17,100 --> 00:25:18,333
和商品之间的关系

703
00:25:18,333 --> 00:25:20,799
拷贝到了售后来啊

704
00:25:20,800 --> 00:25:21,766
拷贝到了社会了

705
00:25:21,766 --> 00:25:23,366
是这样的一个定义

706
00:25:23,733 --> 00:25:25,766
然后这边又有一个东西叫做product item

707
00:25:25,766 --> 00:25:26,799
这个概念是什么呢

708
00:25:27,666 --> 00:25:29,266
比如说这个手机

709
00:25:29,266 --> 00:25:31,099
某一个型号的黑色的手机

710
00:25:31,100 --> 00:25:32,533
是我们在领域某中间

711
00:25:32,533 --> 00:25:34,333
所定义的一个商品的概念

712
00:25:34,366 --> 00:25:35,133
对吧

713
00:25:35,133 --> 00:25:37,366
但是手机这种贵重的东西是有串号的

714
00:25:37,700 --> 00:25:39,600
就是每一个东西是有串号的

715
00:25:39,866 --> 00:25:43,466
所以每一个具体的手机的实力

716
00:25:44,066 --> 00:25:46,533
就是我们所说的product item

717
00:25:47,166 --> 00:25:48,333
这个是手机

718
00:25:48,333 --> 00:25:50,666
这个是里头的每一个实例

719
00:25:50,866 --> 00:25:53,066
每一个实例都会有一个独立的串号

720
00:25:53,066 --> 00:25:56,333
就是手机或者电脑这种贵重的东西

721
00:25:56,333 --> 00:25:58,466
都贵的东西都会有一个独立的串号

722
00:25:58,500 --> 00:26:01,666
我们要把这个串号也要把它描述出来

723
00:26:01,666 --> 00:26:03,333
所以我们定义了一个product item

724
00:26:03,333 --> 00:26:04,133
这个东西

725
00:26:04,566 --> 00:26:06,933
它是某一个商品

726
00:26:07,133 --> 00:26:09,699
然后它是某个商品的特定的一个

727
00:26:09,733 --> 00:26:10,966
所以它有一个串号

728
00:26:11,133 --> 00:26:11,966
这个串号

729
00:26:11,966 --> 00:26:14,899
是要跟我们的售后寄到一起去的

730
00:26:15,266 --> 00:26:19,133
为啥呢就是如果说对于这个商品

731
00:26:19,200 --> 00:26:21,566
申请售后的话

732
00:26:22,700 --> 00:26:25,766
那其实是需要把这个串号输进去的

733
00:26:25,766 --> 00:26:26,533
这个串号呢

734
00:26:26,533 --> 00:26:28,466
目前我们是没有

735
00:26:28,600 --> 00:26:29,466
就从需求

736
00:26:29,466 --> 00:26:30,266
从需求上的

737
00:26:30,266 --> 00:26:33,766
我们并不是要求顾客来输这个串号

738
00:26:33,800 --> 00:26:37,133
我们是售后收到这个货以后

739
00:26:37,766 --> 00:26:38,999
验货的时候

740
00:26:39,266 --> 00:26:42,199
把这个串号输到系统中间去

741
00:26:42,400 --> 00:26:42,800
为啥

742
00:26:42,800 --> 00:26:46,800
因为如果说收到以后出去做维修

743
00:26:47,066 --> 00:26:48,066
你最后维修的时候

744
00:26:48,066 --> 00:26:49,733
要把这个东西寄回给客户

745
00:26:49,733 --> 00:26:50,933
都是一模一样的手机

746
00:26:50,933 --> 00:26:52,566
你咋知道哪个是哪个

747
00:26:53,100 --> 00:26:54,966
所以必须要看这个串号啊

748
00:26:54,966 --> 00:26:55,666
才能知道

749
00:26:55,666 --> 00:26:57,199
说这个维修的手机

750
00:26:57,400 --> 00:26:59,900
是要寄还给某一个顾客的

751
00:26:59,966 --> 00:27:01,499
所以针对这样的一个东西

752
00:27:01,500 --> 00:27:03,066
我们把串号这个东西要描

753
00:27:03,066 --> 00:27:03,333
出来

754
00:27:03,333 --> 00:27:06,566
所以就有一个独立的概念叫做啊

755
00:27:06,566 --> 00:27:08,933
product item啊product item

756
00:27:11,166 --> 00:27:12,066
服务模块

757
00:27:12,533 --> 00:27:15,166
服务模块我们里头包含了两个内容

758
00:27:15,166 --> 00:27:16,966
一个是我们之前在讲

759
00:27:17,666 --> 00:27:19,399
商铺里头的服务的部分

760
00:27:19,400 --> 00:27:20,900
我们把它放过来了

761
00:27:20,900 --> 00:27:22,700
再有一个就是我们的服务单

762
00:27:23,166 --> 00:27:24,766
那我们首先讲服务的部分

763
00:27:24,766 --> 00:27:27,133
我们针对服务的这个概念的定义

764
00:27:27,133 --> 00:27:31,199
是指由服务商在某个地区

765
00:27:31,366 --> 00:27:34,366
针对某个产品所提供的服务

766
00:27:34,366 --> 00:27:36,666
所以这张领域模型应该写的很清楚啊

767
00:27:36,800 --> 00:27:39,766
中间这个是服务service

768
00:27:39,933 --> 00:27:42,599
它是由服务商提供的

769
00:27:42,966 --> 00:27:48,466
在某一个地区所针对某些产品啊

770
00:27:48,466 --> 00:27:49,666
它不是一个产品

771
00:27:50,133 --> 00:27:51,133
因为我们知道

772
00:27:51,133 --> 00:27:54,499
我们的这个产品其实是非常多的

773
00:27:54,500 --> 00:27:55,766
所提供的服务

774
00:27:55,933 --> 00:27:57,099
但是这个过程

775
00:27:57,100 --> 00:27:58,533
这个关系的过程

776
00:27:58,700 --> 00:28:00,166
它是分部建立的

777
00:28:00,366 --> 00:28:01,899
它首先是由服务商

778
00:28:01,900 --> 00:28:04,966
在某一个地区建立了一个服务

779
00:28:04,966 --> 00:28:05,933
所以我们可以看到这个

780
00:28:05,933 --> 00:28:07,399
这个之间是一个conversation关系

781
00:28:07,400 --> 00:28:08,733
它是由服务商建立的

782
00:28:09,100 --> 00:28:10,200
建立了一个服务

783
00:28:10,500 --> 00:28:13,300
然后呢由商铺去

784
00:28:13,300 --> 00:28:15,533
在某个地区去看到这样的一个服务

785
00:28:15,533 --> 00:28:18,466
他觉得适合于用于他的某一个商品

786
00:28:18,700 --> 00:28:18,933
所以

787
00:28:18,933 --> 00:28:21,166
再把这个商品和这个服务建立起关系

788
00:28:21,166 --> 00:28:21,899
了

789
00:28:21,900 --> 00:28:24,300
领目人员看到的是三者之间的关系

790
00:28:24,366 --> 00:28:25,599
但是这个关系的建立

791
00:28:25,600 --> 00:28:27,566
是由服务商先提出

792
00:28:27,866 --> 00:28:30,366
由商户去把他的商品

793
00:28:30,600 --> 00:28:33,666
关联在这个服务里的啊

794
00:28:33,666 --> 00:28:35,799
所以形成了这样的一个东西

795
00:28:36,066 --> 00:28:37,266
那有了这样一个东西

796
00:28:37,266 --> 00:28:38,666
当这个商品申请售后

797
00:28:38,666 --> 00:28:41,166
或这个商品购买的时候

798
00:28:41,300 --> 00:28:43,100
就会产生服务单

799
00:28:44,466 --> 00:28:46,099
啊就会产生服务单

800
00:28:46,200 --> 00:28:48,366
我们把这个服务单

801
00:28:48,600 --> 00:28:51,300
是跟这个串号关到一起去的

802
00:28:51,533 --> 00:28:52,699
当然啊

803
00:28:52,700 --> 00:28:54,933
有些东西可能是没有串号的啊

804
00:28:54,933 --> 00:28:56,099
那这个怎么办

805
00:28:56,600 --> 00:28:58,566
我我们再再考虑一下

806
00:28:58,733 --> 00:28:59,766
现在这个画法

807
00:28:59,766 --> 00:29:02,533
是认为他直接跟串号关联到一起去的

808
00:29:02,533 --> 00:29:05,599
就是这就实际上这样的一个领域模型

809
00:29:05,600 --> 00:29:06,800
实际上限制了什么

810
00:29:07,266 --> 00:29:08,366
实际限定了说

811
00:29:08,566 --> 00:29:09,666
登串号的东西

812
00:29:09,666 --> 00:29:11,999
才能有售后和售前的服务

813
00:29:12,366 --> 00:29:15,299
不登串号的东西是没有服务的

814
00:29:16,733 --> 00:29:17,799
大家觉得合理吗

815
00:29:21,733 --> 00:29:22,199
合理吗

816
00:29:22,200 --> 00:29:24,533
你们觉得有穿号东西才能服务

817
00:29:24,533 --> 00:29:26,199
没穿号东西就不能服务了

818
00:29:28,533 --> 00:29:29,866
目前是这么写的

819
00:29:29,966 --> 00:29:30,966
目前是这么写的

820
00:29:30,966 --> 00:29:34,966
因为我们看到基本上啊

821
00:29:34,966 --> 00:29:36,299
对有些还是不行啊

822
00:29:36,300 --> 00:29:37,466
比如说像家具

823
00:29:37,966 --> 00:29:40,099
家具就是完全没有串号的嘛

824
00:29:40,200 --> 00:29:41,600
那个东西要服务的话

825
00:29:41,600 --> 00:29:42,300
你就不能这么做

826
00:29:42,300 --> 00:29:43,666
所以这个领域模型还得要

827
00:29:43,933 --> 00:29:46,266
还得要怎么去把它描述出来

828
00:29:46,266 --> 00:29:47,866
现在是写的这个是有问题的啊

829
00:29:47,866 --> 00:29:50,466
就是他只是有串号的才能服务

830
00:29:50,466 --> 00:29:51,899
没串号的就不能服务了

831
00:29:52,933 --> 00:29:58,399
而这些服务单是由是由商户产生的

832
00:29:58,700 --> 00:30:00,933
这个服务单是由商户产生的

833
00:30:01,366 --> 00:30:02,599
产生的这个服务单啊

834
00:30:02,600 --> 00:30:03,966
我们把下面可以看到啊

835
00:30:04,100 --> 00:30:05,566
哎我们没把商户建进来

836
00:30:05,566 --> 00:30:06,799
应该把商户建进来啊

837
00:30:06,800 --> 00:30:08,500
这个服务单是由商户产生的

838
00:30:08,500 --> 00:30:11,333
针对某些商品所产生的服务单

839
00:30:11,400 --> 00:30:13,400
然后由服务商去接单

840
00:30:13,466 --> 00:30:16,166
从而形成的这样的一个关系啊

841
00:30:16,166 --> 00:30:19,699
这是服务之领域啊

842
00:30:20,000 --> 00:30:21,700
领域模型的部分啊

843
00:30:21,700 --> 00:30:22,566
大家可以看到

844
00:30:22,566 --> 00:30:24,933
我们在建的过程中间

845
00:30:24,933 --> 00:30:27,333
其实是针对需求的

846
00:30:27,333 --> 00:30:28,966
我们称之为形式化

847
00:30:29,400 --> 00:30:31,866
也就是去探索需求

848
00:30:31,966 --> 00:30:34,499
去找到需求背后的本质

849
00:30:34,766 --> 00:30:37,199
这个本质就会定义

850
00:30:37,200 --> 00:30:37,700
好了以后

851
00:30:37,700 --> 00:30:40,200
就会决定说你什么样的需求能够实现

852
00:30:40,500 --> 00:30:42,200
什么样的需求不能实现

853
00:30:42,200 --> 00:30:43,700
比如说现在这个定义的话

854
00:30:43,700 --> 00:30:45,933
其实就没办法去做家具的

855
00:30:45,933 --> 00:30:47,266
售后服务了

856
00:30:47,266 --> 00:30:49,299
它是跟串号有关系的

857
00:30:49,400 --> 00:30:49,666
所以

858
00:30:49,666 --> 00:30:51,766
我们还是要改一下这个领域模型啊

859
00:30:51,766 --> 00:30:52,566
怎么去描述

860
00:30:52,566 --> 00:30:54,999
说那些没有穿好的商品

861
00:30:55,000 --> 00:30:57,500
也是能做售前和售后服务的

862
00:30:58,400 --> 00:31:00,000
这是领域模型

863
00:31:02,766 --> 00:31:04,066
领域模型的后

864
00:31:04,066 --> 00:31:04,866
之后啊就

865
00:31:04,866 --> 00:31:06,966
其实是要建立这个对象模型

866
00:31:06,966 --> 00:31:10,366
和数据库的部分啊

867
00:31:10,366 --> 00:31:12,099
我们在第一次必做的任务中间

868
00:31:12,100 --> 00:31:12,733
大家可以看到

869
00:31:12,733 --> 00:31:14,166
我其实放出了三个

870
00:31:14,166 --> 00:31:15,899
一个是物流的

871
00:31:16,866 --> 00:31:18,533
呃对象模型

872
00:31:18,533 --> 00:31:19,466
物流的数据库

873
00:31:19,466 --> 00:31:21,399
还有物流的API啊

874
00:31:21,400 --> 00:31:22,200
对象模型数据库

875
00:31:22,200 --> 00:31:24,700
我看完了对象模型的部分

876
00:31:24,700 --> 00:31:27,166
我选了一位同学的数据库的任务

877
00:31:27,166 --> 00:31:28,366
我把它取消了

878
00:31:28,500 --> 00:31:30,733
为啥呢因为我发现

879
00:31:30,733 --> 00:31:31,766
大部分同学

880
00:31:31,866 --> 00:31:34,466
并没有我们原来的那个数据库的设计

881
00:31:34,733 --> 00:31:35,733
做的更好

882
00:31:36,366 --> 00:31:36,566
就是

883
00:31:36,566 --> 00:31:38,199
你没有比我们原来的数据库的设计

884
00:31:38,200 --> 00:31:39,133
做的更有道理

885
00:31:39,133 --> 00:31:41,699
我就不会选用你作为数据库的设计

886
00:31:41,700 --> 00:31:44,200
这里所有的所有的指领域

887
00:31:44,200 --> 00:31:46,666
中间都是有原先的数据库的

888
00:31:46,700 --> 00:31:47,133
那当然

889
00:31:47,133 --> 00:31:49,333
有些原先数据库是要做大改的

890
00:31:49,333 --> 00:31:50,699
比如说我们的服务指领域

891
00:31:50,700 --> 00:31:51,933
这里面加入了新的概念

892
00:31:51,933 --> 00:31:53,199
原来是没有这些东西的

893
00:31:53,300 --> 00:31:55,466
所以这个部分是要完全去大改的

894
00:31:55,766 --> 00:31:56,666
有些部分呢

895
00:31:56,666 --> 00:31:58,266
其实是没有去做大改的

896
00:31:58,266 --> 00:31:59,666
比如说物流的部分

897
00:32:01,366 --> 00:32:02,766
就是物流这个需求

898
00:32:02,866 --> 00:32:05,166
是去年和今年是没有大改的

899
00:32:05,400 --> 00:32:07,666
呃领域模型的部分来说呢

900
00:32:07,800 --> 00:32:09,200
对吧对象模型的部分来说呢

901
00:32:09,200 --> 00:32:11,400
其实这位同学做的还不错啊

902
00:32:11,400 --> 00:32:13,900
因为去年的物流部分是选座部分

903
00:32:13,900 --> 00:32:15,200
今年的是b座部分

904
00:32:15,200 --> 00:32:15,400
所以

905
00:32:15,400 --> 00:32:18,466
去年我们是没有给出他的对象模型的

906
00:32:18,533 --> 00:32:19,866
那今年因为改成了b座部分

907
00:32:19,866 --> 00:32:21,199
所以我们需要他的对象模型

908
00:32:21,200 --> 00:32:22,600
数据库是有的这

909
00:32:22,600 --> 00:32:23,900
个数据库就是去年的数据库

910
00:32:24,466 --> 00:32:24,933
呃

911
00:32:24,933 --> 00:32:28,166
大部分同学就是基本上所有同学做的

912
00:32:28,166 --> 00:32:30,166
并没有比去年的做的更好

913
00:32:30,333 --> 00:32:32,699
所以我就把这个必做任务给取消了

914
00:32:33,333 --> 00:32:35,066
用去年的数据库啊

915
00:32:35,300 --> 00:32:37,366
那其他的模块也会一样

916
00:32:38,200 --> 00:32:40,500
就其他的模块的话

917
00:32:40,766 --> 00:32:42,966
我们主要是做数据库的设计

918
00:32:42,966 --> 00:32:44,699
因为是选做模块

919
00:32:44,733 --> 00:32:45,666
对象模型

920
00:32:45,666 --> 00:32:49,466
允许同学们每个组自己去任意发挥

921
00:32:49,466 --> 00:32:52,066
但是我们会限定他的数据库的设计

922
00:32:52,200 --> 00:32:54,300
所以我们会把他其他的部分的

923
00:32:54,300 --> 00:32:55,166
数据库的设计

924
00:32:55,166 --> 00:32:56,966
把它作为闭轴中把它放出来

925
00:32:57,200 --> 00:32:59,000
这里头同样有这个问题

926
00:32:59,000 --> 00:33:00,266
就是有一些的数据库

927
00:33:00,266 --> 00:33:02,066
是比较去年是做的

928
00:33:02,133 --> 00:33:03,599
比如说顾客这个部分

929
00:33:04,100 --> 00:33:06,266
这个跟去年的需求没有发生改变

930
00:33:06,566 --> 00:33:07,366
所以

931
00:33:07,900 --> 00:33:08,700
你没有比

932
00:33:08,766 --> 00:33:10,399
没有在去年的数据库的基础上

933
00:33:10,400 --> 00:33:11,066
做的更好

934
00:33:11,066 --> 00:33:12,599
那我就会把这个必做任务给他

935
00:33:12,600 --> 00:33:14,966
就我所有看完交了的必做任务的话

936
00:33:15,000 --> 00:33:16,400
没有比去年做的更好的话

937
00:33:16,400 --> 00:33:18,600
或者更有更加有意义的数据库的话

938
00:33:18,600 --> 00:33:20,000
我就把这个取消掉

939
00:33:20,333 --> 00:33:22,166
有一呃售后

940
00:33:23,366 --> 00:33:24,333
售后是有改变的

941
00:33:24,333 --> 00:33:25,699
我们加入了这个串单啊

942
00:33:25,700 --> 00:33:28,133
这个单号服务的变动最大

943
00:33:28,366 --> 00:33:30,099
因为我们其实把商铺的一个概念

944
00:33:30,100 --> 00:33:31,066
移到这个地方

945
00:33:31,266 --> 00:33:33,999
所以这个部分的这个数据库设计啊

946
00:33:34,000 --> 00:33:36,166
会动的比较大一点

947
00:33:37,966 --> 00:33:41,133
呃这是我们的对象模型

948
00:33:41,133 --> 00:33:43,533
包括对象模型和数据库的部分

949
00:33:44,933 --> 00:33:46,399
这一部分有什么问题

950
00:33:52,466 --> 00:33:53,166
我在上课的时候啊

951
00:33:53,166 --> 00:33:54,399
因为有同学在问啊

952
00:33:54,566 --> 00:33:57,266
我们说了三门课是一样的东西

953
00:33:57,266 --> 00:33:58,299
就是软攻

954
00:33:58,666 --> 00:34:01,166
面向对象和教啊

955
00:34:01,166 --> 00:34:03,266
一是一样的题目

956
00:34:03,266 --> 00:34:04,333
一样的分组

957
00:34:04,566 --> 00:34:07,866
所以呃因为我们软工

958
00:34:07,866 --> 00:34:10,066
我们面向对象这边其实也做了次调整

959
00:34:10,066 --> 00:34:11,133
原本我们是把

960
00:34:11,866 --> 00:34:13,466
物流模块作为选做的

961
00:34:13,466 --> 00:34:14,766
今年改成了b座

962
00:34:14,866 --> 00:34:17,866
所以软弓和焦阿姨也是一样

963
00:34:18,300 --> 00:34:21,166
那我们的整体的这个做法

964
00:34:21,166 --> 00:34:23,266
就是b座模块呢

965
00:34:24,300 --> 00:34:25,500
是在10月份

966
00:34:25,500 --> 00:34:26,466
就是在这个月

967
00:34:26,466 --> 00:34:27,266
就下个月

968
00:34:27,500 --> 00:34:29,666
我们会有所有同学协作

969
00:34:29,666 --> 00:34:30,799
去做出来一个版本

970
00:34:30,800 --> 00:34:33,533
其中我自己做了两个啊

971
00:34:33,533 --> 00:34:35,266
然后还剩下的四个

972
00:34:35,266 --> 00:34:37,866
是由其他同学协作去把它完成

973
00:34:38,333 --> 00:34:41,499
选中部分是由每个小组二选一

974
00:34:41,600 --> 00:34:43,500
就是你要么选订单顾客

975
00:34:43,766 --> 00:34:46,933
要么选这个售后和服务

976
00:34:47,333 --> 00:34:48,299
然后去完成

977
00:34:48,300 --> 00:34:49,333
最后检查的时候

978
00:34:49,333 --> 00:34:52,099
是把所有东西合在一起来检查

979
00:34:52,200 --> 00:34:53,766
那对于软工来说

980
00:34:54,200 --> 00:34:56,766
软工是要你交那个全部是交的文档

981
00:34:56,900 --> 00:34:59,900
那你就只交选座部分的文档就好了

982
00:34:59,966 --> 00:35:01,533
因为b座部分的文档

983
00:35:01,566 --> 00:35:04,066
我们会全部把它写出来

984
00:35:04,066 --> 00:35:05,899
就是由所有做b座任务的同学

985
00:35:05,900 --> 00:35:07,933
不仅仅负责完成b座任务的代码

986
00:35:08,266 --> 00:35:10,499
也完成b座部分的所有的文档

987
00:35:10,900 --> 00:35:12,133
所以用b座部分的文档

988
00:35:12,133 --> 00:35:14,099
给大家去打一个板

989
00:35:14,466 --> 00:35:17,366
知道选座部分的所有的文档怎么去选

990
00:35:17,566 --> 00:35:20,399
所以你们交给软工的作业中间啊

991
00:35:20,400 --> 00:35:22,700
主要是以选座的部分为主

992
00:35:22,800 --> 00:35:25,733
但是主体他比较讲总体的系统结构啊

993
00:35:25,733 --> 00:35:26,533
这些东西

994
00:35:27,000 --> 00:35:30,000
就去用必做部分写好的文档

995
00:35:30,000 --> 00:35:31,800
加上你们选做部分的东西啊

996
00:35:31,800 --> 00:35:33,666
交给软工的部分

997
00:35:33,966 --> 00:35:35,266
交法一那边就比较简单

998
00:35:35,266 --> 00:35:37,599
就是o面相对象多少分

999
00:35:37,600 --> 00:35:38,500
交法一多少分

1000
00:35:38,866 --> 00:35:40,399
他面相对象50分

1001
00:35:40,400 --> 00:35:41,800
交法一60分啊

1002
00:35:41,800 --> 00:35:43,800
就是直接对考过去就好了

1003
00:35:43,800 --> 00:35:44,700
然后作业嘛

1004
00:35:44,700 --> 00:35:45,666
各算各的分啊

1005
00:35:45,666 --> 00:35:46,466
是这样的

1006
00:35:46,866 --> 00:35:47,933
这个是这个

1007
00:35:47,933 --> 00:35:49,133
那这个也就涉及到说

1008
00:35:49,133 --> 00:35:53,099
我们在第一阶段的任务中间啊

1009
00:35:53,100 --> 00:35:54,900
最后一批的必做任务其实是

1010
00:35:54,900 --> 00:35:57,533
跟大家要交给软工的作业是重合的

1011
00:35:58,066 --> 00:36:01,766
就是最后一批的必做任务是给大家

1012
00:36:01,800 --> 00:36:03,333
是大家在软工中间交的

1013
00:36:03,333 --> 00:36:04,599
第一个需求分析的作业

1014
00:36:04,600 --> 00:36:05,600
是有重合的

1015
00:36:05,900 --> 00:36:08,566
所以最后一批的必做任务是

1016
00:36:08,766 --> 00:36:12,299
大家把软工作业交完以后再更新上来

1017
00:36:12,300 --> 00:36:12,733
要不然

1018
00:36:12,733 --> 00:36:15,799
交给软工的作业就全都是一样的了

1019
00:36:16,566 --> 00:36:16,899
是啊

1020
00:36:16,900 --> 00:36:18,733
所以我们把最后一批的必做任务

1021
00:36:18,733 --> 00:36:19,533
更新到微提上

1022
00:36:19,533 --> 00:36:21,933
的时间是定在了软工作完以后啊

1023
00:36:21,933 --> 00:36:24,933
软工作业交完以后再完成这块

1024
00:36:24,933 --> 00:36:25,733
有问题吗

1025
00:36:29,500 --> 00:36:31,933
好那我们看一下这个Viki啊

1026
00:36:33,700 --> 00:36:36,600
Viki第一份的需求规格说明书啊

1027
00:36:36,600 --> 00:36:37,566
我们刚才已经说了

1028
00:36:37,566 --> 00:36:39,133
剩下的必做的部分

1029
00:36:40,466 --> 00:36:41,699
剩下的选做的部分

1030
00:36:41,700 --> 00:36:45,566
就是到软工完成以后再把它补充上去

1031
00:36:45,566 --> 00:36:47,933
这样就形成了完整的需求规格说明书

1032
00:36:48,300 --> 00:36:50,500
那这份做完了以后

1033
00:36:51,466 --> 00:36:52,566
下一部分的作业

1034
00:36:52,566 --> 00:36:54,466
其实我们是把它分成了两块

1035
00:36:55,066 --> 00:36:57,133
这两块逐块的来做

1036
00:36:57,133 --> 00:36:59,866
我们的这个

1037
00:37:01,566 --> 00:37:02,499
设计说明书

1038
00:37:04,600 --> 00:37:06,533
逐块的来做设计说明书

1039
00:37:06,533 --> 00:37:07,966
设计说明书比较庞大

1040
00:37:08,000 --> 00:37:11,366
我们会分成9个模块来独立的写

1041
00:37:11,366 --> 00:37:13,166
每一个模块是一个

1042
00:37:13,466 --> 00:37:16,199
那这里头是有若干个必做模块的

1043
00:37:16,200 --> 00:37:17,966
然后有若干个选做模块

1044
00:37:18,200 --> 00:37:20,200
选做模块的这一部分就不会把它写完

1045
00:37:20,200 --> 00:37:23,766
我们只写完我们给你的部分

1046
00:37:24,100 --> 00:37:25,766
比如说领域模型和数据库

1047
00:37:25,766 --> 00:37:27,166
其他的都不会去写

1048
00:37:27,366 --> 00:37:28,799
那这个选做部分

1049
00:37:28,800 --> 00:37:30,266
就是大家要自己把它写完

1050
00:37:30,266 --> 00:37:32,666
交给软工的作业

1051
00:37:32,733 --> 00:37:35,699
但是必做部分的内容我们会全部写完

1052
00:37:35,700 --> 00:37:38,666
目前我已经把地区全部写完啊

1053
00:37:38,666 --> 00:37:40,699
这个写完也就意味着做完了

1054
00:37:40,700 --> 00:37:42,533
所有的代码全部做完了啊

1055
00:37:42,533 --> 00:37:43,899
所有代码全部测试完

1056
00:37:44,133 --> 00:37:45,866
大家觉得地区这个模块要花

1057
00:37:45,866 --> 00:37:46,699
多长时间做完

1058
00:37:47,266 --> 00:37:48,066
你们觉得

1059
00:37:49,400 --> 00:37:50,766
你们觉得祸害多长时间

1060
00:37:51,266 --> 00:37:52,166
看看这个

1061
00:37:53,133 --> 00:37:53,966
看看这个

1062
00:37:58,700 --> 00:37:59,533
地区这个模块

1063
00:37:59,533 --> 00:38:00,499
这是b座的

1064
00:38:02,133 --> 00:38:04,999
应该大家知道这是整个9个b

1065
00:38:05,000 --> 00:38:08,700
9个模块中间最简单的一个是吧

1066
00:38:09,366 --> 00:38:10,366
一个概念

1067
00:38:10,500 --> 00:38:11,500
一个对象

1068
00:38:11,533 --> 00:38:14,333
一张表最简单的一个

1069
00:38:14,566 --> 00:38:18,899
所以这个部分连做完到写文档

1070
00:38:18,900 --> 00:38:20,966
我大概花了6个小时左右

1071
00:38:21,500 --> 00:38:23,666
6个小时把它全部做完了啊

1072
00:38:23,700 --> 00:38:25,166
包括测试也全部做完了

1073
00:38:26,000 --> 00:38:29,733
所以我们第二节课就来讲

1074
00:38:29,733 --> 00:38:31,733
这个部分是怎么做的啊

1075
00:38:31,733 --> 00:38:33,799
所有的文档我有更新在这个上头了

1076
00:38:33,800 --> 00:38:35,100
这个其实也比较少

1077
00:38:35,400 --> 00:38:36,400
没有特别多

1078
00:39:01,366 --> 00:39:02,299
大家要知道啊

1079
00:39:02,300 --> 00:39:03,933
这个设计和写代码

1080
00:39:03,933 --> 00:39:06,933
其实是就是我们教了同学这么多年

1081
00:39:06,933 --> 00:39:07,566
我们发现

1082
00:39:07,566 --> 00:39:10,099
是不能放任同学自己去做设计

1083
00:39:10,100 --> 00:39:11,700
和自己去写代码的

1084
00:39:11,966 --> 00:39:13,733
因为你那样你水平提不高

1085
00:39:14,200 --> 00:39:15,266
所以大家可以看到

1086
00:39:15,266 --> 00:39:15,533
我们

1087
00:39:15,533 --> 00:39:18,466
无论是在设计和代码的这个部分来说

1088
00:39:18,466 --> 00:39:20,066
其实都是会做两道

1089
00:39:20,066 --> 00:39:21,533
一道是我自己做的

1090
00:39:21,566 --> 00:39:23,699
一道是b座同学做的

1091
00:39:23,733 --> 00:39:25,266
然后b座同学做的过程中做

1092
00:39:25,266 --> 00:39:26,299
b座同学应该知道

1093
00:39:26,300 --> 00:39:27,100
那是刚刚

1094
00:39:27,133 --> 00:39:28,866
那是我跟你改了很多次以后

1095
00:39:28,866 --> 00:39:30,366
形成的那个b座的东西

1096
00:39:30,566 --> 00:39:32,266
然后你们再做你们自己的

1097
00:39:32,300 --> 00:39:33,666
所以你们实际上能看到

1098
00:39:34,866 --> 00:39:36,699
之前的我做的部分

1099
00:39:36,733 --> 00:39:39,199
还有必做的同学做的部分

1100
00:39:39,766 --> 00:39:41,733
最后是个什么样子

1101
00:39:41,733 --> 00:39:43,466
然后仿照这种方式啊

1102
00:39:43,466 --> 00:39:45,999
去完成他的设计和写他的代码

1103
00:39:49,000 --> 00:39:53,000
那我们就以地区这个模块为例来讲

1104
00:39:53,300 --> 00:39:55,333
这个直折驱动的设计来讲

1105
00:39:55,333 --> 00:39:56,733
这个部分是怎么样设计

1106
00:39:56,966 --> 00:39:59,666
实现和测试的

1107
00:39:59,766 --> 00:40:01,733
就是整个的这个过程啊

1108
00:40:01,733 --> 00:40:03,699
最后程序员的最后一道关口就

1109
00:40:03,700 --> 00:40:05,800
是你把它全部代码写出来

1110
00:40:05,800 --> 00:40:07,400
然后所有代码全部测试完

1111
00:40:07,400 --> 00:40:08,600
你的事情就结束了

1112
00:40:08,700 --> 00:40:11,333
交给后面的测试部的人再去做测试

1113
00:40:11,600 --> 00:40:13,733
所以我们讲最简单这个模块

1114
00:40:13,733 --> 00:40:15,066
是怎么完成这个部分的

1115
00:40:16,766 --> 00:40:19,066
我们这里头设计的主要的思想

1116
00:40:19,066 --> 00:40:21,666
是用了一种职责驱动的设计

1117
00:40:22,500 --> 00:40:24,866
那这里头其实包含了三个概念

1118
00:40:24,866 --> 00:40:25,933
一个叫做职责

1119
00:40:25,933 --> 00:40:27,099
一个叫做角色

1120
00:40:27,100 --> 00:40:28,500
一个叫做协作

1121
00:40:29,066 --> 00:40:31,299
这个职责驱动的设计是讲什么呢

1122
00:40:31,300 --> 00:40:33,266
其实是讲我们在面向对象中间

1123
00:40:33,266 --> 00:40:35,166
最基本的那个东西

1124
00:40:35,166 --> 00:40:36,933
对象对象

1125
00:40:36,933 --> 00:40:38,133
他到底做什么

1126
00:40:39,000 --> 00:40:40,366
我们做对象做什么

1127
00:40:40,366 --> 00:40:42,333
我们前面在做对象模型的时候啊

1128
00:40:42,333 --> 00:40:45,133
大家已经看到我们其实已经明确了

1129
00:40:50,900 --> 00:40:52,400
这个文档打开啊

1130
00:40:52,400 --> 00:40:53,700
我们在做对象模型的时候

1131
00:40:53,700 --> 00:40:54,966
其实我们已经明确了

1132
00:40:54,966 --> 00:40:56,099
说一个对象

1133
00:40:57,266 --> 00:40:59,399
一个对象里头他有什么样的属性

1134
00:41:00,166 --> 00:41:01,533
这个其实在多对象模型中间

1135
00:41:01,533 --> 00:41:02,533
已经明确了

1136
00:41:02,600 --> 00:41:04,466
明确了这个对象和对象之间

1137
00:41:04,466 --> 00:41:05,866
有些什么样的关系

1138
00:41:06,266 --> 00:41:07,333
这个也知道了

1139
00:41:07,600 --> 00:41:09,333
当然这个可能不正确啊

1140
00:41:09,500 --> 00:41:11,733
他的属性和他的关系可能是不正确

1141
00:41:11,733 --> 00:41:13,299
但是我们在建立对象模型的时候

1142
00:41:13,300 --> 00:41:13,966
其实已建立了

1143
00:41:13,966 --> 00:41:16,266
一个我们的第一印象版本

1144
00:41:16,733 --> 00:41:19,933
然后我们在这之后做的事情

1145
00:41:19,966 --> 00:41:21,766
就是这些对象做什么

1146
00:41:22,666 --> 00:41:23,933
什么叫做对象做什么呢

1147
00:41:23,933 --> 00:41:26,399
就是些对象有些什么样的方法

1148
00:41:26,600 --> 00:41:27,100
我们知道

1149
00:41:27,100 --> 00:41:28,700
一个对象是包括对象的属性

1150
00:41:28,700 --> 00:41:29,733
和对象的方法的

1151
00:41:30,000 --> 00:41:31,100
我们说对象做什么

1152
00:41:31,100 --> 00:41:34,000
就是给他去说这对象做什么样的方法

1153
00:41:34,400 --> 00:41:36,466
在明确这些对象做什么的时候

1154
00:41:36,466 --> 00:41:38,166
我们依然会去调整

1155
00:41:38,166 --> 00:41:39,866
这个对象模型中间的属性

1156
00:41:40,133 --> 00:41:41,299
和对象的关系

1157
00:41:41,500 --> 00:41:43,000
甚至会产生新的对象

1158
00:41:43,200 --> 00:41:46,466
但是我们其实在做这个过程中间

1159
00:41:47,066 --> 00:41:49,366
我们是要有一个初始的东西

1160
00:41:49,366 --> 00:41:51,099
就是我们之前现在看到的

1161
00:41:51,100 --> 00:41:52,733
这个初始的对象模型的

1162
00:41:53,100 --> 00:41:54,933
对于区域来说啊

1163
00:41:54,933 --> 00:41:55,666
地区来说

1164
00:41:55,666 --> 00:41:56,899
这个模块其实很简单

1165
00:41:56,900 --> 00:41:58,933
因为就是一个对象一个关系

1166
00:41:58,933 --> 00:42:01,066
就是地区和地区的上级关系

1167
00:42:01,866 --> 00:42:03,366
那这么简单的对象

1168
00:42:03,366 --> 00:42:04,866
我们依然要说

1169
00:42:04,900 --> 00:42:06,933
这个对象他的职责是什么

1170
00:42:06,933 --> 00:42:08,533
就他到底干什么

1171
00:42:09,133 --> 00:42:10,766
然后他的角色是什么

1172
00:42:11,100 --> 00:42:14,100
角色比职责更小一点啊

1173
00:42:14,100 --> 00:42:15,400
当然针对一个对象来说

1174
00:42:15,400 --> 00:42:16,200
就这个里头

1175
00:42:16,200 --> 00:42:18,566
在我们这个地区这个里头来说

1176
00:42:18,766 --> 00:42:20,066
他的角色等于他的职责

1177
00:42:20,066 --> 00:42:21,199
因为他太简单了

1178
00:42:21,300 --> 00:42:23,000
但是对一个复杂对象来说

1179
00:42:23,000 --> 00:42:25,266
其实他在不同的场合上

1180
00:42:25,533 --> 00:42:27,566
是在承担着不同的角色的

1181
00:42:27,966 --> 00:42:31,666
就是我们认为对象是它的本质

1182
00:42:31,800 --> 00:42:33,700
但是它在不同场合的时候

1183
00:42:33,700 --> 00:42:35,100
它会去做不同的事情

1184
00:42:35,100 --> 00:42:36,366
这是它的角色

1185
00:42:36,733 --> 00:42:37,733
在实现的时候

1186
00:42:37,733 --> 00:42:39,366
角色其实就会变成什么呢

1187
00:42:39,366 --> 00:42:40,366
会变成接口

1188
00:42:40,966 --> 00:42:41,999
就是我们说这个对象

1189
00:42:42,000 --> 00:42:43,133
他在干这个事情的时候

1190
00:42:43,133 --> 00:42:44,399
他要实现这个接口

1191
00:42:44,566 --> 00:42:45,766
他要干另外一个对象的时候

1192
00:42:45,766 --> 00:42:46,566
干另外一件事情时候

1193
00:42:46,566 --> 00:42:47,966
他要实现另外一个接口

1194
00:42:48,533 --> 00:42:50,533
那所有的这些对象

1195
00:42:50,866 --> 00:42:53,199
以及他所实现的接口

1196
00:42:53,333 --> 00:42:55,533
最终是要协作起来

1197
00:42:55,733 --> 00:42:57,866
去完成我们特定的功能

1198
00:42:58,000 --> 00:43:00,066
这就是我们的在面

1199
00:43:00,066 --> 00:43:01,933
对象的职责驱动的设计

1200
00:43:01,933 --> 00:43:04,333
中间的三个最关键的定义

1201
00:43:04,600 --> 00:43:06,133
明确每个对象干什么

1202
00:43:06,133 --> 00:43:06,999
他的职责

1203
00:43:07,100 --> 00:43:08,966
明确这个对象在具体做一件事情时候

1204
00:43:08,966 --> 00:43:10,366
他存在的角色是什么

1205
00:43:10,366 --> 00:43:11,933
这是他所要实现的接口

1206
00:43:12,133 --> 00:43:13,966
第三是他怎么合起来

1207
00:43:14,100 --> 00:43:15,900
完成我们特定的功能

1208
00:43:16,066 --> 00:43:17,333
好我们先休息一会

1209
00:53:22,266 --> 00:53:22,999
好

1210
00:53:23,000 --> 00:53:26,133
这个就是我们说的职责角色和协作啊

1211
00:53:26,133 --> 00:53:26,766
这个可能大家

1212
00:53:26,766 --> 00:53:27,733
听起来比较抽象

1213
00:53:27,733 --> 00:53:29,666
没关系我们在后面的例子中间

1214
00:53:29,666 --> 00:53:32,566
可以大家更明确知道说什么是职责

1215
00:53:32,566 --> 00:53:33,466
什么是角色

1216
00:53:33,466 --> 00:53:34,333
什么是协作

1217
00:53:34,666 --> 00:53:38,599
那当然对于地区这个模块来说

1218
00:53:38,600 --> 00:53:39,866
角色不明显

1219
00:53:40,000 --> 00:53:41,533
因为它不是很复杂

1220
00:53:41,866 --> 00:53:43,666
那我们其实更多的是讲的

1221
00:53:43,666 --> 00:53:45,466
地区这个对象的职责

1222
00:53:45,566 --> 00:53:47,799
以及怎么去协作的

1223
00:53:52,600 --> 00:53:54,466
我们在这里所讲的

1224
00:53:54,733 --> 00:53:56,733
面向对象的驱动的设计的方法

1225
00:53:56,733 --> 00:53:58,799
叫做grasp方法

1226
00:53:58,900 --> 00:54:01,766
这个全称叫做general responsibility assignment

1227
00:54:01,766 --> 00:54:02,999
software Partners

1228
00:54:03,266 --> 00:54:04,999
把所有的首字母提出来

1229
00:54:05,000 --> 00:54:05,766
就是一个单词

1230
00:54:05,766 --> 00:54:06,699
叫做grasp

1231
00:54:07,466 --> 00:54:08,466
那这个方法

1232
00:54:08,466 --> 00:54:11,533
其实就是职责驱动设计的一种

1233
00:54:11,800 --> 00:54:14,266
目前用的比较多的一种方法

1234
00:54:14,500 --> 00:54:15,566
这种方法呢

1235
00:54:16,500 --> 00:54:18,166
里头原本的方法

1236
00:54:18,166 --> 00:54:21,099
一共有9种不同的方法

1237
00:54:21,300 --> 00:54:23,200
但是其中有三种方法

1238
00:54:23,200 --> 00:54:24,900
其实是没什么多大的意义的

1239
00:54:24,900 --> 00:54:25,866
一种是控制器

1240
00:54:25,866 --> 00:54:27,166
那是讲体系结构的

1241
00:54:27,533 --> 00:54:30,566
另外一个呢是我们说的虚构

1242
00:54:30,966 --> 00:54:33,399
这个其实比较难去琢磨

1243
00:54:33,700 --> 00:54:34,966
还有一个是更广泛的

1244
00:54:34,966 --> 00:54:38,366
叫做便利化保护PV啊

1245
00:54:38,466 --> 00:54:41,266
所以我们把控制器

1246
00:54:41,566 --> 00:54:44,766
虚构和PV这三种方法拿掉

1247
00:54:44,766 --> 00:54:47,299
今天我们只讲其中的6种方法

1248
00:54:47,800 --> 00:54:50,500
创建者Creator信息专家啊

1249
00:54:50,500 --> 00:54:51,733
information x不等

1250
00:54:51,800 --> 00:54:54,166
这是两个最基本的方法

1251
00:54:54,333 --> 00:54:57,599
可以说我们70%-80%的代码

1252
00:54:57,766 --> 00:55:00,699
都是用创建者和信息专家写出来的

1253
00:55:00,800 --> 00:55:01,900
就是最基本的

1254
00:55:01,900 --> 00:55:03,766
你在重复的使用这两种方法

1255
00:55:04,500 --> 00:55:06,133
高类句和低偶合

1256
00:55:06,133 --> 00:55:07,966
就是high cohension和low copy

1257
00:55:07,966 --> 00:55:10,099
其实是两种价值观

1258
00:55:10,700 --> 00:55:13,766
就是针对我们特定的这个问题

1259
00:55:13,766 --> 00:55:15,499
我们其实是有多种方案的

1260
00:55:15,666 --> 00:55:17,099
那选择哪一种方案

1261
00:55:17,266 --> 00:55:20,066
其实我们就是用的高类句和低偶合

1262
00:55:20,066 --> 00:55:22,699
这个价值观去做的判断啊

1263
00:55:22,700 --> 00:55:23,766
这是所以前面两

1264
00:55:23,766 --> 00:55:25,066
种是最基本的方法

1265
00:55:25,800 --> 00:55:26,666
中间两种

1266
00:55:26,666 --> 00:55:29,866
是我们在做设计的时候的一个价值观

1267
00:55:29,933 --> 00:55:31,099
那最后两种方法

1268
00:55:31,100 --> 00:55:32,300
其实是比较高级的方法

1269
00:55:32,300 --> 00:55:33,500
一个叫做多态

1270
00:55:33,566 --> 00:55:36,199
就是我们用继承的多态去实现啊

1271
00:55:36,200 --> 00:55:37,300
polymorphie的

1272
00:55:37,533 --> 00:55:40,333
还有一个是间接啊interaction

1273
00:55:40,466 --> 00:55:42,066
就是本来我们可以直接调用的

1274
00:55:42,066 --> 00:55:44,799
但是我们在这里故意不去直接调用啊

1275
00:55:44,800 --> 00:55:46,333
中间插入了一个东西

1276
00:55:46,333 --> 00:55:48,733
去间接的使用它啊interaction

1277
00:55:49,533 --> 00:55:51,699
我们今天主要讲的是前面两种

1278
00:55:51,700 --> 00:55:52,566
最基本的方法

1279
00:55:52,566 --> 00:55:54,533
就是create和信息专家

1280
00:55:54,733 --> 00:55:58,333
结合我们最简单的模块地区啊来讲

1281
00:55:59,366 --> 00:56:00,899
首先讲创建者

1282
00:56:01,666 --> 00:56:03,599
创建者其实解决的一个问题

1283
00:56:03,600 --> 00:56:06,533
就是对象如何创建啊

1284
00:56:06,533 --> 00:56:08,099
如果不用创建者方法的话

1285
00:56:08,100 --> 00:56:09,500
对象全部都是平面的

1286
00:56:09,500 --> 00:56:11,733
创建出来的就全是溜出来的啊

1287
00:56:11,733 --> 00:56:13,866
溜出来以后再去建立关系

1288
00:56:14,400 --> 00:56:17,166
但是我们通常在面向对象中间

1289
00:56:17,166 --> 00:56:20,533
不会简单的把对象平面的创建起来

1290
00:56:20,533 --> 00:56:21,966
然后把它关联起来

1291
00:56:22,133 --> 00:56:23,566
因为这样做的话啊

1292
00:56:23,566 --> 00:56:25,099
代码过于琐碎

1293
00:56:25,100 --> 00:56:27,933
而且他的约束性不强

1294
00:56:28,333 --> 00:56:31,466
所以我们一般会由一些对象

1295
00:56:31,466 --> 00:56:33,399
去创建另外一些对象

1296
00:56:34,100 --> 00:56:34,866
那通常来说

1297
00:56:34,866 --> 00:56:37,266
我们说创建其他对象的那些对象

1298
00:56:37,566 --> 00:56:39,199
被称之为创建者

1299
00:56:39,500 --> 00:56:41,266
那谁是创建者

1300
00:56:41,533 --> 00:56:43,999
我们通常用这4个关系啊

1301
00:56:44,000 --> 00:56:46,300
去决定说谁会创建谁

1302
00:56:46,900 --> 00:56:49,333
如果说b里头包含了a

1303
00:56:49,400 --> 00:56:52,966
就是a完全就是b的一个局部

1304
00:56:53,500 --> 00:56:55,300
是整体和局部的关系

1305
00:56:55,300 --> 00:56:56,500
conversation的关系

1306
00:56:56,733 --> 00:56:59,133
那这时候其实大部分情况下头

1307
00:56:59,133 --> 00:57:01,899
我们都会由整体来创建局部

1308
00:57:02,166 --> 00:57:03,866
这个就在领域模型和对象模型中间

1309
00:57:03,866 --> 00:57:07,499
我们都会标那个黑实心的菱形箭头

1310
00:57:07,500 --> 00:57:08,300
的时候啊

1311
00:57:08,300 --> 00:57:10,333
其实我们都会考虑说由整体去

1312
00:57:10,333 --> 00:57:11,166
创建局部

1313
00:57:11,366 --> 00:57:13,466
那除了整体和局部的关系以外

1314
00:57:13,966 --> 00:57:16,299
如果b跟a有关系

1315
00:57:16,500 --> 00:57:18,133
如果b会调用a

1316
00:57:18,533 --> 00:57:20,099
如果要创建a的时候

1317
00:57:20,100 --> 00:57:21,133
他有初始化数据

1318
00:57:21,133 --> 00:57:22,899
就构造函数的那些参数

1319
00:57:23,100 --> 00:57:24,500
那些数据在b里头

1320
00:57:24,500 --> 00:57:27,466
我们都会考虑说由b去创建a

1321
00:57:27,666 --> 00:57:30,266
这总而言之就是为了避免平面的

1322
00:57:30,266 --> 00:57:31,666
去创建对象

1323
00:57:32,900 --> 00:57:33,533
怎么做啊

1324
00:57:33,533 --> 00:57:35,299
这是我们在领域当中只有一个对象

1325
00:57:35,300 --> 00:57:36,366
就是region啊

1326
00:57:36,533 --> 00:57:37,733
region这一个对象

1327
00:57:37,733 --> 00:57:40,499
地区对象其实也有个创建问题

1328
00:57:40,800 --> 00:57:42,733
就是当我要建一个地区的时候

1329
00:57:43,600 --> 00:57:45,700
这个对象怎么创建出来

1330
00:57:47,566 --> 00:57:49,866
我们看一下这个他的

1331
00:57:51,600 --> 00:57:54,733
这个API这个API就是管理员

1332
00:57:54,733 --> 00:57:56,766
在地区底下去创建一个子地区啊

1333
00:57:56,766 --> 00:57:57,299
我们知道

1334
00:57:57,300 --> 00:58:00,266
地区这个对象在创建的时候

1335
00:58:00,266 --> 00:58:02,399
其实是有约束的

1336
00:58:02,533 --> 00:58:04,466
他不能创建一个孤立地区

1337
00:58:04,466 --> 00:58:05,599
就创建一个地区

1338
00:58:05,600 --> 00:58:07,666
其实是不重属于任何一个地方

1339
00:58:07,733 --> 00:58:08,799
我们在这个系统中间

1340
00:58:08,800 --> 00:58:11,166
我们的第一级的的地区已经建好了

1341
00:58:11,166 --> 00:58:12,133
但是不能动的

1342
00:58:12,300 --> 00:58:13,933
就是我们中华人民共和国

1343
00:58:13,933 --> 00:58:15,533
建在了最上面那一级

1344
00:58:16,266 --> 00:58:17,399
所以在这个系统中间

1345
00:58:17,400 --> 00:58:18,600
所有的地区

1346
00:58:18,600 --> 00:58:21,533
只能建在中华人民共和国底下

1347
00:58:21,766 --> 00:58:23,599
你不能建到外国去建一个地区

1348
00:58:23,600 --> 00:58:25,300
因为我们现在这个

1349
00:58:25,666 --> 00:58:28,799
这个平台是不允许跨国电商的

1350
00:58:29,000 --> 00:58:30,600
所以在地区这个模块

1351
00:58:30,600 --> 00:58:32,466
中间的最上面一级

1352
00:58:32,466 --> 00:58:33,699
是被卡死的

1353
00:58:33,700 --> 00:58:34,866
那是不能再建了

1354
00:58:34,933 --> 00:58:36,866
就是中华人民共和国下面的

1355
00:58:36,866 --> 00:58:37,966
可以任意的去改动

1356
00:58:37,966 --> 00:58:39,533
因为中华人民共和国的境内

1357
00:58:39,533 --> 00:58:40,166
所有的地区

1358
00:58:40,166 --> 00:58:42,333
有可能会产生行政区划的调整

1359
00:58:42,766 --> 00:58:44,466
所以有可能产生一个新的地区

1360
00:58:44,666 --> 00:58:47,333
也有可能有一个地区被废弃掉了啊

1361
00:58:47,333 --> 00:58:48,466
其实他不是删除掉

1362
00:58:48,466 --> 00:58:49,533
是被废弃掉了

1363
00:58:49,700 --> 00:58:50,666
这个原因是因为

1364
00:58:50,666 --> 00:58:52,499
这个地区曾经有发货的订单

1365
00:58:52,500 --> 00:58:54,300
那些订单依然要能看到

1366
00:58:54,300 --> 00:58:55,933
说他发到这个地区的

1367
00:58:56,133 --> 00:58:58,133
但是这个地区

1368
00:58:58,133 --> 00:59:01,133
其实是不能再继续再用了啊再用了

1369
00:59:02,666 --> 00:59:04,333
我们的API是长这个样的

1370
00:59:05,733 --> 00:59:09,266
就是在地区底下去创建此地区啊

1371
00:59:09,266 --> 00:59:12,299
其实把地区的一部分的属性

1372
00:59:12,966 --> 00:59:15,066
把它传过来

1373
00:59:15,266 --> 00:59:17,066
然后在某个指定地底下

1374
00:59:17,066 --> 00:59:18,799
去创建它的指定区

1375
00:59:18,866 --> 00:59:21,466
这是用race的风格所定义的啊

1376
00:59:21,466 --> 00:59:22,299
我们顺便说一下

1377
00:59:22,300 --> 00:59:25,766
我们在定义这个API的这个规矩啊

1378
00:59:29,466 --> 00:59:31,366
在我们的电商平台里头

1379
00:59:31,366 --> 00:59:34,333
我们的所有API被分成了三类API

1380
00:59:34,733 --> 00:59:36,533
一类API是不需要登录的

1381
00:59:37,133 --> 00:59:39,299
一类API是顾客用的

1382
00:59:39,300 --> 00:59:41,400
顾客是需要登录或者不需要登录的

1383
00:59:41,400 --> 00:59:43,466
所以总的API总那边分两类

1384
00:59:43,466 --> 00:59:45,899
顾客用的和后台用的

1385
00:59:46,133 --> 00:59:47,566
那顾客用的里头

1386
00:59:47,566 --> 00:59:50,666
分为登陆的和不需要登陆的啊

1387
00:59:50,666 --> 00:59:52,199
所有的顾客的API里头

1388
00:59:52,200 --> 00:59:54,866
都不带前面那个Sharps ID

1389
00:59:55,566 --> 00:59:57,566
所有带了Sharps ID的

1390
00:59:57,566 --> 00:59:59,799
就是前面那一段Sharps d ID的

1391
00:59:59,800 --> 01:00:00,933
那一段的API

1392
01:00:01,333 --> 01:00:04,933
说明这个API是后端使用的

1393
01:00:05,766 --> 01:00:08,333
这个did表示的是商铺的ID

1394
01:00:08,533 --> 01:00:10,299
如果说是平台管理员用的话

1395
01:00:10,300 --> 01:00:12,000
那个商铺ID是一个很特别的

1396
01:00:12,000 --> 01:00:12,933
指0

1397
01:00:13,866 --> 01:00:17,266
其他的都是这个商铺的管理员

1398
01:00:17,266 --> 01:00:18,333
他是哪个商铺的

1399
01:00:18,566 --> 01:00:20,366
需要把他的ID带进来

1400
01:00:20,500 --> 01:00:23,000
那新增地区这个东西的话啊

1401
01:00:23,000 --> 01:00:25,700
大家可以看到他规定的说d i d只能为0

1402
01:00:25,933 --> 01:00:29,299
就是所有的商铺是不允许

1403
01:00:29,366 --> 01:00:30,133
什么呢

1404
01:00:30,133 --> 01:00:32,933
不允许说在平台里头建地区的

1405
01:00:32,933 --> 01:00:34,099
他不能调这个API

1406
01:00:34,400 --> 01:00:37,333
调这个API就会出错

1407
01:00:38,000 --> 01:00:39,300
那有同学说

1408
01:00:39,300 --> 01:00:42,266
那我商铺管理员假设我是个黑客啊

1409
01:00:42,266 --> 01:00:43,799
我用商铺管理员登上来

1410
01:00:43,800 --> 01:00:45,866
我就直接写一个shopling region

1411
01:00:45,866 --> 01:00:47,466
ID调过来可不可以

1412
01:00:48,266 --> 01:00:49,299
你们觉得可不可以

1413
01:00:49,366 --> 01:00:50,266
不可以的

1414
01:00:50,266 --> 01:00:52,966
因为我们有一个AOP在前面

1415
01:00:52,966 --> 01:00:53,999
把它管住了

1416
01:00:54,166 --> 01:00:57,066
就是要判断当前登录用户的商铺

1417
01:00:57,066 --> 01:01:00,866
和这个路径上面的那个shop的DID

1418
01:01:00,866 --> 01:01:01,799
是不是一致的

1419
01:01:01,800 --> 01:01:04,066
是一致的才可以走

1420
01:01:04,100 --> 01:01:05,600
不是一致的就不可以走

1421
01:01:05,600 --> 01:01:08,466
所以这一个API虽然这么写

1422
01:01:08,466 --> 01:01:10,533
但其实它只能写shops 0

1423
01:01:10,566 --> 01:01:12,499
然后region哪个地区

1424
01:01:12,566 --> 01:01:13,933
然后底下建一个指地区

1425
01:01:13,933 --> 01:01:15,399
只能只能这么写啊

1426
01:01:15,800 --> 01:01:17,166
这是我们这个整个

1427
01:01:17,166 --> 01:01:18,533
这个API的这个规矩

1428
01:01:20,700 --> 01:01:21,900
所以只能为0啊

1429
01:01:21,900 --> 01:01:24,600
要不然就会抛出这个超超范

1430
01:01:24,600 --> 01:01:25,666
超范围的这个错误

1431
01:01:25,666 --> 01:01:26,699
就十七号错误

1432
01:01:27,800 --> 01:01:29,533
那下面写的是它的内容

1433
01:01:30,133 --> 01:01:31,933
然后把它提交

1434
01:01:32,300 --> 01:01:34,400
提交的时候其实是有一定的限制的啊

1435
01:01:34,400 --> 01:01:35,866
就是上级地区不能废弃

1436
01:01:35,866 --> 01:01:36,666
你要是废弃了

1437
01:01:36,666 --> 01:01:37,533
其实是不能在底下

1438
01:01:37,533 --> 01:01:40,066
再去建新建的子地区的

1439
01:01:42,533 --> 01:01:44,799
我们看一下整体的这个代码啊

1440
01:01:44,800 --> 01:01:46,100
因为这是第一个API

1441
01:01:46,100 --> 01:01:47,600
所以我们讲到整体的结构

1442
01:01:47,900 --> 01:01:51,566
我们使用了一个MVC

1443
01:01:52,100 --> 01:01:55,333
就是一个层次体系结构和DD结构

1444
01:01:55,333 --> 01:01:56,966
混合的这样一个结构

1445
01:01:57,266 --> 01:02:00,799
就是它既不是完全的层次体系结构

1446
01:02:01,200 --> 01:02:03,133
也不是完全的滴

1447
01:02:03,133 --> 01:02:04,299
滴滴的架构啊

1448
01:02:04,300 --> 01:02:07,700
就是那个领域驱动设计的这个架构

1449
01:02:07,700 --> 01:02:09,400
我们其实是混合了两种

1450
01:02:09,666 --> 01:02:11,766
我们的最上面一层是控制器层

1451
01:02:11,966 --> 01:02:16,899
这个是为上面去提供rest of API的啊

1452
01:02:16,900 --> 01:02:18,766
所以如果在滴滴的价格中间

1453
01:02:18,766 --> 01:02:22,366
这个称之为rest of API的Adapter最下

1454
01:02:22,366 --> 01:02:23,899
面一层是map层

1455
01:02:24,000 --> 01:02:26,466
这个是用来去存取关系数据库的

1456
01:02:26,466 --> 01:02:28,399
因为这个模块没有其他的数据库

1457
01:02:28,700 --> 01:02:30,266
就是把它存在MYC库里的

1458
01:02:30,266 --> 01:02:33,066
所以map层是用来存取关系数据库的

1459
01:02:33,266 --> 01:02:34,566
这个在滴滴的价格中间

1460
01:02:34,566 --> 01:02:37,399
称之为DATABASED Adapter

1461
01:02:37,766 --> 01:02:39,499
所以如果在DDD架构中间

1462
01:02:39,700 --> 01:02:42,133
Controller层和Maptage都属于Adapter

1463
01:02:42,266 --> 01:02:43,799
但是我们在这里可以看到

1464
01:02:43,800 --> 01:02:46,533
我们没有用DD架构中间

1465
01:02:46,533 --> 01:02:48,799
把它合成一层的这样的一个定义

1466
01:02:48,800 --> 01:02:51,366
而是把它在层次体系结构中间

1467
01:02:51,366 --> 01:02:54,799
把它定义成为控制器层和Mapper层

1468
01:02:55,400 --> 01:02:56,733
中间的两层啊

1469
01:02:56,733 --> 01:02:58,999
收费值层实际上是在滴滴架构中间

1470
01:02:59,000 --> 01:03:01,933
称之为abdication层啊

1471
01:03:02,900 --> 01:03:04,866
倒层在滴滴架构中间

1472
01:03:04,866 --> 01:03:06,799
称之为朵面层

1473
01:03:06,800 --> 01:03:08,500
但其实我们啊

1474
01:03:08,500 --> 01:03:11,366
不能严格的把倒层称之为朵面层

1475
01:03:11,366 --> 01:03:13,966
我们其实应该把中间的那个bo

1476
01:03:14,166 --> 01:03:16,733
那个包在滴滴价格中间

1477
01:03:16,733 --> 01:03:18,166
称之为斗魅城啊

1478
01:03:18,166 --> 01:03:19,166
很大家不记得了

1479
01:03:19,166 --> 01:03:21,499
我把那张体系结构图调出来啊

1480
01:03:25,166 --> 01:03:25,966
下一下

1481
01:03:33,166 --> 01:03:35,499
就大a不记得第一季的体系结构了

1482
01:03:40,166 --> 01:03:41,599
看他一脸茫然

1483
01:03:50,466 --> 01:03:52,366
这个这个

1484
01:03:52,366 --> 01:03:53,299
这么基础的东西

1485
01:03:53,300 --> 01:03:54,266
我一遍遍讲啊

1486
01:03:54,266 --> 01:03:54,966
大家一定要知道

1487
01:03:54,966 --> 01:03:56,499
这一定是要考试的

1488
01:03:58,466 --> 01:04:00,799
所以不要到考试之前再去背这个

1489
01:04:00,800 --> 01:04:01,733
就没有意义了

1490
01:04:01,733 --> 01:04:03,666
这个其实就是在整个设计过程中间

1491
01:04:03,666 --> 01:04:05,999
这些观念都是融

1492
01:04:08,800 --> 01:04:09,800
不是这个版本

1493
01:04:12,066 --> 01:04:13,499
融会贯通在里头

1494
01:05:05,200 --> 01:05:09,166
这个我们的架构其实是混合了

1495
01:05:10,600 --> 01:05:14,866
这个分层的体系结构和DED的架构啊

1496
01:05:15,000 --> 01:05:16,533
我们的控制器层

1497
01:05:16,933 --> 01:05:19,166
其实是这个restaurant Adapter

1498
01:05:19,500 --> 01:05:21,966
map层是ORM Adapter

1499
01:05:22,300 --> 01:05:24,100
然后收费值层是application

1500
01:05:25,300 --> 01:05:27,766
呃这个稻城呢

1501
01:05:27,766 --> 01:05:29,266
其实在这里是没有描述的

1502
01:05:29,266 --> 01:05:30,566
Bo其实是中间的

1503
01:05:30,566 --> 01:05:32,366
这个领域模型是这样的一个概念

1504
01:05:32,366 --> 01:05:34,866
你你如果认为稻城也是ORM Adapter

1505
01:05:34,866 --> 01:05:35,666
也可以啊

1506
01:05:35,666 --> 01:05:36,966
就稻层和map层

1507
01:05:36,966 --> 01:05:38,566
称之为ORM Adapter

1508
01:05:38,866 --> 01:05:41,733
然后控制器层是reservation API

1509
01:05:41,966 --> 01:05:44,533
service层是application

1510
01:05:44,533 --> 01:05:47,133
然后Bo是中间的DOMAIN object

1511
01:05:47,166 --> 01:05:48,966
是这样的一个关系

1512
01:05:52,866 --> 01:05:54,766
呃代码放到这边

1513
01:05:55,100 --> 01:05:56,000
其实很简单

1514
01:05:56,066 --> 01:05:57,466
这就全部的代码

1515
01:05:58,066 --> 01:05:59,066
总共这么代码啊

1516
01:05:59,066 --> 01:06:00,133
就这么个代码

1517
01:06:00,366 --> 01:06:02,499
连写代码到弄文档

1518
01:06:02,766 --> 01:06:05,066
也大概要干6个小时左右啊

1519
01:06:05,066 --> 01:06:05,933
6个小时左右

1520
01:06:20,066 --> 01:06:21,999
嗯不应该要把类图放在哪

1521
01:06:22,366 --> 01:06:24,566
我们整体的这个类图啊

1522
01:06:24,566 --> 01:06:25,566
长这个样

1523
01:06:26,266 --> 01:06:28,366
这个是不是有点看不清楚

1524
01:06:29,800 --> 01:06:30,700
那我们

1525
01:06:32,466 --> 01:06:33,666
从这个开始看起吧

1526
01:06:36,366 --> 01:06:42,066
创建者怎么创建一个指地区的对象

1527
01:06:42,166 --> 01:06:46,166
我把它的完整的过程用顺序图画出来

1528
01:06:47,266 --> 01:06:48,066
能看懂吗

1529
01:06:48,866 --> 01:06:50,899
看一下能不能看懂

1530
01:06:59,800 --> 01:07:02,133
这个从控制器层service层

1531
01:07:02,133 --> 01:07:05,666
稻城到我们的领域模型啊

1532
01:07:05,666 --> 01:07:07,133
全画了以后

1533
01:07:07,133 --> 01:07:10,666
其实不会画的这么的仔细啊

1534
01:07:10,666 --> 01:07:11,799
以后去其实不是画

1535
01:07:11,800 --> 01:07:12,933
画的这么仔细

1536
01:07:13,166 --> 01:07:14,266
我们可以看到最后一张图

1537
01:07:14,266 --> 01:07:15,466
就没有画的这么仔细

1538
01:07:16,133 --> 01:07:17,099
这张图描述了

1539
01:07:17,100 --> 01:07:19,933
说我们从控制器层一个API过来

1540
01:07:19,933 --> 01:07:22,333
就我们刚才说那个API过来啊

1541
01:07:22,333 --> 01:07:24,199
我们可以看到路径上的有super ID

1542
01:07:25,200 --> 01:07:27,266
然后路径上头有region的ID

1543
01:07:27,366 --> 01:07:29,499
这第二个是region ID传过来的

1544
01:07:29,500 --> 01:07:31,933
body呢是在VO里头

1545
01:07:32,366 --> 01:07:34,533
最后一个参数是我们用AOP切上去的

1546
01:07:34,533 --> 01:07:35,699
这当前登录的用户

1547
01:07:35,700 --> 01:07:36,733
它是有TOKEN的

1548
01:07:36,766 --> 01:07:38,133
这个TOKEN会被解析出来

1549
01:07:38,133 --> 01:07:39,733
放到了这个右侧底下

1550
01:07:39,800 --> 01:07:42,700
变成了我们在Controller层的4个参数

1551
01:07:43,200 --> 01:07:44,700
传过来传

1552
01:07:44,700 --> 01:07:45,733
过来以后啊

1553
01:07:45,733 --> 01:07:47,566
在面向对象的领域中间

1554
01:07:47,566 --> 01:07:48,366
大家知道

1555
01:07:48,400 --> 01:07:50,800
进入到面向对象的领域的第一件事情

1556
01:07:51,200 --> 01:07:54,000
是把东西变成对象

1557
01:07:55,166 --> 01:07:55,733
我们可以看到

1558
01:07:55,733 --> 01:07:56,799
我们首先做的一件事情

1559
01:07:56,800 --> 01:07:59,000
就是把VO变成了Bo对象

1560
01:08:00,100 --> 01:08:03,533
呃用cloud factory的copy方法

1561
01:08:04,066 --> 01:08:06,333
呃region是我们的新的对象啊

1562
01:08:06,333 --> 01:08:07,699
就是我们的地区对象

1563
01:08:07,700 --> 01:08:08,966
这是Bo的对象

1564
01:08:09,333 --> 01:08:09,666
然后

1565
01:08:09,666 --> 01:08:12,566
我们把从前端传过来的这个VO对象

1566
01:08:12,566 --> 01:08:13,699
把它拷贝过来

1567
01:08:14,400 --> 01:08:14,900
大家知道

1568
01:08:14,900 --> 01:08:17,266
我们在控制器层用VO去接的话

1569
01:08:17,266 --> 01:08:18,799
是因为VO是有什么

1570
01:08:18,800 --> 01:08:23,333
是有呃输入值的合法性验证的

1571
01:08:24,100 --> 01:08:25,466
所以接过来以后

1572
01:08:25,466 --> 01:08:28,066
接到手上说明合法行驶证是有通过了

1573
01:08:28,400 --> 01:08:28,733
然后

1574
01:08:28,733 --> 01:08:32,266
它的结构和这个reading是不太一样的

1575
01:08:32,700 --> 01:08:34,900
啊我们可以看一下在

1576
01:08:38,800 --> 01:08:39,766
这张图里头

1577
01:08:40,366 --> 01:08:42,066
这张图可能有点小了

1578
01:08:42,066 --> 01:08:43,166
我把它烤出来吧

1579
01:09:04,533 --> 01:09:05,566
这也不好看

1580
01:09:08,100 --> 01:09:09,066
拿大一点吧

1581
01:09:33,466 --> 01:09:34,599
让他这么打啊

1582
01:09:34,766 --> 01:09:37,366
这样应该能够看得清楚

1583
01:09:39,100 --> 01:09:39,766
这里头啊

1584
01:09:39,766 --> 01:09:40,699
大家可以看到

1585
01:09:40,700 --> 01:09:45,533
VO和我们的Bo对象其实是有差别的

1586
01:09:45,800 --> 01:09:47,566
比如说我们的这个状态

1587
01:09:48,333 --> 01:09:50,966
比如说我们的级别状态

1588
01:09:51,300 --> 01:09:54,366
还有我们的级别在VO中间是没有的

1589
01:09:54,566 --> 01:09:56,933
VO中间因为这里比较简单

1590
01:09:56,933 --> 01:09:58,199
它里头只有一个对象

1591
01:09:58,266 --> 01:09:59,733
我们现在看到的就是VO

1592
01:09:59,733 --> 01:10:01,999
只有VO的一小部分属性

1593
01:10:02,600 --> 01:10:03,533
一部分属性

1594
01:10:03,733 --> 01:10:05,799
当所有的VO的这些属性

1595
01:10:05,800 --> 01:10:07,466
就从前端书架这些属性是有

1596
01:10:07,466 --> 01:10:08,566
做了合法性教练

1597
01:10:09,000 --> 01:10:10,733
他的合法性教练完成了以后呢

1598
01:10:10,733 --> 01:10:12,866
则会把这个对象的属性

1599
01:10:13,266 --> 01:10:16,299
用我们独立的一个静态的方法

1600
01:10:16,300 --> 01:10:19,200
把它拷贝到这个对象上来啊

1601
01:10:19,200 --> 01:10:20,766
所以大家可以看到的

1602
01:10:26,933 --> 01:10:29,133
这个就是在干这件事情

1603
01:10:29,133 --> 01:10:31,866
把VO的对象拷贝过来

1604
01:10:32,266 --> 01:10:33,766
拷贝过来以后

1605
01:10:34,166 --> 01:10:36,766
然后我们从service层开始

1606
01:10:37,066 --> 01:10:40,566
我们就是用Bo对象来进行操作了

1607
01:10:40,700 --> 01:10:42,500
所以我们调收费时辰的方法

1608
01:10:42,500 --> 01:10:43,933
create sub regions

1609
01:10:44,066 --> 01:10:45,933
把ID传过来

1610
01:10:45,933 --> 01:10:48,866
这是他的上级地区的ID

1611
01:10:49,100 --> 01:10:50,800
把我们要建的这个region传过来

1612
01:10:50,800 --> 01:10:52,100
还有从前面拿过来

1613
01:10:52,100 --> 01:10:55,200
这个user就是谁建的啊

1614
01:10:55,200 --> 01:10:56,266
把它带过去

1615
01:10:56,466 --> 01:10:59,199
然后在收费值城的这个里面

1616
01:10:59,200 --> 01:11:00,800
我们做的事情是什么呢

1617
01:11:00,800 --> 01:11:03,866
我们首先要看上级地区是不是存在

1618
01:11:04,266 --> 01:11:06,766
以及说这个地区的状态

1619
01:11:06,766 --> 01:11:08,733
是不是一个合法的状态

1620
01:11:09,000 --> 01:11:10,700
如果说是合法的状态

1621
01:11:10,700 --> 01:11:14,366
我们才可以建这个夏季地区

1622
01:11:14,400 --> 01:11:15,900
比如说他不是停用的

1623
01:11:15,900 --> 01:11:16,933
不是废弃的

1624
01:11:17,000 --> 01:11:18,166
才可以建夏季地区

1625
01:11:18,166 --> 01:11:19,299
否则的话就不能建

1626
01:11:19,400 --> 01:11:20,133
所以第一件事情

1627
01:11:20,133 --> 01:11:24,766
我们去把在稻城把ID给他

1628
01:11:24,766 --> 01:11:26,899
把这个对象给他找过来

1629
01:11:26,966 --> 01:11:28,999
找过来以后要做合法营接链啊

1630
01:11:29,000 --> 01:11:32,066
这段代码我忘了写了啊

1631
01:11:32,166 --> 01:11:33,066
是bug啊

1632
01:11:33,066 --> 01:11:34,266
待会我把它补上去

1633
01:11:34,466 --> 01:11:35,333
但我涂上了

1634
01:11:35,333 --> 01:11:36,133
我没有画

1635
01:11:36,533 --> 01:11:39,933
然后呢我们则会在这个地区底下

1636
01:11:40,266 --> 01:11:43,166
去创建一个新的地区

1637
01:11:44,400 --> 01:11:47,066
啊去创建一个新的地区

1638
01:11:47,366 --> 01:11:49,066
创建一个新的地区

1639
01:11:49,066 --> 01:11:50,066
我们可以看到

1640
01:11:50,066 --> 01:11:54,099
这个方法就是一个创建对象的方法了

1641
01:11:54,600 --> 01:11:55,800
怎么创建对象法

1642
01:11:56,566 --> 01:11:58,166
我们的做法就是

1643
01:11:58,166 --> 01:12:00,866
我们把创建对象的这个职责

1644
01:12:03,166 --> 01:12:05,166
交给了他的整体

1645
01:12:05,600 --> 01:12:07,266
我们在这张图上可以看到

1646
01:12:07,266 --> 01:12:09,799
地区和地区之间实际存在的关系的

1647
01:12:10,266 --> 01:12:11,266
这个关系是什么呢

1648
01:12:11,266 --> 01:12:12,999
这个关系是整体和局部的关系

1649
01:12:13,000 --> 01:12:17,700
就是上级地区是下级地区的整体

1650
01:12:18,166 --> 01:12:20,333
为啥因为任何一个下级地区

1651
01:12:20,333 --> 01:12:21,666
一定是归属于一个上

1652
01:12:21,666 --> 01:12:22,333
级地区的

1653
01:12:22,333 --> 01:12:25,733
比如说厦门市是一定归属于福建省的

1654
01:12:26,066 --> 01:12:28,366
厦门市不可能脱离福建省存在

1655
01:12:28,366 --> 01:12:31,566
不存在任何孤立的这个地区

1656
01:12:31,733 --> 01:12:34,599
如果说整个福建省被废止了啊

1657
01:12:34,600 --> 01:12:35,466
假如说啊

1658
01:12:35,566 --> 01:12:37,733
整个福建省被废止了

1659
01:12:37,733 --> 01:12:39,766
那厦门市也就都废止了

1660
01:12:39,966 --> 01:12:43,899
所以说他是一个整体和局部的关系

1661
01:12:44,300 --> 01:12:45,166
是这样一个关系

1662
01:12:45,266 --> 01:12:46,966
那是整体和局部的关系

1663
01:12:46,966 --> 01:12:50,666
我们直接套用了创建者的方法

1664
01:12:50,766 --> 01:12:54,533
把创建下级地区这个职责

1665
01:12:55,466 --> 01:12:58,466
交给了他的上级地区去完成

1666
01:12:58,466 --> 01:13:00,599
这个就是我们所说的职责

1667
01:13:01,500 --> 01:13:02,200
职责从哪来

1668
01:13:02,200 --> 01:13:03,366
职责从功能来

1669
01:13:03,500 --> 01:13:05,966
对于这个功能就是一个创建指地区

1670
01:13:06,266 --> 01:13:08,266
所以它的功能中间有一个职责

1671
01:13:08,766 --> 01:13:09,799
有两个职责啊

1672
01:13:09,800 --> 01:13:11,500
一个职责是要去找到

1673
01:13:11,500 --> 01:13:12,766
这个地区是不存在

1674
01:13:13,500 --> 01:13:16,400
判断这个地区是不是合法

1675
01:13:16,533 --> 01:13:18,666
如果这个地区是合法的状态

1676
01:13:18,666 --> 01:13:20,199
则在底下创建一个指定区

1677
01:13:20,200 --> 01:13:21,166
三个职责

1678
01:13:21,266 --> 01:13:24,666
那其中我们把创建指地区的

1679
01:13:24,666 --> 01:13:25,999
这个创建地区的职责

1680
01:13:26,000 --> 01:13:27,900
交给他的上级地区去完成

1681
01:13:28,366 --> 01:13:29,666
上级地区怎么去完成呢

1682
01:13:29,666 --> 01:13:32,366
上级地区其实会去调这个盗对象

1683
01:13:32,700 --> 01:13:35,100
去把这个地区给他插进去

1684
01:13:35,400 --> 01:13:37,500
然后把它返回回来

1685
01:13:37,600 --> 01:13:39,066
然后这个值会返回这个

1686
01:13:39,066 --> 01:13:40,799
注意这个主观变量啊

1687
01:13:40,800 --> 01:13:42,100
这个值是返回到这

1688
01:13:42,400 --> 01:13:43,700
然后这个值呢

1689
01:13:43,700 --> 01:13:45,766
就会把它再用cloudic的

1690
01:13:45,766 --> 01:13:47,599
把它变成DTO对象

1691
01:13:47,966 --> 01:13:49,066
给它返回回来

1692
01:13:49,500 --> 01:13:50,900
所以在这张图里头

1693
01:13:50,900 --> 01:13:52,733
我们在静态模型这后面

1694
01:13:52,733 --> 01:13:53,933
静态模型放到最后了啊

1695
01:13:54,200 --> 01:13:56,333
可以看到我们首先把v o

1696
01:13:56,933 --> 01:13:59,166
把它通过它变成了b o

1697
01:14:00,000 --> 01:14:02,800
然后呢b o其实通过它变成了PO

1698
01:14:02,800 --> 01:14:05,366
因为它去存的时候再把它变成POPO

1699
01:14:05,366 --> 01:14:06,599
存到数据库里去

1700
01:14:07,133 --> 01:14:09,499
对吧然后如果他有返回值的话

1701
01:14:09,500 --> 01:14:13,766
又把这个Bo通过它变成DTO

1702
01:14:14,000 --> 01:14:15,133
给它返回去

1703
01:14:15,300 --> 01:14:18,800
所以我们的VO DTO Bo和PU的作用啊

1704
01:14:18,800 --> 01:14:21,000
在这张图上的这张里头

1705
01:14:21,000 --> 01:14:22,200
其实是能看得出来的

1706
01:14:26,900 --> 01:14:27,533
看到这张图

1707
01:14:27,533 --> 01:14:29,866
应该大家知道代码怎么写了对吧

1708
01:14:29,866 --> 01:14:31,066
这就是我们的设计

1709
01:14:31,666 --> 01:14:32,533
这就是我们的设计

1710
01:14:32,533 --> 01:14:33,466
当然了啊

1711
01:14:33,466 --> 01:14:35,899
这个设计其实是没必要写的这么细的

1712
01:14:36,066 --> 01:14:38,799
这是要给大家做一个范例

1713
01:14:38,966 --> 01:14:42,266
所以我实际上把这个设计全部写出来

1714
01:14:42,266 --> 01:14:45,199
代码80%都已经出来了

1715
01:14:45,933 --> 01:14:46,966
怎么写啊

1716
01:14:47,166 --> 01:14:50,566
这里头大家可以看到一个重要的特点

1717
01:14:50,766 --> 01:14:51,166
就是

1718
01:14:51,166 --> 01:14:55,666
我们没有把代码集中在某一个地方

1719
01:14:55,800 --> 01:14:57,300
我们在之前我们有说了

1720
01:14:57,300 --> 01:14:59,066
我们要做分层的体系结构

1721
01:14:59,066 --> 01:15:01,599
大家可以看到这是在做分层

1722
01:15:02,500 --> 01:15:05,500
service control层service层倒层

1723
01:15:05,500 --> 01:15:08,166
我们看到的三层有看到

1724
01:15:08,166 --> 01:15:09,466
为什么没有my per层

1725
01:15:09,466 --> 01:15:10,333
因为my per层

1726
01:15:10,333 --> 01:15:12,333
大家大伙可以看到是没有代码的

1727
01:15:12,333 --> 01:15:13,733
一行代码都没有

1728
01:15:14,200 --> 01:15:16,466
我们的所有代码都在control层

1729
01:15:16,466 --> 01:15:17,666
设备层和稻城

1730
01:15:18,000 --> 01:15:20,300
什么代码写在了哪一层

1731
01:15:20,400 --> 01:15:22,400
我们是有特定的定义的

1732
01:15:22,533 --> 01:15:23,766
比如说对于control层

1733
01:15:23,766 --> 01:15:24,933
他所做的事情是什么

1734
01:15:24,933 --> 01:15:25,766
就做了两件事情

1735
01:15:25,766 --> 01:15:26,999
第二和第七

1736
01:15:27,600 --> 01:15:30,133
一个是把read对象变成啊b o对象

1737
01:15:30,133 --> 01:15:30,999
变成read对象

1738
01:15:31,266 --> 01:15:33,999
第二是把返回值read对象变成DTO对象

1739
01:15:34,066 --> 01:15:35,166
所以control成

1740
01:15:35,166 --> 01:15:40,533
我们之前说的它的职责是承接输入

1741
01:15:40,666 --> 01:15:43,533
把输入转化成我们的对象模型领域

1742
01:15:43,533 --> 01:15:45,566
模型领域对象

1743
01:15:46,733 --> 01:15:47,766
承接输出

1744
01:15:47,966 --> 01:15:50,399
把我们的领域对象

1745
01:15:50,400 --> 01:15:53,333
转成要输出的DTO对象啊

1746
01:15:53,333 --> 01:15:55,066
所以这就是很明显可以看到

1747
01:15:55,566 --> 01:15:56,533
control成就是干了这

1748
01:15:56,533 --> 01:15:58,399
个事情社会层干什么

1749
01:15:58,400 --> 01:16:00,666
社会层是我们的协调者

1750
01:16:00,666 --> 01:16:01,499
领域作用

1751
01:16:01,500 --> 01:16:02,266
所以大家也看到

1752
01:16:02,266 --> 01:16:04,533
社会层其实自己并没有做太多的事情

1753
01:16:04,733 --> 01:16:07,466
做的一件事情是去找到这个对象

1754
01:16:07,933 --> 01:16:09,599
然后他要去判断这个地区

1755
01:16:09,600 --> 01:16:10,766
对象是不是合法的

1756
01:16:10,766 --> 01:16:11,933
状态是不是合法的

1757
01:16:12,000 --> 01:16:13,100
如果状态是合法

1758
01:16:13,100 --> 01:16:14,933
他就要底下去创建一个新的对象

1759
01:16:14,966 --> 01:16:17,499
无论是找还是创建

1760
01:16:17,566 --> 01:16:20,199
都不是把代码写到收费市场的

1761
01:16:20,266 --> 01:16:21,666
他是个协调者

1762
01:16:22,000 --> 01:16:23,100
是个协作的过程

1763
01:16:23,100 --> 01:16:25,333
就是我们说的职责协作

1764
01:16:25,600 --> 01:16:28,100
我们自己就缺中间那个角色

1765
01:16:28,100 --> 01:16:29,733
因为就只有一个对象

1766
01:16:30,200 --> 01:16:32,266
就没有去分出角色

1767
01:16:32,266 --> 01:16:33,299
但是我们可以看到

1768
01:16:33,300 --> 01:16:37,066
职责和协作这两个概念的存在

1769
01:16:37,066 --> 01:16:40,699
职责他把它分给了刀对象去做查询

1770
01:16:40,933 --> 01:16:43,466
分给了reading对象去做创建

1771
01:16:43,766 --> 01:16:44,566
协作

1772
01:16:44,566 --> 01:16:49,199
是在service层的代码中间去协作的啊

1773
01:16:49,200 --> 01:16:52,300
在收费层代码中间去协作的啊

1774
01:16:52,300 --> 01:16:55,166
然后具体的后面的部分啊

1775
01:16:55,166 --> 01:16:56,399
其实就不是

1776
01:16:56,600 --> 01:16:58,666
就是属于代码实现的细节部分

1777
01:16:58,733 --> 01:17:00,966
如果说在画面相对象的设计的时候

1778
01:17:00,966 --> 01:17:02,966
其实这张图画到第五步

1779
01:17:05,000 --> 01:17:05,966
就足够了

1780
01:17:06,300 --> 01:17:07,966
第六步其实是可以不画

1781
01:17:07,966 --> 01:17:09,333
第七步需要画哈

1782
01:17:10,066 --> 01:17:11,266
第五步就足够了

1783
01:17:11,266 --> 01:17:12,466
第六步其实是不需要画

1784
01:17:12,466 --> 01:17:15,099
因为面对象的设计到此就结束了

1785
01:17:15,200 --> 01:17:18,733
就是职职责确定了

1786
01:17:18,733 --> 01:17:20,199
分给不同的对象

1787
01:17:20,533 --> 01:17:23,099
协作由谁来负责来做

1788
01:17:23,166 --> 01:17:24,766
那具体职责怎么做

1789
01:17:24,966 --> 01:17:26,266
这个东西怎么做

1790
01:17:26,533 --> 01:17:29,366
这个就是具体的代码去实现

1791
01:17:29,533 --> 01:17:30,733
我们看一下这个代码啊

1792
01:17:30,733 --> 01:17:31,966
这个代码我刚才说的时候

1793
01:17:31,966 --> 01:17:33,966
我就发现我这里没有去判断它的状态

1794
01:17:33,966 --> 01:17:35,966
之后客户把它改过去

1795
01:17:41,666 --> 01:17:44,666
所以代码是有bug的啊bug是

1796
01:17:45,966 --> 01:17:47,166
14个存在

1797
01:17:56,966 --> 01:17:59,299
多讲多讨论啊你

1798
01:17:59,300 --> 01:18:00,133
其实在讨论过程中

1799
01:18:00,133 --> 01:18:01,866
就能发现自己写代码的bug

1800
01:18:02,000 --> 01:18:03,100
这个比什么呢

1801
01:18:03,100 --> 01:18:07,166
比被测试出来花的代价要小太多了

1802
01:18:07,200 --> 01:18:08,000
如果

1803
01:18:09,200 --> 01:18:10,066
到后面测试

1804
01:18:10,066 --> 01:18:13,199
特别是到测试部去测试出来那

1805
01:18:15,666 --> 01:18:16,566
画的代价就太大了

1806
01:18:16,566 --> 01:18:18,999
如果到顾客那里再被发现的话

1807
01:18:19,300 --> 01:18:21,000
那个就会造成损失了啊

1808
01:18:21,000 --> 01:18:22,166
那不就是代价了

1809
01:18:22,400 --> 01:18:24,100
所以我们会讲说

1810
01:18:24,100 --> 01:18:27,766
为什么在写的过程中间要先做设计

1811
01:18:28,533 --> 01:18:30,599
写完了以后要去跟别人沟通

1812
01:18:30,600 --> 01:18:31,333
其实这个过程

1813
01:18:31,333 --> 01:18:31,999
你就能发现

1814
01:18:32,000 --> 01:18:34,266
自己写的代码里头是有问题的

1815
01:18:34,300 --> 01:18:35,700
然后去不断的修改

1816
01:18:36,100 --> 01:18:37,400
然后自己做测试

1817
01:18:37,700 --> 01:18:40,100
做完了以后再交给测试部去做测试

1818
01:18:42,600 --> 01:18:43,933
我们看一下这张代码

1819
01:19:07,766 --> 01:19:09,366
啊我们创建地区

1820
01:19:09,366 --> 01:19:11,166
我把它分成两个三个control

1821
01:19:11,166 --> 01:19:13,699
它是在管理员这个control里头

1822
01:19:15,900 --> 01:19:17,266
创建值地区

1823
01:19:19,100 --> 01:19:20,066
大家应该能看到

1824
01:19:20,066 --> 01:19:20,866
这段代码

1825
01:19:20,866 --> 01:19:23,599
就跟我的图上的画的是一模一样的

1826
01:19:23,766 --> 01:19:25,699
第一句把VO对象

1827
01:19:25,700 --> 01:19:29,266
把它转变成为我们的领域模型对象

1828
01:19:29,500 --> 01:19:31,666
最后一句把返回的值

1829
01:19:31,666 --> 01:19:33,933
把它变成DTO的对象

1830
01:19:34,400 --> 01:19:36,766
对吧这里用了nonbook的一个插件

1831
01:19:36,766 --> 01:19:38,333
用了他的build插件啊

1832
01:19:39,166 --> 01:19:40,766
然后把它直接我

1833
01:19:40,866 --> 01:19:42,699
因为有了nonbook的这个插件的话

1834
01:19:42,700 --> 01:19:44,166
我们没必要用6的方法

1835
01:19:44,166 --> 01:19:45,766
不用没必要这么去建

1836
01:19:46,266 --> 01:19:47,533
因为里头有两个值啊

1837
01:19:47,533 --> 01:19:50,266
所以用number这个插件这样做更简单

1838
01:19:50,266 --> 01:19:52,866
这个其实大家应该在我们在后面会讲

1839
01:19:52,866 --> 01:19:54,366
这个其实叫做科瑞化

1840
01:19:54,400 --> 01:19:55,766
叫做颗粒化啊

1841
01:19:56,066 --> 01:19:59,733
这是呃面向函数编程的一个概念

1842
01:19:59,733 --> 01:20:00,733
但我们用nonbuk

1843
01:20:00,733 --> 01:20:02,566
就直接把这个东西颗粒化了

1844
01:20:02,966 --> 01:20:04,899
中间这个就是我们去调服务层

1845
01:20:05,200 --> 01:20:08,366
所以控制器层的职责是什么

1846
01:20:08,366 --> 01:20:09,266
就是我们首先不

1847
01:20:09,266 --> 01:20:10,699
说每一个对象的职责

1848
01:20:10,900 --> 01:20:12,933
每一个层的职责都要很明确

1849
01:20:12,933 --> 01:20:13,766
控制器是职责

1850
01:20:13,766 --> 01:20:14,966
就是接收输入

1851
01:20:15,300 --> 01:20:16,200
产生输出

1852
01:20:16,666 --> 01:20:17,866
中间什么都不做

1853
01:20:18,066 --> 01:20:19,133
中间事情交给什么呢

1854
01:20:19,133 --> 01:20:22,166
交给我们的收费值城去做

1855
01:20:22,366 --> 01:20:24,466
所以收费值城的代码

1856
01:20:26,066 --> 01:20:27,499
的create这个方法

1857
01:20:43,166 --> 01:20:43,966
这个方法

1858
01:20:44,933 --> 01:20:46,899
大家可以看到我这里漏写的一段代码

1859
01:20:46,933 --> 01:20:49,066
是吧按照我们的逻辑是

1860
01:20:49,066 --> 01:20:51,866
第一首先找到这个地区的对象

1861
01:20:52,000 --> 01:20:53,100
找回来以后怎么呢

1862
01:20:53,100 --> 01:20:54,066
不能直接建

1863
01:20:55,566 --> 01:20:58,599
呃当然直接建也可以

1864
01:20:58,733 --> 01:20:59,266
这个逻辑

1865
01:20:59,266 --> 01:21:00,666
你看你是写在收入层

1866
01:21:00,666 --> 01:21:03,933
还是写在对象对象里头

1867
01:21:03,933 --> 01:21:05,099
那我的倾向语来说

1868
01:21:05,100 --> 01:21:08,466
应该是写在这个credit SUB region里头啊

1869
01:21:09,100 --> 01:21:09,933
找到这个对象

1870
01:21:09,933 --> 01:21:11,099
然后去见他

1871
01:21:11,100 --> 01:21:12,733
这是我们的收入层代码

1872
01:21:14,200 --> 01:21:15,866
然后这段代码在哪呢

1873
01:21:15,866 --> 01:21:16,866
这一段代码在

1874
01:21:17,333 --> 01:21:18,999
就是找到这个对象里头啊

1875
01:21:19,000 --> 01:21:20,133
在这个reading里头

1876
01:21:37,333 --> 01:21:38,133
在这

1877
01:21:42,500 --> 01:21:43,700
这里就没有写这个判断

1878
01:21:43,700 --> 01:21:45,166
这个车要加上这个判断

1879
01:21:45,166 --> 01:21:45,699
就是他

1880
01:21:45,700 --> 01:21:48,000
并不是所有的状态都是可以见

1881
01:21:48,000 --> 01:21:49,900
只见下级

1882
01:21:50,400 --> 01:21:52,966
下级的地区的

1883
01:21:53,000 --> 01:21:56,200
要必须是当前这个状态是varity的状态

1884
01:21:56,200 --> 01:21:57,266
是有效状态

1885
01:21:57,500 --> 01:21:59,200
才可以建夏季地区啊

1886
01:21:59,300 --> 01:22:01,300
或者说停用的状态才可以

1887
01:22:01,566 --> 01:22:03,533
停用状态的主要就是suspend状态

1888
01:22:03,533 --> 01:22:04,299
主要的原因是

1889
01:22:04,300 --> 01:22:06,666
因为我可能有个新的行政区划出来了

1890
01:22:06,900 --> 01:22:08,000
但那个新的行政区划呢

1891
01:22:08,000 --> 01:22:09,700
我还没有正式用

1892
01:22:09,933 --> 01:22:10,166
所以

1893
01:22:10,166 --> 01:22:13,299
我可以先建一个suspend的这个地区

1894
01:22:13,300 --> 01:22:15,133
然后把底下的都建好

1895
01:22:15,533 --> 01:22:17,733
然后再把它恢复就可以了啊

1896
01:22:17,733 --> 01:22:17,966
所以

1897
01:22:17,966 --> 01:22:19,999
我们会中间有个suspend的这个状态

1898
01:22:20,166 --> 01:22:21,766
所以它在varit和suspend状态

1899
01:22:21,766 --> 01:22:22,899
是可以间下级

1900
01:22:22,900 --> 01:22:24,066
底级学这要加判断

1901
01:22:24,266 --> 01:22:26,466
这个是讲的时候就会发现这个代

1902
01:22:26,466 --> 01:22:27,666
码绝对有问题

1903
01:22:27,666 --> 01:22:28,933
现在没有加这个判断

1904
01:22:29,100 --> 01:22:32,466
那如果说是varit和suspent的这个状态

1905
01:22:32,466 --> 01:22:35,999
它就可以把当前状态设成varit

1906
01:22:36,000 --> 01:22:38,000
这个是我们状态基图上所写的

1907
01:22:38,000 --> 01:22:40,000
创建一个状态的时候

1908
01:22:40,200 --> 01:22:42,466
他的新建状态是varit

1909
01:22:42,466 --> 01:22:45,099
所以第一句话是状态基图所写的

1910
01:22:45,200 --> 01:22:46,333
然后把它的level

1911
01:22:46,333 --> 01:22:47,266
它的level是什么

1912
01:22:47,266 --> 01:22:48,699
就是它的层次

1913
01:22:49,266 --> 01:22:51,799
在中华人民共和国是第零层

1914
01:22:51,800 --> 01:22:55,300
然后银一二三到底是国家省市地啊

1915
01:22:55,300 --> 01:22:57,100
所以把上级的level加一

1916
01:22:57,933 --> 01:23:01,066
然后把自己的这个ID啊

1917
01:23:01,066 --> 01:23:03,399
指向他的上集的这个ID

1918
01:23:03,400 --> 01:23:07,933
然后我们去用稻城把它塞进去啊

1919
01:23:08,100 --> 01:23:09,166
那稻城代码

1920
01:23:09,166 --> 01:23:10,166
我们再来看一下

1921
01:23:16,866 --> 01:23:17,566
稻城代码

1922
01:23:17,566 --> 01:23:19,333
其实就是负责侦山改查了

1923
01:23:23,900 --> 01:23:25,000
比如这个音色的

1924
01:23:29,266 --> 01:23:31,699
这个insert的这个过程啊

1925
01:23:31,700 --> 01:23:34,100
就是我要把当前的创建者

1926
01:23:34,200 --> 01:23:35,733
就是因为我们数据库里头要记忆

1927
01:23:35,733 --> 01:23:36,866
说这个是谁改的

1928
01:23:36,866 --> 01:23:38,466
什么时间谁建的

1929
01:23:38,466 --> 01:23:40,166
这个是谁什么时间建的

1930
01:23:40,266 --> 01:23:41,533
把这两个属性设好

1931
01:23:41,533 --> 01:23:44,666
然后再用clock object把我们的bo对象

1932
01:23:44,666 --> 01:23:45,766
就是do对象啊

1933
01:23:45,766 --> 01:23:46,566
领域对象

1934
01:23:46,666 --> 01:23:49,466
把它转化成为Po对象

1935
01:23:49,666 --> 01:23:51,099
把它做列一个转化

1936
01:23:51,200 --> 01:23:53,100
然后再调map程把它存下去

1937
01:23:53,166 --> 01:23:53,699
存下去以后

1938
01:23:53,700 --> 01:23:55,733
它会把它新的ID返回回来

1939
01:23:56,066 --> 01:23:58,666
所以我们会把它的这个ID

1940
01:23:58,666 --> 01:24:00,199
返回到这个bo上面

1941
01:24:00,200 --> 01:24:01,666
再把bo返回回来

1942
01:24:01,800 --> 01:24:03,766
那我们再看这个map程

1943
01:24:05,200 --> 01:24:06,366
一层层往下看

1944
01:24:07,200 --> 01:24:09,733
map层就真正是去超级数操作数据库了

1945
01:24:09,800 --> 01:24:12,100
但是我们的map层非常非常的简单

1946
01:24:12,100 --> 01:24:12,900
没有代码

1947
01:24:13,900 --> 01:24:15,600
包括我们刚才看到那个safe的

1948
01:24:15,600 --> 01:24:16,500
那都没写

1949
01:24:16,500 --> 01:24:19,266
为啥因为那个代码是来自于GPA

1950
01:24:19,266 --> 01:24:22,766
repository里头来自于这个

1951
01:24:23,933 --> 01:24:27,133
来自于这个定义里头的

1952
01:24:27,133 --> 01:24:27,366
所以

1953
01:24:27,366 --> 01:24:29,866
我们这里只需要写我们特定的东西

1954
01:24:29,966 --> 01:24:34,466
MAPT层就是跟我们特定的架构有关

1955
01:24:34,466 --> 01:24:36,966
我们这里使用的不是使用的mybetes

1956
01:24:37,066 --> 01:24:38,799
为什么同学们不爱使用mybetes

1957
01:24:38,800 --> 01:24:40,000
就是因为大家会发现

1958
01:24:40,000 --> 01:24:43,966
使用Supreme data JPA更加的简单

1959
01:24:43,966 --> 01:24:47,566
就写这么两个就能把东西存进去啊

1960
01:24:47,600 --> 01:24:49,166
我们卖bets的视频应该看了

1961
01:24:49,166 --> 01:24:51,333
这个应该还没有看是吧

1962
01:24:51,466 --> 01:24:53,699
还在比较靠后的地方

1963
01:24:54,133 --> 01:24:57,099
呃我们两个技术在底头都用

1964
01:24:57,866 --> 01:24:59,899
除了那个呃

1965
01:24:59,900 --> 01:25:01,700
支付模块用的是mybetes以外

1966
01:25:01,700 --> 01:25:04,100
其他的模块同学们都不爱用mybetes

1967
01:25:04,200 --> 01:25:05,566
就是因为大家可以看到

1968
01:25:06,000 --> 01:25:07,766
这个极度的简单化了

1969
01:25:07,800 --> 01:25:09,733
是吧所以map城非常的简单

1970
01:25:09,733 --> 01:25:11,366
直接把它存下去就好

1971
01:25:11,366 --> 01:25:12,566
这实际上用的Hybrid啊

1972
01:25:12,566 --> 01:25:13,866
这其实是用的Hybrid

1973
01:25:14,133 --> 01:25:15,999
用的GPA访问的Hybrid

1974
01:25:16,000 --> 01:25:17,300
来完成的这个过程

1975
01:25:19,000 --> 01:25:20,766
这个其实在业内啊

1976
01:25:20,766 --> 01:25:22,099
不常不常用

1977
01:25:22,100 --> 01:25:25,066
为啥呢因为my betes时间太久了

1978
01:25:25,166 --> 01:25:27,799
然后很多代码在my betes上改不过来

1979
01:25:28,000 --> 01:25:30,333
但是其实大家应该知道一个道理

1980
01:25:30,333 --> 01:25:33,533
就是后出的东西虽然用的人少

1981
01:25:33,666 --> 01:25:36,899
但是它一定比之前的东西要好

1982
01:25:36,900 --> 01:25:38,333
他才会去做后面东西

1983
01:25:38,333 --> 01:25:40,499
spinder GPS实际上是比较后出来的

1984
01:25:40,700 --> 01:25:43,600
总的原则来说就是代码会越写越少啊

1985
01:25:43,600 --> 01:25:44,600
代码会写越少

1986
01:25:45,600 --> 01:25:47,533
这个就是我们在这张图上

1987
01:25:47,533 --> 01:25:48,799
所看到的这个过程

1988
01:25:49,733 --> 01:25:53,366
所以一张图你若画的很细的话

1989
01:25:53,366 --> 01:25:55,099
见图基本上见代码

1990
01:25:55,200 --> 01:25:56,066
就这张图画出来

1991
01:25:56,066 --> 01:25:57,899
代码基本上就全部能够写出来

1992
01:25:57,933 --> 01:26:00,466
但是我们一般不需要

1993
01:26:00,466 --> 01:26:02,899
把这个图画的如此之细

1994
01:26:03,400 --> 01:26:05,533
我们其实画到一个大概

1995
01:26:05,533 --> 01:26:09,333
你知道怎么写代码的部分就可以了啊

1996
01:26:09,333 --> 01:26:10,899
其实还是有很多细节

1997
01:26:11,133 --> 01:26:12,299
去写到代码中间啊

1998
01:26:12,300 --> 01:26:14,766
不需要把图画到如此之细啊

1999
01:26:15,600 --> 01:26:17,400
这是创建者

2000
01:26:18,400 --> 01:26:21,666
那第二个我们要讲的是信息专家啊

2001
01:26:21,666 --> 01:26:23,733
今天主要讲前面两个最基本的

2002
01:26:23,733 --> 01:26:24,933
然后我们会用更多的例子

2003
01:26:24,933 --> 01:26:26,533
来大家巩固这两个部分

2004
01:26:26,866 --> 01:26:27,866
信息专家是什么啊

2005
01:26:27,866 --> 01:26:29,266
创建者其实解决了一个问题

2006
01:26:29,266 --> 01:26:30,666
就是谁创建谁

2007
01:26:30,666 --> 01:26:31,899
在这个例子中间

2008
01:26:31,900 --> 01:26:33,966
我们其实在说一个reading对象

2009
01:26:34,666 --> 01:26:36,999
就是一个region对象

2010
01:26:39,000 --> 01:26:40,666
在这里的这个region对象

2011
01:26:40,666 --> 01:26:42,399
他其实是由他自己来创建的

2012
01:26:42,400 --> 01:26:43,366
因为他自己存在的

2013
01:26:43,366 --> 01:26:46,366
一个这样的一个common性关系

2014
01:26:46,366 --> 01:26:49,166
所以是由上级地区来创建下级地区

2015
01:26:49,333 --> 01:26:51,499
这么做的好处在于哪哈

2016
01:26:51,700 --> 01:26:53,066
这么做的好处在于说

2017
01:26:53,066 --> 01:26:54,799
我们这个代码写出来你就知道

2018
01:26:54,800 --> 01:26:58,366
不可能创建出来孤立的地区

2019
01:26:59,333 --> 01:27:00,499
从代码上来说

2020
01:27:00,500 --> 01:27:02,733
就不可能创建出来孤立地区

2021
01:27:02,733 --> 01:27:04,366
因为我们从这个逻辑上

2022
01:27:05,066 --> 01:27:07,066
从这个对象模型的逻辑上来说

2023
01:27:07,066 --> 01:27:08,866
就不存在于一个孤立地区

2024
01:27:08,866 --> 01:27:10,266
它不属于任何一个省

2025
01:27:10,266 --> 01:27:11,533
不属于任何一个市

2026
01:27:11,600 --> 01:27:12,966
就没有这样的一个地区

2027
01:27:13,600 --> 01:27:16,300
所以我们的这个代码这么写出来

2028
01:27:16,300 --> 01:27:17,666
就不可能创建出来

2029
01:27:17,666 --> 01:27:18,799
鼓励你去大家想

2030
01:27:18,800 --> 01:27:19,700
大家去看啊

2031
01:27:19,700 --> 01:27:20,900
理解这个代码就知道

2032
01:27:20,966 --> 01:27:23,699
所以这个逻辑是用代码来保证的

2033
01:27:23,766 --> 01:27:26,733
而不是说你在里头出错啊

2034
01:27:26,733 --> 01:27:28,599
能够搞出搞出来的啊

2035
01:27:28,600 --> 01:27:30,733
代码上保证他不会出这样的一个错误

2036
01:27:30,966 --> 01:27:31,999
就从设计上啊

2037
01:27:32,000 --> 01:27:33,766
保证他不会出这样的一个错误

2038
01:27:34,533 --> 01:27:35,599
信息专家的原则

2039
01:27:36,366 --> 01:27:37,399
信息专家的原则

2040
01:27:37,466 --> 01:27:39,966
其实创建者原则只解决了一个问题

2041
01:27:39,966 --> 01:27:40,999
就是创建问题

2042
01:27:41,000 --> 01:27:42,333
我们知道在一个对象中间

2043
01:27:42,333 --> 01:27:44,399
一个类中间其实还有很多的方法

2044
01:27:48,166 --> 01:27:49,566
那些方法从何而来

2045
01:27:50,533 --> 01:27:51,566
我们说剩下的方法

2046
01:27:51,566 --> 01:27:54,133
中间的百分之七八十都是由这个来的

2047
01:27:54,700 --> 01:27:56,566
就是信息专家的原则

2048
01:27:56,900 --> 01:27:57,766
那信息专家原则

2049
01:27:57,766 --> 01:27:59,466
其实就是一个分配职责的问题

2050
01:27:59,466 --> 01:28:00,733
就是我们刚才可以看到

2051
01:28:00,733 --> 01:28:02,199
当我们做一个功能的时候

2052
01:28:02,200 --> 01:28:03,900
我们其实是把功能分解

2053
01:28:03,900 --> 01:28:05,566
成为了若干个职责

2054
01:28:05,966 --> 01:28:06,933
然后就有一个问题

2055
01:28:06,933 --> 01:28:08,166
这个职责分给谁

2056
01:28:08,866 --> 01:28:10,299
这个职责分给谁

2057
01:28:11,333 --> 01:28:12,599
分的这个原则

2058
01:28:12,600 --> 01:28:15,400
就是我们称之为知者为知

2059
01:28:15,500 --> 01:28:18,766
谁具备完成这个职责所需要的信息

2060
01:28:19,066 --> 01:28:20,566
就由谁来承担

2061
01:28:21,300 --> 01:28:21,766
我们在这里

2062
01:28:21,766 --> 01:28:25,733
其实已经看到了这样的一个过程

2063
01:28:25,800 --> 01:28:26,866
这个过程是什么呢

2064
01:28:26,866 --> 01:28:29,566
就是当我创建对象的时候啊

2065
01:28:29,566 --> 01:28:30,466
创建指对象的时候

2066
01:28:30,466 --> 01:28:33,866
其实我要判断这个指对象的状态

2067
01:28:34,000 --> 01:28:37,766
是否能够去撞这个地区的状态

2068
01:28:37,766 --> 01:28:39,399
是否能去见指地区

2069
01:28:39,800 --> 01:28:40,733
这就是我们的一个职责

2070
01:28:40,733 --> 01:28:41,366
我们有三个职责

2071
01:28:41,366 --> 01:28:43,199
找到这个对象他能不能见

2072
01:28:43,200 --> 01:28:44,066
然后去见他

2073
01:28:44,066 --> 01:28:45,099
三个职责啊

2074
01:28:45,333 --> 01:28:46,699
那其中的第二个职责

2075
01:28:46,966 --> 01:28:49,099
我们其实有两种做法

2076
01:28:49,100 --> 01:28:51,066
一种做法是直接在收尾室层写

2077
01:28:52,400 --> 01:28:53,733
直接在这一层写

2078
01:28:54,066 --> 01:28:56,566
那另外一种做法是直在这里来写

2079
01:28:58,100 --> 01:29:00,300
就是写到这个credit region里头

2080
01:29:00,500 --> 01:29:01,333
那为什么

2081
01:29:01,333 --> 01:29:03,999
我们会选择在credit region中间去写

2082
01:29:04,000 --> 01:29:06,566
而不直接在service上去写

2083
01:29:06,566 --> 01:29:08,299
这就是信息专家的原则

2084
01:29:08,300 --> 01:29:10,133
知则为知

2085
01:29:10,466 --> 01:29:12,599
当我们要去判断一个地区

2086
01:29:12,600 --> 01:29:15,366
能不能建夏季地子地区的时候

2087
01:29:15,800 --> 01:29:17,366
它的依据是什么

2088
01:29:17,366 --> 01:29:19,999
它的依据是这个地区的状态是什么

2089
01:29:20,166 --> 01:29:22,466
而这个状态是region的属性

2090
01:29:23,066 --> 01:29:23,366
所以

2091
01:29:23,366 --> 01:29:26,599
你如果在社会层去写这个代码的话

2092
01:29:26,666 --> 01:29:29,299
你需要拿到reading的属性去做判

2093
01:29:29,300 --> 01:29:32,566
断然后再去做这样的一个决断

2094
01:29:32,966 --> 01:29:35,199
但是我们用这种方式去写的话啊

2095
01:29:35,200 --> 01:29:36,466
写到这个里头的话

2096
01:29:36,666 --> 01:29:37,666
就使得说

2097
01:29:38,566 --> 01:29:41,099
他不需要把这个状态拿出来

2098
01:29:41,300 --> 01:29:42,666
到收费室去能判断

2099
01:29:42,766 --> 01:29:43,933
这就是我们说的

2100
01:29:43,933 --> 01:29:46,466
信息专家的这样的一个原则

2101
01:29:47,000 --> 01:29:50,400
那我们再来看另外一个方法

2102
01:29:50,400 --> 01:29:51,500
这个方法叫做

2103
01:29:52,966 --> 01:29:53,766
呃

2104
01:29:54,666 --> 01:29:56,133
获得上级地区

2105
01:29:56,766 --> 01:29:57,499
这个是什么呢

2106
01:29:57,500 --> 01:29:59,400
这个就是我们在做运费模板的时候

2107
01:29:59,400 --> 01:30:00,666
需要这样的一个功能

2108
01:30:00,666 --> 01:30:04,533
当我们拿到一个这个商品

2109
01:30:04,533 --> 01:30:06,766
拿到一个呃

2110
01:30:06,800 --> 01:30:09,466
就是拿到一个顾顾客的订单的时候

2111
01:30:09,466 --> 01:30:09,966
那个订单

2112
01:30:09,966 --> 01:30:12,399
一般都是订到了某一个居委会

2113
01:30:12,600 --> 01:30:15,733
比如说这个我们这个翔安校区啊

2114
01:30:15,733 --> 01:30:17,799
这么一个最底下的这样的一个机构

2115
01:30:18,500 --> 01:30:18,600
但是

2116
01:30:18,600 --> 01:30:20,866
我们的运费模板不是定到居委会的

2117
01:30:20,866 --> 01:30:22,366
我们的运费模板是定在市

2118
01:30:22,466 --> 01:30:23,599
至少定在市一级

2119
01:30:23,600 --> 01:30:24,700
甚至省一级的

2120
01:30:25,566 --> 01:30:26,933
至少是这样的

2121
01:30:26,966 --> 01:30:28,966
审视这一期的这个运费模板

2122
01:30:29,366 --> 01:30:30,899
所以那边就需要知道一个事情

2123
01:30:30,900 --> 01:30:32,666
当务前订单是到一个居委会的

2124
01:30:32,666 --> 01:30:33,699
那我怎么知道

2125
01:30:33,700 --> 01:30:35,400
这个居委会用哪个运费模板

2126
01:30:35,733 --> 01:30:36,666
实际上需要知道

2127
01:30:36,666 --> 01:30:39,066
说这个地区的所有的上级地区

2128
01:30:39,400 --> 01:30:41,966
就是它上面的这个区啊

2129
01:30:42,333 --> 01:30:43,766
市啊省啊

2130
01:30:43,766 --> 01:30:44,899
国家一直在上面啊

2131
01:30:44,900 --> 01:30:46,000
全部都需要知道

2132
01:30:46,366 --> 01:30:47,933
这个就是这个API啊

2133
01:30:47,933 --> 01:30:49,599
这个API的作用

2134
01:30:51,966 --> 01:30:52,766
怎么做的啊

2135
01:30:52,766 --> 01:30:53,899
大家可以看一下

2136
01:30:54,600 --> 01:30:56,266
我这就没写控制系统了

2137
01:30:56,533 --> 01:30:57,266
我这个图啊

2138
01:30:57,266 --> 01:30:57,933
就没写控制系统

2139
01:30:57,933 --> 01:30:59,366
因为控制系统非常简单

2140
01:30:59,566 --> 01:31:00,799
控制系统其实我们可以看到

2141
01:31:00,800 --> 01:31:02,166
就只做了两件事情

2142
01:31:02,166 --> 01:31:04,899
一件是把v o变成我们的b o

2143
01:31:05,100 --> 01:31:08,000
再把返回的值从b从b o变成DTO

2144
01:31:08,466 --> 01:31:09,566
然后就调设备值层

2145
01:31:09,566 --> 01:31:10,966
啊就是这么一件事情

2146
01:31:10,966 --> 01:31:12,566
所以以后的图里头

2147
01:31:12,566 --> 01:31:14,799
我们都不会再画控制器层了啊

2148
01:31:14,800 --> 01:31:16,900
因为我们主要用这个顺序图

2149
01:31:17,266 --> 01:31:18,099
去描述

2150
01:31:18,100 --> 01:31:21,366
我们的这个职责是怎么来实现的

2151
01:31:21,366 --> 01:31:23,133
所以我们一般在画顺序图的

2152
01:31:23,133 --> 01:31:24,566
都是从啊

2153
01:31:24,566 --> 01:31:26,099
servers城来入口

2154
01:31:26,466 --> 01:31:29,266
所以servers城的这个部分来说啊

2155
01:31:29,266 --> 01:31:32,733
我们定义了一个rechieve parent regions

2156
01:31:32,733 --> 01:31:35,399
啊把ID传贯的是region ID

2157
01:31:35,400 --> 01:31:37,866
就这个地区的上级ID是什么

2158
01:31:37,900 --> 01:31:39,100
那同样的

2159
01:31:39,300 --> 01:31:39,900
第一个事情

2160
01:31:39,900 --> 01:31:43,366
是要找当前这个地区是否存在

2161
01:31:43,933 --> 01:31:45,399
当前这个地区都不存在

2162
01:31:45,400 --> 01:31:47,400
那找到这个对象啊

2163
01:31:47,700 --> 01:31:48,933
找到这个对象以后呢

2164
01:31:48,933 --> 01:31:52,099
我们就找这个对象的上级地区

2165
01:31:52,400 --> 01:31:53,566
那怎么找这个对象的

2166
01:31:53,566 --> 01:31:54,533
对象的上级地区

2167
01:31:54,533 --> 01:31:58,499
你们觉得是依赖于我们对象里头的

2168
01:31:59,900 --> 01:32:00,766
这个关系

2169
01:32:01,333 --> 01:32:02,466
依赖于这个关系

2170
01:32:02,466 --> 01:32:04,599
才能找到他的所有的上级地区

2171
01:32:04,966 --> 01:32:08,566
所以在找上级地区的这个职责的时候

2172
01:32:08,566 --> 01:32:09,866
我们就存在着一个问题

2173
01:32:09,866 --> 01:32:12,133
我们把这个职责分配给谁去做

2174
01:32:13,733 --> 01:32:15,499
找上级地区的这个职责

2175
01:32:15,500 --> 01:32:16,800
分配给谁去做呢

2176
01:32:17,500 --> 01:32:18,900
我们按照信息专家的原则

2177
01:32:18,900 --> 01:32:20,766
把它分给了reading去做

2178
01:32:21,500 --> 01:32:22,566
所以在reading里面

2179
01:32:22,566 --> 01:32:25,066
做了一个get as an assessed的方法

2180
01:32:25,100 --> 01:32:27,500
把它的所有上级地区全部返回来

2181
01:32:27,533 --> 01:32:30,933
而这段代码就写在了这个里头

2182
01:32:31,066 --> 01:32:33,866
写到了region的这个里头啊

2183
01:32:33,866 --> 01:32:36,333
其实在画面相对象的设计的时候

2184
01:32:36,333 --> 01:32:39,566
这一部分的图同样可以不画

2185
01:32:39,800 --> 01:32:41,066
所以面相对象的设计

2186
01:32:41,066 --> 01:32:43,666
最关键的就是职责的明确

2187
01:32:44,000 --> 01:32:45,366
从功能到职责

2188
01:32:45,933 --> 01:32:47,133
从职责到职责

2189
01:32:47,133 --> 01:32:48,566
分给谁啊

2190
01:32:48,566 --> 01:32:50,866
所以我们进来的这个地方是功能

2191
01:32:50,866 --> 01:32:52,599
拿到上级地区这个是功能

2192
01:32:52,600 --> 01:32:54,133
社会层所提供出去的是功

2193
01:32:54,133 --> 01:32:56,133
能在社会层所做的事情

2194
01:32:56,133 --> 01:32:57,933
就是应该把这样的一个功能

2195
01:32:57,933 --> 01:33:00,866
分解成为若干个职责

2196
01:33:01,066 --> 01:33:04,466
把这些职责分解给不同的对象去做

2197
01:33:04,933 --> 01:33:06,199
有一部分分解给到去做

2198
01:33:06,200 --> 01:33:07,100
拿到这个对象

2199
01:33:07,100 --> 01:33:08,566
然后根据这个对象啊

2200
01:33:08,566 --> 01:33:12,866
把功能分给不同的对象啊

2201
01:33:12,866 --> 01:33:14,133
去完成这样的一个职责

2202
01:33:14,133 --> 01:33:16,799
但是因为我们这个你这个地区

2203
01:33:16,800 --> 01:33:19,266
这个模块中间只有一个对象啊

2204
01:33:19,266 --> 01:33:19,766
reading对象

2205
01:33:19,766 --> 01:33:21,566
所以说就分给他去做了

2206
01:33:21,700 --> 01:33:23,566
我们可以看一下这一端代码

2207
01:33:26,933 --> 01:33:28,933
我们直接从社会层开始看起啊

2208
01:33:55,566 --> 01:33:58,133
收一层的rechief parent

2209
01:34:04,933 --> 01:34:06,499
啊这个这个方法

2210
01:34:09,100 --> 01:34:10,666
这个方法里头啊

2211
01:34:11,166 --> 01:34:12,599
大家会发现说

2212
01:34:12,600 --> 01:34:15,566
其实我们的代码中间写的比什么呢

2213
01:34:15,566 --> 01:34:18,699
比我们在顺序图中间更多

2214
01:34:19,600 --> 01:34:20,200
大家可以看到

2215
01:34:20,200 --> 01:34:22,766
我们用哪一部分的代码

2216
01:34:22,766 --> 01:34:25,266
其实是没有写在顺序图里头的

2217
01:34:26,333 --> 01:34:27,133
哪一部分

2218
01:34:27,766 --> 01:34:28,799
就是有一个职责

2219
01:34:28,800 --> 01:34:30,966
其实我们没有把它写在顺序图里头

2220
01:34:32,100 --> 01:34:33,600
这个职责就是缓存

2221
01:34:33,900 --> 01:34:36,166
这里头我们使用了radis缓存

2222
01:34:36,566 --> 01:34:37,366
也就是因为

2223
01:34:37,366 --> 01:34:40,166
这个会是一个被高频调用的过程

2224
01:34:40,500 --> 01:34:43,466
我们的目标是在第一次被查过以后

2225
01:34:43,466 --> 01:34:45,933
这个东西被存到了radis缓存中间

2226
01:34:46,166 --> 01:34:47,466
所以当第二次

2227
01:34:47,466 --> 01:34:50,099
同样一个地区去查他的上级地区时候

2228
01:34:50,100 --> 01:34:51,733
他不会去数据库里查了

2229
01:34:51,900 --> 01:34:55,400
而是改由Redis去做查询

2230
01:34:55,766 --> 01:34:58,566
所以这一部分哈

2231
01:34:59,566 --> 01:35:02,166
那这一部分就是在做Redis的缓存

2232
01:35:02,566 --> 01:35:04,133
我们在red中间去找

2233
01:35:04,133 --> 01:35:06,166
说有没有存在这个对象

2234
01:35:06,166 --> 01:35:07,466
如果有存在这个对象的话

2235
01:35:07,466 --> 01:35:08,566
那么就直接把这个

2236
01:35:09,133 --> 01:35:10,566
这里主页不是存的这个对象啊

2237
01:35:10,566 --> 01:35:11,533
存的这些ID

2238
01:35:11,800 --> 01:35:13,733
直接把这些ID变成对象

2239
01:35:13,866 --> 01:35:16,766
这就是把直接把ID变成对象给他存

2240
01:35:16,766 --> 01:35:18,666
回去了大家应该也能看到

2241
01:35:18,666 --> 01:35:20,299
我们的这个代码中间

2242
01:35:20,333 --> 01:35:23,199
其实我们有大量的代码

2243
01:35:23,500 --> 01:35:25,066
采用了什么方式来写呢

2244
01:35:25,700 --> 01:35:27,333
采用了流编程的方式来写

2245
01:35:27,333 --> 01:35:28,766
这就是我们在最后会讲到的

2246
01:35:28,766 --> 01:35:29,599
函数式编程

2247
01:35:29,766 --> 01:35:33,399
这里头基本上所有涉及到集合的代码

2248
01:35:34,100 --> 01:35:35,600
全部是用牛编程写的

2249
01:35:35,600 --> 01:35:38,933
我们底头基本上是看不到复循环的

2250
01:35:39,166 --> 01:35:39,933
就是没有

2251
01:35:39,933 --> 01:35:41,466
基本上是没有复循环的

2252
01:35:41,700 --> 01:35:43,000
所有的这个东西

2253
01:35:43,000 --> 01:35:44,366
都是用函数式编程来写的

2254
01:35:44,366 --> 01:35:44,799
这为什么

2255
01:35:44,800 --> 01:35:47,166
因为函数式编程有

2256
01:35:47,700 --> 01:35:49,366
相对于我们传统编程的话

2257
01:35:49,366 --> 01:35:51,266
其实是有很大的好处的

2258
01:35:51,500 --> 01:35:53,066
不仅仅是代码更少

2259
01:35:53,800 --> 01:35:58,300
而且他的这个错误率会更低

2260
01:35:58,400 --> 01:35:59,566
因为代码少啊

2261
01:35:59,566 --> 01:36:00,799
错误率会更低

2262
01:36:01,000 --> 01:36:02,400
但是他的坏处在哪

2263
01:36:03,000 --> 01:36:03,933
话术在于说

2264
01:36:04,333 --> 01:36:05,599
你要保证一次写对

2265
01:36:05,666 --> 01:36:06,799
这可不好调试

2266
01:36:07,266 --> 01:36:09,066
这个非常不好调试啊

2267
01:36:09,200 --> 01:36:11,000
所以基本上来说

2268
01:36:11,000 --> 01:36:12,266
如果这里都出错的话

2269
01:36:12,266 --> 01:36:14,933
错误的指示也非常非常的含糊

2270
01:36:15,066 --> 01:36:15,599
看不出来

2271
01:36:15,600 --> 01:36:16,566
就是我们现在的

2272
01:36:16,733 --> 01:36:17,799
现在的这个工具

2273
01:36:17,800 --> 01:36:19,366
对于函数式编程的支持

2274
01:36:19,366 --> 01:36:20,666
当它出错了以后

2275
01:36:20,900 --> 01:36:22,600
其实它并不像我们传统编程那样

2276
01:36:22,600 --> 01:36:24,400
可以很明确的知道错在什么地方

2277
01:36:24,533 --> 01:36:26,066
这个你就是出错以后

2278
01:36:26,066 --> 01:36:27,599
比较难去找它的位置

2279
01:36:27,933 --> 01:36:29,666
但是如果说你代码是写对的

2280
01:36:29,666 --> 01:36:31,933
那其实它是一个非常高效的做法

2281
01:36:34,300 --> 01:36:35,133
我们现在代码中间

2282
01:36:35,133 --> 01:36:37,266
大量都是使用函数的编程来做的

2283
01:36:37,566 --> 01:36:40,899
所以这一段就是在red中间有

2284
01:36:40,900 --> 01:36:41,900
就从red中间直接返回

2285
01:36:41,900 --> 01:36:44,600
然后把它编成对象啊

2286
01:36:47,000 --> 01:36:48,400
对然后把直接把它变成对象

2287
01:36:48,400 --> 01:36:49,466
这个可以把它删掉啊

2288
01:36:49,466 --> 01:36:51,533
这个可能应该是不用了

2289
01:36:52,066 --> 01:36:54,166
那这一个部分呢

2290
01:36:54,166 --> 01:36:55,566
就是red中间没有

2291
01:36:56,366 --> 01:36:58,366
如果red中间没有的话那

2292
01:36:58,366 --> 01:37:00,066
就是要从数据库里去找了

2293
01:37:00,300 --> 01:37:01,133
数据库怎么找的

2294
01:37:01,133 --> 01:37:01,966
我们把这个职责

2295
01:37:01,966 --> 01:37:05,199
放到了red对象中间去拿

2296
01:37:05,200 --> 01:37:06,400
拿回来以后

2297
01:37:06,733 --> 01:37:09,466
同样的把它变成存到red中间

2298
01:37:09,466 --> 01:37:11,199
因为下次再找同一个东西的话

2299
01:37:11,200 --> 01:37:12,200
就会从red中间去找了

2300
01:37:12,200 --> 01:37:15,666
所以这个是在red中间去再存进去啊

2301
01:37:15,666 --> 01:37:17,299
然后把它返回回去

2302
01:37:17,533 --> 01:37:19,266
那red中间是怎么找的

2303
01:37:19,266 --> 01:37:21,066
我们看一下这个red的代码

2304
01:37:42,566 --> 01:37:44,499
这个这个就是我们的region代码

2305
01:37:45,966 --> 01:37:47,533
region代码其实很简单啊

2306
01:37:47,533 --> 01:37:49,466
就是我要知道它的祖先是什么

2307
01:37:49,466 --> 01:37:52,933
那我就去找它的祖先的祖先是什么

2308
01:37:53,666 --> 01:37:55,133
找首先自己

2309
01:37:55,466 --> 01:37:58,766
然后去看自己的parent region是什么

2310
01:37:58,766 --> 01:38:00,599
把自己的parent region加进去

2311
01:38:00,600 --> 01:38:03,166
然后再去找这个的parent region

2312
01:38:03,166 --> 01:38:06,099
我们的这个限制了时辰

2313
01:38:06,366 --> 01:38:07,499
限制了时辰啊

2314
01:38:07,500 --> 01:38:09,366
限制了这样的一个层次

2315
01:38:10,166 --> 01:38:11,899
好我们今天就讲到这里吧

